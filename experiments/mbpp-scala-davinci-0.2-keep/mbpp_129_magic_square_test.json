{
  "name": "mbpp_129_magic_square_test",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to calculate whether the matrix is a magic square.\n    def magicSquareTest(my_matrix : List[List[Long]]) : Boolean = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(magicSquareTest((List[List[Long]](List[Long](7l.toLong, 12l.toLong, 1l.toLong, 14l.toLong), List[Long](2l.toLong, 13l.toLong, 8l.toLong, 11l.toLong), List[Long](16l.toLong, 3l.toLong, 10l.toLong, 5l.toLong), List[Long](9l.toLong, 6l.toLong, 15l.toLong, 4l.toLong)))) == (true));\n    assert(magicSquareTest((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 1l.toLong), List[Long](4l.toLong, 3l.toLong, 8l.toLong)))) == (true));\n    assert(magicSquareTest((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 1l.toLong), List[Long](4l.toLong, 3l.toLong, 7l.toLong)))) == (false));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        // Check if the matrix is a square matrix\n        if (my_matrix.length != my_matrix(0).length) return false\n        // Check if the matrix is a magic square\n        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - row_with_index._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum).toSet\n        val sum_rows = my_matrix.map(x => x.sum).toSet\n        val sum_diags = Set(sum_diag1, sum_diag2)\n        val sum_set = sum_cols ++ sum_rows ++ sum_diags\n        if (sum_set.size == 1) true\n        else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(x => my_matrix(x)(x)).sum\n        val sum_diag2 = (0 until n).map(x => my_matrix(x)(n - x - 1)).sum\n        val sum_cols = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum).toList\n        val sum_rows = (0 until n).map(x => my_matrix(x).sum).toList\n        val sum_diags = List(sum_diag1, sum_diag2)\n        val sum_all = sum_cols ++ sum_rows ++ sum_diags\n        val sum_set = sum_all.toSet\n        sum_set.size == 1 && sum_set.head == sum",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val column_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diagonal_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ column_sums ++ diagonal_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_row.size == 1 && sum_col.size == 1 && sum_diag == sum && sum_anti_diag == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = my_matrix.transpose.map(_.sum).toSet\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag.toSet.size == 1) true else false",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - 1 - row_i._2)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(sum => sum == magic_number) && col_sums.forall(sum => sum == magic_number) && diag_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum)\n        val sum_col = my_matrix.transpose.map(x => x.sum)\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sum_all = sum_row ::: sum_col ::: sum_diag\n        sum_all.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = my_matrix.transpose.map(x => x.sum)\n        val diag_sums = List(my_matrix.indices.map(x => my_matrix(x)(x)).sum, my_matrix.indices.map(x => my_matrix(x)(n - x - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_col = (0 until n).map(i => (0 until m).map(j => my_matrix(j)(i)).sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (sum != sum_col || sum != sum_diag || sum != sum_diag2) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = (0 until n).map(i => my_matrix(i)(i)).sum :: (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum :: Nil\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_index => row_index._1(row_index._2)).sum, my_matrix.zipWithIndex.map(row_index => row_index._1(n - row_index._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val s = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = (0 until n).map(i => my_matrix(i)(i)).sum :: (0 until n).map(i => my_matrix(i)(n - i - 1)).sum :: Nil\n        val sums = row_sums ::: col_sums ::: diag_sums\n        sums.forall(x => x == s)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val sum_rows = my_matrix.map(x => x.sum)\n        val sum_cols = my_matrix.transpose.map(x => x.sum)\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        if (sum_rows.forall(x => x == sum) && sum_cols.forall(x => x == sum) && sum_diag.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        if (sum_diag1 != sum_diag2 || sum_diag1 != sum) return false\n        for (i <- 0 until n) {\n            val sum_row = my_matrix(i).sum\n            val sum_col = (0 until n).map(j => my_matrix(j)(i)).sum\n            if (sum_row != sum_col || sum_row != sum) return false\n        }\n        true",
    "        val n = my_matrix.length\n        val s = my_matrix.map(x => x.sum).sum / n\n        val m = my_matrix.transpose.map(x => x.sum).sum / n\n        val d1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val d2 = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        if (s == m && s == d1 && s == d2) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val sum_rows = my_matrix.map(x => x.sum)\n        val sum_cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_rows.forall(x => x == sum) && sum_cols.forall(x => x == sum) && sum_diag1 == sum && sum_diag2 == sum",
    "        // Check if the matrix is a square matrix.\n        if (my_matrix.length != my_matrix(0).length) return false\n        // Check if the matrix is a magic square.\n        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        // Check the rows.\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != magic_number) return false\n        }\n        // Check the columns.\n        for (i <- 0 until n) {\n            var sum = 0L\n            for (j <- 0 until n) {\n                sum += my_matrix(j)(i)\n            }\n            if (sum != magic_number) return false\n        }\n        // Check the diagonals.\n        var sum = 0L\n        for (i <- 0 until n) {\n            sum += my_matrix(i)(i)\n        }\n        if (sum != magic_number) return false\n        sum = 0L\n        for (i <- 0 until n) {\n            sum += my_matrix(i)(n - 1 - i)\n        }\n        if (sum != magic_number) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_cols = (0 until n).map(i => my_matrix.map(_(i)).sum).sum\n        val sum_rows = my_matrix.map(_.sum).sum\n        sum == sum_diag1 && sum == sum_diag2 && sum == sum_cols && sum == sum_rows",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag = my_matrix.indices.map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_rows = my_matrix.map(_.sum).toSet\n        val sum_cols = my_matrix.indices.map(i => my_matrix.map(_(i)).sum).toSet\n        if (sum_rows.size == 1 && sum_cols.size == 1 && sum_rows.head == sum_cols.head && sum_rows.head == sum && sum_diag == sum && sum_diag2 == sum) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_number = (1 to n).sum\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum)\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_row.forall(_ == sum) && sum_col.forall(_ == sum) && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - row_i._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val diag1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val diag2 = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val cols = (0 until n).map(i => my_matrix.map(_(i)).sum).toList\n        val rows = my_matrix.map(_.sum).toList\n        val all_sums = rows ++ cols ++ List(diag1, diag2)\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum)\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        if (sum_row.forall(_ == sum) && sum_col.forall(_ == sum) && sum_diag == sum && sum_anti_diag == sum) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val diagonal_sum = (0 until n).map(i => my_matrix(i)(i)).sum\n        val reverse_diagonal_sum = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val column_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val all_sums = row_sums ++ column_sums ++ List(diagonal_sum, reverse_diagonal_sum)\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        (sum == diag1) && (sum == diag2) && (row_sums.forall(_ == sum)) && (col_sums.forall(_ == sum))",
    "        val n = my_matrix.length\n        val magic_number = (1 to n).map(x => x.toLong).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(x => my_matrix.map(y => y(x)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val sum_rows = my_matrix.map(_.sum)\n        val sum_cols = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val sum_diags = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        if (sum_rows.forall(_ == sum) && sum_cols.forall(_ == sum) && sum_diags.forall(_ == sum)) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = my_matrix.transpose.map(col => col.sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(\n            (0 until n).map(i => my_matrix(i)(i)).sum,\n            (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        )\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val diagonal1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diagonal2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        diagonal1 == sum && diagonal2 == sum && row_sums.forall(_ == sum) && col_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum != sum) return false\n        if (my_matrix.map(x => x(my_matrix.indexOf(x))).sum != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diag2 = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val sum_col = my_matrix.transpose.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).sum\n        if (sum_diag1 == sum_diag2 && sum_diag1 == sum_col && sum_diag1 == sum_row) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_rows = my_matrix.map(x => x.sum).toSet\n        val sum_cols = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        if (sum_rows.size == 1 && sum_cols.size == 1 && sum_rows.head == sum_cols.head && sum_rows.head == sum_diag1 && sum_rows.head == sum_diag2) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.flatten.sum\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => my_matrix.map(row => row(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        sum_row.size == 1 && sum_col.size == 1 && sum_diag == sum && sum_anti_diag == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(_.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(_(i)).sum != sum) return false\n        }\n        if (my_matrix.indices.map(i => my_matrix(i)(i)).sum != sum) return false\n        if (my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_set = Set(sum_row, sum_col, Set(sum_diag1, sum_diag2)).flatten\n        sum_set.size == 1",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diagonal = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diagonal_reverse = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_column = my_matrix.transpose.map(x => x.sum).toSet\n        if (sum_row.size == 1 && sum_column.size == 1 && sum_diagonal == sum && sum_diagonal_reverse == sum) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        if (row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(_.sum).sum\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(_(i)).sum != sum) return false\n        }\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_(i)).sum != sum) return false\n        if (my_matrix.map(_",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diag2 = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = my_matrix.transpose.map(_.sum).toSet\n        sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_diag == sum_diag2 && sum_diag == sum_row.head",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_col = (0 until n).map(x => my_matrix.map(y => y(x)).sum).sum\n        val sum_diag = (0 until n).map(x => my_matrix(x)(x)).sum\n        val sum_diag2 = (0 until n).map(x => my_matrix(x)(n - x - 1)).sum\n        if (sum != sum_col || sum != sum_diag || sum != sum_diag2) return false\n        val sum_row = my_matrix.map(x => x.sum).sum\n        if (sum_row != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum).toSet\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sum_set = sum_row ++ sum_col ++ sum_diag\n        if (sum_set.size == 1) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row => row._1(row._2)).sum, my_matrix.zipWithIndex.map(row => row._1(n - 1 - row._2)).sum)\n        if (row_sums.forall(sum => sum == magic_number) && col_sums.forall(sum => sum == magic_number) && diag_sums.forall(sum => sum == magic_number)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == magic_number)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row => row._1(row._2)).sum, my_matrix.zipWithIndex.map(row => row._1(n - row._2 - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diagonal = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diagonal_2 = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val sum_column = my_matrix.transpose.map(x => x.sum).sum\n        if (sum == sum_diagonal && sum == sum_diagonal_2 && sum == sum_column) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum)\n        val sum_col = (0 until n).map(i => (0 until m).map(j => my_matrix(j)(i)).sum)\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_row.forall(_ == sum) && sum_col.forall(_ == sum) && sum_diag == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val rows = my_matrix.map(x => x.sum)\n        val cols = my_matrix.transpose.map(x => x.sum)\n        val diag1 = my_matrix.indices.map(i => my_matrix(i)(i)).sum\n        val diag2 = my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum\n        rows.forall(_ == sum) && cols.forall(_ == sum) && diag1 == sum && diag2 == sum",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.zipWithIndex.map(x => x._1(x._2)).sum != sum) return false\n        if (my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum != sum) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val diag1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val diag2 = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val rows = my_matrix.map(x => x.sum)\n        val cols = my_matrix.transpose.map(x => x.sum)\n        if (rows.forall(x => x == sum) && cols.forall(x => x == sum) && diag1 == sum && diag2 == sum) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != sum) return false\n            if (my_matrix.map(x => x(i)).sum != sum) return false\n        }\n        if (my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum != sum) return false\n        if (my_matrix.map(x => x(my_matrix.indexOf(x))).sum != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => my_matrix.map(x => x(i)).sum).toSet\n        val sum_diag = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag.size == 1 && sum_row.head == sum_col.head && sum_col.head == sum_diag.head) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag_2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => my_matrix.map(x => x(i)).sum).toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_diag == sum_diag_2 && sum_diag == sum_row.head) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val magic_sum = sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = my_matrix.transpose.map(_.sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == magic_sum)",
    "        val n = my_matrix.length\n        var sum = 0L\n        for (i <- 0 until n) sum += my_matrix(0)(i)\n        for (i <- 0 until n) {\n            var sum_row = 0L\n            var sum_col = 0L\n            for (j <- 0 until n) {\n                sum_row += my_matrix(i)(j)\n                sum_col += my_matrix(j)(i)\n            }\n            if (sum_row != sum || sum_col != sum) return false\n        }\n        var sum_diag1 = 0L\n        var sum_diag2 = 0L\n        for (i <- 0 until n) {\n            sum_diag1 += my_matrix(i)(i)\n            sum_diag2 += my_matrix(i)(n - i - 1)\n        }\n        if (sum_diag1 != sum || sum_diag2 != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val diag1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val diag2 = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = my_matrix.transpose.map(_.sum)\n        val row_col_sums = row_sums ++ col_sums\n        val all_sums = row_col_sums ++ List(diag1, diag2)\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => my_matrix.map(row => row(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        if (row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diag2 = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum).sum\n        val sum_row = my_matrix.map(_.sum).sum\n        if (sum_diag1 == sum_diag2 && sum_diag1 == sum_col && sum_diag1 == sum_row) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_row.contains(sum) && sum_col.contains(sum) && sum_diag1 == sum && sum_diag2 == sum) true else false",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row => row._1(row._2)).sum, my_matrix.zipWithIndex.map(row => row._1(n - row._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(_.sum).sum\n        var i = 0\n        while (i < n) {\n            if (my_matrix(i).sum != sum) return false\n            var j = 0\n            while (j < n) {\n                if (my_matrix.map(_(j)).sum != sum) return false\n                j += 1\n            }\n            i += 1\n        }\n        var k = 0\n        var l = 0\n        var diagonal_sum = 0L\n        while (k < n) {\n            diagonal_sum += my_matrix(k)(l)\n            k += 1\n            l += 1\n        }\n        if (diagonal_sum != sum) return false\n        k = 0\n        l = n - 1\n        diagonal_sum = 0L\n        while (k < n) {\n            diagonal_sum += my_matrix(k)(l)\n            k += 1\n            l -= 1\n        }\n        if (diagonal_sum != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_row.size == 1 && sum_col.size == 1 && sum_diag == sum && sum_anti_diag == sum",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until m).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - row_i._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val row_sum = my_matrix.map(x => x.sum).toSet\n        if (row_sum.size != 1) return false\n        val col_sum = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        if (col_sum.size != 1) return false\n        val diag_sum = (0 until n).map(i => my_matrix(i)(i)).sum\n        if (diag_sum != row_sum.head) return false\n        val diag_sum2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (diag_sum2 != row_sum.head) return false\n        return true",
    "        val n = my_matrix.length\n        val row_sum = my_matrix.map(x => x.sum).toSet\n        val col_sum = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val diag_sum = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag_sum2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_set = Set(row_sum, col_sum, Set(diag_sum, diag_sum2)).flatten\n        sum_set.size == 1",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val row_sums = (0 until n).map(i => my_matrix(i).sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        return (sum == diag1 && sum == diag2 && row_sums.forall(_ == sum) && col_sums.forall(_ == sum))",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.size\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(_ == sum) && col_sums.forall(_ == sum) && diag_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = (0 until n).map(i => my_matrix(i)(i)).sum :: (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum :: Nil\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val magic_number = n * (n * n + 1) / 2\n        // check rows\n        for (i <- 0 until n) {\n            var sum = 0L\n            for (j <- 0 until n) {\n                sum += my_matrix(i)(j)\n            }\n            if (sum != magic_number) return false\n        }\n        // check columns\n        for (j <- 0 until n) {\n            var sum = 0L\n            for (i <- 0 until n) {\n                sum += my_matrix(i)(j)\n            }\n            if (sum != magic_number) return false\n        }\n        // check diagonals\n        var sum = 0L\n        for (i <- 0 until n) {\n            sum += my_matrix(i)(i)\n        }\n        if (sum != magic_number) return false\n        sum = 0L\n        for (i <- 0 until n) {\n            sum += my_matrix(i)(n - 1 - i)\n        }\n        if (sum != magic_number) return false\n        return true",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val diag1 = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val diag2 = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        val rows = my_matrix.map(_.sum)\n        val cols = my_matrix.transpose.map(_.sum)\n        if (sum == diag1 && sum == diag2 && rows.forall(_ == sum) && cols.forall(_ == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        sum_row.size == 1 && sum_col.size == 1 && sum_diag == sum && sum_anti_diag == sum",
    "        // Check if the matrix is a square.\n        if (my_matrix.length != my_matrix(0).length) return false\n        // Check if the matrix is a magic square.\n        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        return sums.forall(sum => sum == magic_sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(0, n - 1).map(i => (0 until n).map(j => my_matrix(j)((i + j) % n)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until m).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_row.size == 1 && sum_col.size == 1 && sum_diag1 == sum_diag2",
    "        var sum = my_matrix(0).sum\n        for (i <- 1 until my_matrix.size) {\n            if (my_matrix(i).sum != sum) return false\n        }\n        for (i <- 0 until my_matrix.size) {\n            var temp_sum = 0L\n            for (j <- 0 until my_matrix.size) {\n                temp_sum += my_matrix(j)(i)\n            }\n            if (temp_sum != sum) return false\n        }\n        var temp_sum = 0L\n        for (i <- 0 until my_matrix.size) {\n            temp_sum += my_matrix(i)(i)\n        }\n        if (temp_sum != sum) return false\n        temp_sum = 0L\n        for (i <- 0 until my_matrix.size) {\n            temp_sum += my_matrix(i)(my_matrix.size - 1 - i)\n        }\n        if (temp_sum != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        if (sum != diag1 || sum != diag2) return false\n        for (i <- 0 until n) {\n            if (row_sums(i) != sum || col_sums(i) != sum) return false\n        }\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(\n            (0 until n).map(i => my_matrix(i)(i)).sum,\n            (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        )\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        val unique_sums = sums.toSet\n        return unique_sums.size == 1 && unique_sums.head == magic_sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet.size == 1\n        val sum_col = (0 until n).map(i => my_matrix.map(x => x(i)).sum).toSet.size == 1\n        sum_row && sum_col && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diagonal = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_diagonal2 = my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum\n        val sum_column = my_matrix.transpose.map(_.sum).sum\n        if (sum == sum_diagonal && sum == sum_diagonal2 && sum == sum_column) true else false",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(sum => sum == magic_constant) && col_sums.forall(sum => sum == magic_constant) && diag_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sums = row_sums ++ col_sums ++ List(diag1, diag2)\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row => row._1(row._2)).sum, my_matrix.zipWithIndex.map(row => row._1(n - 1 - row._2)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag_2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_col = (0 until n).map(i => my_matrix.map(_(i)).sum).sum\n        val sum_row = my_matrix.map(_.sum).sum\n        sum == sum_diag && sum == sum_diag_2 && sum == sum_col && sum == sum_row",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        var sum = my_matrix.head.sum\n        var result = true\n        for (i <- 0 until my_matrix.size) {\n            if (my_matrix(i).sum != sum) result = false\n            if (my_matrix.map(x => x(i)).sum != sum) result = false\n        }\n        if (my_matrix.zipWithIndex.map(x => x._1(x._2)).sum != sum) result = false\n        if (my_matrix.zipWithIndex.map(x => x._1(my_matrix.size - x._2 - 1)).sum != sum) result = false\n        result",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ::: col_sums ::: diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.size\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        row_sums.forall(x => x == magic_number) && col_sums.forall(x => x == magic_number) && diag_sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_rows = my_matrix.map(_.sum).toSet\n        val sum_cols = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diags = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        if (sum_rows.size == 1 && sum_cols.size == 1 && sum_diags.toSet.size == 1 && sum_rows.head == sum_cols.head && sum_cols.head == sum_diags.head) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val rows = my_matrix.map(_.sum)\n        val cols = for (i <- 0 until n) yield my_matrix.map(_(i)).sum\n        val diag1 = for (i <- 0 until n) yield my_matrix(i)(i)\n        val diag2 = for (i <- 0 until n) yield my_matrix(i)(n - i - 1)\n        val diags = List(diag1, diag2).map(_.sum)\n        val all = rows ++ cols ++ diags\n        all.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - row_with_index._2 - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag1 = (for (i <- 0 until n) yield my_matrix(i)(i)).sum\n        val diag2 = (for (i <- 0 until n) yield my_matrix(i)(n - 1 - i)).sum\n        val rows = my_matrix.map(x => x.sum)\n        val cols = (for (i <- 0 until n) yield (for (j <- 0 until n) yield my_matrix(j)(i)).sum).toList\n        if (diag1 == sum && diag2 == sum && rows.forall(x => x == sum) && cols.forall(x => x == sum)) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_diag1 == sum_diag2 && sum_diag1 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val sum_rows = my_matrix.map(_.sum)\n        val sum_cols = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val sum_diags = List(my_matrix.zipWithIndex.map(x => x._1(x._2)), my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1))).map(_.sum)\n        val sum_all = sum_rows ++ sum_cols ++ sum_diags\n        sum_all.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_sum = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - row_i._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val column_sums = my_matrix.transpose.map(column => column.sum)\n        val diagonal_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ column_sums ++ diagonal_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum).sum\n        val sum_rows = my_matrix.map(x => x.sum).sum\n        if (sum_diag1 == sum && sum_diag2 == sum && sum_cols == sum && sum_rows == sum) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val sum_rows = my_matrix.map(_.sum)\n        val sum_cols = my_matrix.transpose.map(_.sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        if (sum_rows.forall(_ == sum) && sum_cols.forall(_ == sum) && sum_diag1 == sum && sum_diag2 == sum) true else false",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(\n            (0 until n).map(i => my_matrix(i)(i)).sum,\n            (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        )\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_row.head == sum_col.head && sum_diag1 == sum && sum_diag2 == sum) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_row = (0 until n).map(i => my_matrix(i).sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        (sum_row.size == 1) && (sum_col.size == 1) && (sum_diag1 == sum) && (sum_diag2 == sum) && (sum_row.head == sum) && (sum_col.head == sum)",
    "        // Check if the matrix is a square matrix.\n        if (my_matrix.length != my_matrix(0).length) {\n            return false\n        }\n        // Check if the matrix is a magic square.\n        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        for (i <- 0 until n) {\n            var sum = 0L\n            for (j <- 0 until n) {\n                sum += my_matrix(i)(j)\n            }\n            if (sum != magic_number) {\n                return false\n            }\n        }\n        for (j <- 0 until n) {\n            var sum = 0L\n            for (i <- 0 until n) {\n                sum += my_matrix(i)(j)\n            }\n            if (sum != magic_number) {\n                return false\n            }\n        }\n        var sum = 0L\n        for (i <- 0 until n) {\n            sum += my_matrix(i)(i)\n        }\n        if (sum != magic_number) {\n            return false\n        }\n        sum = 0L\n        for (i <- 0 until n) {\n            sum += my_matrix(i)(n - 1 - i)\n        }\n        if (sum != magic_number) {\n            return false\n        }\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag.toSet.size == 1 && sum_row.head == sum_col.head && sum_col.head == sum_diag.head) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_cols = (0 until n).map(i => my_matrix.map(_(i)).sum).sum\n        val sum_rows = (0 until n).map(i => my_matrix(i).sum).sum\n        sum == sum_diag1 && sum == sum_diag2 && sum == sum_cols && sum == sum_rows",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val all_sums = row_sums ++ col_sums ++ List(diag1, diag2)\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = my_matrix.transpose.map(x => x.sum).toSet\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        if (sum_row.size != 1 || sum_col.size != 1 || sum_diag.size != 1) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(x => my_matrix(x)(x)).sum\n        val sum_diag2 = (0 until n).map(x => my_matrix(x)(n - 1 - x)).sum\n        val sum_cols = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum).toList\n        val sum_rows = my_matrix.map(x => x.sum)\n        val sum_cols_unique = sum_cols.toSet.size\n        val sum_rows_unique = sum_rows.toSet.size\n        val sum_unique = Set(sum_diag1, sum_diag2).size\n        if (sum_cols_unique == 1 && sum_rows_unique == 1 && sum_unique == 1) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row => row._1(row._2)).sum, my_matrix.zipWithIndex.map(row => row._1(n - row._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        val unique_sums = sums.toSet\n        unique_sums.size == 1 && unique_sums.head == magic_number",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val diagonal_sum = (0 until n).map(i => my_matrix(i)(i)).sum\n        val anti_diagonal_sum = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val column_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        row_sums.forall(_ == sum) && column_sums.forall(_ == sum) && diagonal_sum == sum && anti_diagonal_sum == sum",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)), my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2))).map(diag => diag.sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val magic_sum = n * (n * n + 1) / 2\n        if (sum != magic_sum) return false\n        for (i <- 0 until n) {\n            if (my_matrix(i).sum != magic_sum) return false\n            if (my_matrix.map(x => x(i)).sum != magic_sum) return false\n        }\n        if (my_matrix.indices.map(x => my_matrix(x)(x)).sum != magic_sum) return false\n        if (my_matrix.indices.map(x => my_matrix(x)(n - x - 1)).sum != magic_sum) return false\n        return true",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - row_with_index._2 - 1)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.flatten.sum\n        val sum_row = my_matrix.map(row => row.sum)\n        val sum_col = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_list = sum_row ++ sum_col ++ List(sum_diag1, sum_diag2)\n        sum_list.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val magic_constant = sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = (0 until n).map(i => my_matrix(i)(i)).sum :: (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum :: Nil\n        val all_sums = row_sums ::: col_sums ::: diag_sums\n        all_sums.forall(_ == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        // Check rows\n        val row_sums = my_matrix.map(_.sum)\n        if (row_sums.toSet.size != 1) return false\n        // Check columns\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        if (col_sums.toSet.size != 1) return false\n        // Check diagonals\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        if (diag_sums.toSet.size != 1) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diagonal = my_matrix.zipWithIndex.map(x => x._1(x._2)).sum\n        val sum_anti_diagonal = my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum\n        if (sum_diagonal != sum_anti_diagonal) return false\n        for (i <- 0 until n) {\n            val sum_row = my_matrix(i).sum\n            val sum_column = my_matrix.map(x => x(i)).sum\n            if (sum_row != sum_column || sum_row != sum_diagonal) return false\n        }\n        return true",
    "        // check if the matrix is square\n        if (my_matrix.length != my_matrix(0).length) return false\n        // check if the matrix is magic square\n        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (sum_row.size != 1 || sum_col.size != 1 || sum_diag != sum || sum_anti_diag != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum).toSet\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag.size == 1 && sum_row.contains(sum) && sum_col.contains(sum) && sum_diag.contains(sum)) true else false",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(col => (0 until n).map(row => my_matrix(row)(col)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = (0 until n).map(i => my_matrix(i)(i)).sum :: (0 until n).map(i => my_matrix(i)(n - i - 1)).sum :: Nil\n        val sums = row_sums ::: col_sums ::: diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 to n - 1).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        return (sum == diag1 && sum == diag2 && row_sums.forall(_ == sum) && col_sums.forall(_ == sum))",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val diag2 = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        val cols = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toList\n        val rows = my_matrix.map(x => x.sum)\n        val all_sums = rows ++ cols ++ List(diag1, diag2)\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val row_sum = my_matrix.map(x => x.sum).toSet\n        val col_sum = (0 until n).map(i => my_matrix.map(x => x(i)).sum).toSet\n        val diag_sum = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sum_set = row_sum ++ col_sum ++ diag_sum\n        sum_set.size == 1",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val diag1 = (0 until n).map(x => my_matrix(x)(x)).sum\n        val diag2 = (0 until n).map(x => my_matrix(x)(n - 1 - x)).sum\n        val cols = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum).toList\n        val rows = (0 until n).map(x => my_matrix(x).sum).toList\n        val cols_test = cols.forall(x => x == sum)\n        val rows_test = rows.forall(x => x == sum)\n        val diag1_test = diag1 == sum\n        val diag2_test = diag2 == sum\n        cols_test && rows_test && diag1_test && diag2_test",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        row_sums.forall(sum => sum == magic_number) && col_sums.forall(sum => sum == magic_number) && diag_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sum = (0 until n).map(i => my_matrix(i)(i)).sum\n        val anti_diag_sum = (0 until n).map(i => my_matrix(i)(n - i - 1)).sum\n        if (row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sum == sum && anti_diag_sum == sum) true else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_rows = my_matrix.map(_.sum)\n        val sum_cols = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_rows.forall(_ == sum) && sum_cols.forall(_ == sum) && sum_diag1 == sum && sum_diag2 == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        return (row_sums.forall(x => x == sum) && col_sums.forall(x => x == sum) && diag_sums.forall(x => x == sum))",
    "        var sum = my_matrix(0).sum\n        for (i <- 1 to my_matrix.length - 1) {\n            if (my_matrix(i).sum != sum) return false\n        }\n        for (j <- 0 to my_matrix.length - 1) {\n            var temp = 0L\n            for (i <- 0 to my_matrix.length - 1) {\n                temp += my_matrix(i)(j)\n            }\n            if (temp != sum) return false\n        }\n        var temp = 0L\n        for (i <- 0 to my_matrix.length - 1) {\n            temp += my_matrix(i)(i)\n        }\n        if (temp != sum) return false\n        temp = 0L\n        for (i <- 0 to my_matrix.length - 1) {\n            temp += my_matrix(i)(my_matrix.length - 1 - i)\n        }\n        if (temp != sum) return false\n        return true",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val magic_number = n * (n * n + 1) / 2\n        def checkRow(row : List[Long]) : Boolean = {\n            row.sum == magic_number\n        }\n        def checkColumn(column : List[Long]) : Boolean = {\n            column.sum == magic_number\n        }\n        def checkDiagonal(diagonal : List[Long]) : Boolean = {\n            diagonal.sum == magic_number\n        }\n        def checkReverseDiagonal(diagonal : List[Long]) : Boolean = {\n            diagonal.sum == magic_number\n        }\n        def checkMatrix(my_matrix : List[List[Long]]) : Boolean = {\n            my_matrix.forall(checkRow) && (0 until n).forall(i => checkColumn((0 until n).map(j => my_matrix(j)(i)).toList)) && checkDiagonal((0 until n).map(i => my_matrix(i)(i)).toList) && checkReverseDiagonal((0 until n).map(i => my_matrix(i)(n - i - 1)).toList)\n        }\n        checkMatrix(my_matrix)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == magic_constant)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == magic_number)",
    "        val n = my_matrix.length\n        var sum = 0L\n        for (i <- 0 until n) {\n            sum += my_matrix(0)(i)\n        }\n        for (i <- 0 until n) {\n            var sum_row = 0L\n            for (j <- 0 until n) {\n                sum_row += my_matrix(i)(j)\n            }\n            if (sum_row != sum) return false\n        }\n        for (i <- 0 until n) {\n            var sum_col = 0L\n            for (j <- 0 until n) {\n                sum_col += my_matrix(j)(i)\n            }\n            if (sum_col != sum) return false\n        }\n        var sum_diag = 0L\n        for (i <- 0 until n) {\n            sum_diag += my_matrix(i)(i)\n        }\n        if (sum_diag != sum) return false\n        sum_diag = 0L\n        for (i <- 0 until n) {\n            sum_diag += my_matrix(i)(n - 1 - i)\n        }\n        if (sum_diag != sum) return false\n        return true"
  ]
}