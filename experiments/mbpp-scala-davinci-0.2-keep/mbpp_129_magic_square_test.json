{
  "name": "mbpp_129_magic_square_test",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to calculate whether the matrix is a magic square.\n    def magicSquareTest(my_matrix : List[List[Long]]) : Boolean = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(magicSquareTest((List[List[Long]](List[Long](7l.toLong, 12l.toLong, 1l.toLong, 14l.toLong), List[Long](2l.toLong, 13l.toLong, 8l.toLong, 11l.toLong), List[Long](16l.toLong, 3l.toLong, 10l.toLong, 5l.toLong), List[Long](9l.toLong, 6l.toLong, 15l.toLong, 4l.toLong)))) == (true));\n    assert(magicSquareTest((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 1l.toLong), List[Long](4l.toLong, 3l.toLong, 8l.toLong)))) == (true));\n    assert(magicSquareTest((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 6l.toLong), List[Long](9l.toLong, 5l.toLong, 1l.toLong), List[Long](4l.toLong, 3l.toLong, 7l.toLong)))) == (false));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        // Check if the matrix is a square matrix\n        if (my_matrix.length != my_matrix(0).length) return false\n        // Check if the matrix is a magic square\n        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(row_with_index._2)).sum, my_matrix.zipWithIndex.map(row_with_index => row_with_index._1(n - row_with_index._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        val sum_cols = (0 until n).map(i => my_matrix.map(x => x(i)).sum).toSet\n        val sum_rows = my_matrix.map(x => x.sum).toSet\n        val sum_diags = Set(sum_diag1, sum_diag2)\n        val sum_set = sum_cols ++ sum_rows ++ sum_diags\n        if (sum_set.size == 1) true\n        else false",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_diag1 = (0 until n).map(x => my_matrix(x)(x)).sum\n        val sum_diag2 = (0 until n).map(x => my_matrix(x)(n - x - 1)).sum\n        val sum_cols = (0 until n).map(x => (0 until n).map(y => my_matrix(y)(x)).sum).toList\n        val sum_rows = (0 until n).map(x => my_matrix(x).sum).toList\n        val sum_diags = List(sum_diag1, sum_diag2)\n        val sum_all = sum_cols ++ sum_rows ++ sum_diags\n        val sum_set = sum_all.toSet\n        sum_set.size == 1 && sum_set.head == sum",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        if (n != m) return false\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - x._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val column_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diagonal_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        val sums = row_sums ++ column_sums ++ diagonal_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = (0 until n).map(i => (0 until n).map(j => my_matrix(j)(i)).sum).toSet\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_anti_diag = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        sum_row.size == 1 && sum_col.size == 1 && sum_diag == sum && sum_anti_diag == sum",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_row = my_matrix.map(_.sum).toSet\n        val sum_col = my_matrix.transpose.map(_.sum).toSet\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        if (sum_row.size == 1 && sum_col.size == 1 && sum_diag.toSet.size == 1) true else false",
    "        val n = my_matrix.length\n        val magic_constant = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_i => row_i._1(row_i._2)).sum, my_matrix.zipWithIndex.map(row_i => row_i._1(n - 1 - row_i._2)).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(sum => sum == magic_constant)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = List(my_matrix.map(x => x(x.length - 1 - my_matrix.indexOf(x))).sum, my_matrix.map(x => x(my_matrix.indexOf(x))).sum)\n        val all_sums = row_sums ++ col_sums ++ diag_sums\n        all_sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - 1 - i)).sum)\n        row_sums.forall(sum => sum == magic_number) && col_sums.forall(sum => sum == magic_number) && diag_sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum\n        val sum_row = my_matrix.map(x => x.sum)\n        val sum_col = my_matrix.transpose.map(x => x.sum)\n        val sum_diag = List(my_matrix.indices.map(i => my_matrix(i)(i)).sum, my_matrix.indices.map(i => my_matrix(i)(n - i - 1)).sum)\n        val sum_all = sum_row ::: sum_col ::: sum_diag\n        sum_all.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(x => x._1(x._2)).sum, my_matrix.zipWithIndex.map(x => x._1(n - 1 - x._2)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = my_matrix.transpose.map(x => x.sum)\n        val diag_sums = List(my_matrix.indices.map(x => my_matrix(x)(x)).sum, my_matrix.indices.map(x => my_matrix(x)(n - x - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(x => x == sum)",
    "        val n = my_matrix.length\n        val m = my_matrix(0).length\n        val sum = my_matrix.map(_.sum).sum\n        val sum_col = (0 until n).map(i => (0 until m).map(j => my_matrix(j)(i)).sum).sum\n        val sum_diag = (0 until n).map(i => my_matrix(i)(i)).sum\n        val sum_diag2 = (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum\n        if (sum != sum_col || sum != sum_diag || sum != sum_diag2) return false\n        true",
    "        val n = my_matrix.length\n        val sum = my_matrix.map(_.sum).sum / n\n        val row_sums = my_matrix.map(_.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(_(i)).sum)\n        val diag_sums = (0 until n).map(i => my_matrix(i)(i)).sum :: (0 until n).map(i => my_matrix(i)(n - 1 - i)).sum :: Nil\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(_ == sum)",
    "        val n = my_matrix.length\n        val magic_number = n * (n * n + 1) / 2\n        val row_sums = my_matrix.map(row => row.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(row => row(i)).sum)\n        val diag_sums = List(my_matrix.zipWithIndex.map(row_index => row_index._1(row_index._2)).sum, my_matrix.zipWithIndex.map(row_index => row_index._1(n - row_index._2 - 1)).sum)\n        val sums = row_sums ++ col_sums ++ diag_sums\n        sums.forall(sum => sum == magic_number)",
    "        val n = my_matrix.length\n        val s = my_matrix.map(x => x.sum).sum / n\n        val row_sums = my_matrix.map(x => x.sum)\n        val col_sums = (0 until n).map(i => my_matrix.map(x => x(i)).sum)\n        val diag_sums = (0 until n).map(i => my_matrix(i)(i)).sum :: (0 until n).map(i => my_matrix(i)(n - i - 1)).sum :: Nil\n        val sums = row_sums ::: col_sums ::: diag_sums\n        sums.forall(x => x == s)"
  ]
}