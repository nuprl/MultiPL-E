{
  "name": "mbpp_297_flatten_list",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to flatten a given nested list structure.\n    def flattenList(list1 : Any) : List[Long] = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(flattenList((Any(0l, 10l, List[Long](20l.toLong, 30l.toLong), 40l, 50l, List[Long](60l.toLong, 70l.toLong, 80l.toLong), List[Long](90l.toLong, 100l.toLong, 110l.toLong, 120l.toLong)))).equals((List[Long](0l.toLong, 10l.toLong, 20l.toLong, 30l.toLong, 40l.toLong, 50l.toLong, 60l.toLong, 70l.toLong, 80l.toLong, 90l.toLong, 100l.toLong, 110l.toLong, 120l.toLong))));\n    assert(flattenList((Any(List[Long](10l.toLong, 20l.toLong), List[Long](40l.toLong), List[Long](30l.toLong, 56l.toLong, 25l.toLong), List[Long](10l.toLong, 20l.toLong), List[Long](33l.toLong), List[Long](40l.toLong)))).equals((List[Long](10l.toLong, 20l.toLong, 40l.toLong, 30l.toLong, 56l.toLong, 25l.toLong, 10l.toLong, 20l.toLong, 33l.toLong, 40l.toLong))));\n    assert(flattenList((Any(List[Long](1l.toLong, 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](10l.toLong, 11l.toLong, 12l.toLong), List[Long](7l.toLong, 8l.toLong, 9l.toLong)))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong, 10l.toLong, 11l.toLong, 12l.toLong, 7l.toLong, 8l.toLong, 9l.toLong))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => list.foreach(x => list2 = list2 ::: flattenList(x))\n            case x : Long => list2 = list2 :+ x\n        }\n        list2",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => list.foreach(x => list2 = list2 ::: flattenList(x))\n            case x : Long => list2 = list2 :+ x\n        }\n        list2",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => list.foreach(x => list2 = list2 ::: flattenList(x))\n            case x : Long => list2 = list2 :+ x\n        }\n        list2",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        var list2 : List[Long] = List()\n        list1 match {\n            case list : List[Any] => for (x <- list) list2 = list2 ::: flattenList(x)\n            case x : Long => list2 = list2 :+ x\n        }\n        return list2",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => list.foreach(x => list2 = list2 ::: flattenList(x))\n            case x : Long => list2 = list2 :+ x\n            case _ =>\n        }\n        list2",
    "        list1 match {\n            case Nil => Nil\n            case x :: xs => x match {\n                case x : Long => x :: flattenList(xs)\n                case x : List[Any] => flattenList(x) ::: flattenList(xs)\n            }\n        }",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case long : Long => List(long)\n            case _ => List()\n        }",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        list1 match {\n            case Nil => Nil\n            case (x : Long) :: xs => x :: flattenList(xs)\n            case (x : List[Any]) :: xs => flattenList(x) ::: flattenList(xs)\n        }",
    "        list1 match {\n            case Nil => Nil\n            case (x:List[Any]) :: xs => flattenList(x) ::: flattenList(xs)\n            case x :: xs => x :: flattenList(xs)\n        }",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => {\n                for (item <- list) {\n                    list2 = list2 ::: flattenList(item)\n                }\n            }\n            case item : Long => {\n                list2 = list2 :+ item\n            }\n        }\n        list2",
    "        list1 match {\n            case Nil => Nil\n            case x :: xs => x match {\n                case y : Long => y :: flattenList(xs)\n                case y : List[Any] => flattenList(y) ::: flattenList(xs)\n            }\n        }",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => list.foreach(x => list2 = list2 ::: flattenList(x))\n            case x : Long => list2 = list2 :+ x\n        }\n        list2",
    "        var list2 = List[Long]()\n        list1 match {\n            case list : List[Any] => list.foreach(x => list2 = list2 ++ flattenList(x))\n            case x : Long => list2 = list2 :+ x\n        }\n        list2",
    "        list1 match {\n            case list : List[Any] => list.flatMap(flattenList)\n            case x : Long => List(x)\n            case _ => List()\n        }",
    "        list1 match {\n            case Nil => Nil\n            case head :: tail => head match {\n                case head : Long => head :: flattenList(tail)\n                case head : List[Any] => flattenList(head) ::: flattenList(tail)\n            }\n        }",
    "        var list2 : List[Long] = List()\n        list1 match {\n            case list : List[Any] => {\n                for (i <- list) {\n                    list2 = list2 ::: flattenList(i)\n                }\n            }\n            case x : Long => {\n                list2 = list2 :+ x\n            }\n        }\n        list2",
    "        list1 match {\n            case x : Long => List(x)\n            case x : List[Any] => x.flatMap(flattenList)\n            case _ => List()\n        }"
  ]
}