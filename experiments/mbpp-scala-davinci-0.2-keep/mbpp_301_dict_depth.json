{
  "name": "mbpp_301_dict_depth",
  "language": "scala",
  "prompt": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Write a function to find the depth of a dictionary.\n    def dictDepth(d : Any) : Long = {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_301_dict_depth.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    def main(args: Array[String]) = {\n    assert(dictDepth((Any(\"a\" -> 1l, \"b\" -> Map[String,Map[String,Map[Long,Long]]](\"c\" -> Map[String,Map[Long,Long]](\"d\" -> Map[Long,Long]()))))) == (4l));\n    assert(dictDepth((Any(\"a\" -> 1l, \"b\" -> Map[String,String](\"c\" -> \"python\")))) == (2l));\n    assert(dictDepth((Any(1l -> \"Sun\", 2l -> Map[Long,Map[Long,String]](3l -> Any(4l -> \"Mon\"))))) == (3l));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => {\n                val depths = d.map(x => dictDepth(x._2))\n                if (depths.isEmpty) 1 else depths.max + 1\n            }\n            case _ => 1\n        }",
    "        d match {\n            case d : Map[Any, Any] => {\n                val depths = d.map(x => dictDepth(x._2))\n                if (depths.isEmpty) 1 else 1 + depths.max\n            }\n            case _ => 1\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth).max\n            case _ => 0\n        }",
    "        d match {\n            case null => 0\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth).max\n            case d : List[Any] => 1 + d.map(dictDepth).max\n            case _ => 1\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => {\n                if (d.size == 0) 1\n                else d.values.map(dictDepth(_)).max + 1\n            }\n            case _ => 1\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth).max\n            case _ => 0\n        }",
    "        d match {\n            case d : Map[Any, Any] => 1 + d.values.map(dictDepth(_)).max\n            case _ => 0\n        }"
  ]
}