name: HumanEval_58_common
language: js
prompt: "//Return sorted unique common elements for two arrays.\n// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n// [2, 3]\nfunction common(l1, l2){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = common;\n  assert.deepEqual(candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
  \ 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5, 3, 2, 8], [3, 2]),[2,\
  \ 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2, 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4,\
  \ 3, 2, 8], []),[]);\n}\n\ntest();"
completions: ["    var result = []\n    for (var i = 0; i < l1.length; i++){\n   \
    \     for (var j = 0; j < l2.length; j++){\n            if (l1[i] == l2[j]){\n\
    \                result.push(l1[i])\n            }\n        }\n    }\n    return\
    \ result.sort(function(a, b){return a-b});\n}\n", "    var result = [];\n    for(var\
    \ i=0; i<l1.length; i++){\n        for(var j=0; j<l2.length; j++){\n         \
    \   if(l1[i]==l2[j]){\n                if(result.indexOf(l1[i])==-1){\n      \
    \              result.push(l1[i]);\n                }\n            }\n       \
    \ }\n    }\n    return result;\n}\n", "    return [...new Set(l1.filter(n=>l2.includes(n)))].sort();\n\
    }\n", "    let newArray = [];\n    for(let i=0; i<l1.length; i++){\n        for(let\
    \ j=0; j<l2.length; j++){\n            if(l1[i] === l2[j]){\n                newArray.push(l1[i]);\n\
    \            }\n        }\n    }\n    return newArray.sort();\n}\n", "    //var\
    \ result = l1.filter(function(val){ return l2.indexOf(val) > -1; });\n    //return\
    \ result.sort().filter(function(item, pos, ary) { return !pos || item != ary[pos\
    \ - 1]; });\n    return l1.filter(function(val){ return l2.indexOf(val) > -1;\
    \ }).sort().filter(function(item, pos, ary) { return !pos || item != ary[pos -\
    \ 1]; });\n}\n", "    var common_arr = []\n    var st = Math.min(l1.length, l2.length)\n\
    \    var nd = Math.max(l1.length, l2.length)\n    for(var i = 0; i < st; i++){\n\
    \        for(var j = 0; j < nd; j++){\n            if(l1[i] === l2[j]){\n    \
    \            common_arr.push(l1[i])\n            }\n        }\n    }\n    return\
    \ common_arr.sort()\n}\n", "    let commonElements = [];\n    for(let i = 0; i\
    \ < l1.length; i++){\n        for(let j = 0; j < l2.length; j++){\n          \
    \  if(l1[i] === l2[j]){\n                commonElements.push(l1[i]);\n       \
    \     }\n        }\n    }\n    return commonElements.sort((a, b) => {return a\
    \ - b;});\n}\n", "    // let newArr = []\n    // let set = new Set(l1.concat(l2))\n\
    \    // let map = new Map()\n    // for(let item of set){\n    //     map.set(item,\
    \ 0)\n    // }\n    // for(let item of l1){\n    //     if(map.has(item)){\n \
    \   //         map.set(item, map.get(item) + 1)\n    //     }\n    // }\n    //\
    \ for(let item of l2){\n    //     if(map.has(item)){\n    //         map.set(item,\
    \ map.get(item) + 1)\n    //     }\n    // }\n    // for(let item of set){\n \
    \   //     if(map.get(item) == 2){\n    //         newArr.push(item)\n    // \
    \    }\n    // }\n    // return newArr\n    // let arr1 = l1.filter(item => l2.includes(item))\n\
    \    // let arr2 = l2.filter(item => l1.includes(item))\n    // return [...new\
    \ Set(arr1.concat(arr2))]\n    return [...new Set(l1.filter(item => l2.includes(item)))];\n\
    }", "    var commons = [];\n    for(var i = 0; i < l1.length; i++){\n        for(var\
    \ j = 0; j < l2.length; j++){\n            if(l1[i] == l2[j]){\n             \
    \   if(commons.indexOf(l1[i]) == -1){\n                    commons.push(l1[i]);\n\
    \                }\n            }\n        }\n    }\n    return commons;\n}\n",
  "    let result = [];\n    l1.forEach(item => l2.includes(item) ? result.push(item)\
    \ : null);\n    return Array.from(new Set(result)).sort((a, b) => a - b);\n}\n",
  "  return [...new Set(l1.filter(x => l2.includes(x)))].sort();\n}", "  const uniq1\
    \ = Array.from(new Set(l1));\n  const uniq2 = Array.from(new Set(l2));\n  let\
    \ results = [];\n  uniq1.forEach(function(item){\n    uniq2.forEach(function(item2){\n\
    \      if(item == item2){\n        results.push(item);\n      }\n    });\n  });\n\
    \  return results.sort();\n}\n", "    let hm = new HashMap();\n    let set1 =\
    \ new Set();\n    let set2 = new Set();\n    for(let el of l1){\n        if(hm.has(el)){\n\
    \            set1.add(el);\n        }\n        else{\n            hm.set(el, true);\n\
    \        }\n    }\n    for(let el of l2){\n        if(hm.has(el)){\n         \
    \   set2.add(el);\n        }\n    }\n    let intersection = new Set([...set1].filter(x\
    \ => set2.has(x)));\n    return [...intersection];\n}", "    var list = l1.concat(l2);\n\
    \    return list.filter(function(item, pos) {\n        return list.indexOf(item)\
    \ == pos;\n    }).sort(function(a, b){return a-b});\n}\n", "    var result=[];\n\
    \    for(var i=0; i<l1.length; i++){\n        for(var j=0; j<l2.length; j++){\n\
    \            if(l1[i]===l2[j]){\n                result.push(l1[i]);\n       \
    \     }\n        }\n    }\n    return unique(result);\n}\n", "  const l1Sorted\
    \ = l1.sort((a, b) => a - b);\n  const l2Sorted = l2.sort((a, b) => a - b);\n\
    \  const l1Set = new Set(l1Sorted);\n  const l2Set = new Set(l2Sorted);\n  const\
    \ l1SetAndL2Set = new Set([...l1Set].filter(val => l2Set.has(val)));\n  return\
    \ [...l1SetAndL2Set];\n}\n\nmodule.exports = {\n  common\n};", "    let arr1 =\
    \ l1.sort(function(a, b){return a-b});\n    let arr2 = l2.sort(function(a, b){return\
    \ a-b});\n    let unique = [];\n    let i = 0;\n    let j = 0;\n    while(i <\
    \ arr1.length && j < arr2.length){\n        if(arr1[i] === arr2[j]){\n       \
    \     unique.push(arr1[i]);\n            i++;\n            j++;\n        }\n \
    \       else if(arr1[i] < arr2[j]){\n            i++;\n        }\n        else{\n\
    \            j++;\n        }\n    }\n    return unique;\n}\n", "  var intersect\
    \ = l1.filter(function(n) {\n   return l2.indexOf(n) !== -1;\n});\n  var unique\
    \ = [];\n  for (var i=0; i<intersect.length; i++){\n    if (unique.indexOf(intersect[i])\
    \ === -1){\n      unique.push(intersect[i]);\n    }\n  }\n  return unique.sort();\n\
    }\n", "    let set1 = new Set(l1);\n    let set2 = new Set(l2);\n    let result\
    \ = new Set([...set1].filter(x => set2.has(x)));\n    return Array.from(result).sort((a,\
    \ b) => a - b);\n}\n", "\treturn l1.filter(x => l2.includes(x));\n}\n\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
