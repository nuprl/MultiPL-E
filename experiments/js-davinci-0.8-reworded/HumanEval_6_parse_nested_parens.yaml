name: HumanEval_6_parse_nested_parens
language: js
prompt: "//Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n// [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = parse_nested_parens;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"\
  ),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[1,\
  \ 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[4]);\n}\n\ntest();"
completions: ["    var level = 0;\n    var maxlevel = 0;\n    var result = [];\n \
    \   for (var i = 0; i < paren_string.length; i++){\n        if (paren_string[i]\
    \ == \"(\"){\n            level += 1;\n            if (level > maxlevel){\n  \
    \              maxlevel = level;\n            }\n        }\n        else if (paren_string[i]\
    \ == \")\"){\n            level -= 1;\n        }\n        else if (paren_string[i]\
    \ == \" \"){\n            result.push(maxlevel);\n            maxlevel = 0;\n\
    \            level = 0;\n        }\n    }\n    result.push(maxlevel);\n    return\
    \ result;\n}\n\n", "    let maxCount = 0;\n    let nested_parens = [];\n    paren_string.split('\
    \ ').forEach(paren => {\n        let count = 0;\n        paren.split('').forEach(char\
    \ => {\n            if(char === '('){\n                count++;\n            }\
    \ else if(char === ')'){\n                count--;\n            }\n        });\n\
    \        if(count > maxCount){\n            maxCount = count;\n        }\n   \
    \     nested_parens.push(count);\n    });\n    return nested_parens;\n}\n", " \
    \   var new_string = paren_string.replace(/ /g, '');\n    var stack = [];\n  \
    \  var count = 0;\n    var max = 0;\n    var group = [];\n    var last_char =\
    \ \"\";\n    var last_paren = \"\";\n    for (var i = 0; i < new_string.length;\
    \ i++){\n        var char = new_string[i];\n        if (char === \"(\"){\n   \
    \         stack.push(char);\n            count++;\n            if (count > max){\n\
    \                max = count;\n            }\n        }\n        else if (char\
    \ === \")\"){\n            stack.pop();\n            count--;\n        }\n   \
    \     if (last_char === \")\" && char === \"(\"){\n            group.push(max);\n\
    \            max = 0;\n        }\n        last_char = char;\n    }\n    group.push(max);\n\
    \    return group;\n}\n", "    var result = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            for(var j = i + 1;\
    \ j < paren_string.length; j++){\n                if(paren_string[j] === '('){\n\
    \                    result.push(1)\n                }\n                if(paren_string[j]\
    \ === ')'){\n                    result.push(0)\n                }\n         \
    \   }\n        }\n    }\n    return result;\n}", "    // your code here\n    paren_string\
    \ = paren_string.split(\" \");\n    var index = 0;\n    var indexOne = 0;\n  \
    \  var indexTwo = 0;\n    var result = [];\n    var count = 0;\n    for(var i\
    \ = 0; i < paren_string.length; i++){\n        index = paren_string[i].indexOf(\"\
    (\");\n        indexOne = paren_string[i].indexOf(\")\");\n        indexTwo =\
    \ paren_string[i].lastIndexOf(\")\");\n        count = 0;\n        while(indexOne\
    \ < indexTwo){\n            count++;\n            indexOne = paren_string[i].indexOf(\"\
    )\", indexOne + 1);\n        }\n        result.push(count);\n    }\n    return\
    \ result;\n}", "    var paren_array = paren_string.split(\" \");\n    var result\
    \ = [];\n    for(var i = 0; i < paren_array.length; i++){\n        var paren_counter\
    \ = 0;\n        var max_paren_counter = 0;\n        for(var j = 0; j < paren_array[i].length;\
    \ j++){\n            if(paren_array[i][j] == \"(\"){\n                paren_counter\
    \ += 1;\n                if(paren_counter > max_paren_counter){\n            \
    \        max_paren_counter = paren_counter;\n                }\n            }\n\
    \            else if(paren_array[i][j] == \")\"){\n                paren_counter\
    \ -= 1;\n            }\n        }\n        result.push(max_paren_counter);\n \
    \   }\n    return result;\n}\n\n", "    var group = paren_string.split(\" \");\n\
    \    for(var i = 0; i < group.length; i++){\n        var max_nest = 0;\n     \
    \   var nest = 0;\n        for(var j = 0; j < group[i].length; j++){\n       \
    \     if(group[i][j] == '('){\n                nest++;\n                if(nest\
    \ > max_nest){\n                    max_nest = nest;\n                }\n    \
    \        }\n            else if(group[i][j] == ')'){\n                nest--;\n\
    \            }\n        }\n        group[i] = max_nest;\n    }\n    return group;\n\
    }\n", "  var paren_arr = paren_string.split(' ');\n  var result = [];\n  for(var\
    \ i = 0; i < paren_arr.length; i++){\n    result.push(find_nested_parens(paren_arr[i]));\n\
    \  }\n  return result;\n}\n", "    let answer = [];\n    let levels = [];\n  \
    \  for(let i = 0; i < paren_string.length; i++){\n        let curr_char = paren_string[i];\n\
    \        //if curr_char == '(', then we push to the levels stack\n        if(curr_char\
    \ == '('){\n            levels.push(1);\n        }\n        // if curr_char ==\
    \ ')', then we subtract from the last index in levels\n        else if(curr_char\
    \ == ')'){\n            if(levels.length == 0){\n                levels.push(0);\n\
    \            }\n            else{\n                levels[levels.length - 1] -=\
    \ 1;\n            }\n        }\n        // if curr_char == ' ', then we add an\
    \ element to levels\n        else if(curr_char == ' '){\n            answer.push(levels[levels.length\
    \ - 1]);\n            levels.push(0);\n        }\n    }\n    return answer;\n\
    }\n", "    var paren_arr = paren_string.split(\" \")\n    var paren_result = []\n\
    \    for (var i = 0; i < paren_arr.length; i++){\n        paren_result.push(parse_parens(paren_arr[i]))\n\
    \    }\n    return paren_result\n}\n", "\tvar result = [];\n\tvar temp = [];\n\
    \tparen_string.split(' ').forEach(function(element, index, array){\n\t\ttemp =\
    \ parse_string(element);\n\t\tresult.push(temp);\n\t});\n\treturn result;\n}\n",
  "  const count = [];\n  const openingParens = [\"(\", \"[\", \"{\"];\n  const closingParens\
    \ = [\")\", \"]\", \"}\"];\n  let stack = [];\n  let str = '';\n  for (let i =\
    \ 0; i < paren_string.length; i++) {\n    if (paren_string[i] === \" \") {\n \
    \     count.push(stack.length);\n      stack = [];\n      str = '';\n    } else\
    \ {\n      str += paren_string[i];\n      if (openingParens.includes(paren_string[i]))\
    \ {\n        stack.push(paren_string[i]);\n      } else if (closingParens.includes(paren_string[i]))\
    \ {\n        if (closingParens.indexOf(paren_string[i]) === openingParens.indexOf(stack[stack.length\
    \ - 1])) {\n          stack.pop();\n        } else {\n          throw `Parens\
    \ don't match in ${str}`;\n        }\n      }\n    }\n  }\n  count.push(stack.length);\n\
    \  return count;\n}\n\nmodule.exports = {\n  parse_nested_parens,\n};", "  var\
    \ finalArray = paren_string.split(\" \");\n  var level = 0;\n  var parenLevels\
    \ = new Array();\n  for(var i = 0; i < finalArray.length; i++){\n    level = 0;\n\
    \    for(var j = 0; j < finalArray[i].length; j++){\n      if(finalArray[i][j]\
    \ == \"(\"){\n        level++;\n      }\n      else if(finalArray[i][j] == \"\
    )\"){\n        level--;\n      }\n    }\n    parenLevels.push(level);\n  }\n \
    \ return parenLevels;\n}", "  //create array to return\n  var paren_array = paren_string.split(\"\
    \ \");\n  //array to store answers\n  var answers = [];\n  //loop through each\
    \ paren\n  for(var i = 0; i < paren_array.length; i++){\n    //starting count\n\
    \    var counter = 0;\n    //maximum count\n    var max_count = 0;\n    //loop\
    \ through each paren\n    for(var j = 0; j < paren_array[i].length; j++){\n  \
    \    //if it's an open paren\n      if(paren_array[i][j] === \"(\"){\n       \
    \ //add to counter\n        counter++;\n        //if counter is greater than max\
    \ count, replace it\n        if(counter > max_count){\n          max_count = counter;\n\
    \        }\n      }\n      //if it's a close paren\n      else if(paren_array[i][j]\
    \ === \")\"){\n        //subtract from counter\n        counter--;\n      }\n\
    \    }\n    //push current max count to answers array\n    answers.push(max_count);\n\
    \  }\n  //return answers array\n  return answers;\n}", "    var output = [];\n\
    \    var start = 0;\n    var end = 0;\n    while(paren_string.length > 0){\n \
    \       end = paren_string.indexOf(\" \");\n        if(end == -1){\n         \
    \   end = paren_string.length;\n        }\n        var substring = paren_string.substring(start,\
    \ end);\n        paren_string = paren_string.substring(end + 1);\n        output.push(nested_parens(substring));\n\
    \    }\n    return output;\n}\n", "    var arr = paren_string.split(\" \");\n\
    \    var ret = [];\n    for(var i = 0; i < arr.length; i++){\n        var leftCount\
    \ = 0;\n        var rightCount = 0;\n        var left = true;\n        var max\
    \ = 0;\n        for(var j = 0; j < arr[i].length; j++){\n            if(arr[i][j]\
    \ == \"(\"){\n                if(left) leftCount++;\n                else rightCount++;\n\
    \            }\n            else if(arr[i][j] == \")\"){\n                if(left)\
    \ leftCount--;\n                else rightCount--;\n            }\n          \
    \  if(leftCount < 0){\n                left = false;\n                leftCount\
    \ = 0;\n            }\n            if(rightCount < 0){\n                left =\
    \ true;\n                rightCount = 0;\n            }\n            max = Math.max(max,\
    \ Math.max(leftCount, rightCount));\n        }\n        ret.push(max);\n    }\n\
    \    return ret;\n}\n", "    let stack = [];\n    let ans = [];\n    let max =\
    \ 0;\n    let current = 0;\n    for(let i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] == '('){\n            stack.push(paren_string[i]);\n\
    \            current += 1;\n            max = Math.max(max, current);\n      \
    \  }\n        else if(paren_string[i] == ')'){\n            stack.pop();\n   \
    \         current -= 1;\n        }\n        else{\n            ans.push(max);\n\
    \            max = 0;\n            current = 0;\n        }\n    }\n    return\
    \ ans;\n}\n", "    var result = [];\n    var new_string = '';\n    paren_string\
    \ = paren_string.replace(/\\(\\(/g, '(');\n    for (var i = 0; i < paren_string.length;\
    \ i++){\n        if (paren_string[i] == '(' || paren_string[i] == ')') {\n   \
    \         new_string += paren_string[i];\n        }\n    }\n    var str_array\
    \ = new_string.split(' ');\n    console.log(str_array);\n    str_array.forEach(function(elem){\n\
    \        result.push(parse_parens(elem));\n    });\n    return result;\n}\n\n",
  "    return paren_string.split(' ').map(i => {\n        var parens = 0;\n      \
    \  var max_parens = 0;\n        for (var j=0; j<i.length; j++){\n            if\
    \ (i[j] == '('){\n                parens++;\n                if (parens > max_parens){\n\
    \                    max_parens = parens;\n                }\n            }\n\
    \            else if (i[j] == ')'){\n                parens--;\n            }\n\
    \        }\n        return max_parens;\n    });\n}\n\n\n", "    var parens = paren_string.split(\"\
    \ \");\n    var num_parens = [];\n    for (var i = 0; i < parens.length; i++){\n\
    \        num_parens.push(num_nested_parens(parens[i]));\n    }\n    return num_parens;\n\
    }\n", "    var parens = paren_string.split(\" \");\n    var result = [];\n   \
    \ for(var i = 0; i < parens.length; i++){\n        result.push(find_nested_level(parens[i]));\n\
    \    }\n    return result;\n}\n", "    let res = [];\n    let parens = paren_string.split('\
    \ ');\n    for(let paren of parens){\n        let stack = [];\n        let max\
    \ = 0;\n        for(let i = 0; i < paren.length; i++){\n            if(paren[i]\
    \ === '('){\n                stack.push(paren[i]);\n                max = Math.max(max,\
    \ stack.length);\n            }\n            else{\n                stack.pop();\n\
    \            }\n        }\n        res.push(max);\n    }\n    return res;\n}",
  "    var paren_array = paren_string.split(' ');\n    var output = [];\n    for(var\
    \ i = 0; i < paren_array.length; i++){\n        output.push(count_paren_depth(paren_array[i]));\n\
    \    }\n    return output;\n}\n", "    return paren_string.split(' ').map(function(a){\n\
    \        return a.split('').reduce(function(max, x){\n            if(x == '('){\n\
    \                max++;\n            }\n            else if(x == ')'){\n     \
    \           max--;\n            }\n            return max;\n        }, 0);\n \
    \   });\n}\n", "  const grp_arr = paren_string.split(' ');\n  // console.log(grp_arr);\n\
    \  const level_arr = grp_arr.map(grp=>{\n    let max_level = 0;\n    let level\
    \ = 0;\n    for(let i=0; i<grp.length; i++){\n      if(grp[i]==='('){\n      \
    \  level += 1;\n        if(level>max_level){\n          max_level = level;\n \
    \       }\n      }\n      else if(grp[i]===')'){\n        level -= 1;\n      }\n\
    \    }\n    return max_level;\n  });\n  return level_arr;\n}\n", "\tlet paren_groups\
    \ = paren_string.split(\" \");\n\tlet levels = [];\n\tfor(let i = 0; i < paren_groups.length;\
    \ i++){\n\t\tlevels.push(deepest_parens(paren_groups[i]));\n\t}\n\treturn levels;\n\
    }", "    // your code here\n    var result = [];\n    var groups = paren_string.split(\"\
    \ \");\n    var max = 0;\n    var count = 0;\n    for (var i = 0; i < groups.length;\
    \ i++) {\n        for (var j = 0; j < groups[i].length; j++) {\n            if\
    \ (groups[i][j] == \"(\") {\n                count ++;\n            } else if\
    \ (groups[i][j] == \")\") {\n                count --;\n            }\n      \
    \      if (count > max) {\n                max = count;\n            }\n     \
    \   }\n        result.push(max);\n        max = 0;\n        count = 0;\n    }\n\
    \    return result;\n}", "  var count = 0;\n  var arr = [];\n  var result = [];\n\
    \  var sub_str = '';\n  var index = 0;\n  var start_index = 0;\n  var end_index\
    \ = 0;\n  var new_arr = [];\n  for(var i = 0; i < paren_string.length; i++){\n\
    \    if(paren_string[i] === '('){\n      count++;\n    }\n    if(paren_string[i]\
    \ === ')'){\n      count--;\n    }\n    arr.push(count);\n  }\n  for(var j = 0;\
    \ j < arr.length; j++){\n    if(arr[j] === 0){\n      end_index = j;\n      sub_str\
    \ = paren_string.slice(start_index, end_index + 1);\n      new_arr.push(sub_str);\n\
    \      start_index = end_index + 2;\n    }\n  }\n  for(var k = 0; k < new_arr.length;\
    \ k++){\n    var max = Math.max.apply(null, new_arr[k].split(''));\n    result.push(max);\n\
    \  }\n  return result;\n}", "    var regex = /\\((.*?)\\)/g;\n    var parens =\
    \ paren_string.match(regex);\n    var result = [];\n    for(var i = 0; i < parens.length;\
    \ i++){\n        var maxCount = 0;\n        var currCount = 0;\n        for(var\
    \ j = 0; j < parens[i].length; j++){\n            if(parens[i][j] == '('){\n \
    \               currCount++;\n            }\n            else if(parens[i][j]\
    \ == ')'){\n                currCount--;\n            }\n            if(currCount\
    \ > maxCount){\n                maxCount = currCount;\n            }\n       \
    \ }\n        result.push(maxCount);\n    }\n    return result;\n}\n", "    var\
    \ paren_array = paren_string.split(\" \");\n    var result = [];\n    for(var\
    \ paren in paren_array){\n        var temp = paren_array[paren];\n        result.push(parse_single_paren(temp));\n\
    \    }\n    return result;\n}\n", "    var paren_arr = paren_string.split(\" \"\
    );\n    var paren_cnt_arr = [];\n    for(var i=0; i<paren_arr.length; i++){\n\
    \        paren_cnt_arr.push(paren_arr[i].length-2);\n    }\n    return paren_cnt_arr;\n\
    }", "    var result = [];\n    var parens = paren_string.split(\" \");\n    for(var\
    \ i = 0; i < parens.length; i++){\n        var cur_max = 0;\n        var cur_paren\
    \ = parens[i];\n        for(var j = 0; j < cur_paren.length; j++){\n         \
    \   if(cur_paren[j] == '('){\n                cur_max += 1;\n            }\n \
    \           else{\n                cur_max -= 1;\n            }\n        }\n \
    \       result.push(cur_max);\n    }\n    return result;\n}\n", "\tlet res = paren_string.split(\"\
    \ \");\n\tres = res.map(elem => {\n\t\tlet cnt = 0;\n\t\tlet max = 0;\n\t\tfor(let\
    \ i = 0; i < elem.length; i++){\n\t\t\tif(elem[i] === \"(\"){\n\t\t\t\tcnt++;\n\
    \t\t\t\tmax = Math.max(max, cnt);\n\t\t\t}\n\t\t\telse if(elem[i] === \")\"){\n\
    \t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t});\n\treturn res;\n}\n", " \
    \   let count_array = [];\n    let paren_array = paren_string.split(\" \");\n\
    \    for (let i = 0; i < paren_array.length; i++){\n        let count = 0;\n \
    \       let curr_paren = paren_array[i];\n        let new_paren = curr_paren.slice(1,\
    \ curr_paren.length - 1);\n        for (let i = 0; i < new_paren.length; i++){\n\
    \            if (new_paren[i] === \"(\"){\n                count++;\n        \
    \    }\n        }\n        count_array.push(count);\n    }\n    return count_array;\n\
    }", "\tvar split_string = paren_string.split(\" \");\n\tvar result = [];\n\tfor(var\
    \ i = 0; i < split_string.length; i++){\n\t\tvar temp = 0;\n\t\tvar max = 0;\n\
    \t\tfor(var j = 0; j < split_string[i].length; j++){\n\t\t\tif(split_string[i][j]\
    \ == \"(\"){\n\t\t\t\ttemp++;\n\t\t\t\tif(temp > max){\n\t\t\t\t\tmax = temp;\n\
    \t\t\t\t}\n\t\t\t}else if(split_string[i][j] == \")\"){\n\t\t\t\ttemp--;\n\t\t\
    \t}\n\t\t}\n\t\tresult.push(max);\n\t}\n\treturn result;\n}\n", "  var deepest\
    \ = 0;\n  var deepest_array = [];\n  var count = 0;\n  for (var i = 0; i < paren_string.length;\
    \ i++){\n    if (paren_string[i] === \"(\"){\n      count++;\n      if (count\
    \ > deepest){\n        deepest = count;\n      }\n    } else if (paren_string[i]\
    \ === \")\"){\n      count--;\n      if (count === 0){\n        deepest_array.push(deepest);\n\
    \        deepest = 0;\n      }\n    }\n  }\n  return deepest_array;\n}\n", " \
    \   return paren_string.split(' ').map(function(x){\n        return x.match(/\\\
    (((?=\\()*\\))/g).length;\n    });\n}\n", "    var answer = [];\n    var paren_array\
    \ = paren_string.split(\" \");\n    for (var i = 0; i < paren_array.length; i++){\n\
    \        var current_group = paren_array[i];\n        var current_sum = 0;\n \
    \       var max_sum = 0;\n        for (var j = 0; j < current_group.length; j++){\n\
    \            var current_char = current_group[j];\n            if (current_char\
    \ == \"(\"){\n                current_sum++;\n            }\n            else\
    \ if (current_char == \")\"){\n                current_sum--;\n            }\n\
    \            if (current_sum > max_sum){\n                max_sum = current_sum;\n\
    \            }\n        }\n        answer.push(max_sum);\n    }\n    return answer;\n\
    }\n", "    // split the string by spaces\n    let arrayOfGroups = paren_string.split(\"\
    \ \");\n    //for each string of parens we need to find the deepest level of nesting\
    \ of parentheses.\n    let maxLevels = [];\n    for(let i = 0; i < arrayOfGroups.length;\
    \ i++){\n        // go through each string character by character looking for\
    \ ( or )\n        let currentString = arrayOfGroups[i];\n        let currentLevel\
    \ = 0;\n        let maxLevel = 0;\n        for(let j = 0; j < currentString.length;\
    \ j++){\n            // if we find a ( we add 1 to our currentLevel\n        \
    \    if(currentString[j] === \"(\"){\n                currentLevel += 1;\n   \
    \         }\n            // if we find a ) we subtract 1 from our currentLevel\n\
    \            if(currentString[j] === \")\"){\n                currentLevel -=\
    \ 1;\n            }\n            // after each new character we check to see if\
    \ our currentLevel is larger than our maxLevel.\n            if(currentLevel >\
    \ maxLevel){\n                maxLevel = currentLevel;\n            }\n      \
    \  }\n        // then we push maxLevel to our maxLevels array\n        maxLevels.push(maxLevel);\n\
    \    }\n    return maxLevels;\n}\n", "    const parens = paren_string.split(\"\
    \ \");\n    const results = [];\n    for(let paren of parens){\n        let cur\
    \ = 0;\n        let max = 0;\n        for(let i = 0; i < paren.length; i++){\n\
    \            if(paren[i] === \"(\"){\n                cur++;\n               \
    \ max = Math.max(max, cur);\n            }\n            else if(paren[i] === \"\
    )\"){\n                cur--;\n            }\n        }\n        results.push(max);\n\
    \    }\n    return results;\n}\n", "    var max_nesting_count = 0;\n    var nesting_count\
    \ = 0;\n    var nesting_count_arr = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == \"(\"){\n            nesting_count++;\n\
    \            if(nesting_count > max_nesting_count){\n                max_nesting_count\
    \ = nesting_count;\n            }\n        }\n        else if(paren_string[i]\
    \ == \")\"){\n            nesting_count_arr.push(nesting_count);\n           \
    \ nesting_count = 0;\n        }\n    }\n    return nesting_count_arr;\n}\n", " \
    \   //TODO\n    let array_of_parens = paren_string.split(\" \");\n    let levels\
    \ = [];\n    for (let group of array_of_parens){\n        let highest = 0;\n \
    \       let level = 0;\n        for (let i = 0; i < group.length; i++){\n    \
    \        if (group[i] == \"(\"){\n                level += 1;\n            }\n\
    \            else if (group[i] == \")\"){\n                level -= 1;\n     \
    \       }\n            if (level > highest){\n                highest = level;\n\
    \            }\n        }\n        levels.push(highest);\n    }\n    return levels;\n\
    }\n\n", "    let paren_splitted = paren_string.split(\" \");\n    let paren_max\
    \ = [];\n    for (let i = 0; i < paren_splitted.length; i++){\n        paren_max.push(parse_parens(paren_splitted[i]));\n\
    \    }\n    return paren_max;\n}\n", "    // Write a solution here\n    var splitString\
    \ = paren_string.split(\" \");\n    var result = [];\n    var stack = [];\n  \
    \  for(var i = 0; i < splitString.length; i++){\n        if(splitString[i] ===\
    \ \"(\"){\n            stack.push(splitString[i]);\n        }\n        else if(splitString[i]\
    \ === \")\"){\n            stack.pop();\n        }\n        result.push(stack.length);\n\
    \    }\n    return result;\n}\n", "  var result = [];\n  var groups = paren_string.split(\"\
    \ \");\n  for (var i = 0; i < groups.length; i++){\n    var current = groups[i];\n\
    \    var num_open = 0;\n    var max_open = 0;\n    for (var j = 0; j < current.length;\
    \ j++){\n      if (current[j] == \"(\"){\n        num_open += 1;\n        if (num_open\
    \ > max_open){\n          max_open = num_open;\n        }\n      }\n      else\
    \ if (current[j] == \")\"){\n        num_open -= 1;\n      }\n    }\n    result.push(max_open);\n\
    \  }\n  return result;\n}\n", "    let parens = paren_string.split(' ');\n   \
    \ let parsed = [];\n    for(let i = 0; i < parens.length; i++){\n        parsed.push(parse_single_paren(parens[i]));\n\
    \    }\n    return parsed;\n}\n", "    var max_open = 0;\n    var paren_array\
    \ = paren_string.split(\" \");\n    var output = [];\n    for (var i = 0; i <\
    \ paren_array.length; i++){\n        var s = paren_array[i];\n        var curr_max\
    \ = 0;\n        var curr_open = 0;\n        for (var j = 0; j < s.length; j++){\n\
    \            if (s[j] == '('){\n                curr_open++;\n               \
    \ if (curr_open > curr_max){\n                    curr_max = curr_open;\n    \
    \            }\n            }\n            else if (s[j] == ')'){\n          \
    \      curr_open--;\n            }\n        }\n        output.push(curr_max);\n\
    \    }\n    return output;\n}", "    var result = [];\n    var regex = /[()]/g;\n\
    \    var match_arr = paren_string.match(regex);\n    var max_depth = 0;\n    var\
    \ depth = 0;\n    for(var i = 0; i < match_arr.length; i++){\n        if(match_arr[i]\
    \ == \"(\"){\n            depth++;\n            if(depth > max_depth){\n     \
    \           max_depth = depth;\n            }\n        }\n        else if(match_arr[i]\
    \ == \")\"){\n            depth--;\n        }\n        if(i < match_arr.length\
    \ - 1 && match_arr[i+1] == \" \"){\n            result.push(max_depth);\n    \
    \        max_depth = 0;\n        }\n    }\n    return result;\n}", "    const\
    \ strings = paren_string.split(' ');\n    const answers = [];\n    for(const string\
    \ of strings){\n        let stack = [];\n        let maxDepth = 0;\n        for(const\
    \ char of string){\n            if(char === '('){\n                stack.push(char);\n\
    \                maxDepth = Math.max(maxDepth, stack.length);\n            }\n\
    \            else{\n                stack.pop();\n            }\n        }\n \
    \       answers.push(maxDepth);\n    }\n    return answers;\n}\n\nmodule.exports\
    \ = {\n    parse_nested_parens\n};", "    var stack=[];\n    var result=[];\n\
    \    for(var i=0;i<paren_string.length;i++){\n        if(paren_string[i]=='('){\n\
    \            stack.push(paren_string[i]);\n        }\n        else if(paren_string[i]==')'){\n\
    \            stack.pop();\n        }\n        else if(paren_string[i]==' '){\n\
    \            result.push(stack.length);\n        }\n    }\n    return result;\n\
    }\n", "  let paren_groups = paren_string.split(\" \");\n  let paren_levels = [];\n\
    \  for (let i = 0; i < paren_groups.length; i++){\n    let current_paren_group\
    \ = paren_groups[i];\n    let current_paren_level = 0;\n    let deepest_paren_level\
    \ = 0;\n    for (let j = 0; j < current_paren_group.length; j++){\n      if (current_paren_group[j]\
    \ === \"(\"){\n        current_paren_level++;\n      }\n      if (current_paren_group[j]\
    \ === \")\"){\n        current_paren_level--;\n      }\n      if (current_paren_level\
    \ > deepest_paren_level){\n        deepest_paren_level = current_paren_level;\n\
    \      }\n    }\n    paren_levels.push(deepest_paren_level);\n  }\n  return paren_levels;\n\
    }\n", "    const parenArr = paren_string.split(' ');\n    let result = [];\n \
    \   parenArr.forEach(element => {\n        let count = 0;\n        let currentDepth\
    \ = 0;\n        for(let i = 0; i < element.length; i++){\n            if(element[i]\
    \ === '('){\n                count++;\n                if(count > currentDepth){\n\
    \                    currentDepth = count;\n                }\n            }else\
    \ if(element[i] === ')'){\n                count--;\n            }\n        }\n\
    \        result.push(currentDepth);\n    });\n    return result;\n}\n", "    paren_string\
    \ = paren_string.split(\" \");\n    var max_depth = 0;\n    var answer = [];\n\
    \    for(var i = 0; i < paren_string.length; i++){\n        var j = 0;\n     \
    \   var current_depth = 0;\n        while(j < paren_string[i].length){\n     \
    \       if(paren_string[i][j] == \"(\"){\n                current_depth++;\n \
    \           }else if(paren_string[i][j] == \")\"){\n                current_depth--;\n\
    \            }\n            j++;\n        }\n        answer.push(current_depth);\n\
    \    }\n    return answer;\n}\n", "    let paren_arr = paren_string.split(\" \"\
    );\n    let max_levels = [];\n    paren_arr.forEach(value => {\n        let level\
    \ = 0;\n        let max_level = 0;\n        for(let i = 0; i < value.length; i++){\n\
    \            if(value[i] === \"(\"){\n                level++;\n             \
    \   if(level > max_level){\n                    max_level = level;\n         \
    \       }\n            }\n            else if(value[i] === \")\"){\n         \
    \       level--;\n            }\n        }\n        max_levels.push(max_level);\n\
    \    });\n    return max_levels;\n}", "    let paren = paren_string.split(\" \"\
    );\n    // console.log(paren);\n    let return_array = [];\n    for(let i = 0;\
    \ i < paren.length; i++){\n        let count = 0;\n        let max = 0;\n    \
    \    for(let j = 0; j < paren[i].length; j++){\n            if(paren[i][j] ===\
    \ \"(\"){\n                count++;\n                if(count > max){\n      \
    \              max = count;\n                }\n            }\n            else\
    \ if(paren[i][j] === \")\"){\n                count--;\n            }\n      \
    \  }\n        return_array.push(max);\n    }\n    return return_array;\n}", "\t\
    var paren_array = paren_string.split(' ');\n\tvar paren_levels = [];\n\tfor (var\
    \ i = 0; i < paren_array.length; i++){\n\t\tvar current_paren_level = 0;\n\t\t\
    var current_paren_string = paren_array[i];\n\t\tfor (var j = 0; j < current_paren_string.length;\
    \ j++){\n\t\t\tif (current_paren_string[j] == '('){\n\t\t\t\tcurrent_paren_level++;\n\
    \t\t\t}\n\t\t\telse if (current_paren_string[j] == ')'){\n\t\t\t\tcurrent_paren_level--;\n\
    \t\t\t}\n\t\t}\n\t\tparen_levels.push(current_paren_level);\n\t}\n\treturn paren_levels;\n\
    }\n", "    let max_num = 0;\n    let arr = paren_string.split(\" \");\n    let\
    \ results = [];\n    for(let i = 0; i < arr.length; i++){\n        let num = 0;\n\
    \        for(let j = 0; j < arr[i].length; j++){\n            if(arr[i][j] ===\
    \ \"(\"){\n                num += 1;\n            }else if(arr[i][j] === \")\"\
    ){\n                num -= 1;\n            }\n        }\n        if(num > max_num){\n\
    \            max_num = num;\n        }\n        results.push(max_num);\n    }\n\
    \    return results;\n}\n", "\tvar paren_list = paren_string.split(\" \");\n\t\
    return paren_list.map(function(str){\n\t\tvar count = 0;\n\t\tvar max = 0;\n\t\
    \tfor(var i = 0; i < str.length; i++){\n\t\t\tif(str[i] == \"(\"){\n\t\t\t\tcount++;\n\
    \t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\
    \ if(str[i] == \")\"){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t\
    });\n}\n", "    var prev = [0], result = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            prev.push(prev[prev.length\
    \ - 1] + 1);\n        }else if(paren_string[i] == ')'){\n            result.push(prev.pop());\n\
    \        }\n    }\n    return result;\n}\n", "  var groups = paren_string.split(\"\
    \ \");\n  var result = [];\n  for(i=0; i<groups.length; i++){\n    var max = 0;\n\
    \    var count = 0;\n    for(j=0; j<groups[i].length; j++){\n      if(groups[i][j]=='('){\n\
    \        count++;\n        if(count>max){\n          max = count;\n        }\n\
    \      }\n      else if(groups[i][j]==')'){\n        count--;\n      }\n    }\n\
    \    result.push(max);\n  }\n  return result;\n}", "    var parenArray = paren_string.split(\"\
    \ \");\n    var result = [];\n    for(var i = 0; i < parenArray.length; i++){\n\
    \        var paren_stack = [];\n        var max = 0;\n        for(var j = 0; j\
    \ < parenArray[i].length; j++){\n            if(parenArray[i][j] == \"(\"){\n\
    \                paren_stack.push(parenArray[i][j]);\n                if(paren_stack.length\
    \ > max){\n                    max = paren_stack.length;\n                }\n\
    \            }\n            else if(parenArray[i][j] == \")\"){\n            \
    \    paren_stack.pop();\n            }\n        }\n        result.push(max);\n\
    \    }\n    return result;\n}", "  let paren_group = paren_string.split(' ');\n\
    \  let result = [];\n  for(let i = 0; i < paren_group.length; i++){\n    let count\
    \ = 0;\n    let max = 0;\n    for(let j = 0; j < paren_group[i].length; j++){\n\
    \      if(paren_group[i][j] === '('){\n        count ++;\n        if(count > max){\n\
    \          max = count;\n        }\n      }else if(paren_group[i][j] === ')'){\n\
    \        count --;\n      }\n    }\n    result.push(max);\n  }\n  return result;\n\
    }\n", "  let split = paren_string.split(' ');\n  return split.map(paren=> {\n\
    \    let depth = 0;\n    let count = 0;\n    for (let i = 0; i < paren.length;\
    \ i++) {\n      if (paren[i] === '(') {\n        depth++;\n        if (depth >\
    \ count) {\n          count = depth;\n        }\n      } else {\n        depth--;\n\
    \      }\n    }\n    return count;\n  });\n}\n", "  var max = 0;\n  var arr =\
    \ [];\n  var stack = [];\n  var stringArr = paren_string.split(\" \");\n  var\
    \ j = 0;\n  var i = 0;\n  while(j < stringArr.length){\n    while(i < stringArr[j].length){\n\
    \      if(stringArr[j][i] === \"(\"){\n        stack.push(stringArr[j][i]);\n\
    \      }\n      else if(stringArr[j][i] === \")\"){\n        stack.pop();\n  \
    \    }\n      i++;\n    }\n    arr.push(stack.length);\n    i = 0;\n    j++;\n\
    \  }\n  return arr;\n}\n", "  let max_level = 0, current_level = 0, res = [];\n\
    \  for(let i = 0; i < paren_string.length; i++){\n    if(paren_string[i] === '('){\n\
    \      current_level++;\n      max_level = Math.max(max_level, current_level);\n\
    \    }else if(paren_string[i] === ')'){\n      current_level--;\n    }else if(paren_string[i]\
    \ === ' '){\n      res.push(max_level);\n      max_level = 0;\n      current_level\
    \ = 0;\n    }\n  }\n  res.push(max_level);\n  return res;\n}\n", "    var groups\
    \ = paren_string.split(\" \");\n    var res = [];\n    for(var i=0; i<groups.length;\
    \ i++){\n        var deepest_level = 0;\n        var curr_level = 0;\n       \
    \ for(var j=0; j<groups[i].length; j++){\n            if(groups[i][j]===\"(\"\
    ){\n                curr_level++;\n                if(curr_level>deepest_level){\n\
    \                    deepest_level = curr_level;\n                }\n        \
    \    }\n            else if(groups[i][j]===\")\"){\n                curr_level--;\n\
    \            }\n        }\n        res.push(deepest_level);\n    }\n    return\
    \ res;\n}\n", "\n}\n", "  let finalArray = [];\n  let splitArray = paren_string.split(\"\
    \ \");\n  for (i=0; i<splitArray.length; i++){\n    let parenString = splitArray[i];\n\
    \    let count = 0;\n    let tempCount = 0;\n    for (j=0; j<parenString.length;\
    \ j++){\n      if (parenString[j] === '('){\n        tempCount += 1;\n      }\n\
    \      if (parenString[j] === ')'){\n        tempCount -= 1;\n      }\n      if\
    \ (tempCount > count){\n        count = tempCount;\n      }\n    }\n    finalArray.push(count);\n\
    \  }\n  return finalArray;\n}\n\n", "\tlet parenList = paren_string.split(\" \"\
    );\n\tlet nestedParenArr = [];\n\tfor(let i = 0; i < parenList.length; i++){\n\
    \t\tlet paren = parenList[i];\n\t\tlet count = 0;\n\t\tlet max = 0;\n\t\tfor(let\
    \ j = 0; j < paren.length; j++){\n\t\t\tif(paren[j] === \"(\"){\n\t\t\t\tcount++;\n\
    \t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}else if(paren[j]\
    \ === \")\"){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tnestedParenArr.push(max);\n\
    \t}\n\treturn nestedParenArr;\n}\n", "    var results = [];\n    var parens =\
    \ paren_string.split(\" \");\n    for(var i = 0; i < parens.length; i++){\n  \
    \      var index = 0;\n        var maxIndex = 0;\n        var length = parens[i].length;\n\
    \        var lengthMax = 0;\n        while(index < length){\n            if(parens[i][index]\
    \ == \"(\"){\n                maxIndex++;\n                lengthMax++;\n    \
    \        }\n            else if(parens[i][index] == \")\"){\n                maxIndex--;\n\
    \                lengthMax++;\n            }\n            index++;\n        }\n\
    \        results.push(lengthMax);\n    }\n    return results;\n}\n", "    var\
    \ paren_arr = paren_string.split(\" \");\n    var max_paren = 0;\n    var paren_counter\
    \ = 0;\n    var result = [];\n    for(var i = 0; i < paren_arr.length; i++){\n\
    \        var paren_level = paren_arr[i];\n        for(var j = 0; j < paren_level.length;\
    \ j++){\n            if(paren_level[j] == \"(\"){\n                paren_counter++;\n\
    \            }\n            else if(paren_level[j] == \")\"){\n              \
    \  paren_counter--;\n            }\n            max_paren = Math.max(max_paren,\
    \ paren_counter);\n        }\n        result.push(max_paren);\n        max_paren\
    \ = 0;\n        paren_counter = 0;\n    }\n    return result;\n}\n", "    var\
    \ parens = paren_string.split(\" \");\n    var levels = []\n    for (var i = 0;\
    \ i < parens.length; i++){\n        var stack = [];\n        var count = 0;\n\
    \        for (var j = 0; j < parens[i].length; j++){\n            if (parens[i][j]\
    \ == '('){\n                stack.push('(');\n                count++;\n     \
    \       }\n            else if (parens[i][j] == ')'){\n                stack.pop();\n\
    \                count--;\n            }\n        }\n        levels.push(Math.abs(count));\n\
    \    }\n    return levels;\n}\n", "    let paren_groups = paren_string.split(\"\
    \ \");\n    return paren_groups.map( (group) => {\n        let stack = [];\n \
    \       let curr_level = 0;\n        let max_level = 0;\n        for (let i =\
    \ 0; i < group.length; i++){\n            if (group[i] === \"(\"){\n         \
    \       stack.push(1);\n                curr_level++;\n                max_level\
    \ = Math.max(max_level, curr_level);\n            } else if (group[i] === \")\"\
    ){\n                stack.pop();\n                curr_level--;\n            }\n\
    \        }\n        return max_level;\n    });\n}\n", "  var level = [],\n   \
    \   max = [];\n  //split paren_string into array of individual strings\n  var\
    \ parens = paren_string.split(\" \");\n  //iterate through parens\n  for (var\
    \ i = 0; i < parens.length; i++){\n    var count = 0;\n    for (var j = 0; j <\
    \ parens[i].length; j++){\n      //if paren is open, add one to count\n      if\
    \ (parens[i][j] === \"(\"){\n        count++;\n      }\n      //if paren is closed,\
    \ subtract one from count\n      else if (parens[i][j] === \")\"){\n        count--;\n\
    \      }\n      //if count is negative, return invalid parenthasis\n      if (count\
    \ < 0){\n        return \"invalid parenthasis\";\n      }\n    }\n    //push count\
    \ to level array\n    level.push(count);\n  }\n  //iterate through level array\n\
    \  for (var k = 0; k < level.length; k++){\n    //if level is greater than 1,\
    \ push level to max array\n    if (level[k] > 1){\n      max.push(level[k]);\n\
    \    }\n    //else level is 1\n    else {\n      //iterate through max array\n\
    \      for (var m = 0; m < max.length; m++){\n        //if level is greater than\
    \ max, push level to max array\n        if (level[k] > max[m]){\n          max.push(level[k]);\n\
    \        }\n      }\n    }\n  }\n  return max;\n}", "  let final_array = [];\n\
    \  let split_string = paren_string.split(\" \");\n  for (let i = 0; i < split_string.length;\
    \ i++){\n    let current_string = split_string[i];\n    let count = 0;\n    let\
    \ max_count = 0;\n    for (let j = 0; j < current_string.length; j++){\n     \
    \ if (current_string[j] === \"(\"){\n        count++;\n        if (count > max_count){\n\
    \          max_count = count;\n        }\n      } else if (current_string[j] ===\
    \ \")\"){\n        count--;\n      }\n    }\n    final_array.push(max_count);\n\
    \  }\n  return final_array;\n}\n", "    var parens = paren_string.split(\" \"\
    );\n    var max_depth = 0;\n    var paren_depth = 0;\n    var depth_arr = [];\n\
    \    for(var i = 0; i < parens.length; i++){\n        for(var j = 0; j < parens[i].length;\
    \ j++){\n            if(parens[i][j] == \"(\"){\n                paren_depth +=\
    \ 1;\n            }else if(parens[i][j] == \")\"){\n                paren_depth\
    \ -= 1;\n            }\n            if(paren_depth > max_depth){\n           \
    \     max_depth = paren_depth;\n            }\n        }\n        depth_arr.push(max_depth);\n\
    \        max_depth = 0;\n        paren_depth = 0;\n    }\n    return depth_arr;\n\
    }", "    var paren_split = paren_string.split(\" \");\n    var deepest_nesting\
    \ = [];\n    for (i = 0; i < paren_split.length; i++){\n        var current_depth\
    \ = 0;\n        var max_depth = 0;\n        for (n = 0; n < paren_split[i].length;\
    \ n++){\n            if (paren_split[i][n] == \"(\"){\n                current_depth\
    \ += 1;\n                if (current_depth > max_depth){\n                   \
    \ max_depth = current_depth;\n                }\n            }\n            else\
    \ if (paren_split[i][n] == \")\"){\n                current_depth -= 1;\n    \
    \        }\n        }\n        deepest_nesting.push(max_depth);\n    }\n    return\
    \ deepest_nesting;\n}\n", "    paren_string = paren_string.replace(/\\s/g,'');\n\
    \    var max_index = 0;\n    var count = 0;\n    var arr = [];\n    while(paren_string.length\
    \ > 0){\n        if(paren_string[0] == \"(\"){\n            count++;\n       \
    \     if(count > max_index){\n                max_index = count;\n           \
    \ }\n        }\n        else if(paren_string[0] == \")\"){\n            count--;\n\
    \        }\n        paren_string = paren_string.slice(1);\n    }\n    console.log(max_index);\n\
    \    return max_index;\n}\n", "  var paren_array = paren_string.split(\" \");\n\
    \  var output = [];\n  for (var i = 0; i < paren_array.length; i++){\n    var\
    \ paren_index = 0;\n    var current_paren_array = paren_array[i].split(\"\");\n\
    \    var current_paren_level = 0;\n    var max_paren_level = 0;\n    while (paren_index\
    \ < current_paren_array.length){\n      if (current_paren_array[paren_index] ==\
    \ \"(\"){\n        current_paren_level += 1;\n        if (current_paren_level\
    \ > max_paren_level){\n          max_paren_level = current_paren_level;\n    \
    \    }\n      } else if (current_paren_array[paren_index] == \")\"){\n       \
    \ current_paren_level -= 1;\n      }\n      paren_index += 1;\n    }\n    output.push(max_paren_level);\n\
    \  }\n  return output;\n}\n", "    const paren_list = paren_string.split(\" \"\
    );\n    let output = []\n    for (let i = 0; i < paren_list.length; i++){\n  \
    \      let stack = [];\n        let count = 0;\n        for (let j = 0; j < paren_list[i].length;\
    \ j++){\n            if (paren_list[i][j] === '('){\n                stack.push(paren_list[i][j]);\n\
    \                count++;\n            }\n            else if (paren_list[i][j]\
    \ === ')'){\n                if (stack.length > 0){\n                    stack.pop();\n\
    \                }\n                else{\n                    count = 0;\n  \
    \                  break;\n                }\n            }\n        }\n     \
    \   output.push(count);\n    }\n    return output;\n}\n", "    let arr = paren_string.split(\"\
    \ \");\n    let depth = [];\n    for(let i = 0; i < arr.length; i++){\n      \
    \  depth.push(getDepth(arr[i]));\n    }\n    return depth;\n}\n", "  var output\
    \ = [];\n  var max = 0;\n  var count = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      count++;\n      if(count > max){\n\
    \        max = count;\n      }\n    }\n    if(paren_string[i] == ')'){\n     \
    \ count--;\n    }\n    if(paren_string[i] == ' '){\n      output.push(max);\n\
    \      max = 0;\n      count = 0;\n    }\n  }\n  return output;\n}", "    var\
    \ array_string = paren_string.split(\" \");\n    var array_result = [];\n    var\
    \ num_parens = 0;\n    var count_parens = 0;\n    var new_str = \"\";\n    for(var\
    \ i = 0; i < array_string.length; i++){\n        num_parens = 0;\n        count_parens\
    \ = 0;\n        new_str = \"\";\n        for(var j = 0; j < array_string[i].length;\
    \ j++){\n            if(array_string[i][j] == \"(\"){\n                count_parens\
    \ = count_parens + 1;\n            }\n            else if(array_string[i][j] ==\
    \ \")\"){\n                count_parens = count_parens - 1;\n            }\n \
    \           if(count_parens > num_parens){\n                num_parens = count_parens;\n\
    \            }\n        }\n        array_result.push(num_parens);\n    }\n   \
    \ return array_result;\n}\n\n", "\t//split into list of paren strings\n\tlet paren_list\
    \ = paren_string.split(\" \");\n\tlet paren_levels = [];\n\tfor (var i = 0; i\
    \ < paren_list.length; i++) {\n\t\tparen_levels.push(get_paren_levels(paren_list[i]));\n\
    \t}\n\treturn paren_levels;\n}\n", "  // //Your code here\n  // return undefined;\n\
    \  // 1. create array to hold nested paren pairs\n  // 2. loop through paren_string,\
    \ push first paren to array\n  // 3. loop through array, if there's a closing\
    \ paren without an opening paren, push to array\n  // 4. loop through array, find\
    \ the longest string.length, return that length\n  var parenArray = [];\n  for\
    \ (var i = 0; i < paren_string.length; i++) {\n    if (paren_string[i] === '(')\
    \ {\n      parenArray.push(paren_string[i]);\n    } else if (paren_string[i] ===\
    \ ')') {\n      parenArray.push(paren_string[i]);\n    }\n  }\n  console.log(parenArray);\n\
    \  var longest = parenArray[0];\n  for (var j = 0; j < parenArray.length; j++)\
    \ {\n    if (parenArray[j].length > longest.length) {\n      longest = parenArray[j];\n\
    \    }\n  }\n  return longest.length;\n}\n", "\tlet paren_array = paren_string.split(\"\
    \ \");\n\tlet result = [];\n\tfor(let i = 0; i < paren_array.length; i++){\n\t\
    \tresult.push(depth_of_parens(paren_array[i]));\n\t}\n\treturn result;\n}\n",
  "    var paren_arr = paren_string.split(\" \");\n    var max_level = 0;\n    var\
    \ max_idx = 0;\n    for(var i = 0; i < paren_arr.length; i++){\n        var level\
    \ = 0;\n        for(var j = 0; j < paren_arr[i].length; j++){\n            if(paren_arr[i][j]\
    \ == \"(\"){\n                level++;\n            }\n            else if(paren_arr[i][j]\
    \ == \")\"){\n                level--;\n            }\n        }\n        if(level\
    \ > max_level){\n            max_level = level;\n            max_idx = i;\n  \
    \      }\n    }\n    return [max_level, max_idx];\n}\n", "  var max_parens = [];\n\
    \  var paren_indices = paren_string.split(' ');\n  // should be an array of strings\
    \ representing each of the groups\n  console.log(paren_indices);\n  // iterate\
    \ through paren_indices\n  for (var i = 0; i < paren_indices.length; i++){\n \
    \   var left_paren_count = 0;\n    var right_paren_count = 0;\n    // iterate\
    \ through each character in paren_indices[i]\n    for (var j = 0; j < paren_indices[i].length;\
    \ j++){\n      if (paren_indices[i][j] === '('){\n        left_paren_count +=\
    \ 1;\n      }\n      else if (paren_indices[i][j] === ')'){\n        right_paren_count\
    \ += 1;\n      }\n    }\n    // if number of left parentheses > right parens\n\
    \    if (left_paren_count > right_paren_count){\n      max_parens.push(left_paren_count);\n\
    \    }\n    else {\n      max_parens.push(right_paren_count);\n    }\n  }\n  console.log(max_parens);\n\
    \  return max_parens;\n}\n\nparse_nested_parens(\"(()()) ((())) () ((())()())\"\
    );", "    // paren_string.split(' ').map(paren_string => paren_string.split('').reduce((memo,\
    \ value) => {\n    //     if (value === '(') {\n    //         memo++;\n    //\
    \     } else if (value === ')') {\n    //         memo--;\n    //     }\n    //\
    \     return memo;\n    // }, 0))\n    var levels = [];\n    var level = 0;\n\
    \    var current = 0;\n    for (var i = 0; i < paren_string.length; i++) {\n \
    \       if (paren_string[i] === '(') {\n            level++;\n        } else if\
    \ (paren_string[i] === ')') {\n            level--;\n        } else if (paren_string[i]\
    \ === ' ') {\n            levels.push(level);\n            level = 0;\n      \
    \  }\n    }\n    return levels;\n}\n", "    let final_output = [];\n    let paren_array\
    \ = paren_string.split(\" \");\n    for(let i = 0; i < paren_array.length; i++){\n\
    \        let group = paren_array[i];\n        let max_nesting = 0;\n        let\
    \ current_nesting = 0;\n        for(let j = 0; j < group.length; j++){\n     \
    \       if(group[j] === \"(\"){\n                current_nesting += 1;\n     \
    \           if(current_nesting > max_nesting){\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            else if(group[j]\
    \ === \")\"){\n                current_nesting -= 1;\n            }\n        }\n\
    \        final_output.push(max_nesting);\n    }\n    return final_output;\n}\n",
  "  var parens = paren_string.split(\" \");\n  var result = [];\n  for(var i = 0;\
    \ i < parens.length; i++){\n    var current = parens[i];\n    var temp = 0;\n\
    \    var max = 0;\n    for(var j = 0; j < current.length; j++){\n      if(current[j]\
    \ === \"(\"){\n        temp++;\n        if(temp > max){\n          max = temp;\n\
    \        }\n      }\n      else if(current[j] === \")\"){\n        temp--;\n \
    \     }\n    }\n    result.push(max);\n  }\n  return result;\n}\n", "    var result\
    \ = [];\n    var deep = 0;\n    var i;\n    var temp = 0;\n    var len = paren_string.length;\n\
    \    for(i = 0; i < len; i++){\n        if(paren_string[i] === '('){\n       \
    \     temp++;\n            if(temp > deep){\n                deep = temp;\n  \
    \          }\n        }\n        else if(paren_string[i] === ')'){\n         \
    \   temp--;\n        }\n        else if(paren_string[i] === ' '){\n          \
    \  result.push(deep);\n            deep = 0;\n            temp = 0;\n        }\n\
    \    }\n    result.push(deep);\n    return result;\n}\n", "    let result = [];\n\
    \    let paren_groups = paren_string.split(\" \");\n    for(let i = 0; i < paren_groups.length;\
    \ i++){\n        let startParenIndex = -1;\n        let maxNestingLevel = 0;\n\
    \        let currentNestingLevel = 0;\n        for(let j = 0; j < paren_groups[i].length;\
    \ j++){\n            if(paren_groups[i][j] === \"(\"){\n                if(startParenIndex\
    \ < 0){\n                    startParenIndex = j;\n                }\n       \
    \         currentNestingLevel++;\n                if(currentNestingLevel > maxNestingLevel){\n\
    \                    maxNestingLevel = currentNestingLevel;\n                }\n\
    \            }\n            else if(paren_groups[i][j] === \")\"){\n         \
    \       currentNestingLevel--;\n            }\n        }\n        result.push(maxNestingLevel);\n\
    \    }\n    return result;\n}\n", "    var parens = paren_string.split(' ');\n\
    \    var result = [];\n    var stack = [];\n    for(i = 0; i < parens.length;\
    \ i++){\n        for(j = 0; j < parens[i].length; j++){\n            var elem\
    \ = parens[i][j];\n            if(elem == '('){\n                stack.push(elem);\n\
    \            }\n            else if(elem == ')'){\n                stack.pop();\n\
    \            }\n        }\n        result.push(stack.length);\n        stack =\
    \ [];\n    }\n    return result;\n}", "    let paren_array = paren_string.split(\"\
    \ \");\n    let max_depth = 0;\n    let max_depth_list = [];\n    for(let i =\
    \ 0; i < paren_array.length; i++){\n        for(let j = 0; j < paren_array[i].length;\
    \ j++){\n            if(paren_array[i][j] === \"(\"){\n                max_depth\
    \ += 1;\n            }\n            else if(paren_array[i][j] === \")\"){\n  \
    \              max_depth_list.push(max_depth);\n                max_depth = 0;\n\
    \            }\n        }\n    }\n    return max_depth_list;\n}\n", "  return\
    \ paren_string.split(' ').map(parens => {\n    let max = 0, level = 0\n    parens.split('').forEach(paren\
    \ => {\n      if (paren === '(')\n        max = Math.max(++level, max)\n     \
    \ else\n        level--\n    })\n    return max\n  })\n}\n", "    return paren_string.split('\
    \ ').map(parse_parens);\n}\n", "    var paren_string_arr = paren_string.split(\"\
    \ \");\n    return paren_string_arr.map(function(item){\n        var count = 0;\n\
    \        var max_count = 0;\n        for(var i = 0; i < item.length; i++){\n \
    \           if(item[i] === \"(\"){\n                count++;\n               \
    \ if(count > max_count){\n                    max_count = count;\n           \
    \     }\n            }\n            else if(item[i] === \")\"){\n            \
    \    count--;\n            }\n        }\n        return max_count;\n    });\n}",
  "    var arr = paren_string.split(\" \");\n    var result = [];\n    for(var i =\
    \ 0; i < arr.length; i++){\n        var count = 0;\n        var str = arr[i];\n\
    \        for(var j = 0; j < str.length; j++){\n            if(str[j] == '('){\n\
    \                count++;\n            }\n            else if(str[j] == ')'){\n\
    \                count--;\n            }\n        }\n        result.push(count);\n\
    \    }\n    return result;\n}\n\n", "    let result = [];\n    let split_string\
    \ = paren_string.split(\" \");\n    //console.log(split_string);\n    let max_levels\
    \ = 0;\n    let count = 0;\n    for(let i = 0; i < split_string.length; i++){\n\
    \        for(let j = 0; j < split_string[i].length; j++){\n            //console.log(split_string[i][j]);\n\
    \            if(split_string[i][j] === \"(\"){\n                count += 1;\n\
    \            }\n            else if(split_string[i][j] === \")\"){\n         \
    \       count -= 1;\n            }\n            if(count > max_levels){\n    \
    \            max_levels = count;\n            }\n        }\n        result.push(max_levels);\n\
    \        max_levels = 0;\n        count = 0;\n    }\n    return result;\n}", "\t\
    var result = [];\n\tvar parens = paren_string.split(\" \");\n\tfor(var i = 0;\
    \ i < parens.length; i++){\n\t\tvar num_open = 0;\n\t\tvar max_level = 0;\n\t\t\
    for(var j = 0; j < parens[i].length; j++){\n\t\t\tif(parens[i][j] == \"(\"){\n\
    \t\t\t\tnum_open++;\n\t\t\t\tif(num_open > max_level){\n\t\t\t\t\tmax_level =\
    \ num_open;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(parens[i][j] == \")\"){\n\t\t\t\
    \tnum_open--;\n\t\t\t}\n\t\t}\n\t\tresult.push(max_level);\n\t}\n\treturn result;\n\
    }\n", "  let stack = [];\n  let split_string = paren_string.split(' ');\n  let\
    \ result = [];\n  for(let i = 0; i < split_string.length; i++){\n    let current_string\
    \ = split_string[i];\n    for(let j = 0; j < current_string.length; j++){\n  \
    \    if(current_string[j] === '('){\n        stack.push(current_string[j]);\n\
    \      }\n      else if(current_string[j] === ')'){\n        stack.pop();\n  \
    \    }\n    }\n    result.push(stack.length);\n    stack = [];\n  }\n  return\
    \ result;\n}", "    var paren_groups = paren_string.split(\" \");\n    var result\
    \ = [];\n    var level;\n    var max;\n    for(var i = 0; i < paren_groups.length;\
    \ i++){\n        level = 0;\n        max = 0;\n        for(var j = 0; j < paren_groups[i].length;\
    \ j++){\n            if(paren_groups[i][j] == \"(\"){\n                level++;\n\
    \                if(level > max){\n                    max = level;\n        \
    \        }\n            }\n            else if(paren_groups[i][j] == \")\"){\n\
    \                level--;\n            }\n        }\n        result.push(max);\n\
    \    }\n    return result;\n}\n\n", "    var parens_array = paren_string.split(\"\
    \ \");\n    var result = [];\n    for(var i = 0; i < parens_array.length; i++){\n\
    \        result.push(count_nested_parens(parens_array[i]));\n    }\n    return\
    \ result;\n}\n", "    var open_parens = 0;\n    var max_depth = 0;\n    var max_per_group\
    \ = [];\n    var current_number = \"\";\n    for (var i = 0; i < paren_string.length;\
    \ i++){\n        if (paren_string[i] == \"(\"){\n            open_parens++;\n\
    \            if (open_parens > max_depth){\n                max_depth = open_parens;\n\
    \            }\n        }\n        else if (paren_string[i] == \")\"){\n     \
    \       open_parens--;\n        }\n        else if (paren_string[i] == \" \"){\n\
    \            max_per_group.push(max_depth);\n            max_depth = 0;\n    \
    \    }\n    }\n    max_per_group.push(max_depth);\n    return max_per_group;\n\
    }\n", "    var count_arr = [];\n    var paren_arr = paren_string.split(\" \");\n\
    \    var level = 0;\n    var count = 0;\n    var length = paren_arr.length;\n\
    \    for(var i = 0; i < length; i++){\n        level = 0;\n        count = 0;\n\
    \        var paren = paren_arr[i];\n        var paren_length = paren.length;\n\
    \        for(var j = 0; j < paren_length; j++){\n            if(paren[j] == '('){\n\
    \                level++;\n                if(level > count){\n              \
    \      count = level;\n                }\n            }\n            else if(paren[j]\
    \ == ')'){\n                level--;\n            }\n        }\n        count_arr.push(count);\n\
    \    }\n    return count_arr;\n}\n", "  //start by splitting the string into groups\
    \ delimited by spaces\n  var groups = paren_string.split(\" \");\n  //declare\
    \ an array to hold the results\n  var results = [];\n  //loop through the groups\n\
    \  for(var i = 0; i < groups.length; i++){\n    //check to see if the group is\
    \ empty\n    if(groups[i] === \"\"){\n      //if it is, push an empty array to\
    \ the results array\n      results.push(0);\n    }\n    //if it isn't empty, run\
    \ the count_nested_parens function\n    else{\n      results.push(count_nested_parens(groups[i]));\n\
    \    }\n  }\n  //return the results array\n  return results;\n}\n", "    var result\
    \ = [];\n    var strings = paren_string.split(\" \");\n    var stack = [];\n \
    \   for(var i = 0; i < strings.length; i++){\n        var current = strings[i];\n\
    \        stack = [];\n        for(var j = 0; j < current.length; j++){\n     \
    \       if(current[j] == '('){\n                stack.push(current[j]);\n    \
    \        }else if(current[j] == ')'){\n                stack.pop();\n        \
    \    }\n        }\n        result.push(stack.length);\n    }\n    return result;\n\
    }\n", "    var arr = paren_string.split(\" \");\n    var result = [];\n    for(var\
    \ i = 0; i < arr.length; i++){\n        var count = 0;\n        var max = 0;\n\
    \        for(var j = 0; j < arr[i].length; j++){\n            if(arr[i][j] ==\
    \ \"(\"){\n                count += 1;\n                if(count > max){\n   \
    \                 max = count;\n                }\n            }\n           \
    \ else if(arr[i][j] == \")\"){\n                count -= 1;\n            }\n \
    \       }\n        result.push(max);\n    }\n    return result;\n}\n", "    var\
    \ max_nesting_level = 0;\n    var current_nesting_level = 0;\n    var nested_parens_array\
    \ = [];\n    var groups = paren_string.split(\" \");\n    for (var i = 0; i <\
    \ groups.length; i++){\n        var group = groups[i];\n        for (var j = 0;\
    \ j < group.length; j++){\n            var character = group[j];\n           \
    \ if (character == \"(\"){\n                current_nesting_level += 1;\n    \
    \        } else if (character == \")\"){\n                current_nesting_level\
    \ -= 1;\n            }\n            if (current_nesting_level > max_nesting_level){\n\
    \                max_nesting_level = current_nesting_level;\n            }\n \
    \       }\n        nested_parens_array.push(max_nesting_level);\n        max_nesting_level\
    \ = 0;\n        current_nesting_level = 0;\n    }\n    return nested_parens_array;\n\
    }", "    var paren_groups = paren_string.split(\" \");\n    var result = [];\n\
    \    for(var i = 0; i < paren_groups.length; i++){\n        var paren_group =\
    \ paren_groups[i];\n        var idx = 0;\n        var max_nest = 0;\n        var\
    \ cur_nest = 0;\n        while(idx < paren_group.length){\n            if(paren_group[idx]\
    \ == \"(\"){\n                cur_nest += 1;\n                max_nest = Math.max(max_nest,\
    \ cur_nest);\n            }else{\n                cur_nest -= 1;\n           \
    \ }\n            idx += 1;\n        }\n        result.push(max_nest);\n    }\n\
    \    return result;\n}\n", "    var paren_groups = paren_string.split(\" \");\n\
    \    var depths = [];\n    for (i=0; i<paren_groups.length; i++){\n        depths.push(get_paren_depth(paren_groups[i]));\n\
    \    }\n    return depths;\n}\n", "    var paren_groups = paren_string.split(\"\
    \ \");\n    // console.log(paren_groups);\n    var res = [];\n    for(var i =\
    \ 0; i < paren_groups.length; i++) {\n        var paren_group = paren_groups[i];\n\
    \        var temp = [];\n        var level = 0;\n        for(var j = 0; j < paren_group.length;\
    \ j++) {\n            var char = paren_group[j];\n            if(char == '(')\
    \ {\n                level++;\n            } else if(char == ')') {\n        \
    \        level--;\n            }\n            temp.push(level);\n        }\n \
    \       // console.log(temp);\n        res.push(Math.max.apply(null, temp));\n\
    \    }\n    return res;\n}\n", "\tvar paren_string = paren_string.split(\" \"\
    );\n\tvar output = [];\n\tfor (var i = 0; i < paren_string.length; i++){\n\t\t\
    var counter = 0;\n\t\tvar temp = [];\n\t\tfor (var j = 0; j < paren_string[i].length;\
    \ j++){\n\t\t\tvar char = paren_string[i][j];\n\t\t\tif (char == \"(\"){\n\t\t\
    \t\tcounter++;\n\t\t\t\ttemp.push(counter);\n\t\t\t}\n\t\t\telse if (char == \"\
    )\"){\n\t\t\t\ttemp.push(counter);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t}\n\t\toutput.push(Math.max.apply(null,\
    \ temp));\n\t}\n\treturn output;\n}\n", "    // return a array consisting of the\
    \ max nesting of each group in the string.\n    // your code here.\n    var level_array\
    \ = paren_string.split(\" \");\n    var return_array = [];\n    var level = 0;\n\
    \    for (var i=0; i<level_array.length; i++){\n        var current_level = 0;\n\
    \        for (var j=0; j<level_array[i].length; j++){\n            if (level_array[i][j]\
    \ == \"(\"){\n                current_level++;\n            }\n            else\
    \ if (level_array[i][j] == \")\"){\n                if (current_level > level){\n\
    \                    level = current_level;\n                }\n             \
    \   current_level--;\n            }\n        }\n        return_array.push(level);\n\
    \        level = 0;\n    }\n    return return_array;\n}\n", "    let result =\
    \ [];\n    let cur = 0;\n    let max = 0;\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            cur++;\n          \
    \  max = Math.max(max, cur);\n        }else if(paren_string[i] === ')'){\n   \
    \         cur--;\n        }else if(paren_string[i] === ' '){\n            result.push(max);\n\
    \            max = 0;\n            cur = 0;\n        }\n    }\n    result.push(max);\n\
    \    return result;\n}\n", "\tvar paren_list = paren_string.split(\" \");\n\t\
    var deepest_nesting = [];\n\tfor(var i = 0; i < paren_list.length; i++){\n\t\t\
    var paren_arr = paren_list[i].split(\"\");\n\t\tvar current_level = 0;\n\t\tvar\
    \ max_level = 0;\n\t\tfor(var j = 0; j < paren_arr.length; j++){\n\t\t\tif(paren_arr[j]\
    \ == \"(\"){\n\t\t\t\tcurrent_level++;\n\t\t\t\tif(current_level > max_level){\n\
    \t\t\t\t\tmax_level = current_level;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(paren_arr[j]\
    \ == \")\"){\n\t\t\t\tcurrent_level--;\n\t\t\t}\n\t\t}\n\t\tdeepest_nesting.push(max_level);\n\
    \t}\n\treturn deepest_nesting;\n}", "    var lvl = 0, maxlvl = 0, maxlvls = [];\n\
    \    for (var i = 0; i < paren_string.length; i++){\n        if (paren_string[i]\
    \ == \"(\") lvl++;\n        if (paren_string[i] == \")\") lvl--;\n        if (paren_string[i]\
    \ == \" \") {\n            maxlvls.push(maxlvl);\n            maxlvl = 0;\n  \
    \      }\n        if (lvl > maxlvl) maxlvl = lvl;\n    }\n    maxlvls.push(maxlvl);\n\
    \    return maxlvls;\n}", "    // TODO: Complete this function, removing the next\
    \ line.\n    return [0];\n}\n", "  // create an empty array\n  let arr = [];\n\
    \  // split the string into arrays using spaces\n  let parens = paren_string.split(\"\
    \ \");\n  // loop through the parens array\n  for (var i = 0; i < parens.length;\
    \ i++) {\n    // use the find_max_nested_parens function\n    arr.push(find_max_nested_parens(parens[i]));\n\
    \  }\n  // return the array\n  return arr;\n}", "    var arr = paren_string.split(\"\
    \ \");\n    var count = 0;\n    var final = [];\n    var max = 0;\n    for(var\
    \ i = 0; i < arr.length; i++){\n        for(var j = 0; j < arr[i].length; j++){\n\
    \            if(arr[i][j] == \"(\"){\n                count++;\n            }\n\
    \            else if(arr[i][j] == \")\"){\n                count--;\n        \
    \    }\n        }\n        final.push(count);\n        count = 0;\n    }\n   \
    \ return final;\n}\n", "  // var arr_of_parens = paren_string.split(\" \");\n\
    \  // var depth_arr = [];\n  // for (var i = 0; i < arr_of_parens.length; i++)\
    \ {\n  //   var depth = 0;\n  //   for (var j = 0; j < arr_of_parens[i].length;\
    \ j++) {\n  //     if (arr_of_parens[i][j] === \"(\") {\n  //       depth++;\n\
    \  //     }\n  //   }\n  //   depth_arr.push(depth);\n  // }\n  // return depth_arr;\n\
    \  var paren_stack = [];\n  var depth_arr = [];\n  var depth = 0;\n  for (var\
    \ i = 0; i < paren_string.length; i++) {\n    if (paren_string[i] === \"(\") {\n\
    \      paren_stack.push(paren_string[i]);\n      depth++;\n    } else if (paren_string[i]\
    \ === \")\") {\n      paren_stack.pop();\n      if (paren_stack.length === 0)\
    \ {\n        depth_arr.push(depth);\n        depth = 0;\n      }\n    }\n  }\n\
    \  return depth_arr;\n}\n", "\tvar result = [];\n\tvar count = 0;\n\tfor(var i\
    \ = 0; i < paren_string.length; i++){\n\t\tif(paren_string[i] === \"(\"){\n\t\t\
    \tcount += 1;\n\t\t}else if(paren_string[i] === \")\"){\n\t\t\tcount -= 1;\n\t\
    \t}else if(paren_string[i] === \" \"){\n\t\t\tresult.push(count);\n\t\t\tcount\
    \ = 0;\n\t\t}\n\t}\n\tresult.push(count);\n\treturn result;\n}", "    let parens\
    \ = paren_string.split(\" \");\n    let counter = [];\n    for(let i = 0; i <\
    \ parens.length; i++){\n        let count = 0;\n        let current = parens[i];\n\
    \        for(let j = 0; j < current.length; j++){\n            if(current[j] ===\
    \ \"(\"){\n                count++;\n            }\n        }\n        counter.push(count);\n\
    \    }\n    return counter;\n}\n\nlet str = \"(()()) ((())) () ((())()())\";",
  "    const results = [];\n    const parens = paren_string.split(' ');\n    for (const\
    \ paren of parens) {\n        const result = get_max_nested_paren(paren);\n  \
    \      results.push(result);\n    }\n    return results;\n}\n", "    let result\
    \ = []\n    let max_stack = []\n    let st_val = []\n    let max_depth = 0\n \
    \   for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ == \"(\"){\n            st_val.push(paren_string[i])\n            if(st_val.length\
    \ > max_depth){\n                max_depth = st_val.length\n            }\n  \
    \      }\n        else if(paren_string[i] == \")\"){\n            st_val.pop()\n\
    \        }\n        else if(paren_string[i] == \" \"){\n            max_stack.push(max_depth)\n\
    \            max_depth = 0\n        }\n    }\n    max_stack.push(max_depth)\n\
    \    return max_stack\n}\n", "    //your code here\n}\n\n", "    var re = /([()]{2,})/g;\n\
    \    var result = paren_string.match(re);\n    console.log(result);\n    return\
    \ result;\n}\n\nparse_nested_parens(\"(()()) ((())) () ((())()())\");", "    var\
    \ results = []\n    var arr = paren_string.split(\" \")\n    for(var i = 0; i\
    \ < arr.length; i++){\n        var count = 0\n        var max = 0\n        for(var\
    \ j = 0; j < arr[i].length; j++){\n            if(arr[i][j] == \"(\"){\n     \
    \           count++\n                if(count > max){\n                    max\
    \ = count\n                }\n            }\n            if(arr[i][j] == \")\"\
    ){\n                count--\n            }\n        }\n        results.push(max)\n\
    \    }\n    return results\n}\n", "    let count = 0;\n    let max = 0;\n    let\
    \ result = [];\n    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === \"(\"){\n            count++;\n            if(count > max){\n          \
    \      max = count;\n            }\n        }\n        if(paren_string[i] ===\
    \ \")\"){\n            count--;\n        }\n        if(paren_string[i] === \"\
    \ \"){\n            result.push(max);\n            max = 0;\n            count\
    \ = 0;\n        }\n    }\n    result.push(max);\n    return result;\n}", "\tlet\
    \ results = [];\n\tlet paren_groups = paren_string.split(\" \");\n\tparen_groups.forEach(function(group){\n\
    \t\tresults.push(count_parens(group));\n\t});\n\treturn results;\n}\n", "    let\
    \ arr = paren_string.split(\" \");\n    let result = [];\n    for(let i = 0; i\
    \ < arr.length; i++){\n        result.push(paren_helper(arr[i]));\n    }\n   \
    \ return result;\n}\n", "    return paren_string.split(' ').map(group => {\n \
    \       let count = 0;\n        let max_count = 0;\n        for (let i = 0; i\
    \ < group.length; i++) {\n            if (group[i] === '(') {\n              \
    \  count += 1;\n                max_count = Math.max(max_count, count);\n    \
    \        } else if (group[i] === ')') {\n                count -= 1;\n       \
    \     }\n        }\n        return max_count;\n    });\n}", "  var open = 0, close\
    \ = 0, max = 0, res = [];\n  for(var i = 0; i < paren_string.length; i++){\n \
    \   if(paren_string[i] == '('){\n      open++;\n      if(open > max){\n      \
    \  max = open;\n      }\n    }\n    else if(paren_string[i] == ')'){\n      close++;\n\
    \      if(close > max){\n        max = close;\n      }\n    }\n    else if(paren_string[i]\
    \ == ' '){\n      res.push(max);\n      max = 0;\n      open = 0;\n      close\
    \ = 0;\n    }\n  }\n  res.push(max);\n  return res;\n}\n", "  var paren_array\
    \ = paren_string.split(' ');\n  var result = [];\n  for(var i = 0; i < paren_array.length;\
    \ i++){\n    var paren = paren_array[i];\n    var open_count = 0;\n    var max_count\
    \ = 0;\n    for(var j = 0; j < paren.length; j++){\n      if(paren[j] === '('){\n\
    \        open_count++;\n        if(open_count > max_count){\n          max_count\
    \ = open_count;\n        }\n      }\n      else{\n        open_count--;\n    \
    \  }\n    }\n    result.push(max_count);\n  }\n  return result;\n}\n\n", "  var\
    \ paren_depth = [];\n  var paren_array = paren_string.split(' ');\n  // split\
    \ the string into groups\n  // check each group and record the depth\n  paren_array.forEach(function(group){\n\
    \    var depth = 0;\n    //check each character in a group\n    group.split('').forEach(function(ch){\n\
    \      if(ch === '('){\n        depth += 1;\n      }\n      else if(ch === ')'){\n\
    \        depth -= 1;\n      }\n    });\n    paren_depth.push(depth);\n  });\n\
    \  return paren_depth;\n}\n", "  var arr = paren_string.split(\" \");\n  var result\
    \ = [];\n  var max = 0;\n  for(var i = 0; i < arr.length; i++){\n    var curr\
    \ = arr[i];\n    var count = 0;\n    for(var j = 0; j < curr.length; j++){\n \
    \     if(curr[j] === \"(\"){\n        count++;\n      }else if(curr[j] === \"\
    )\"){\n        count--;\n      }\n    }\n    result.push(count);\n  }\n  return\
    \ result;\n}\n", "\tvar paren_array = paren_string.split(' ');\n\tvar res = [];\n\
    \tfor(var i=0; i<paren_array.length; i++){\n\t\tvar temp = 0;\n\t\tvar count =\
    \ 0;\n\t\tfor(var j=0; j<paren_array[i].length; j++){\n\t\t\tif(paren_array[i][j]\
    \ == '('){\n\t\t\t\tcount += 1;\n\t\t\t\tif(count > temp){\n\t\t\t\t\ttemp = count;\n\
    \t\t\t\t}\n\t\t\t}else if(paren_array[i][j] == ')'){\n\t\t\t\tcount -= 1;\n\t\t\
    \t}\n\t\t}\n\t\tres.push(temp);\n\t}\n\treturn res;\n}\n", "  var results = [];\n\
    \  var paren_groups = paren_string.split(\" \");\n  for (var i = 0; i < paren_groups.length;\
    \ i++){\n    var num_open = 0;\n    var num_close = 0;\n    var num_open_parentheses\
    \ = 0;\n    var num_closed_parentheses = 0;\n    for (var j = 0; j < paren_groups[i].length;\
    \ j++){\n      if (paren_groups[i][j] === \"(\"){\n        num_open_parentheses++;\n\
    \        num_open++;\n      } else if (paren_groups[i][j] === \")\"){\n      \
    \  num_closed_parentheses++;\n        num_close++;\n      }\n    }\n    if (num_open\
    \ === num_close && num_open_parentheses === num_closed_parentheses){\n      results.push(num_open);\n\
    \    } else {\n      results.push(0);\n    }\n  }\n  return results;\n}\n", "\t\
    var max_depth = 0;\n\tvar depth = 0;\n\tvar max_depth_arr = [];\n\tfor(var i =\
    \ 0; i < paren_string.length; i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tdepth++;\n\
    \t\t\tif(depth > max_depth){\n\t\t\t\tmax_depth = depth;\n\t\t\t}\n\t\t}\n\t\t\
    else if(paren_string[i] == ')'){\n\t\t\tmax_depth_arr.push(max_depth);\n\t\t\t\
    max_depth = 0;\n\t\t\tdepth = 0;\n\t\t}\n\t}\n\treturn max_depth_arr;\n}\n", " \
    \ var match_groups = paren_string.split(\" \");\n  var arr_results = new Array();\n\
    \  for (var i = 0; i < match_groups.length; i++){\n    var curr_max = 0;\n   \
    \ var paren_stack = new Array();\n    var current_group = match_groups[i];\n \
    \   for (var j = 0; j < current_group.length; j++){\n      var curr_paren = current_group[j];\n\
    \      if (curr_paren == \"(\"){\n        paren_stack.push(curr_paren);\n    \
    \    if (paren_stack.length > curr_max){\n          curr_max = paren_stack.length;\n\
    \        }\n      }\n      else{\n        if (paren_stack.length > 0){\n     \
    \     paren_stack.pop();\n        }\n      }\n    }\n    arr_results.push(curr_max);\n\
    \  }\n  return arr_results;\n}\n", "    var split_string = paren_string.split(\"\
    \ \");\n    //console.log(split_string);\n    var paren_list = new Array();\n\
    \    for(var i = 0; i < split_string.length; i++){\n        var level = 0;\n \
    \       var max = 0;\n        for(var j = 0; j < split_string[i].length; j++){\n\
    \            if(split_string[i][j] == \"(\"){\n                level++;\n    \
    \            if(level > max){\n                    max = level;\n            \
    \    }\n            }\n            else if(split_string[i][j] == \")\"){\n   \
    \             level--;\n            }\n        }\n        paren_list.push(max);\n\
    \    }\n    return paren_list;\n}", "\tlet paren_groups = paren_string.split(\"\
    \ \");\n\tlet max_levels = [];\n\tfor(let group of paren_groups){\n\t\tlet num_levels\
    \ = 1;\n\t\tlet current_level = 0;\n\t\tfor(let char of group){\n\t\t\tif(char\
    \ === \"(\"){\n\t\t\t\tcurrent_level += 1;\n\t\t\t\tif(current_level > num_levels){\n\
    \t\t\t\t\tnum_levels = current_level;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(char\
    \ === \")\"){\n\t\t\t\tcurrent_level -= 1;\n\t\t\t}\n\t\t}\n\t\tmax_levels.push(num_levels);\n\
    \t}\n\treturn max_levels;\n}\n", "  let max_nesting_level = 0;\n  let current_nesting_level\
    \ = 0;\n  let result = [];\n  for(let i = 0; i < paren_string.length; i++){\n\
    \    if(paren_string[i] === '('){\n      current_nesting_level++;\n      if(current_nesting_level\
    \ > max_nesting_level){\n        max_nesting_level = current_nesting_level;\n\
    \      }\n    }\n    if(paren_string[i] === ')'){\n      current_nesting_level--;\n\
    \    }\n    if(paren_string[i] === ' '){\n      result.push(max_nesting_level);\n\
    \      max_nesting_level = 0;\n      current_nesting_level = 0;\n    }\n  }\n\
    \  result.push(max_nesting_level);\n  return result;\n}\n", "  var r= [], g= '',\
    \ d= 0, m= 0;\n  for(var i= 0; i< paren_string.length; i++){\n    var c= paren_string[i];\n\
    \    if(c== '('){\n      d++;\n      if(d> m) m= d;\n    }\n    else if(c== ')'){\n\
    \      d--;\n    }\n    else if(c== ' ' && g.length> 0){\n      r.push(m);\n \
    \     g= '';\n      m= 0;\n    }\n    g+= c;\n  }\n  if(g.length> 0) r.push(m);\n\
    \  return r;\n}\n", "\t//Fill in your code here\n    var paren_list = paren_string.split(\"\
    \ \");\n    var paren_arr = [];\n    for (var i=0; i<paren_list.length; i++){\n\
    \        var paren_str = paren_list[i];\n        var paren_obj = {\n         \
    \   current: 0,\n            max: 0\n        };\n        for (var j=0; j<paren_str.length;\
    \ j++){\n            if (paren_str[j] == \"(\"){\n                paren_obj.current\
    \ += 1;\n                if (paren_obj.current > paren_obj.max){\n           \
    \         paren_obj.max = paren_obj.current;\n                }\n            }\n\
    \            else if (paren_str[j] == \")\"){\n                paren_obj.current\
    \ -= 1;\n            }\n        }\n        paren_arr.push(paren_obj.max);\n  \
    \  }\n    return paren_arr;\n}\n", "    var result = [];\n    var idx = 0;\n \
    \   while(idx < paren_string.length){\n        result.push(get_deepest_nesting(paren_string.substring(idx)));\n\
    \        idx += result[result.length - 1] + 1;\n    }\n    return result;\n}\n",
  "  let arr = paren_string.split(' ');\n  let result = [];\n  for(var i = 0; i <\
    \ arr.length; i++){\n    let stack = [];\n    let count = 0;\n    for(var j =\
    \ 0; j < arr[i].length; j++){\n      if(arr[i][j] === '('){\n        stack.push(arr[i][j]);\n\
    \        count++;\n      }\n      if(arr[i][j] === ')'){\n        stack.pop();\n\
    \      }\n    }\n    result.push(count);\n  }\n  return result;\n}\n", "  const\
    \ parens = paren_string.split(' ');\n  var result = [];\n  for (let i = 0; i <\
    \ parens.length; i++){\n    var max = 0;\n    var count = 0;\n    for (let j =\
    \ 0; j < parens[i].length; j++){\n      if (parens[i][j] === '('){\n        count++;\n\
    \        if (count > max){\n          max = count;\n        }\n      }\n     \
    \ else if (parens[i][j] === ')'){\n        count--;\n      }\n    }\n    result.push(max);\n\
    \  }\n  return result;\n}\n", "    const paren_list = paren_string.split(\" \"\
    );\n    let result = [];\n    for(let item of paren_list){\n        let number_of_nested_parens\
    \ = 0;\n        let temp_count = 0;\n        for(let char of item){\n        \
    \    if(char === '('){\n                temp_count += 1;\n            }\n    \
    \        else if(char === ')'){\n                if(temp_count > number_of_nested_parens){\n\
    \                    number_of_nested_parens = temp_count;\n                }\n\
    \                temp_count -= 1;\n            }\n        }\n        result.push(number_of_nested_parens);\n\
    \    }\n    return result;\n}\n", "    var paren_array = paren_string.split(\"\
    \ \");\n    var result = [];\n    for(var i = 0; i < paren_array.length; i++){\n\
    \        result.push(parse_single_paren(paren_array[i]));\n    }\n    return result;\n\
    }\n", "    let groups = paren_string.split(\" \");\n    let output = [];\n   \
    \ for(let i = 0; i < groups.length; i++){\n        output.push(get_max_count(groups[i]));\n\
    \    }\n    return output;\n}", "    const paren_array = paren_string.split('\
    \ ');\n    return paren_array.map(item => {\n        return get_nested_parens(item);\n\
    \    });\n}\n", "  var groups = paren_string.split(\" \");\n  var depths = [];\n\
    \  for (var i = 0; i < groups.length; i++){\n    depths.push(nested_parens(groups[i]));\n\
    \  }\n  return depths;\n}\n", "\tparen_string = paren_string.split(\" \");\n\t\
    var deepest = 0;\n\tvar result = [];\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\tdeepest = 0;\n\t\tfor(var j = 0; j < paren_string[i].length; j++){\n\
    \t\t\tif(paren_string[i][j] == \"(\"){\n\t\t\t\tdeepest++;\n\t\t\t}\n\t\t\telse\
    \ if(paren_string[i][j] == \")\"){\n\t\t\t\tdeepest--;\n\t\t\t}\n\t\t}\n\t\tresult.push(deepest);\n\
    \t}\n\treturn result;\n}\n", "    var deepest = paren_string.split(\" \").map(function(paren){\n\
    \        var count = 0;\n        var max = 0;\n        for(var i = 0; i < paren.length;\
    \ i++){\n            if(paren[i] === \"(\"){\n                count++;\n     \
    \           if(count > max){\n                    max = count;\n             \
    \   }\n            }\n            else if(paren[i] === \")\"){\n             \
    \   count--;\n            }\n        }\n        return max;\n    });\n    return\
    \ deepest;\n}\n", "    return paren_string.split(' ').map(item => {\n        let\
    \ stack = []\n        let deepest_level = 0\n        let current_level = 0\n \
    \       for (let i = 0; i < item.length; i++) {\n            if (item[i] === '(')\
    \ {\n                stack.push(item[i])\n                current_level += 1\n\
    \                if (current_level > deepest_level) {\n                    deepest_level\
    \ = current_level\n                }\n            } else if (item[i] === ')')\
    \ {\n                stack.pop()\n                current_level -= 1\n       \
    \     }\n        }\n        return deepest_level\n    })\n}\n\n", "    //find\
    \ the opening parenthesis\n    var open_paren_index=paren_string.indexOf(\"(\"\
    );\n    var results=[];\n    var current_string=\"\";\n    while(open_paren_index!=-1){\n\
    \        current_string=paren_string.substring(open_paren_index,paren_string.indexOf(\"\
    \ \",open_paren_index)+1);\n        console.log(current_string);\n        results.push(count_nested_parens(current_string));\n\
    \        open_paren_index=paren_string.indexOf(\"(\",open_paren_index+1);\n  \
    \  }\n    return results;\n}\n", "    return paren_string.split(' ').map(x =>\
    \ x.match(/\\(/g).length);\n}\n", "    let result = [];\n    let left_paren_count\
    \ = 0;\n    let right_paren_count = 0;\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            left_paren_count++;\n\
    \        }else if(paren_string[i] === ')'){\n            right_paren_count++;\n\
    \        }else if(paren_string[i] === ' '){\n            result.push(left_paren_count\
    \ + right_paren_count);\n            left_paren_count = 0;\n            right_paren_count\
    \ = 0;\n        }\n    }\n    result.push(left_paren_count + right_paren_count);\n\
    \    return result;\n}", "    const paren_group = paren_string.split(' ');\n \
    \   let paren_level = []\n    for (let i = 0; i < paren_group.length; i++) {\n\
    \        let paren_count = [];\n        let count = 0;\n        let max_count\
    \ = 0;\n        let char_array = paren_group[i].split('');\n        for (let j\
    \ = 0; j < char_array.length; j++) {\n            if (char_array[j] === '(') {\n\
    \                count++;\n                if (count > max_count) {\n        \
    \            max_count = count;\n                }\n            } else if (char_array[j]\
    \ === ')') {\n                count--;\n            }\n        }\n        paren_level.push(max_count);\n\
    \    }\n    return paren_level;\n}", "    var list = [];\n    var tmp = paren_string.split(\"\
    \ \");\n    for(var i=0; i<tmp.length; i++){\n        var stk = [];\n        for(var\
    \ j=0; j<tmp[i].length; j++){\n            if(tmp[i][j] == \"(\"){\n         \
    \       stk.push(tmp[i][j]);\n            }\n            else if(tmp[i][j] ==\
    \ \")\"){\n                stk.pop();\n            }\n        }\n        if(stk.length\
    \ == 0){\n            list.push(tmp[i].length/2);\n        }\n    }\n    return\
    \ list;\n}\n", "    var max_nested = 0;\n    var result = [];\n    var space_split\
    \ = paren_string.split(\" \");\n    for(var i = 0; i < space_split.length; i++){\n\
    \        var paren_string = space_split[i];\n        max_nested = 0;\n       \
    \ for(var j = 0; j < paren_string.length; j++){\n            var paren = paren_string[j];\n\
    \            var next_paren = paren_string[j+1];\n            if(paren == \")\"\
    \ && next_paren == \"(\"){\n                max_nested++;\n            }\n   \
    \     }\n        result.push(max_nested);\n    }\n    return result;\n}\n", " \
    \   let max_nested_level = 0, current_nested_level = 0;\n    const results = [];\n\
    \    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            current_nested_level += 1;\n            max_nested_level\
    \ = Math.max(max_nested_level, current_nested_level);\n        }else if(paren_string[i]\
    \ === ')'){\n            results.push(max_nested_level);\n            current_nested_level\
    \ -= 1;\n            max_nested_level = current_nested_level;\n        }\n   \
    \ }\n    return results;\n}\n\nmodule.exports = {\n    parse_nested_parens\n};",
  "    //write a solution here\n    // let word_list = paren_string.split(' ');\n\
    \    //\n    // // console.log(word_list)\n    // // console.log(word_list[0])\n\
    \    //\n    // let word_list_length = word_list.length;\n    // let result =\
    \ [];\n    //\n    // for (let i = 0; i < word_list_length; i++){\n    //    \
    \ let word = word_list[i];\n    //     let current_word_result = [];\n    // \
    \    for (let i = 0; i < word.length; i++){\n    //         if (word[i] === '('){\n\
    \    //             if (current_word_result.length === 0){\n    //           \
    \      current_word_result.push(1);\n    //             }\n    //            \
    \ else{\n    //                 current_word_result.push(current_word_result[current_word_result.length\
    \ - 1] + 1);\n    //             }\n    //         }\n    //         else if (word[i]\
    \ === ')'){\n    //             if (current_word_result.length === 0){\n    //\
    \                 current_word_result.push(0);\n    //             }\n    // \
    \            else{\n    //                 current_word_result.push(current_word_result[current_word_result.length\
    \ - 1] - 1);\n    //             }\n    //         }\n    //     }\n    //   \
    \  result.push(Math.max(...current_word_result));\n    // }\n    // return result;\n\
    \n    //refactor\n    let word_list = paren_string.split(' ');\n    let word_list_length\
    \ = word_list.length;\n    let result = [];\n\n    for (let i = 0; i < word_list_length;\
    \ i++){\n        let word = word_list[i];\n        let current_word_result = [];\n\
    \        for (let i = 0; i < word.length; i++){\n            if (word[i] === '('){\n\
    \                current_word_result.push(current_word_result.length === 0 ? 1\
    \ : current", "    var ret = [];\n    var cur = 0;\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            cur++;\n        }else\
    \ if(paren_string[i] == ')'){\n            cur--;\n        }else if(paren_string[i]\
    \ == ' '){\n            ret.push(cur);\n            cur = 0;\n        }\n    }\n\
    \    ret.push(cur);\n    return ret;\n}\n", "  const parens_array = paren_string.split(\"\
    \ \");\n  let results = [];\n  for (let i = 0; i < parens_array.length; i++){\n\
    \    results.push(getMaxNestedParens(parens_array[i]));\n  }\n  return results;\n\
    }\n", "    let output = [];\n    let current_paren_string = '';\n    for(let i\
    \ = 0; i < paren_string.length; i++){\n        let current_char = paren_string[i];\n\
    \        if(current_char === ' '){\n            let level = compute_level(current_paren_string);\n\
    \            output.push(level);\n            current_paren_string = '';\n   \
    \     } else {\n            current_paren_string += current_char;\n        }\n\
    \    }\n    let level = compute_level(current_paren_string);\n    output.push(level);\n\
    \    return output;\n}\n", "  //pattern to match group of nested parentheses\n\
    \  var pattern = /\\(\\(?\\(?\\)+\\)?\\)/g;\n  //get array of matches\n  var matches\
    \ = paren_string.match(pattern);\n  //return array of deepest nesting levels\n\
    \  return matches.map(function(match){\n    //if match only has outer parentheses,\
    \ return 1\n    if(match.match(/^\\(\\)\\s?$/)){\n      return 1;\n    }\n   \
    \ //else keep track of nesting level as you iterate through the match\n    var\
    \ nesting_level = 0;\n    var max_nesting_level = 0;\n    for(var i = 0; i < match.length;\
    \ i++){\n      if(match[i] === '('){\n        nesting_level++;\n      }\n    \
    \  else if(match[i] === ')'){\n        nesting_level--;\n      }\n      if(nesting_level\
    \ > max_nesting_level){\n        max_nesting_level = nesting_level;\n      }\n\
    \    }\n    return max_nesting_level;\n  });\n}\n", "\tvar ret = [];\n\tvar temp\
    \ = '';\n\tfor(var i = 0; i < paren_string.length; i++){\n\t\tif(paren_string[i]\
    \ == ' '){\n\t\t\tret.push(nested_parens(temp));\n\t\t\ttemp = '';\n\t\t}else{\n\
    \t\t\ttemp += paren_string[i];\n\t\t}\n\t}\n\tif(temp != ''){\n\t\tret.push(nested_parens(temp));\n\
    \t}\n\treturn ret;\n}\n", "    var paren_array = paren_string.split(' ');\n  \
    \  var output = [];\n    for(var i = 0; i < paren_array.length; i++){\n      \
    \  output.push(count_max_parens(paren_array[i]));\n    }\n    return output;\n\
    }\n", "  //initialize counter variables\n  var i, j,\n      count,\n      parenArray,\n\
    \      depthArray = [];\n\n  //split parentheses string into array\n  parenArray\
    \ = paren_string.split(\" \");\n\n  //loop through the array to find max depth\n\
    \  for (i = 0; i < parenArray.length; i++){\n    count = 0;\n    for (j = 0; j\
    \ < parenArray[i].length; j++){\n      if (parenArray[i][j] === \"(\"){\n    \
    \    count += 1;\n      }\n      else if (parenArray[i][j] === \")\"){\n     \
    \   count -= 1;\n      }\n    }\n    depthArray.push(count);\n  }\n  return depthArray;\n\
    }\n", "\tconst parens = paren_string.split(' ');\n\tlet output = [];\n\tparens.forEach(paren\
    \ => {\n\t\tlet max = 0;\n\t\tlet count = 0;\n\t\tparen.split('').forEach(c =>\
    \ {\n\t\t\tif (c === '(') {\n\t\t\t\tcount += 1;\n\t\t\t\tif (count > max) {\n\
    \t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t} else if (c === ')') {\n\t\t\t\tcount\
    \ -= 1;\n\t\t\t}\n\t\t});\n\t\toutput.push(max);\n\t});\n\treturn output;\n}\n",
  "    var paren_groups = paren_string.split(\" \");\n    var max_depth = [];\n  \
    \  for (var i = 0; i < paren_groups.length; i++){\n        max_depth.push(Math.floor(paren_groups[i].length/2));\n\
    \    }\n    return max_depth;\n}", "  return paren_string.split(\" \").map(function(ele){\n\
    \    // Extract elements from the array and check for the number of brackets.\n\
    \    var left_count = 0;\n    var right_count = 0;\n    for(var i = 0; i < ele.length;\
    \ i++){\n      if(ele[i] === \"(\"){\n        left_count++;\n      }\n      else\
    \ if(ele[i] === \")\"){\n        right_count++;\n      }\n    }\n    // Return\
    \ the difference in number of left and right brackets.\n    return left_count\
    \ - right_count;\n  });\n}\n", "\tvar group_arr = paren_string.split(\" \");\n\
    \tvar result = [];\n\tfor(var i = 0; i < group_arr.length; i++){\n\t\tvar paren_group\
    \ = group_arr[i];\n\t\tvar max_depth = 0;\n\t\tvar current_depth = 0;\n\t\tfor(var\
    \ j = 0; j < paren_group.length; j++){\n\t\t\tif(paren_group[j] == \"(\"){\n\t\
    \t\t\tcurrent_depth++;\n\t\t\t\tif(current_depth > max_depth){\n\t\t\t\t\tmax_depth\
    \ = current_depth;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(paren_group[j] == \")\"\
    ){\n\t\t\t\tcurrent_depth--;\n\t\t\t}\n\t\t}\n\t\tresult.push(max_depth);\n\t\
    }\n\treturn result;\n}", "  let arr = paren_string.split(\" \")\n  let res = []\n\
    \  for(let i=0; i<arr.length; i++){\n    let max = 0\n    let count = 0\n    for(let\
    \ j=0; j<arr[i].length; j++){\n      if(arr[i][j] === \"(\"){\n        count++\n\
    \        if(count > max){\n          max = count\n        }\n      }else if(arr[i][j]\
    \ === \")\"){\n        count--\n      }\n    }\n    res.push(max)\n  }\n  return\
    \ res\n}\n", "  const parens = paren_string.split(\" \");\n  let array = [];\n\
    \  for(let i = 0; i < parens.length; i++){\n    let count = 0;\n    let max =\
    \ 0;\n    for(let j = 0; j < parens[i].length; j++){\n      if(parens[i][j] ===\
    \ \"(\"){\n        count++;\n      }\n      if(parens[i][j] === \")\"){\n    \
    \    count--;\n      }\n      if(count > max){\n        max = count;\n      }\n\
    \    }\n    array.push(max);\n  }\n  return array;\n}\n\n", "    var max_levels\
    \ = [];\n    var paren_groups = paren_string.split(\" \");\n    for (i = 0; i\
    \ < paren_groups.length; i++){\n        var curr_depth = 0;\n        var max_depth\
    \ = 0;\n        for (j = 0; j < paren_groups[i].length; j++){\n            if\
    \ (paren_groups[i][j] == \"(\"){\n                curr_depth++;\n            \
    \    if (curr_depth > max_depth){\n                    max_depth = curr_depth;\n\
    \                }\n            }\n            else if (paren_groups[i][j] ==\
    \ \")\"){\n                curr_depth--;\n            }\n        }\n        max_levels.push(max_depth);\n\
    \    }\n    return max_levels;\n}", "    var paren_groups = paren_string.split(\"\
    \ \");\n    var max_nesting = [];\n    var last_match = null;\n    var nesting_level\
    \ = 0;\n    for (var i = 0; i < paren_groups.length; i++){\n        var parens\
    \ = paren_groups[i];\n        for (var j = 0; j < parens.length; j++){\n     \
    \       if (parens[j] == \"(\"){\n                nesting_level += 1;\n      \
    \      }\n            else if (parens[j] == \")\"){\n                nesting_level\
    \ -= 1;\n            }\n        }\n        if (nesting_level > last_match){\n\
    \            last_match = nesting_level;\n        }\n        max_nesting.push(last_match);\n\
    \        nesting_level = 0;\n    }\n    return max_nesting;\n}", "  let results\
    \ = [];\n  let groups = paren_string.split(\" \");\n  for (let i = 0; i < groups.length;\
    \ i++){\n    let group = groups[i];\n    let max_nesting = 0;\n    let current_nesting\
    \ = 0;\n    for (let j = 0; j < group.length; j++){\n      if (group[j] === \"\
    (\"){\n        current_nesting += 1;\n        if (current_nesting > max_nesting){\n\
    \          max_nesting = current_nesting;\n        }\n      } else if (group[j]\
    \ === \")\"){\n        current_nesting -= 1;\n      }\n    }\n    results.push(max_nesting);\n\
    \  }\n  return results;\n}\n", "    let arr = paren_string.split(\" \");\n   \
    \ let results = [];\n    for(let i = 0; i < arr.length; i++){\n        let count\
    \ = 0;\n        let parens = 0;\n        for(let j = 0; j < arr[i].length; j++){\n\
    \            if(arr[i][j] === \"(\"){\n                parens++;\n           \
    \     if(parens > count){\n                    count = parens;\n             \
    \   }\n            } else if(arr[i][j] === \")\"){\n                parens--;\n\
    \            }\n        }\n        results.push(count);\n    }\n    return results;\n\
    }\n", "    const parens = paren_string.split(' ');\n    let output = [];\n   \
    \ for(const paren of parens){\n        let stack = [];\n        let current_max\
    \ = 0;\n        for(const char of paren){\n            if(char === '('){\n   \
    \             stack.push(char);\n                if(stack.length > current_max){\n\
    \                    current_max = stack.length;\n                }\n        \
    \    }\n            else if(char === ')'){\n                stack.pop();\n   \
    \         }\n        }\n        output.push(current_max);\n    }\n    return output;\n\
    }\n", "    var parens = paren_string.split(' ');\n    var max_nesting = [];\n\
    \    var nesting_count = 0;\n    var current_string = '';\n    for(var j = 0;\
    \ j < parens.length; j++){\n        current_string = parens[j];\n        for(var\
    \ i = 0; i < current_string.length; i++){\n            if(current_string[i] ===\
    \ '('){\n                nesting_count++;\n            } else if(current_string[i]\
    \ === ')'){\n                nesting_count--;\n            }\n        }\n    \
    \    max_nesting.push(nesting_count);\n        nesting_count = 0;\n    }\n   \
    \ return max_nesting;\n}\n", "  // this is obviously wrong\n  // return paren_string.replace(/[^()]/g,'').split('()').length\
    \ - 1;\n  let answer = [];\n  let paren_array = paren_string.split(' ');\n  let\
    \ paren_deepest = 0;\n  paren_array.forEach(function(paren){\n    let paren_depth\
    \ = 0;\n    for(let i = 0; i < paren.length; i++){\n      if(paren[i] === '('){\n\
    \        paren_depth++;\n      } else if(paren[i] === ')'){\n        paren_depth--;\n\
    \      }\n    }\n    if(paren_depth > paren_deepest){\n      paren_deepest = paren_depth;\n\
    \    }\n    answer.push(paren_depth);\n  });\n  return answer;\n}\n", "    //\
    \ TODO: implement\n}\n", "    var paren_array = paren_string.split(\" \"); //turn\
    \ the string into an array\n    var level_array = []; //create the array of levels\n\
    \n    for (i = 0; i < paren_array.length; i++){ //loop through each item in the\
    \ array\n        var level = 0; //each parentheses has a level of 0\n\n      \
    \  for (j = 0; j < paren_array[i].length; j++){ //loop through each character\
    \ in the parentheses\n            var character = paren_array[i].charAt(j); //character\
    \ is equal to the jth character in the parentheses\n\n            if (character\
    \ == \"(\"){ //if the character is a left parentheses\n                level++;\
    \ //increase the level by 1\n            }\n\n            if (character == \"\
    )\"){ //if the character is a right parentheses\n                level--; //decrease\
    \ the level by 1\n            }\n        }\n\n        level_array.push(level);\
    \ //push the level to the array\n    }\n\n    return level_array; //return the\
    \ array\n}\n", "\tlet output = [];\n\tlet parens_array = paren_string.split(\"\
    \ \");\n\n\tfor(let i = 0; i < parens_array.length; i++){\n\t\tlet current_paren\
    \ = parens_array[i];\n\t\tlet count = 0;\n\t\tlet max_count = 0;\n\t\tfor(let\
    \ j = 0; j < current_paren.length; j++){\n\t\t\tif(current_paren[j] === \"(\"\
    ){\n\t\t\t\tcount++;\n\t\t\t\tif(count > max_count){\n\t\t\t\t\tmax_count = count;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\telse if(current_paren[j] === \")\"){\n\t\t\t\tcount--;\n\
    \t\t\t}\n\t\t}\n\t\toutput.push(max_count);\n\t}\n\treturn output;\n}\n", "\t\
    var result = [];\n\tvar depth = 0;\n\tvar maxDepth = 0;\n\tfor(var i = 0; i <\
    \ paren_string.length; i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tdepth++;\n\
    \t\t\tif(depth > maxDepth){\n\t\t\t\tmaxDepth = depth;\n\t\t\t}\n\t\t}else if(paren_string[i]\
    \ == ')'){\n\t\t\tdepth--;\n\t\t}else if(paren_string[i] == ' '){\n\t\t\tresult.push(maxDepth);\n\
    \t\t\tmaxDepth = 0;\n\t\t\tdepth = 0;\n\t\t}\n\t}\n\treturn result;\n}\n", " \
    \   var parenList = [];\n    var stack = [];\n    var maxSoFar = 0;\n    var i\
    \ = 0;\n    var current;\n    while(i < paren_string.length){\n        if(paren_string[i]\
    \ == \"(\"){\n            stack.push(paren_string[i]);\n            maxSoFar =\
    \ Math.max(maxSoFar, stack.length);\n        }else if(paren_string[i] == \")\"\
    ){\n            stack.pop();\n        }else if(paren_string[i] == \" \"){\n  \
    \          parenList.push(maxSoFar);\n            maxSoFar = 0;\n        }\n \
    \       i++;\n    }\n    parenList.push(maxSoFar);\n    return parenList;\n}\n",
  "    var counter = 0;\n    var result = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            counter++;\n       \
    \ }\n        else if(paren_string[i] == ')'){\n            counter--;\n      \
    \  }\n        else if(paren_string[i] == ' '){\n            result.push(counter);\n\
    \            counter = 0;\n        }\n    }\n    return result;\n}\n", "\tvar\
    \ group_arr = paren_string.split(\" \");\n\tvar result = [];\n\tfor(var g in group_arr){\n\
    \t\tvar curr_group = group_arr[g];\n\t\tresult.push(parse_single_group(curr_group));\n\
    \t}\n\treturn result;\n}\n", "    var regex = /\\(([^()]*)\\)/\n    var parens\
    \ = paren_string.split(\" \")\n    var results = []\n    var count = 0\n    for\
    \ (var i = 0; i < parens.length; i++){\n        while (regex.test(parens[i])){\n\
    \            parens[i] = parens[i].replace(regex, '')\n            count++\n \
    \       }\n        results.push(count)\n        count = 0\n    }\n    return results\n\
    }\n", "    var l = paren_string.length;\n    var arr = [];\n    var x = 0;\n \
    \   for(var i = 0; i < l; i++){\n        if(paren_string[i] == '('){\n       \
    \     x++;\n        }else if(paren_string[i] == ')'){\n            x--;\n    \
    \    }else if(paren_string[i] == ' '){\n            arr.push(x);\n           \
    \ x = 0;\n        }\n    }\n    arr.push(x);\n    return arr;\n}\n\nparse_nested_parens(\"\
    (()()) ((())) () ((())()())\");", "  var parens_array = paren_string.split(\"\
    \ \");\n  var max_depths = [];\n  for (var i = 0; i < parens_array.length; i++){\n\
    \    max_depths.push(process_parens(parens_array[i]));\n  }\n  return max_depths;\n\
    }\n", "    let count_arr = [];\n    let count = 0;\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === \"(\"){\n            count++\n       \
    \ }\n        if(paren_string[i] === \")\"){\n            count--\n        }\n\
    \        if(paren_string[i] === \" \" && count === 0){\n            count_arr.push(count)\n\
    \            count = 0\n        }\n    }\n    count_arr.push(count)\n    return\
    \ count_arr\n}", "    var results = [];\n    var values = paren_string.split(\"\
    \ \");\n    for(var i = 0; i < values.length; i++){\n        results.push(getMaxLevel(values[i]));\n\
    \    }\n    return results;\n}\n", "  let arr = paren_string.split(' ');\n  let\
    \ finalArr = [];\n  let deepest = 0;\n  let parens = 0;\n  let currentParens =\
    \ 0;\n  let currentDeepest = 0;\n  arr.forEach(el => {\n    parens = 0;\n    for\
    \ (let i = 0; i < el.length; i++) {\n      if (el[i] === '(') {\n        parens\
    \ += 1;\n        currentParens += 1;\n        if (currentParens > currentDeepest)\
    \ {\n          currentDeepest = currentParens;\n        }\n      } else if (el[i]\
    \ === ')') {\n        parens -= 1;\n        currentParens -= 1;\n      }\n   \
    \ }\n    finalArr.push(currentDeepest);\n    currentDeepest = 0;\n    currentParens\
    \ = 0;\n  });\n  return finalArr;\n}\n", "  var parens = paren_string.split(\"\
    \ \");\n  var result = [];\n  for(var i = 0; i < parens.length; i++){\n    var\
    \ count = 0;\n    var max = 0;\n    for(var j = 0; j < parens[i].length; j++){\n\
    \      if(parens[i][j] == \"(\"){\n        count++;\n        if(count > max){\n\
    \          max = count;\n        }\n      }\n      else if(parens[i][j] == \"\
    )\"){\n        count--;\n      }\n    }\n    result.push(max);\n  }\n  return\
    \ result;\n}\n", "    let result = [];\n    let pair = 0;\n    let index = 0;\n\
    \    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === \"(\"){\n            pair += 1;\n        }\n        if(paren_string[i] ===\
    \ \")\"){\n            pair -= 1;\n        }\n        if(paren_string[i] === \"\
    \ \"){\n            result.push(pair);\n            pair = 0;\n        }\n   \
    \ }\n    result.push(pair);\n    return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
