name: HumanEval_6_parse_nested_parens
language: js
prompt: "//Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n// [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = parse_nested_parens;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"\
  ),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[1,\
  \ 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[4]);\n}\n\ntest();"
completions: ["    var level = 0;\n    var maxlevel = 0;\n    var result = [];\n \
    \   for (var i = 0; i < paren_string.length; i++){\n        if (paren_string[i]\
    \ == \"(\"){\n            level += 1;\n            if (level > maxlevel){\n  \
    \              maxlevel = level;\n            }\n        }\n        else if (paren_string[i]\
    \ == \")\"){\n            level -= 1;\n        }\n        else if (paren_string[i]\
    \ == \" \"){\n            result.push(maxlevel);\n            maxlevel = 0;\n\
    \            level = 0;\n        }\n    }\n    result.push(maxlevel);\n    return\
    \ result;\n}\n\n", "    let maxCount = 0;\n    let nested_parens = [];\n    paren_string.split('\
    \ ').forEach(paren => {\n        let count = 0;\n        paren.split('').forEach(char\
    \ => {\n            if(char === '('){\n                count++;\n            }\
    \ else if(char === ')'){\n                count--;\n            }\n        });\n\
    \        if(count > maxCount){\n            maxCount = count;\n        }\n   \
    \     nested_parens.push(count);\n    });\n    return nested_parens;\n}\n", " \
    \   var new_string = paren_string.replace(/ /g, '');\n    var stack = [];\n  \
    \  var count = 0;\n    var max = 0;\n    var group = [];\n    var last_char =\
    \ \"\";\n    var last_paren = \"\";\n    for (var i = 0; i < new_string.length;\
    \ i++){\n        var char = new_string[i];\n        if (char === \"(\"){\n   \
    \         stack.push(char);\n            count++;\n            if (count > max){\n\
    \                max = count;\n            }\n        }\n        else if (char\
    \ === \")\"){\n            stack.pop();\n            count--;\n        }\n   \
    \     if (last_char === \")\" && char === \"(\"){\n            group.push(max);\n\
    \            max = 0;\n        }\n        last_char = char;\n    }\n    group.push(max);\n\
    \    return group;\n}\n", "    var result = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === '('){\n            for(var j = i + 1;\
    \ j < paren_string.length; j++){\n                if(paren_string[j] === '('){\n\
    \                    result.push(1)\n                }\n                if(paren_string[j]\
    \ === ')'){\n                    result.push(0)\n                }\n         \
    \   }\n        }\n    }\n    return result;\n}", "    // your code here\n    paren_string\
    \ = paren_string.split(\" \");\n    var index = 0;\n    var indexOne = 0;\n  \
    \  var indexTwo = 0;\n    var result = [];\n    var count = 0;\n    for(var i\
    \ = 0; i < paren_string.length; i++){\n        index = paren_string[i].indexOf(\"\
    (\");\n        indexOne = paren_string[i].indexOf(\")\");\n        indexTwo =\
    \ paren_string[i].lastIndexOf(\")\");\n        count = 0;\n        while(indexOne\
    \ < indexTwo){\n            count++;\n            indexOne = paren_string[i].indexOf(\"\
    )\", indexOne + 1);\n        }\n        result.push(count);\n    }\n    return\
    \ result;\n}", "    var paren_array = paren_string.split(\" \");\n    var result\
    \ = [];\n    for(var i = 0; i < paren_array.length; i++){\n        var paren_counter\
    \ = 0;\n        var max_paren_counter = 0;\n        for(var j = 0; j < paren_array[i].length;\
    \ j++){\n            if(paren_array[i][j] == \"(\"){\n                paren_counter\
    \ += 1;\n                if(paren_counter > max_paren_counter){\n            \
    \        max_paren_counter = paren_counter;\n                }\n            }\n\
    \            else if(paren_array[i][j] == \")\"){\n                paren_counter\
    \ -= 1;\n            }\n        }\n        result.push(max_paren_counter);\n \
    \   }\n    return result;\n}\n\n", "    var group = paren_string.split(\" \");\n\
    \    for(var i = 0; i < group.length; i++){\n        var max_nest = 0;\n     \
    \   var nest = 0;\n        for(var j = 0; j < group[i].length; j++){\n       \
    \     if(group[i][j] == '('){\n                nest++;\n                if(nest\
    \ > max_nest){\n                    max_nest = nest;\n                }\n    \
    \        }\n            else if(group[i][j] == ')'){\n                nest--;\n\
    \            }\n        }\n        group[i] = max_nest;\n    }\n    return group;\n\
    }\n", "  var paren_arr = paren_string.split(' ');\n  var result = [];\n  for(var\
    \ i = 0; i < paren_arr.length; i++){\n    result.push(find_nested_parens(paren_arr[i]));\n\
    \  }\n  return result;\n}\n", "    let answer = [];\n    let levels = [];\n  \
    \  for(let i = 0; i < paren_string.length; i++){\n        let curr_char = paren_string[i];\n\
    \        //if curr_char == '(', then we push to the levels stack\n        if(curr_char\
    \ == '('){\n            levels.push(1);\n        }\n        // if curr_char ==\
    \ ')', then we subtract from the last index in levels\n        else if(curr_char\
    \ == ')'){\n            if(levels.length == 0){\n                levels.push(0);\n\
    \            }\n            else{\n                levels[levels.length - 1] -=\
    \ 1;\n            }\n        }\n        // if curr_char == ' ', then we add an\
    \ element to levels\n        else if(curr_char == ' '){\n            answer.push(levels[levels.length\
    \ - 1]);\n            levels.push(0);\n        }\n    }\n    return answer;\n\
    }\n", "    var paren_arr = paren_string.split(\" \")\n    var paren_result = []\n\
    \    for (var i = 0; i < paren_arr.length; i++){\n        paren_result.push(parse_parens(paren_arr[i]))\n\
    \    }\n    return paren_result\n}\n", "\tvar result = [];\n\tvar temp = [];\n\
    \tparen_string.split(' ').forEach(function(element, index, array){\n\t\ttemp =\
    \ parse_string(element);\n\t\tresult.push(temp);\n\t});\n\treturn result;\n}\n",
  "  const count = [];\n  const openingParens = [\"(\", \"[\", \"{\"];\n  const closingParens\
    \ = [\")\", \"]\", \"}\"];\n  let stack = [];\n  let str = '';\n  for (let i =\
    \ 0; i < paren_string.length; i++) {\n    if (paren_string[i] === \" \") {\n \
    \     count.push(stack.length);\n      stack = [];\n      str = '';\n    } else\
    \ {\n      str += paren_string[i];\n      if (openingParens.includes(paren_string[i]))\
    \ {\n        stack.push(paren_string[i]);\n      } else if (closingParens.includes(paren_string[i]))\
    \ {\n        if (closingParens.indexOf(paren_string[i]) === openingParens.indexOf(stack[stack.length\
    \ - 1])) {\n          stack.pop();\n        } else {\n          throw `Parens\
    \ don't match in ${str}`;\n        }\n      }\n    }\n  }\n  count.push(stack.length);\n\
    \  return count;\n}\n\nmodule.exports = {\n  parse_nested_parens,\n};", "  var\
    \ finalArray = paren_string.split(\" \");\n  var level = 0;\n  var parenLevels\
    \ = new Array();\n  for(var i = 0; i < finalArray.length; i++){\n    level = 0;\n\
    \    for(var j = 0; j < finalArray[i].length; j++){\n      if(finalArray[i][j]\
    \ == \"(\"){\n        level++;\n      }\n      else if(finalArray[i][j] == \"\
    )\"){\n        level--;\n      }\n    }\n    parenLevels.push(level);\n  }\n \
    \ return parenLevels;\n}", "  //create array to return\n  var paren_array = paren_string.split(\"\
    \ \");\n  //array to store answers\n  var answers = [];\n  //loop through each\
    \ paren\n  for(var i = 0; i < paren_array.length; i++){\n    //starting count\n\
    \    var counter = 0;\n    //maximum count\n    var max_count = 0;\n    //loop\
    \ through each paren\n    for(var j = 0; j < paren_array[i].length; j++){\n  \
    \    //if it's an open paren\n      if(paren_array[i][j] === \"(\"){\n       \
    \ //add to counter\n        counter++;\n        //if counter is greater than max\
    \ count, replace it\n        if(counter > max_count){\n          max_count = counter;\n\
    \        }\n      }\n      //if it's a close paren\n      else if(paren_array[i][j]\
    \ === \")\"){\n        //subtract from counter\n        counter--;\n      }\n\
    \    }\n    //push current max count to answers array\n    answers.push(max_count);\n\
    \  }\n  //return answers array\n  return answers;\n}", "    var output = [];\n\
    \    var start = 0;\n    var end = 0;\n    while(paren_string.length > 0){\n \
    \       end = paren_string.indexOf(\" \");\n        if(end == -1){\n         \
    \   end = paren_string.length;\n        }\n        var substring = paren_string.substring(start,\
    \ end);\n        paren_string = paren_string.substring(end + 1);\n        output.push(nested_parens(substring));\n\
    \    }\n    return output;\n}\n", "    var arr = paren_string.split(\" \");\n\
    \    var ret = [];\n    for(var i = 0; i < arr.length; i++){\n        var leftCount\
    \ = 0;\n        var rightCount = 0;\n        var left = true;\n        var max\
    \ = 0;\n        for(var j = 0; j < arr[i].length; j++){\n            if(arr[i][j]\
    \ == \"(\"){\n                if(left) leftCount++;\n                else rightCount++;\n\
    \            }\n            else if(arr[i][j] == \")\"){\n                if(left)\
    \ leftCount--;\n                else rightCount--;\n            }\n          \
    \  if(leftCount < 0){\n                left = false;\n                leftCount\
    \ = 0;\n            }\n            if(rightCount < 0){\n                left =\
    \ true;\n                rightCount = 0;\n            }\n            max = Math.max(max,\
    \ Math.max(leftCount, rightCount));\n        }\n        ret.push(max);\n    }\n\
    \    return ret;\n}\n", "    let stack = [];\n    let ans = [];\n    let max =\
    \ 0;\n    let current = 0;\n    for(let i = 0; i < paren_string.length; i++){\n\
    \        if(paren_string[i] == '('){\n            stack.push(paren_string[i]);\n\
    \            current += 1;\n            max = Math.max(max, current);\n      \
    \  }\n        else if(paren_string[i] == ')'){\n            stack.pop();\n   \
    \         current -= 1;\n        }\n        else{\n            ans.push(max);\n\
    \            max = 0;\n            current = 0;\n        }\n    }\n    return\
    \ ans;\n}\n", "    var result = [];\n    var new_string = '';\n    paren_string\
    \ = paren_string.replace(/\\(\\(/g, '(');\n    for (var i = 0; i < paren_string.length;\
    \ i++){\n        if (paren_string[i] == '(' || paren_string[i] == ')') {\n   \
    \         new_string += paren_string[i];\n        }\n    }\n    var str_array\
    \ = new_string.split(' ');\n    console.log(str_array);\n    str_array.forEach(function(elem){\n\
    \        result.push(parse_parens(elem));\n    });\n    return result;\n}\n\n",
  "    return paren_string.split(' ').map(i => {\n        var parens = 0;\n      \
    \  var max_parens = 0;\n        for (var j=0; j<i.length; j++){\n            if\
    \ (i[j] == '('){\n                parens++;\n                if (parens > max_parens){\n\
    \                    max_parens = parens;\n                }\n            }\n\
    \            else if (i[j] == ')'){\n                parens--;\n            }\n\
    \        }\n        return max_parens;\n    });\n}\n\n\n", "    var parens = paren_string.split(\"\
    \ \");\n    var num_parens = [];\n    for (var i = 0; i < parens.length; i++){\n\
    \        num_parens.push(num_nested_parens(parens[i]));\n    }\n    return num_parens;\n\
    }\n", "    var parens = paren_string.split(\" \");\n    var result = [];\n   \
    \ for(var i = 0; i < parens.length; i++){\n        result.push(find_nested_level(parens[i]));\n\
    \    }\n    return result;\n}\n", "    let res = [];\n    let parens = paren_string.split('\
    \ ');\n    for(let paren of parens){\n        let stack = [];\n        let max\
    \ = 0;\n        for(let i = 0; i < paren.length; i++){\n            if(paren[i]\
    \ === '('){\n                stack.push(paren[i]);\n                max = Math.max(max,\
    \ stack.length);\n            }\n            else{\n                stack.pop();\n\
    \            }\n        }\n        res.push(max);\n    }\n    return res;\n}",
  "    var paren_array = paren_string.split(' ');\n    var output = [];\n    for(var\
    \ i = 0; i < paren_array.length; i++){\n        output.push(count_paren_depth(paren_array[i]));\n\
    \    }\n    return output;\n}\n", "    return paren_string.split(' ').map(function(a){\n\
    \        return a.split('').reduce(function(max, x){\n            if(x == '('){\n\
    \                max++;\n            }\n            else if(x == ')'){\n     \
    \           max--;\n            }\n            return max;\n        }, 0);\n \
    \   });\n}\n", "  const grp_arr = paren_string.split(' ');\n  // console.log(grp_arr);\n\
    \  const level_arr = grp_arr.map(grp=>{\n    let max_level = 0;\n    let level\
    \ = 0;\n    for(let i=0; i<grp.length; i++){\n      if(grp[i]==='('){\n      \
    \  level += 1;\n        if(level>max_level){\n          max_level = level;\n \
    \       }\n      }\n      else if(grp[i]===')'){\n        level -= 1;\n      }\n\
    \    }\n    return max_level;\n  });\n  return level_arr;\n}\n", "\tlet paren_groups\
    \ = paren_string.split(\" \");\n\tlet levels = [];\n\tfor(let i = 0; i < paren_groups.length;\
    \ i++){\n\t\tlevels.push(deepest_parens(paren_groups[i]));\n\t}\n\treturn levels;\n\
    }", "    // your code here\n    var result = [];\n    var groups = paren_string.split(\"\
    \ \");\n    var max = 0;\n    var count = 0;\n    for (var i = 0; i < groups.length;\
    \ i++) {\n        for (var j = 0; j < groups[i].length; j++) {\n            if\
    \ (groups[i][j] == \"(\") {\n                count ++;\n            } else if\
    \ (groups[i][j] == \")\") {\n                count --;\n            }\n      \
    \      if (count > max) {\n                max = count;\n            }\n     \
    \   }\n        result.push(max);\n        max = 0;\n        count = 0;\n    }\n\
    \    return result;\n}", "  var count = 0;\n  var arr = [];\n  var result = [];\n\
    \  var sub_str = '';\n  var index = 0;\n  var start_index = 0;\n  var end_index\
    \ = 0;\n  var new_arr = [];\n  for(var i = 0; i < paren_string.length; i++){\n\
    \    if(paren_string[i] === '('){\n      count++;\n    }\n    if(paren_string[i]\
    \ === ')'){\n      count--;\n    }\n    arr.push(count);\n  }\n  for(var j = 0;\
    \ j < arr.length; j++){\n    if(arr[j] === 0){\n      end_index = j;\n      sub_str\
    \ = paren_string.slice(start_index, end_index + 1);\n      new_arr.push(sub_str);\n\
    \      start_index = end_index + 2;\n    }\n  }\n  for(var k = 0; k < new_arr.length;\
    \ k++){\n    var max = Math.max.apply(null, new_arr[k].split(''));\n    result.push(max);\n\
    \  }\n  return result;\n}", "    var regex = /\\((.*?)\\)/g;\n    var parens =\
    \ paren_string.match(regex);\n    var result = [];\n    for(var i = 0; i < parens.length;\
    \ i++){\n        var maxCount = 0;\n        var currCount = 0;\n        for(var\
    \ j = 0; j < parens[i].length; j++){\n            if(parens[i][j] == '('){\n \
    \               currCount++;\n            }\n            else if(parens[i][j]\
    \ == ')'){\n                currCount--;\n            }\n            if(currCount\
    \ > maxCount){\n                maxCount = currCount;\n            }\n       \
    \ }\n        result.push(maxCount);\n    }\n    return result;\n}\n", "    var\
    \ paren_array = paren_string.split(\" \");\n    var result = [];\n    for(var\
    \ paren in paren_array){\n        var temp = paren_array[paren];\n        result.push(parse_single_paren(temp));\n\
    \    }\n    return result;\n}\n", "    var paren_arr = paren_string.split(\" \"\
    );\n    var paren_cnt_arr = [];\n    for(var i=0; i<paren_arr.length; i++){\n\
    \        paren_cnt_arr.push(paren_arr[i].length-2);\n    }\n    return paren_cnt_arr;\n\
    }", "    var result = [];\n    var parens = paren_string.split(\" \");\n    for(var\
    \ i = 0; i < parens.length; i++){\n        var cur_max = 0;\n        var cur_paren\
    \ = parens[i];\n        for(var j = 0; j < cur_paren.length; j++){\n         \
    \   if(cur_paren[j] == '('){\n                cur_max += 1;\n            }\n \
    \           else{\n                cur_max -= 1;\n            }\n        }\n \
    \       result.push(cur_max);\n    }\n    return result;\n}\n", "\tlet res = paren_string.split(\"\
    \ \");\n\tres = res.map(elem => {\n\t\tlet cnt = 0;\n\t\tlet max = 0;\n\t\tfor(let\
    \ i = 0; i < elem.length; i++){\n\t\t\tif(elem[i] === \"(\"){\n\t\t\t\tcnt++;\n\
    \t\t\t\tmax = Math.max(max, cnt);\n\t\t\t}\n\t\t\telse if(elem[i] === \")\"){\n\
    \t\t\t\tcnt--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t});\n\treturn res;\n}\n", " \
    \   let count_array = [];\n    let paren_array = paren_string.split(\" \");\n\
    \    for (let i = 0; i < paren_array.length; i++){\n        let count = 0;\n \
    \       let curr_paren = paren_array[i];\n        let new_paren = curr_paren.slice(1,\
    \ curr_paren.length - 1);\n        for (let i = 0; i < new_paren.length; i++){\n\
    \            if (new_paren[i] === \"(\"){\n                count++;\n        \
    \    }\n        }\n        count_array.push(count);\n    }\n    return count_array;\n\
    }", "\tvar split_string = paren_string.split(\" \");\n\tvar result = [];\n\tfor(var\
    \ i = 0; i < split_string.length; i++){\n\t\tvar temp = 0;\n\t\tvar max = 0;\n\
    \t\tfor(var j = 0; j < split_string[i].length; j++){\n\t\t\tif(split_string[i][j]\
    \ == \"(\"){\n\t\t\t\ttemp++;\n\t\t\t\tif(temp > max){\n\t\t\t\t\tmax = temp;\n\
    \t\t\t\t}\n\t\t\t}else if(split_string[i][j] == \")\"){\n\t\t\t\ttemp--;\n\t\t\
    \t}\n\t\t}\n\t\tresult.push(max);\n\t}\n\treturn result;\n}\n", "  var deepest\
    \ = 0;\n  var deepest_array = [];\n  var count = 0;\n  for (var i = 0; i < paren_string.length;\
    \ i++){\n    if (paren_string[i] === \"(\"){\n      count++;\n      if (count\
    \ > deepest){\n        deepest = count;\n      }\n    } else if (paren_string[i]\
    \ === \")\"){\n      count--;\n      if (count === 0){\n        deepest_array.push(deepest);\n\
    \        deepest = 0;\n      }\n    }\n  }\n  return deepest_array;\n}\n", " \
    \   return paren_string.split(' ').map(function(x){\n        return x.match(/\\\
    (((?=\\()*\\))/g).length;\n    });\n}\n", "    var answer = [];\n    var paren_array\
    \ = paren_string.split(\" \");\n    for (var i = 0; i < paren_array.length; i++){\n\
    \        var current_group = paren_array[i];\n        var current_sum = 0;\n \
    \       var max_sum = 0;\n        for (var j = 0; j < current_group.length; j++){\n\
    \            var current_char = current_group[j];\n            if (current_char\
    \ == \"(\"){\n                current_sum++;\n            }\n            else\
    \ if (current_char == \")\"){\n                current_sum--;\n            }\n\
    \            if (current_sum > max_sum){\n                max_sum = current_sum;\n\
    \            }\n        }\n        answer.push(max_sum);\n    }\n    return answer;\n\
    }\n", "    // split the string by spaces\n    let arrayOfGroups = paren_string.split(\"\
    \ \");\n    //for each string of parens we need to find the deepest level of nesting\
    \ of parentheses.\n    let maxLevels = [];\n    for(let i = 0; i < arrayOfGroups.length;\
    \ i++){\n        // go through each string character by character looking for\
    \ ( or )\n        let currentString = arrayOfGroups[i];\n        let currentLevel\
    \ = 0;\n        let maxLevel = 0;\n        for(let j = 0; j < currentString.length;\
    \ j++){\n            // if we find a ( we add 1 to our currentLevel\n        \
    \    if(currentString[j] === \"(\"){\n                currentLevel += 1;\n   \
    \         }\n            // if we find a ) we subtract 1 from our currentLevel\n\
    \            if(currentString[j] === \")\"){\n                currentLevel -=\
    \ 1;\n            }\n            // after each new character we check to see if\
    \ our currentLevel is larger than our maxLevel.\n            if(currentLevel >\
    \ maxLevel){\n                maxLevel = currentLevel;\n            }\n      \
    \  }\n        // then we push maxLevel to our maxLevels array\n        maxLevels.push(maxLevel);\n\
    \    }\n    return maxLevels;\n}\n", "    const parens = paren_string.split(\"\
    \ \");\n    const results = [];\n    for(let paren of parens){\n        let cur\
    \ = 0;\n        let max = 0;\n        for(let i = 0; i < paren.length; i++){\n\
    \            if(paren[i] === \"(\"){\n                cur++;\n               \
    \ max = Math.max(max, cur);\n            }\n            else if(paren[i] === \"\
    )\"){\n                cur--;\n            }\n        }\n        results.push(max);\n\
    \    }\n    return results;\n}\n", "    var max_nesting_count = 0;\n    var nesting_count\
    \ = 0;\n    var nesting_count_arr = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == \"(\"){\n            nesting_count++;\n\
    \            if(nesting_count > max_nesting_count){\n                max_nesting_count\
    \ = nesting_count;\n            }\n        }\n        else if(paren_string[i]\
    \ == \")\"){\n            nesting_count_arr.push(nesting_count);\n           \
    \ nesting_count = 0;\n        }\n    }\n    return nesting_count_arr;\n}\n", " \
    \   //TODO\n    let array_of_parens = paren_string.split(\" \");\n    let levels\
    \ = [];\n    for (let group of array_of_parens){\n        let highest = 0;\n \
    \       let level = 0;\n        for (let i = 0; i < group.length; i++){\n    \
    \        if (group[i] == \"(\"){\n                level += 1;\n            }\n\
    \            else if (group[i] == \")\"){\n                level -= 1;\n     \
    \       }\n            if (level > highest){\n                highest = level;\n\
    \            }\n        }\n        levels.push(highest);\n    }\n    return levels;\n\
    }\n\n", "    let paren_splitted = paren_string.split(\" \");\n    let paren_max\
    \ = [];\n    for (let i = 0; i < paren_splitted.length; i++){\n        paren_max.push(parse_parens(paren_splitted[i]));\n\
    \    }\n    return paren_max;\n}\n", "    // Write a solution here\n    var splitString\
    \ = paren_string.split(\" \");\n    var result = [];\n    var stack = [];\n  \
    \  for(var i = 0; i < splitString.length; i++){\n        if(splitString[i] ===\
    \ \"(\"){\n            stack.push(splitString[i]);\n        }\n        else if(splitString[i]\
    \ === \")\"){\n            stack.pop();\n        }\n        result.push(stack.length);\n\
    \    }\n    return result;\n}\n", "  var result = [];\n  var groups = paren_string.split(\"\
    \ \");\n  for (var i = 0; i < groups.length; i++){\n    var current = groups[i];\n\
    \    var num_open = 0;\n    var max_open = 0;\n    for (var j = 0; j < current.length;\
    \ j++){\n      if (current[j] == \"(\"){\n        num_open += 1;\n        if (num_open\
    \ > max_open){\n          max_open = num_open;\n        }\n      }\n      else\
    \ if (current[j] == \")\"){\n        num_open -= 1;\n      }\n    }\n    result.push(max_open);\n\
    \  }\n  return result;\n}\n", "    let parens = paren_string.split(' ');\n   \
    \ let parsed = [];\n    for(let i = 0; i < parens.length; i++){\n        parsed.push(parse_single_paren(parens[i]));\n\
    \    }\n    return parsed;\n}\n", "    var max_open = 0;\n    var paren_array\
    \ = paren_string.split(\" \");\n    var output = [];\n    for (var i = 0; i <\
    \ paren_array.length; i++){\n        var s = paren_array[i];\n        var curr_max\
    \ = 0;\n        var curr_open = 0;\n        for (var j = 0; j < s.length; j++){\n\
    \            if (s[j] == '('){\n                curr_open++;\n               \
    \ if (curr_open > curr_max){\n                    curr_max = curr_open;\n    \
    \            }\n            }\n            else if (s[j] == ')'){\n          \
    \      curr_open--;\n            }\n        }\n        output.push(curr_max);\n\
    \    }\n    return output;\n}", "    var result = [];\n    var regex = /[()]/g;\n\
    \    var match_arr = paren_string.match(regex);\n    var max_depth = 0;\n    var\
    \ depth = 0;\n    for(var i = 0; i < match_arr.length; i++){\n        if(match_arr[i]\
    \ == \"(\"){\n            depth++;\n            if(depth > max_depth){\n     \
    \           max_depth = depth;\n            }\n        }\n        else if(match_arr[i]\
    \ == \")\"){\n            depth--;\n        }\n        if(i < match_arr.length\
    \ - 1 && match_arr[i+1] == \" \"){\n            result.push(max_depth);\n    \
    \        max_depth = 0;\n        }\n    }\n    return result;\n}", "    const\
    \ strings = paren_string.split(' ');\n    const answers = [];\n    for(const string\
    \ of strings){\n        let stack = [];\n        let maxDepth = 0;\n        for(const\
    \ char of string){\n            if(char === '('){\n                stack.push(char);\n\
    \                maxDepth = Math.max(maxDepth, stack.length);\n            }\n\
    \            else{\n                stack.pop();\n            }\n        }\n \
    \       answers.push(maxDepth);\n    }\n    return answers;\n}\n\nmodule.exports\
    \ = {\n    parse_nested_parens\n};", "    var stack=[];\n    var result=[];\n\
    \    for(var i=0;i<paren_string.length;i++){\n        if(paren_string[i]=='('){\n\
    \            stack.push(paren_string[i]);\n        }\n        else if(paren_string[i]==')'){\n\
    \            stack.pop();\n        }\n        else if(paren_string[i]==' '){\n\
    \            result.push(stack.length);\n        }\n    }\n    return result;\n\
    }\n", "  let paren_groups = paren_string.split(\" \");\n  let paren_levels = [];\n\
    \  for (let i = 0; i < paren_groups.length; i++){\n    let current_paren_group\
    \ = paren_groups[i];\n    let current_paren_level = 0;\n    let deepest_paren_level\
    \ = 0;\n    for (let j = 0; j < current_paren_group.length; j++){\n      if (current_paren_group[j]\
    \ === \"(\"){\n        current_paren_level++;\n      }\n      if (current_paren_group[j]\
    \ === \")\"){\n        current_paren_level--;\n      }\n      if (current_paren_level\
    \ > deepest_paren_level){\n        deepest_paren_level = current_paren_level;\n\
    \      }\n    }\n    paren_levels.push(deepest_paren_level);\n  }\n  return paren_levels;\n\
    }\n", "    const parenArr = paren_string.split(' ');\n    let result = [];\n \
    \   parenArr.forEach(element => {\n        let count = 0;\n        let currentDepth\
    \ = 0;\n        for(let i = 0; i < element.length; i++){\n            if(element[i]\
    \ === '('){\n                count++;\n                if(count > currentDepth){\n\
    \                    currentDepth = count;\n                }\n            }else\
    \ if(element[i] === ')'){\n                count--;\n            }\n        }\n\
    \        result.push(currentDepth);\n    });\n    return result;\n}\n", "    paren_string\
    \ = paren_string.split(\" \");\n    var max_depth = 0;\n    var answer = [];\n\
    \    for(var i = 0; i < paren_string.length; i++){\n        var j = 0;\n     \
    \   var current_depth = 0;\n        while(j < paren_string[i].length){\n     \
    \       if(paren_string[i][j] == \"(\"){\n                current_depth++;\n \
    \           }else if(paren_string[i][j] == \")\"){\n                current_depth--;\n\
    \            }\n            j++;\n        }\n        answer.push(current_depth);\n\
    \    }\n    return answer;\n}\n", "    let paren_arr = paren_string.split(\" \"\
    );\n    let max_levels = [];\n    paren_arr.forEach(value => {\n        let level\
    \ = 0;\n        let max_level = 0;\n        for(let i = 0; i < value.length; i++){\n\
    \            if(value[i] === \"(\"){\n                level++;\n             \
    \   if(level > max_level){\n                    max_level = level;\n         \
    \       }\n            }\n            else if(value[i] === \")\"){\n         \
    \       level--;\n            }\n        }\n        max_levels.push(max_level);\n\
    \    });\n    return max_levels;\n}", "    let paren = paren_string.split(\" \"\
    );\n    // console.log(paren);\n    let return_array = [];\n    for(let i = 0;\
    \ i < paren.length; i++){\n        let count = 0;\n        let max = 0;\n    \
    \    for(let j = 0; j < paren[i].length; j++){\n            if(paren[i][j] ===\
    \ \"(\"){\n                count++;\n                if(count > max){\n      \
    \              max = count;\n                }\n            }\n            else\
    \ if(paren[i][j] === \")\"){\n                count--;\n            }\n      \
    \  }\n        return_array.push(max);\n    }\n    return return_array;\n}", "\t\
    var paren_array = paren_string.split(' ');\n\tvar paren_levels = [];\n\tfor (var\
    \ i = 0; i < paren_array.length; i++){\n\t\tvar current_paren_level = 0;\n\t\t\
    var current_paren_string = paren_array[i];\n\t\tfor (var j = 0; j < current_paren_string.length;\
    \ j++){\n\t\t\tif (current_paren_string[j] == '('){\n\t\t\t\tcurrent_paren_level++;\n\
    \t\t\t}\n\t\t\telse if (current_paren_string[j] == ')'){\n\t\t\t\tcurrent_paren_level--;\n\
    \t\t\t}\n\t\t}\n\t\tparen_levels.push(current_paren_level);\n\t}\n\treturn paren_levels;\n\
    }\n", "    let max_num = 0;\n    let arr = paren_string.split(\" \");\n    let\
    \ results = [];\n    for(let i = 0; i < arr.length; i++){\n        let num = 0;\n\
    \        for(let j = 0; j < arr[i].length; j++){\n            if(arr[i][j] ===\
    \ \"(\"){\n                num += 1;\n            }else if(arr[i][j] === \")\"\
    ){\n                num -= 1;\n            }\n        }\n        if(num > max_num){\n\
    \            max_num = num;\n        }\n        results.push(max_num);\n    }\n\
    \    return results;\n}\n", "\tvar paren_list = paren_string.split(\" \");\n\t\
    return paren_list.map(function(str){\n\t\tvar count = 0;\n\t\tvar max = 0;\n\t\
    \tfor(var i = 0; i < str.length; i++){\n\t\t\tif(str[i] == \"(\"){\n\t\t\t\tcount++;\n\
    \t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\
    \ if(str[i] == \")\"){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t\
    });\n}\n", "    var prev = [0], result = [];\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] == '('){\n            prev.push(prev[prev.length\
    \ - 1] + 1);\n        }else if(paren_string[i] == ')'){\n            result.push(prev.pop());\n\
    \        }\n    }\n    return result;\n}\n", "  var groups = paren_string.split(\"\
    \ \");\n  var result = [];\n  for(i=0; i<groups.length; i++){\n    var max = 0;\n\
    \    var count = 0;\n    for(j=0; j<groups[i].length; j++){\n      if(groups[i][j]=='('){\n\
    \        count++;\n        if(count>max){\n          max = count;\n        }\n\
    \      }\n      else if(groups[i][j]==')'){\n        count--;\n      }\n    }\n\
    \    result.push(max);\n  }\n  return result;\n}", "    var parenArray = paren_string.split(\"\
    \ \");\n    var result = [];\n    for(var i = 0; i < parenArray.length; i++){\n\
    \        var paren_stack = [];\n        var max = 0;\n        for(var j = 0; j\
    \ < parenArray[i].length; j++){\n            if(parenArray[i][j] == \"(\"){\n\
    \                paren_stack.push(parenArray[i][j]);\n                if(paren_stack.length\
    \ > max){\n                    max = paren_stack.length;\n                }\n\
    \            }\n            else if(parenArray[i][j] == \")\"){\n            \
    \    paren_stack.pop();\n            }\n        }\n        result.push(max);\n\
    \    }\n    return result;\n}", "  let paren_group = paren_string.split(' ');\n\
    \  let result = [];\n  for(let i = 0; i < paren_group.length; i++){\n    let count\
    \ = 0;\n    let max = 0;\n    for(let j = 0; j < paren_group[i].length; j++){\n\
    \      if(paren_group[i][j] === '('){\n        count ++;\n        if(count > max){\n\
    \          max = count;\n        }\n      }else if(paren_group[i][j] === ')'){\n\
    \        count --;\n      }\n    }\n    result.push(max);\n  }\n  return result;\n\
    }\n", "  let split = paren_string.split(' ');\n  return split.map(paren=> {\n\
    \    let depth = 0;\n    let count = 0;\n    for (let i = 0; i < paren.length;\
    \ i++) {\n      if (paren[i] === '(') {\n        depth++;\n        if (depth >\
    \ count) {\n          count = depth;\n        }\n      } else {\n        depth--;\n\
    \      }\n    }\n    return count;\n  });\n}\n", "  var max = 0;\n  var arr =\
    \ [];\n  var stack = [];\n  var stringArr = paren_string.split(\" \");\n  var\
    \ j = 0;\n  var i = 0;\n  while(j < stringArr.length){\n    while(i < stringArr[j].length){\n\
    \      if(stringArr[j][i] === \"(\"){\n        stack.push(stringArr[j][i]);\n\
    \      }\n      else if(stringArr[j][i] === \")\"){\n        stack.pop();\n  \
    \    }\n      i++;\n    }\n    arr.push(stack.length);\n    i = 0;\n    j++;\n\
    \  }\n  return arr;\n}\n", "  let max_level = 0, current_level = 0, res = [];\n\
    \  for(let i = 0; i < paren_string.length; i++){\n    if(paren_string[i] === '('){\n\
    \      current_level++;\n      max_level = Math.max(max_level, current_level);\n\
    \    }else if(paren_string[i] === ')'){\n      current_level--;\n    }else if(paren_string[i]\
    \ === ' '){\n      res.push(max_level);\n      max_level = 0;\n      current_level\
    \ = 0;\n    }\n  }\n  res.push(max_level);\n  return res;\n}\n", "    var groups\
    \ = paren_string.split(\" \");\n    var res = [];\n    for(var i=0; i<groups.length;\
    \ i++){\n        var deepest_level = 0;\n        var curr_level = 0;\n       \
    \ for(var j=0; j<groups[i].length; j++){\n            if(groups[i][j]===\"(\"\
    ){\n                curr_level++;\n                if(curr_level>deepest_level){\n\
    \                    deepest_level = curr_level;\n                }\n        \
    \    }\n            else if(groups[i][j]===\")\"){\n                curr_level--;\n\
    \            }\n        }\n        res.push(deepest_level);\n    }\n    return\
    \ res;\n}\n", "\n}\n", "  let finalArray = [];\n  let splitArray = paren_string.split(\"\
    \ \");\n  for (i=0; i<splitArray.length; i++){\n    let parenString = splitArray[i];\n\
    \    let count = 0;\n    let tempCount = 0;\n    for (j=0; j<parenString.length;\
    \ j++){\n      if (parenString[j] === '('){\n        tempCount += 1;\n      }\n\
    \      if (parenString[j] === ')'){\n        tempCount -= 1;\n      }\n      if\
    \ (tempCount > count){\n        count = tempCount;\n      }\n    }\n    finalArray.push(count);\n\
    \  }\n  return finalArray;\n}\n\n", "\tlet parenList = paren_string.split(\" \"\
    );\n\tlet nestedParenArr = [];\n\tfor(let i = 0; i < parenList.length; i++){\n\
    \t\tlet paren = parenList[i];\n\t\tlet count = 0;\n\t\tlet max = 0;\n\t\tfor(let\
    \ j = 0; j < paren.length; j++){\n\t\t\tif(paren[j] === \"(\"){\n\t\t\t\tcount++;\n\
    \t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}else if(paren[j]\
    \ === \")\"){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tnestedParenArr.push(max);\n\
    \t}\n\treturn nestedParenArr;\n}\n", "    var results = [];\n    var parens =\
    \ paren_string.split(\" \");\n    for(var i = 0; i < parens.length; i++){\n  \
    \      var index = 0;\n        var maxIndex = 0;\n        var length = parens[i].length;\n\
    \        var lengthMax = 0;\n        while(index < length){\n            if(parens[i][index]\
    \ == \"(\"){\n                maxIndex++;\n                lengthMax++;\n    \
    \        }\n            else if(parens[i][index] == \")\"){\n                maxIndex--;\n\
    \                lengthMax++;\n            }\n            index++;\n        }\n\
    \        results.push(lengthMax);\n    }\n    return results;\n}\n", "    var\
    \ paren_arr = paren_string.split(\" \");\n    var max_paren = 0;\n    var paren_counter\
    \ = 0;\n    var result = [];\n    for(var i = 0; i < paren_arr.length; i++){\n\
    \        var paren_level = paren_arr[i];\n        for(var j = 0; j < paren_level.length;\
    \ j++){\n            if(paren_level[j] == \"(\"){\n                paren_counter++;\n\
    \            }\n            else if(paren_level[j] == \")\"){\n              \
    \  paren_counter--;\n            }\n            max_paren = Math.max(max_paren,\
    \ paren_counter);\n        }\n        result.push(max_paren);\n        max_paren\
    \ = 0;\n        paren_counter = 0;\n    }\n    return result;\n}\n", "    var\
    \ parens = paren_string.split(\" \");\n    var levels = []\n    for (var i = 0;\
    \ i < parens.length; i++){\n        var stack = [];\n        var count = 0;\n\
    \        for (var j = 0; j < parens[i].length; j++){\n            if (parens[i][j]\
    \ == '('){\n                stack.push('(');\n                count++;\n     \
    \       }\n            else if (parens[i][j] == ')'){\n                stack.pop();\n\
    \                count--;\n            }\n        }\n        levels.push(Math.abs(count));\n\
    \    }\n    return levels;\n}\n", "    let paren_groups = paren_string.split(\"\
    \ \");\n    return paren_groups.map( (group) => {\n        let stack = [];\n \
    \       let curr_level = 0;\n        let max_level = 0;\n        for (let i =\
    \ 0; i < group.length; i++){\n            if (group[i] === \"(\"){\n         \
    \       stack.push(1);\n                curr_level++;\n                max_level\
    \ = Math.max(max_level, curr_level);\n            } else if (group[i] === \")\"\
    ){\n                stack.pop();\n                curr_level--;\n            }\n\
    \        }\n        return max_level;\n    });\n}\n", "  var level = [],\n   \
    \   max = [];\n  //split paren_string into array of individual strings\n  var\
    \ parens = paren_string.split(\" \");\n  //iterate through parens\n  for (var\
    \ i = 0; i < parens.length; i++){\n    var count = 0;\n    for (var j = 0; j <\
    \ parens[i].length; j++){\n      //if paren is open, add one to count\n      if\
    \ (parens[i][j] === \"(\"){\n        count++;\n      }\n      //if paren is closed,\
    \ subtract one from count\n      else if (parens[i][j] === \")\"){\n        count--;\n\
    \      }\n      //if count is negative, return invalid parenthasis\n      if (count\
    \ < 0){\n        return \"invalid parenthasis\";\n      }\n    }\n    //push count\
    \ to level array\n    level.push(count);\n  }\n  //iterate through level array\n\
    \  for (var k = 0; k < level.length; k++){\n    //if level is greater than 1,\
    \ push level to max array\n    if (level[k] > 1){\n      max.push(level[k]);\n\
    \    }\n    //else level is 1\n    else {\n      //iterate through max array\n\
    \      for (var m = 0; m < max.length; m++){\n        //if level is greater than\
    \ max, push level to max array\n        if (level[k] > max[m]){\n          max.push(level[k]);\n\
    \        }\n      }\n    }\n  }\n  return max;\n}", "  let final_array = [];\n\
    \  let split_string = paren_string.split(\" \");\n  for (let i = 0; i < split_string.length;\
    \ i++){\n    let current_string = split_string[i];\n    let count = 0;\n    let\
    \ max_count = 0;\n    for (let j = 0; j < current_string.length; j++){\n     \
    \ if (current_string[j] === \"(\"){\n        count++;\n        if (count > max_count){\n\
    \          max_count = count;\n        }\n      } else if (current_string[j] ===\
    \ \")\"){\n        count--;\n      }\n    }\n    final_array.push(max_count);\n\
    \  }\n  return final_array;\n}\n", "    var parens = paren_string.split(\" \"\
    );\n    var max_depth = 0;\n    var paren_depth = 0;\n    var depth_arr = [];\n\
    \    for(var i = 0; i < parens.length; i++){\n        for(var j = 0; j < parens[i].length;\
    \ j++){\n            if(parens[i][j] == \"(\"){\n                paren_depth +=\
    \ 1;\n            }else if(parens[i][j] == \")\"){\n                paren_depth\
    \ -= 1;\n            }\n            if(paren_depth > max_depth){\n           \
    \     max_depth = paren_depth;\n            }\n        }\n        depth_arr.push(max_depth);\n\
    \        max_depth = 0;\n        paren_depth = 0;\n    }\n    return depth_arr;\n\
    }", "    var paren_split = paren_string.split(\" \");\n    var deepest_nesting\
    \ = [];\n    for (i = 0; i < paren_split.length; i++){\n        var current_depth\
    \ = 0;\n        var max_depth = 0;\n        for (n = 0; n < paren_split[i].length;\
    \ n++){\n            if (paren_split[i][n] == \"(\"){\n                current_depth\
    \ += 1;\n                if (current_depth > max_depth){\n                   \
    \ max_depth = current_depth;\n                }\n            }\n            else\
    \ if (paren_split[i][n] == \")\"){\n                current_depth -= 1;\n    \
    \        }\n        }\n        deepest_nesting.push(max_depth);\n    }\n    return\
    \ deepest_nesting;\n}\n", "    paren_string = paren_string.replace(/\\s/g,'');\n\
    \    var max_index = 0;\n    var count = 0;\n    var arr = [];\n    while(paren_string.length\
    \ > 0){\n        if(paren_string[0] == \"(\"){\n            count++;\n       \
    \     if(count > max_index){\n                max_index = count;\n           \
    \ }\n        }\n        else if(paren_string[0] == \")\"){\n            count--;\n\
    \        }\n        paren_string = paren_string.slice(1);\n    }\n    console.log(max_index);\n\
    \    return max_index;\n}\n", "  var paren_array = paren_string.split(\" \");\n\
    \  var output = [];\n  for (var i = 0; i < paren_array.length; i++){\n    var\
    \ paren_index = 0;\n    var current_paren_array = paren_array[i].split(\"\");\n\
    \    var current_paren_level = 0;\n    var max_paren_level = 0;\n    while (paren_index\
    \ < current_paren_array.length){\n      if (current_paren_array[paren_index] ==\
    \ \"(\"){\n        current_paren_level += 1;\n        if (current_paren_level\
    \ > max_paren_level){\n          max_paren_level = current_paren_level;\n    \
    \    }\n      } else if (current_paren_array[paren_index] == \")\"){\n       \
    \ current_paren_level -= 1;\n      }\n      paren_index += 1;\n    }\n    output.push(max_paren_level);\n\
    \  }\n  return output;\n}\n", "    const paren_list = paren_string.split(\" \"\
    );\n    let output = []\n    for (let i = 0; i < paren_list.length; i++){\n  \
    \      let stack = [];\n        let count = 0;\n        for (let j = 0; j < paren_list[i].length;\
    \ j++){\n            if (paren_list[i][j] === '('){\n                stack.push(paren_list[i][j]);\n\
    \                count++;\n            }\n            else if (paren_list[i][j]\
    \ === ')'){\n                if (stack.length > 0){\n                    stack.pop();\n\
    \                }\n                else{\n                    count = 0;\n  \
    \                  break;\n                }\n            }\n        }\n     \
    \   output.push(count);\n    }\n    return output;\n}\n", "    let arr = paren_string.split(\"\
    \ \");\n    let depth = [];\n    for(let i = 0; i < arr.length; i++){\n      \
    \  depth.push(getDepth(arr[i]));\n    }\n    return depth;\n}\n", "  var output\
    \ = [];\n  var max = 0;\n  var count = 0;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      count++;\n      if(count > max){\n\
    \        max = count;\n      }\n    }\n    if(paren_string[i] == ')'){\n     \
    \ count--;\n    }\n    if(paren_string[i] == ' '){\n      output.push(max);\n\
    \      max = 0;\n      count = 0;\n    }\n  }\n  return output;\n}", "    var\
    \ array_string = paren_string.split(\" \");\n    var array_result = [];\n    var\
    \ num_parens = 0;\n    var count_parens = 0;\n    var new_str = \"\";\n    for(var\
    \ i = 0; i < array_string.length; i++){\n        num_parens = 0;\n        count_parens\
    \ = 0;\n        new_str = \"\";\n        for(var j = 0; j < array_string[i].length;\
    \ j++){\n            if(array_string[i][j] == \"(\"){\n                count_parens\
    \ = count_parens + 1;\n            }\n            else if(array_string[i][j] ==\
    \ \")\"){\n                count_parens = count_parens - 1;\n            }\n \
    \           if(count_parens > num_parens){\n                num_parens = count_parens;\n\
    \            }\n        }\n        array_result.push(num_parens);\n    }\n   \
    \ return array_result;\n}\n\n", "\t//split into list of paren strings\n\tlet paren_list\
    \ = paren_string.split(\" \");\n\tlet paren_levels = [];\n\tfor (var i = 0; i\
    \ < paren_list.length; i++) {\n\t\tparen_levels.push(get_paren_levels(paren_list[i]));\n\
    \t}\n\treturn paren_levels;\n}\n", "  // //Your code here\n  // return undefined;\n\
    \  // 1. create array to hold nested paren pairs\n  // 2. loop through paren_string,\
    \ push first paren to array\n  // 3. loop through array, if there's a closing\
    \ paren without an opening paren, push to array\n  // 4. loop through array, find\
    \ the longest string.length, return that length\n  var parenArray = [];\n  for\
    \ (var i = 0; i < paren_string.length; i++) {\n    if (paren_string[i] === '(')\
    \ {\n      parenArray.push(paren_string[i]);\n    } else if (paren_string[i] ===\
    \ ')') {\n      parenArray.push(paren_string[i]);\n    }\n  }\n  console.log(parenArray);\n\
    \  var longest = parenArray[0];\n  for (var j = 0; j < parenArray.length; j++)\
    \ {\n    if (parenArray[j].length > longest.length) {\n      longest = parenArray[j];\n\
    \    }\n  }\n  return longest.length;\n}\n", "\tlet paren_array = paren_string.split(\"\
    \ \");\n\tlet result = [];\n\tfor(let i = 0; i < paren_array.length; i++){\n\t\
    \tresult.push(depth_of_parens(paren_array[i]));\n\t}\n\treturn result;\n}\n",
  "    var paren_arr = paren_string.split(\" \");\n    var max_level = 0;\n    var\
    \ max_idx = 0;\n    for(var i = 0; i < paren_arr.length; i++){\n        var level\
    \ = 0;\n        for(var j = 0; j < paren_arr[i].length; j++){\n            if(paren_arr[i][j]\
    \ == \"(\"){\n                level++;\n            }\n            else if(paren_arr[i][j]\
    \ == \")\"){\n                level--;\n            }\n        }\n        if(level\
    \ > max_level){\n            max_level = level;\n            max_idx = i;\n  \
    \      }\n    }\n    return [max_level, max_idx];\n}\n", "  var max_parens = [];\n\
    \  var paren_indices = paren_string.split(' ');\n  // should be an array of strings\
    \ representing each of the groups\n  console.log(paren_indices);\n  // iterate\
    \ through paren_indices\n  for (var i = 0; i < paren_indices.length; i++){\n \
    \   var left_paren_count = 0;\n    var right_paren_count = 0;\n    // iterate\
    \ through each character in paren_indices[i]\n    for (var j = 0; j < paren_indices[i].length;\
    \ j++){\n      if (paren_indices[i][j] === '('){\n        left_paren_count +=\
    \ 1;\n      }\n      else if (paren_indices[i][j] === ')'){\n        right_paren_count\
    \ += 1;\n      }\n    }\n    // if number of left parentheses > right parens\n\
    \    if (left_paren_count > right_paren_count){\n      max_parens.push(left_paren_count);\n\
    \    }\n    else {\n      max_parens.push(right_paren_count);\n    }\n  }\n  console.log(max_parens);\n\
    \  return max_parens;\n}\n\nparse_nested_parens(\"(()()) ((())) () ((())()())\"\
    );", "    // paren_string.split(' ').map(paren_string => paren_string.split('').reduce((memo,\
    \ value) => {\n    //     if (value === '(') {\n    //         memo++;\n    //\
    \     } else if (value === ')') {\n    //         memo--;\n    //     }\n    //\
    \     return memo;\n    // }, 0))\n    var levels = [];\n    var level = 0;\n\
    \    var current = 0;\n    for (var i = 0; i < paren_string.length; i++) {\n \
    \       if (paren_string[i] === '(') {\n            level++;\n        } else if\
    \ (paren_string[i] === ')') {\n            level--;\n        } else if (paren_string[i]\
    \ === ' ') {\n            levels.push(level);\n            level = 0;\n      \
    \  }\n    }\n    return levels;\n}\n", "    let final_output = [];\n    let paren_array\
    \ = paren_string.split(\" \");\n    for(let i = 0; i < paren_array.length; i++){\n\
    \        let group = paren_array[i];\n        let max_nesting = 0;\n        let\
    \ current_nesting = 0;\n        for(let j = 0; j < group.length; j++){\n     \
    \       if(group[j] === \"(\"){\n                current_nesting += 1;\n     \
    \           if(current_nesting > max_nesting){\n                    max_nesting\
    \ = current_nesting;\n                }\n            }\n            else if(group[j]\
    \ === \")\"){\n                current_nesting -= 1;\n            }\n        }\n\
    \        final_output.push(max_nesting);\n    }\n    return final_output;\n}\n",
  "  var parens = paren_string.split(\" \");\n  var result = [];\n  for(var i = 0;\
    \ i < parens.length; i++){\n    var current = parens[i];\n    var temp = 0;\n\
    \    var max = 0;\n    for(var j = 0; j < current.length; j++){\n      if(current[j]\
    \ === \"(\"){\n        temp++;\n        if(temp > max){\n          max = temp;\n\
    \        }\n      }\n      else if(current[j] === \")\"){\n        temp--;\n \
    \     }\n    }\n    result.push(max);\n  }\n  return result;\n}\n", "    var result\
    \ = [];\n    var deep = 0;\n    var i;\n    var temp = 0;\n    var len = paren_string.length;\n\
    \    for(i = 0; i < len; i++){\n        if(paren_string[i] === '('){\n       \
    \     temp++;\n            if(temp > deep){\n                deep = temp;\n  \
    \          }\n        }\n        else if(paren_string[i] === ')'){\n         \
    \   temp--;\n        }\n        else if(paren_string[i] === ' '){\n          \
    \  result.push(deep);\n            deep = 0;\n            temp = 0;\n        }\n\
    \    }\n    result.push(deep);\n    return result;\n}\n", "    let result = [];\n\
    \    let paren_groups = paren_string.split(\" \");\n    for(let i = 0; i < paren_groups.length;\
    \ i++){\n        let startParenIndex = -1;\n        let maxNestingLevel = 0;\n\
    \        let currentNestingLevel = 0;\n        for(let j = 0; j < paren_groups[i].length;\
    \ j++){\n            if(paren_groups[i][j] === \"(\"){\n                if(startParenIndex\
    \ < 0){\n                    startParenIndex = j;\n                }\n       \
    \         currentNestingLevel++;\n                if(currentNestingLevel > maxNestingLevel){\n\
    \                    maxNestingLevel = currentNestingLevel;\n                }\n\
    \            }\n            else if(paren_groups[i][j] === \")\"){\n         \
    \       currentNestingLevel--;\n            }\n        }\n        result.push(maxNestingLevel);\n\
    \    }\n    return result;\n}\n", "    var parens = paren_string.split(' ');\n\
    \    var result = [];\n    var stack = [];\n    for(i = 0; i < parens.length;\
    \ i++){\n        for(j = 0; j < parens[i].length; j++){\n            var elem\
    \ = parens[i][j];\n            if(elem == '('){\n                stack.push(elem);\n\
    \            }\n            else if(elem == ')'){\n                stack.pop();\n\
    \            }\n        }\n        result.push(stack.length);\n        stack =\
    \ [];\n    }\n    return result;\n}", "    let paren_array = paren_string.split(\"\
    \ \");\n    let max_depth = 0;\n    let max_depth_list = [];\n    for(let i =\
    \ 0; i < paren_array.length; i++){\n        for(let j = 0; j < paren_array[i].length;\
    \ j++){\n            if(paren_array[i][j] === \"(\"){\n                max_depth\
    \ += 1;\n            }\n            else if(paren_array[i][j] === \")\"){\n  \
    \              max_depth_list.push(max_depth);\n                max_depth = 0;\n\
    \            }\n        }\n    }\n    return max_depth_list;\n}\n", "  return\
    \ paren_string.split(' ').map(parens => {\n    let max = 0, level = 0\n    parens.split('').forEach(paren\
    \ => {\n      if (paren === '(')\n        max = Math.max(++level, max)\n     \
    \ else\n        level--\n    })\n    return max\n  })\n}\n", "    return paren_string.split('\
    \ ').map(parse_parens);\n}\n", "    var paren_string_arr = paren_string.split(\"\
    \ \");\n    return paren_string_arr.map(function(item){\n        var count = 0;\n\
    \        var max_count = 0;\n        for(var i = 0; i < item.length; i++){\n \
    \           if(item[i] === \"(\"){\n                count++;\n               \
    \ if(count > max_count){\n                    max_count = count;\n           \
    \     }\n            }\n            else if(item[i] === \")\"){\n            \
    \    count--;\n            }\n        }\n        return max_count;\n    });\n}",
  "    var arr = paren_string.split(\" \");\n    var result = [];\n    for(var i =\
    \ 0; i < arr.length; i++){\n        var count = 0;\n        var str = arr[i];\n\
    \        for(var j = 0; j < str.length; j++){\n            if(str[j] == '('){\n\
    \                count++;\n            }\n            else if(str[j] == ')'){\n\
    \                count--;\n            }\n        }\n        result.push(count);\n\
    \    }\n    return result;\n}\n\n", "    let result = [];\n    let split_string\
    \ = paren_string.split(\" \");\n    //console.log(split_string);\n    let max_levels\
    \ = 0;\n    let count = 0;\n    for(let i = 0; i < split_string.length; i++){\n\
    \        for(let j = 0; j < split_string[i].length; j++){\n            //console.log(split_string[i][j]);\n\
    \            if(split_string[i][j] === \"(\"){\n                count += 1;\n\
    \            }\n            else if(split_string[i][j] === \")\"){\n         \
    \       count -= 1;\n            }\n            if(count > max_levels){\n    \
    \            max_levels = count;\n            }\n        }\n        result.push(max_levels);\n\
    \        max_levels = 0;\n        count = 0;\n    }\n    return result;\n}", "\t\
    var result = [];\n\tvar parens = paren_string.split(\" \");\n\tfor(var i = 0;\
    \ i < parens.length; i++){\n\t\tvar num_open = 0;\n\t\tvar max_level = 0;\n\t\t\
    for(var j = 0; j < parens[i].length; j++){\n\t\t\tif(parens[i][j] == \"(\"){\n\
    \t\t\t\tnum_open++;\n\t\t\t\tif(num_open > max_level){\n\t\t\t\t\tmax_level =\
    \ num_open;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(parens[i][j] == \")\"){\n\t\t\t\
    \tnum_open--;\n\t\t\t}\n\t\t}\n\t\tresult.push(max_level);\n\t}\n\treturn result;\n\
    }\n", "  let stack = [];\n  let split_string = paren_string.split(' ');\n  let\
    \ result = [];\n  for(let i = 0; i < split_string.length; i++){\n    let current_string\
    \ = split_string[i];\n    for(let j = 0; j < current_string.length; j++){\n  \
    \    if(current_string[j] === '('){\n        stack.push(current_string[j]);\n\
    \      }\n      else if(current_string[j] === ')'){\n        stack.pop();\n  \
    \    }\n    }\n    result.push(stack.length);\n    stack = [];\n  }\n  return\
    \ result;\n}", "    var paren_groups = paren_string.split(\" \");\n    var result\
    \ = [];\n    var level;\n    var max;\n    for(var i = 0; i < paren_groups.length;\
    \ i++){\n        level = 0;\n        max = 0;\n        for(var j = 0; j < paren_groups[i].length;\
    \ j++){\n            if(paren_groups[i][j] == \"(\"){\n                level++;\n\
    \                if(level > max){\n                    max = level;\n        \
    \        }\n            }\n            else if(paren_groups[i][j] == \")\"){\n\
    \                level--;\n            }\n        }\n        result.push(max);\n\
    \    }\n    return result;\n}\n\n", "    var parens_array = paren_string.split(\"\
    \ \");\n    var result = [];\n    for(var i = 0; i < parens_array.length; i++){\n\
    \        result.push(count_nested_parens(parens_array[i]));\n    }\n    return\
    \ result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
