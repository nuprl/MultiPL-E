name: HumanEval_49_modp
language: js
prompt: "//Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n\
  // >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n//\
  \ 8\n// >>> modp(100, 101)\n// 1\nfunction modp(n, p){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101,\
  \ 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3,\
  \ 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30,\
  \ 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"
completions: ["\tif(p == 0) return NaN;\n\tif(n == 0) return 1;\n\tvar m = (n % p)\
    \ % 2;\n\tif(m == 0) return 1;\n\telse return 2*modp(n, (p-1)/2) % p;\n}\n", " \
    \   //Calculate the length of the binary representation of the argument n\n  \
    \  let nlen = length(n);\n    //Actual result\n    let res = 1;\n    //Multiples\
    \ of 2^n in base p\n    let multiple = 1;\n    //We will perform the calculations\
    \ for all non-zero bits in n.\n    for(let i = 0; i < nlen; i++){\n        //If\
    \ bit i is set, multiply the result with the corresponding multiple.\n       \
    \ if(getbit(n, i)){\n            res = (res * multiple) % p;\n        }\n    \
    \    //Multiple = 2 * multiple % p\n        multiple = (multiple * 2) % p;\n \
    \   }\n    return res;\n}\n", "\tif(n < 0){\n\t\treturn -modp(-n, p);\n\t}\n\t\
    if(n == 0){\n\t\treturn 1;\n\t}else if(n % 2 == 0){\n\t\treturn modp(n / 2, p)\
    \ * modp(n / 2, p) % p;\n\t}else{\n\t\treturn modp(n / 2, p) * modp(n / 2, p)\
    \ * 2 % p;\n\t}\n}\n", "  if(n<=0) return 1;\n  else if(n==1) return 2;\n  else\
    \ if(n>=p) return modp(n%p, p);\n  else return (2*modp(n-1, p))%p;\n}\n", "\t\
    var result = 1;\n\twhile(n>0){\n\t\tresult = (result*2)%p;\n\t\tn--;\n\t}\n\t\
    return result;\n}\n\n\n", "    var result = 1;\n    while (n > 0){\n        if\
    \ (n & 1) //n is odd\n            result = (result * 2) % p;\n        n >>= 1;\n\
    \    }\n    return result;\n}\n", "\tif(typeof n === 'undefined' || typeof p ===\
    \ 'undefined')\n\t\tthrow Error('Arguments of modp(n, p) are missing');\n\tif(!Number.isInteger(n)\
    \ || !Number.isInteger(p))\n\t\tthrow Error('Arguments of modp(n, p) must be integers');\n\
    \tif(p < 1)\n\t\tthrow Error('p must be a positive integer');\n\tif(n < 0)\n\t\
    \tthrow Error('n must be a non-negative integer');\n\tif(n == 0)\n\t\treturn 1;\n\
    \tif(n == 1)\n\t\treturn n;\n\tif(n == 2)\n\t\treturn n % p;\n\tif(n % 2 == 0)\n\
    \t\treturn modp(n / 2, p) * modp(2, p) % p;\n\telse\n\t\treturn modp(n - 1, p)\
    \ * modp(2, p) % p;\n}\n", "    var result = 1;\n    while (n){\n        if (n\
    \ & 1)\n            result = (result * 2) % p;\n        n >>= 1;\n    }\n    return\
    \ result;\n}\n", "    n = n.toString(2);\n    var output = 1;\n    for(var i =\
    \ 0; i < n.length; i++){\n        if(n[i] === '1'){\n            output = (output\
    \ * 2) % p;\n        }\n        output = (output * output) % p;\n    }\n    return\
    \ output;\n}\n", "    return bigint(2).pow(n).mod(p).toJSNumber();\n}\n", "  \
    \  if(n===0){\n        return 1;\n    }\n    var a = n;\n    var b = p;\n    var\
    \ r = Math.floor(a / b);\n    var s = a - r * b;\n    while(r !== 0){\n      \
    \  a = b;\n        b = s;\n        r = Math.floor(a / b);\n        s = a - r *\
    \ b;\n    }\n    var t = p/b;\n    var f = [];\n    var q = [];\n    var x0 =\
    \ 0;\n    var x1 = 1;\n    var r0 = 0;\n    var r1 = 1;\n    var q0 = 0;\n   \
    \ var q1 = 0;\n    var i = 0;\n    var j = 0;\n    f[0] = 0;\n    f[1] = 1;\n\
    \    q[0] = 0;\n    q[1] = 0;\n    while(true){\n        r0 = r1;\n        r1\
    \ = a - q1 * b;\n        q0 = q1;\n        q1 = Math.floor(a / b);\n        x0\
    \ = x1;\n        x1 = f[i] - q[i] * f[i+1];\n        f[i+2] = x1;\n        q[i+2]\
    \ = q1;\n        i = i + 1;\n        if(r1 === 0){\n            break;\n     \
    \   }\n    }\n    if(n >= 0){\n        return f[i] % t;\n    }\n    else{\n  \
    \      if(f[i]<0){\n            return f[i] + t;\n        }\n        else{\n \
    \           return -f[i] + t;\n        }\n    }\n}\n", "  if(p == 2) return 1;\n\
    \  if(n == 0) return 1;\n  if(n == 1) return 2;\n  if(n % 2 == 0) return modp(n/2,\
    \ p) * modp(n/2, p) % p;\n  return modp(n/2, p) * modp(n/2, p) * 2 % p;\n}\n",
  "    var v = 1;\n    var v2 = 1;\n    while (n > 0){\n        if (n % 2 == 1){\n\
    \            v = (v * v2) % p;\n        }\n        v2 = (v2 * v2) % p;\n     \
    \   n = n >> 1;\n    }\n    return v;\n}\n", "    if(p < 1)\n        return -1;\n\
    \n    if(n < 0){\n        return -1;\n    }\n\n    // initialize r to 1 (2^0 mod\
    \ p = 1)\n    var r = 1;\n\n    // initialize the exponent mask to 1\n    var\
    \ mask = 1;\n\n    // while there are more bits in the exponent\n    while(mask\
    \ <= n){\n        // if the exponent contains a 1 in this place\n        if((n\
    \ & mask) !== 0){\n            // multiply r by 2^k mod p\n            r = (r\
    \ * 2) % p;\n        }\n\n        // move to the next bit\n        mask = mask\
    \ << 1;\n    }\n\n    return r;\n}\n", "\tvar m = 1;\n\twhile(n > 0){\n\t\tif(n\
    \ % 2 == 1){\n\t\t\tm = (m * 2) % p;\n\t\t}\n\t\tn = Math.floor(n / 2);\n\t}\n\
    \treturn m;\n}\n", "  // your code here\n  let result = 1;\n  for (let i = 0;\
    \ i < n; i++) {\n    result = result * 2 % p;\n  }\n  return result;\n}\n", " \
    \   if(n === 0){\n        return 1;\n    }\n    if(n % 2 === 0){\n        return\
    \ modp(n / 2, p) ** 2 % p;\n    }else{\n        return (modp(n - 1, p) * 2) %\
    \ p;\n    }\n}\n", "    var x = 1;\n    var y = n % p;\n    while (n > 0){\n \
    \       if (n % 2 != 0){\n            x = (x * y) % p;\n        }\n        y =\
    \ (y * y) % p;\n        n = Math.floor(n / 2);\n    }\n    return x;\n}\n", " \
    \   var nn = 1;\n    for(var i = 0; i < n; i++){\n        nn = (nn * 2) % p;\n\
    \    }\n    return nn;\n}\n", "    if(p <= 0) return 1;\n    if(n == 0) return\
    \ 1;\n    if(n % 2 == 0) return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\
    \ return (2 * modp(n / 2, p) * modp(n / 2, p)) % p;\n}\n", "\t// >>> modp(100,\
    \ 101)\n\t// 1\n\tvar res = Math.pow(2, n) % p;\n\treturn res;\n}\n", "    if(n==0){\n\
    \        return 1;\n    }\n    if(n%2==0){\n        var y = modp(n/2, p);\n  \
    \      return (y*y)%p;\n    }else{\n        var y = modp((n-1)/2, p);\n      \
    \  return (y*y*n)%p;\n    }\n}", "  var num = n % p;\n  if (num < 0) {\n    num\
    \ += p;\n  }\n  return num;\n}\n", "\tif(p == 1){\n\t\treturn 0;\n\t}\n\tvar result\
    \ = 1;\n\tfor(var i = 0; i < n; i++){\n\t\tresult = (result * 2) % p;\n\t}\n\t\
    return result;\n}\n", "\tif(p == 0) return 0;\n\tif(n == 0) return 1;\n\tif(n\
    \ % 2 == 0){\n\t\t// n/2 mod p = n mod 2 * n/2 mod p\n\t\t// modp(n/2, p) = modp(n,\
    \ p) * modp(n/2, p)\n\t\treturn modp(n/2, p) * modp(n/2, p) % p;\n\t}\n\telse{\n\
    \t\t// n mod p = n-1 mod p * n mod p\n\t\t// modp(n, p) = modp(n-1, p) * modp(n,\
    \ p)\n\t\treturn modp(n-1, p) * modp(n, p) % p;\n\t}\n}\n", "    if(p==0){\n \
    \       return 1;\n    }\n    if(n==0){\n        return 1;\n    }\n    if(n%2\
    \ == 0){\n        return Math.pow(modp(n/2, p), 2) % p;\n    }else{\n        return\
    \ Math.pow(modp((n-1)/2, p), 2) * 2 % p;\n    }\n}\n", "    //your code here\n\
    \    return -1;\n}\n", "\tvar ret = 1;\n\twhile(n > 0){\n\t\tif(n % 2 == 1){\n\
    \t\t\tret = (ret * 2) % p;\n\t\t}\n\t\tn = n >> 1;\n\t}\n\treturn ret;\n}\n",
  "    if(p === 0){\n        return -1;\n    }\n    return n % p;\n}", "  var x =\
    \ 1, y = n;\n  while (p > 0) {\n    if (p % 2 == 1) {\n      x = (x * y) % 101;\n\
    \    }\n    y = (y * y) % 101;\n    p = p >> 1;\n  }\n  return x;\n}\n", "  if(\
    \ n < 0 ) n = n + p;\n  var result = 1;\n  var base = 2;\n  var exp = n;\n  while(exp\
    \ > 0){\n    var isOdd = exp % 2 == 1;\n    exp = Math.floor(exp / 2);\n    if(isOdd){\n\
    \      result = (result * base) % p;\n    }\n    base = (base * base) % p;\n \
    \ }\n  return result;\n}\n\n", "\t\n}\n", "\tvar s = [1,n%p];\n\tn >>>= 1;\n\t\
    while(n){\n\t\ts.push((s[s.length-1] * s[s.length-1]) % p);\n\t\tif(n%2){\n\t\t\
    \ts.push((s[s.length-1] * s[1]) % p);\n\t\t}\n\t\tn >>>= 1;\n\t}\n\treturn s[s.length-1];\n\
    }\n\n", "\tvar res = 1,\n\t\ti = 0;\n\tfor(; i < n; i++){\n\t\tres = (res * 2)\
    \ % p;\n\t}\n\treturn res;\n}\n", "\tif(n < 0) n = n + Math.floor(-n/p) * p;\n\
    \treturn Math.pow(2, n) % p;\n}\n", "\tvar res = 1;\n\tvar a = 2;\n\twhile(n){\n\
    \t\tif(n & 1){\n\t\t\tres = res * a % p;\n\t\t}\n\t\ta = a * a % p;\n\t\tn >>=\
    \ 1;\n\t}\n\treturn res;\n}\n", "\tif(n == 0) return 1;\n\tif(n == 1) return n\
    \ % p;\n\tif(n % 2 == 0){\n\t\tvar x = modp(n/2, p);\n\t\treturn (x*x) % p;\n\t\
    }\n\telse{\n\t\tvar x = modp((n-1)/2, p);\n\t\treturn (2*x*x) % p;\n\t}\n}\n",
  "    if(n == 0){\n        return 1;\n    }\n    if(n % 2 == 0){\n        return\
    \ Math.pow(modp(n/2, p), 2) % p;\n    }\n    else{\n        return (2 * modp(n\
    \ - 1, p)) % p;\n    }\n}\n", "  if(p == 2) {\n    return n % 2;\n  }\n  if(n\
    \ % 2 == 0) {\n    return (2 * modp(n/2, p)) % p;\n  }\n  else {\n    return (2\
    \ * modp(n/2, p) + 1) % p;\n  }\n}\n", "\tlet r = 1;\n\tn = n % p;\n\twhile (n\
    \ > 0){\n\t\tif (n & 1)\n\t\t\tr = (r * 2) % p;\n\t\tn >>= 1;\n\t}\n\treturn r;\n\
    }\n", "  var t = n;\n  var a = 1;\n  while(t > 0){\n    if(t & 1){\n      a =\
    \ (a * n) % p;\n    }\n    t = t >> 1;\n    n = (n * n) % p;\n  }\n  return a;\n\
    }\n", "  if(n === 0){\n    return 1;\n  }\n  if(n % 2 === 0){\n    return modp(n/2,\
    \ p) ** 2 % p;\n  }\n  return modp(n-1, p) * modp(n+1, p) % p;\n}\n", "\tif(p\
    \ == 1)\n\t\treturn 0;\n\tif(n == 0)\n\t\treturn 1;\n\t\n\tvar z = modp(Math.floor(n/2),\
    \ p);\n\tz = (z*z) % p;\n\tif(n % 2 == 1)\n\t\tz = (z*2) % p;\n\treturn z;\n}\n",
  "  var t = 1;\n  for(var i = 1; i <= n; i++){\n    t = (t * 2) % p;\n  }\n  return\
    \ t;\n}\n\n", "    if(n === 0){\n        return 1;\n    }else if(n === 1){\n \
    \       return n;\n    }else{\n        return (modp(n/2, p)**2) % p;\n    }\n\
    }\n", "    return expmod(2, n, p);\n}\n", "\tn = mod(n, p);\n\tvar result = 1;\n\
    \tfor(var i = 0; i < n; i++){\n\t\tresult = mod(result * 2, p);\n\t}\n\treturn\
    \ result;\n}\n", "  if(n == 0){\n    return 1;\n  }\n  if(n % 2 == 0){\n    var\
    \ tmp = modp(n/2, p);\n    return tmp * tmp % p;\n  }\n  else{\n    return n *\
    \ modp(n-1, p) % p;\n  }\n}\n", "  if(n === 0){\n    return 1;\n  }\n  if(n %\
    \ 2 === 0){\n    return Math.pow(modp(n/2, p), 2) % p;\n  }\n  return (Math.pow(modp((n-1)/2,\
    \ p), 2) * modp(1, p)) % p;\n}\n", "  // TODO\n  return Math.pow(2, n) % p;\n\
    }\n", "    if(n < p){\n        return n;\n    }\n    if(n === 0){\n        return\
    \ 1;\n    }\n    if(n % 2 === 0){\n        return Math.pow(modp(n/2, p), 2) %\
    \ p;\n    }\n    return (modp(n - 1, p) * 2) % p;\n}\n", "  let res = 1;\n  for(let\
    \ i = 1; i <= n; i++){\n    res = (res * 2) % p;\n  }\n  return res;\n}\n", " \
    \   if(p === 1) return 0;\n\n    let exp = n;\n    let two_exp = 1;\n    while(exp\
    \ > 1){\n        two_exp = (two_exp * 2) % p;\n        exp--;\n    }\n    return\
    \ two_exp;\n}\n", "  if(n===0){\n    return 1;\n  }\n  if(p===1){\n    return\
    \ 0;\n  }\n  if(n<0){\n    return p-modp(-n, p);\n  }\n  if(n%2===0){\n    return\
    \ modp(n/2, p)*modp(n/2, p)%p;\n  }\n  return modp(n-1, p)*n%p;\n}\n", "    return\
    \ n%p;\n}", "    if(n === 0){\n        return 1;\n    }\n    if(n % 2 === 0){\n\
    \        return modp(n / 2, p) ** 2 % p;\n    }\n    else{\n        return (modp(n\
    \ / 2, p) ** 2 % p) * 2 % p;\n    }\n}\n", "    if(p == 1)\n        return 0;\n\
    \    return Math.pow(2, n) % p;\n}\n", "  if(n===0){\n    return 1;\n  }\n  else\
    \ if(n%2===0){\n    return ((modp(n/2, p))**2)%p;\n  }\n  else{\n    return ((2%p)*(modp((n-1)/2,\
    \ p))**2)%p;\n  }\n}\n", "\tif(p == 1)\n\t\treturn 0;\n\tif(n == 0)\n\t\treturn\
    \ 1;\n\tif(n == 1)\n\t\treturn n;\n\tvar result = 1;\n\twhile(n > 0){\n\t\tif(n\
    \ & 1)\n\t\t\tresult = (result * 2) % p;\n\t\tn = n >> 1;\n\t}\n\treturn result;\n\
    }\n", "    if(n === 0){\n        return 1;\n    }\n    if(n % 2 === 0){\n    \
    \    var r = modp(n/2, p);\n        return r*r % p;\n    }\n    return (modp(n-1,\
    \ p) * n) % p;\n}\n", "  if(p == 0){\n    return NaN;\n  }\n\n  if(n == 0){\n\
    \    return 1;\n  }\n\n  if(n < 0){\n    return NaN;\n  }\n\n  n = n % p;\n\n\
    \  var result = 1;\n  for(var i = 0; i < n; i++){\n    result = (result * 2) %\
    \ p;\n  }\n\n  return result;\n}\n", "    if(n === 0){\n        return 1;\n  \
    \  }\n    if(n % 2 === 0){\n        return Math.pow(modp(n/2, p), 2) % p;\n  \
    \  }\n    else{\n        return (2 * modp(n - 1, p)) % p;\n    }\n}\n\n", "  if(n\
    \ === 0){\n    return 1;\n  }\n  if(n % 2 === 0){\n    return Math.pow(modp(n/2,\
    \ p), 2) % p;\n  }\n  return (n % p) * modp((n-1)/2, p) % p;\n}\n", "\tif(p ===\
    \ 0){\n\t\treturn 1;\n\t}\n\n\tvar r = modp(n, Math.floor(p/2));\n\tr = (r * r)\
    \ % p;\n\n\tif(p % 2 === 1){\n\t\tr = (r * n) % p;\n\t}\n\n\treturn r;\n}\n",
  "    if(n === 0){\n        return 1;\n    } else if(n === 1){\n        return 2;\n\
    \    }\n    if(n%2 === 0){\n        return Math.pow(modp(n/2, p), 2) % p;\n  \
    \  } else {\n        return (2 * modp(n-1, p)) % p;\n    }\n}\n", "    var result\
    \ = 1;\n    while (n > 0){\n        if (n % 2 == 1){\n            result = (result\
    \ * a) % p;\n        }\n        n = n >> 1;\n        a = (a * a) % p;\n    }\n\
    \    return result;\n}\n", "    var ans = 1;\n    for(var i = 0; i < n; i++){\n\
    \        ans = (ans * 2) % p;\n    }\n    return ans;\n}\n", "    if(n==0){\n\
    \        return 1;\n    }else if(n % 2 == 0){\n        return modp(n / 2, p)**2\
    \ % p;\n    }else{\n        return (2 * modp(n / 2, p)**2) % p;\n    }\n}\n",
  "    var a = 1;\n    for(var i = 0; i < n; i++){\n        a = (a * 2) % p;\n   \
    \ }\n    return a;\n}\n", "  var i, s;\n  var r = n % p;\n  for (i = 0; i < n;\
    \ i++){\n    r = (r * 2) % p;\n  }\n  return r;\n}\n", "\tvar c = 1;\n\tfor(var\
    \ i = 0; i < n; i++){\n\t\tc = (c * 2) % p;\n\t}\n\treturn c;\n}\n", "  if(n ===\
    \ 0){\n    return 1;\n  }\n  if(n % 2 === 0){\n    return modp(n / 2, p) * modp(n\
    \ / 2, p) % p;\n  }\n  return n * modp(n - 1, p) % p;\n}\n", "\tvar c = 1;\n\t\
    while(n--){\n\t\tc = c * 2 % p;\n\t}\n\treturn c;\n}\n", "\tn = n%p;\n\tif(n ===\
    \ 0) return 1;\n\tvar a = modp(n-1, p);\n\treturn (a*n)%p;\n}\n", "    var res\
    \ = 1;\n    for(i = 0; i < n; i++){\n        res = (res * 2) % p;\n    }\n   \
    \ return res;\n}\n", "\tif(n == 0) return 1;\n\tif(n == 1) return 2;\n\t//Calculate\
    \ n/2\n\tvar nh = Math.floor(n/2);\n\t//Calculate sqrt(2)^nh mod p using divide\
    \ & conquer.\n\tvar a = modp(nh, p);\n\t//Calculate 2 * sqrt(2)^nh mod p (using\
    \ remainder)\n\tvar b = (a*a) % p;\n\t//Calculate sqrt(2)^n mod p (using modulo)\n\
    \tif(n % 2 == 0) return b;\n\telse return (2*b) % p;\n}\n", "  if(n == 0){\n \
    \   return 1;\n  } else if(n == 1){\n    return n % p;\n  } else {\n    var n1\
    \ = modp(n/2, p);\n    var n2 = modp(n/2, p);\n    if(n % 2 == 0){\n      return\
    \ (n1 * n2) % p;\n    } else {\n      return ((n1 * n2) * 2) % p;\n    }\n  }\n\
    }\n", "  var power = 1;\n  for(var i = 0; i < n; i++){\n    power = 2 * power\
    \ % p;\n  }\n  return power;\n}\n", "    var result = 1;\n    for (var i = 0;\
    \ i < n; i++){\n        result = (result * 2) % p;\n    }\n    return result;\n\
    }\n", "    var result = 1;\n    while (n>0){\n        result = (result*2)%p;\n\
    \        n=n-1;\n    }\n    return result;\n}\n", "    return Math.pow(2, n) %\
    \ p;\n}\n", "\tif(n == 0)\n\t\treturn 1;\n\tif(n % 2 == 0)\n\t\treturn Math.pow(modp(n/2,\
    \ p), 2) % p;\n\telse\n\t\treturn (2 * modp(n-1, p)) % p;\n}\n", "\t\n\tif(n ==\
    \ 0){\n\t\treturn 1;\n\t}\n\telse if(n == 1){\n\t\treturn 2;\n\t}\n\t\n\t//Number\
    \ of bits\n\tvar numBits = Math.floor(Math.log(n) / Math.log(2)) + 1;\n\t\n\t\
    //Initialize an array to store all powers of 2 modulo p\n\tvar powers = [];\n\t\
    powers[0] = 2;\n\tfor(var i = 1; i < numBits; i++){\n\t\tpowers[i] = (powers[i\
    \ - 1] * powers[i - 1]) % p;\n\t}\n\t\n\t//Calculate the answer by summing up\
    \ 2^i modulo p\n\tvar ans = 1;\n\tfor(var i = 0; i < numBits; i++){\n\t\tvar temp\
    \ = Math.pow(2, i);\n\t\t\n\t\tif(temp <= n){\n\t\t\tans = (ans * powers[i]) %\
    \ p;\n\t\t}\n\t}\n\t\n\treturn ans;\n}\n", "\t\n}\n", "  var r = 1;\n  for(var\
    \ i = 0; i < n; i++){\n    r = (r * 2) % p;\n  }\n  return r;\n}\n", "  var result\
    \ = 1;\n  var base = 2;\n  while (n > 0){\n    if (n%2 != 0){\n      result =\
    \ (result * base) % p;\n    }\n    n = Math.floor(n/2);\n    base = (base * base)\
    \ % p;\n  }\n  return result;\n}\n", "  return Math.pow(2, n) % p;\n}\n", "  if(n\
    \ === 0){\n    return 1;\n  } else if(n % 2 === 0){\n    return modp(n / 2, p)\
    \ ** 2 % p;\n  } else{\n    return (modp(n - 1, p) * modp(1, p)) % p;\n  }\n}\n\
    \n", "    if(n==0){\n        return 1;\n    }\n    var x = modp(n>>1, p);\n  \
    \  x = x*x % p;\n    if(n%2){\n        x = x*2 % p;\n    }\n    return x;\n}\n",
  "\tvar modn = powmod(2, n, p);\n\treturn modn;\n}\n", "    if(n < 0){\n        return\
    \ p - modp(-n, p);\n    }\n    if(n < p){\n        return n;\n    }\n    if(n\
    \ % p === 0){\n        return 0;\n    }\n    while(n > p){\n        n -= p;\n\
    \    }\n    return n;\n}\n", "  if(n === 0){\n    return 1;\n  }\n  if(n % 2 ===\
    \ 0){\n    return modp(n/2, p)**2 % p;\n  } else {\n    return modp(n-1, p) *\
    \ modp(n, p) % p;\n  }\n}\n", "    if(p == 0) throw \"p cannot be 0\";\n    if(n\
    \ == 0) return 1;\n    var b = 0;\n    while(n%2 == 0){\n        n = n/2;\n  \
    \      b++;\n    }\n    var c = Math.pow(2, b);\n    var a = n;\n    var mod =\
    \ (Math.pow(a,c))%p;\n    return mod;\n}\n", "\tlet pow = 1;\n\tlet res = 1;\n\
    \twhile(pow <= n){\n\t\tif(pow & n)\n\t\t\tres = (res * res) % p;\n\t\tpow = pow\
    \ << 1;\n\t}\n\treturn res;\n}\n", "\t// Initialize r = 2^n mod p.\n\t// Compute\
    \ the result by multiplying by 2 and taking the modulo at each step.\n\t//\t>>>\
    \ r = 1\n\t//\t>>> for i in range(n):\n\t//\t...\t\tr = (r * 2) % p\n\t//\t...\n\
    \t//\t>>> r\n\t//\t8\n\t//\t>>> r = 1\n\t//\t>>> for i in range(n):\n\t//\t...\t\
    \tr = (r * 2) % p\n\t//\t...\t\tprint r\n\t//\t2\n\t//\t4\n\t//\t8\n\t//\t6\n\t\
    //\t2\n\t//\t4\n\t//\t8\n\t//\t6\n\tvar r = 1;\n\tfor(var i = 0; i < n; i++){\n\
    \t\tr = (r * 2) % p;\n\t}\n\treturn r;\n}\n", "    let t = 1;\n    let pow = 2;\n\
    \    let last_bit = n % 2;\n    n = n >> 1;\n    while(n > 0){\n        if(n %\
    \ 2 == 1){\n            t = (t * pow) % p;\n        }\n        pow = (pow * pow)\
    \ % p;\n        n = n >> 1;\n    }\n    return (t * last_bit) % p;\n}\n", "  if(n===0){\n\
    \    return 1;\n  }\n  if(n===1){\n    return 2%p;\n  }\n  var x = modp(Math.floor(n/2),\
    \ p);\n  var y = Math.pow(x, 2)%p;\n  if(n%2===0){\n    return y;\n  }else{\n\
    \    return 2*y%p;\n  }\n}\n", "    if(n < p){\n        return n;\n    }\n   \
    \ if(n % 2 == 0){\n        return modp(n/2, p)**2 % p;\n    }\n    else{\n   \
    \     return modp(n-1, p) * modp(n, p) % p;\n    }\n}\n", "    if(!check(n)){\n\
    \        return 0;\n    }\n    if(!check(p)){\n        return 0;\n    }\n    if(n==0){\n\
    \        return 1;\n    }\n    if(n%2==0){\n        return (2*modp(Math.floor(n/2),\
    \ p))%p;\n    }\n    else{\n        return (2*modp(Math.floor(n/2), p)*modp(1,\
    \ p))%p;\n    }\n}\n", "    //TODO\n    if(n==0){\n    \treturn 1;\n    }\n  \
    \  else{\n    \tif(n%2==0){\n    \t\treturn Math.pow(modp(n/2,p),2)%p;\n    \t\
    }\n    \telse{\n    \t\treturn Math.pow(modp(n/2,p),2)*2%p;\n    \t}\n    }\n\
    }\n", "    //TODO\n\t\n\tvar answer = Math.pow(2, n)%p;\n\t\n\treturn answer;\n\
    }\n", "  var r = 1;\n  while (n > 0){\n    if (n & 1 == 1) {\n      r = (r * base)\
    \ % p;\n    }\n    base = (base * base) % p;\n    n >>= 1;\n  }\n  return r;\n\
    }\n", "\t// TODO: to be implemented\n\tvar r;\n\tr = 1;\n\twhile(n > 0){\n\t\t\
    r = (r * 2) % p;\n\t\tn = n - 1;\n\t}\n\treturn r;\n}\n", "\tlet result = 1;\n\
    \tfor(let i = 0; i < n; i++){\n\t\tresult = (result * 2) % p;\n\t}\n\treturn result;\n\
    }\n", "    var res = 1;\n    var exp = n % (p-1);\n    if (exp < 0) exp += p-1;\n\
    \    for (var i = 0; i < n; i++)\n        res = (res * exp) % p;\n    return res;\n\
    }\n", "  if(n == 0){\n    return 1;\n  } else if(n % 2 == 0){\n    return modp(n\
    \ / 2, p) * modp(n / 2, p) % p;\n  } else {\n    return modp(n / 2, p) * modp(n\
    \ / 2, p) * 2 % p;\n  }\n}", "\tvar nlz = n.leadingZeros();\n\tvar res = BigInteger.ONE;\n\
    \twhile(nlz--){\n\t\tres = res.times(res).mod(p);\n\t}\n\tvar mask = BigInteger.ONE.shiftLeft(n.bitLength()).subtract(BigInteger.ONE);\n\
    \tvar rem = n.and(mask);\n\twhile(rem.compareTo(BigInteger.ZERO) != 0){\n\t\t\
    rem = rem.subtract(BigInteger.ONE);\n\t\tres = res.times(res).mod(p);\n\t\tif(rem.testBit(0)){\n\
    \t\t\tres = res.times(2).mod(p);\n\t\t}\n\t}\n\treturn res;\n}", "    var y =\
    \ 1;\n    var x = 2;\n    while (n > 0){\n        while (n % 2 == 0){\n      \
    \      n = (n / 2) | 0;\n            x = (x * x) % p;\n        }\n        n =\
    \ n - 1;\n        y = (x * y) % p;\n    }\n    return y;\n}\n\n", "    if(n===0){\n\
    \treturn 1;\n    }\n    if(n===1){\n\treturn 2;\n    }\n    if(n===2){\n\treturn\
    \ 4;\n    }\n    if(n===3){\n\treturn 8;\n    }\n    return modp(n-1, p)*2%p;\n\
    }\n", "  if(n < p) return n;\n  return modp(n%p, p);\n}\n\n", "\treturn 2;\n}\n\
    \n", "    if(!isInt(n) || !isInt(p)){\n        throw \"modp: n and p must be integers.\"\
    ;\n    }\n    if(p === 0){\n        throw \"modp: p cannot be 0.\";\n    }\n \
    \   if(n === 0){\n        return 1;\n    }\n    var nExponent = n % p;\n    if(nExponent\
    \ < 0){\n        nExponent += p;\n    }\n    return nExponent;\n}\n", "\tif(n\
    \ < 0) throw Error(\"Negative exponent. Unsupported.\")\n\tif(n == 0) return 1\n\
    \treturn (modp(n/2, p) * modp(n/2, p) * modp(n%2, p)) % p\n}\n", "  if( n < 0){\n\
    \    n = n % p + p;\n  }\n  // compute 2^n modulo p\n  var exponent = new BigInteger(1);\n\
    \  for(var i = 0; i < n; i++){\n    exponent = exponent.multiply(new BigInteger(2));\n\
    \  }\n  var modulo = exponent.mod(new BigInteger(p));\n  return modulo.toJSValue();\n\
    }\n\n", "    var ret = 1;\n    while(n>0){\n        if(n & 1){\n            ret\
    \ = (ret * n) % p;\n        }\n        n = n >> 1;\n        n = (n * n) % p;\n\
    \    }\n    return ret;\n}\n", "    if(n == 0){\n        return 1;\n    }\n  \
    \  if(n % 2 == 0){\n        return Math.pow(modp(n/2, p), 2) % p;\n    }\n   \
    \ else{\n        return modp(n - 1, p) * modp(1, p) % p;\n    }\n}\n", "    var\
    \ res = 1;\n    for(var i = 0; i < n; i++){\n        res = (res * 2) % p;\n  \
    \  }\n    return res;\n}\n", "    if(n == 0){\n        return 1;\n    }else if(n\
    \ == 1){\n        return n % p;\n    }else{\n        if(n % 2 == 0){\n       \
    \     return modp(n / 2, p) ** 2 % p;\n        }else{\n            return modp(n\
    \ / 2, p) ** 2 % p * n % p;\n        }\n    }\n}\n", "    return (n*n)%p;\n}\n",
  "    // Check for errors\n    if(n < 0){\n        return \"Please provide a non-negative\
    \ input\";\n    }\n    if(p < 0){\n        return \"Please provide a non-negative\
    \ input\";\n    }\n    if(p == 0){\n        return \"Please provide a non-zero\
    \ modulus\";\n    }\n    if(p == 1){\n        return 0;\n    }\n    // Write code\
    \ here\n    var num = 1;\n    while(n > 0){\n        if(n % 2 == 1){\n       \
    \     num = (num * 2) % p;\n        }\n        n = n / 2;\n    }\n    return num;\n\
    }\n", "    // Your code here\n    let result = 1;\n    let prime = p;\n    let\
    \ power = n;\n    while (power > 0) {\n        if (power & 1) {\n            result\
    \ = (result * prime) % p;\n        }\n        power = power >> 1;\n        prime\
    \ = (prime * prime) % p;\n    }\n    return result;\n}\n", "  return bigInt(2).pow(n).mod(p);\n\
    }\n", "    var result = 1;\n    var nn = n;\n    while (n > 0){\n        if (n\
    \ % 2 == 1){\n            result = (result * nn) % p;\n        }\n        nn =\
    \ (nn * nn) % p;\n        n = Math.floor(n / 2);\n    }\n    return result;\n\
    }\n", "  if(n === 0){\n    return 1;\n  }\n  else{\n    return Math.pow(2, n)\
    \ % p;\n  }\n}\n", "  var i,\n      result = 1;\n  for (i = 0; i < n; i++){\n\
    \    result = (result * 2) % p;\n  }\n  return result;\n}\n", "    if(p < 2) return\
    \ 1;\n    if(n < 2) return n;\n    if(n%2 == 0)\n        return (modp(n/2, p)\
    \ ** 2) % p;\n    else\n        return (modp(n/2, p) ** 2 * 2) % p;\n}\n", " \
    \   if(n<0){\n        n = n+p*((Math.abs(n)/p)|0)+p;\n    }\n    return n%p;\n\
    }\n", "    if(n == 0){\n        return 1;\n    }\n    if(n % 2 == 0){\n      \
    \  return modp(Math.pow(n, 2), p);\n    }\n    else{\n        return (n % p) *\
    \ modp(n, p);\n    }\n}\n", "    return n%p;\n}\n", "\tvar val = 1;\n\tfor(var\
    \ i = 0; i < n; i++){\n\t\tval = (val * 2) % p;\n\t}\n\treturn val;\n}\n", " \
    \ var res = 1;\n  for(var i = 0; i < n; i++){\n    res = (res * 2) % p;\n  }\n\
    \  return res;\n}\n", "    var pow = n%p;\n    var result = 1;\n    var i = 0;\n\
    \    while(i < n){\n        result = (result*pow)%p;\n        i++;\n    }\n  \
    \  return result;\n}\n", "    var result = 1;\n    if (n == 0) return 1;\n   \
    \ else{\n        for (var i = 0; i < n; i++){\n            result = (result *\
    \ 2) % p;\n        }\n    }\n    return result;\n}\n", "\tif(n == 0)\n\t\treturn\
    \ 1;\n\telse if(n == 1)\n\t\treturn 2;\n\telse{\n\t\tvar aux = modp(n - 1, p);\n\
    \t\treturn Math.pow(2, aux) % p;\n\t}\n}\n", "  if(n < 0)\n    return p - modp(-n,\
    \ p);\n  if(n % 2 == 0)\n    return Math.pow(modp(n/2, p), 2) % p;\n  return (Math.pow(modp(n/2,\
    \ p), 2) * 2) % p;\n}\n", "\tif(p <= 0) throw new Error(\"modp: p must be positive\"\
    );\n\tif(n <= 0) return 1;\n\tif(n == 1) return 1;\n\tif(n % 2 == 0) return Math.pow(modp(n/2,\
    \ p), 2) % p;\n\telse return (Math.pow(modp((n-1)/2, p), 2) * 2) % p;\n}\n\nvar\
    \ toint = exports.toint = function toint(n){\n\tvar result = 0;\n\tvar digits\
    \ = String(n).split('');\n\tvar exp = digits.length - 1;\n\tfor(var i = 0; i <\
    \ digits.length; i++){\n\t\tresult += parseInt(digits[i]) * Math.pow(10, exp -\
    \ i);\n\t}\n\treturn result;\n}\n", "    n = n % p;\n    var k = 0;\n    var nn\
    \ = 1;\n    var nk = 1;\n    while (k < n) {\n        nk = (nk * 2) % p;\n   \
    \     nn = (nn + nk) % p;\n        k = k + 1;\n    }\n    return nn;\n}\n\n",
  "  if(n==0){\n    return 1;\n  } else {\n    var r = modp(Math.floor(n/2), p);\n\
    \    r = r*r % p;\n    if(n%2==1){\n      r = r*2 % p;\n    }\n    return r;\n\
    \  }\n}\n", "\tvar num = 1;\n\tfor(var i = 0; i < n; i++){\n\t\tnum = num * 2;\n\
    \t\tif(num >= p){\n\t\t\tnum = num % p;\n\t\t}\n\t}\n\treturn num;\n}\n", "  \
    \  return Math.pow(2, n) % p;\n}\n", "    return pow(2, n, p);\n}\n", "\tif(n\
    \ === 0) return 1;\n\tif(n === 1) return 2;\n\treturn Math.pow(2, n % (p - 1))\
    \ % p;\n}\n", "\t\n}\n", "  let ans = 1;\n  for(let i = 0; i < n; i++){\n    ans\
    \ = (ans * 2) % p;\n  }\n  return ans;\n}\n\n", "    if(n === 0){\n        return\
    \ 1;\n    }\n    var result = 1;\n    for(var i = 1; i <= n; i++){\n        result\
    \ = result * 2 % p;\n    }\n    return result;\n}\n", "    let bin = dec2bin(n);\n\
    \    let result = 1;\n    let mod = 2;\n    let div = p;\n    let i = 0;\n   \
    \ let len = bin.length;\n    while(i < len){\n        if(mod >= p){\n        \
    \    mod = mod % p;\n        }\n        if(bin[i] == 1){\n            result =\
    \ (result * mod) % p;\n        }\n        mod = (mod * mod) % p;\n        i++;\n\
    \    }\n    return result;\n}\n", "\tvar r = 1,\n\t\tmult = 2;\n\twhile(n > 0){\n\
    \t\tif(n % 2 == 1){\n\t\t\tr = (r * mult) % p;\n\t\t}\n\t\tmult = (mult * mult)\
    \ % p;\n\t\tn = n >> 1;\n\t}\n\treturn r;\n}\n", "    let sum = 1;\n    let power\
    \ = n % (p - 1);\n    let factor = 2;\n    while (power > 0) {\n        if (power\
    \ % 2 == 1) {\n            sum = (sum * factor) % p;\n        }\n        factor\
    \ = (factor * factor) % p;\n        power = Math.floor(power / 2);\n    }\n  \
    \  return sum;\n}", "  if(n==0){\n    return 1;\n  }else if(n==1){\n    return\
    \ n;\n  }else{\n    return Math.pow(n, modp(n, p-1)) % p;\n  }\n}\n", "\t// TODO\n\
    \tvar result = 1;\n\tfor(var i = 0; i < n; i++){\n\t\tresult = (result * 2) %\
    \ p;\n\t}\n\treturn result;\n}\n", "  return Math.pow(2, n) % p;\n}\n", "    let\
    \ result = 1;\n    let a = 2;\n    while (n > 0){\n        if (n % 2 == 1){\n\
    \            result = (result * a) % p;\n        }\n        n = Math.floor(n /\
    \ 2);\n        a = (a * a) % p;\n    }\n    return result;\n}\n", "  let remainder\
    \ = n;\n  let binary = n.toString(2);\n  let result = 1;\n  for (let i = binary.length\
    \ - 1; i >= 0; i--) {\n    if (binary[i] === '1') {\n      result = (result *\
    \ remainder) % p;\n    }\n    remainder = (remainder * remainder) % p;\n  }\n\
    \  return result;\n}\n", "\t//To do, start by checking that n is non-negative\
    \ and p is a prime.\n\t//Then implement as described in the instructions.\n\t\
    if (n >= 0 && p > 0) {\n\t\tvar k = 0;\n\t\tvar tmp = 1;\n\t\twhile (n >= 2) {\n\
    \t\t\ttmp = (tmp * tmp) % p;\n\t\t\tn = Math.floor(n / 2);\n\t\t\tk++;\n\t\t}\n\
    \t\tif (n == 1) {\n\t\t\ttmp = (tmp * 2) % p;\n\t\t}\n\t\treturn tmp;\n\t}\n\t\
    else {\n\t\treturn false;\n\t}\n}\n", "    if(n === 0){\n        return 1;\n \
    \   }\n    else if(n === 1){\n        return n;\n    }\n    else{\n        return\
    \ modp(n - 1, p) * 2 % p;\n    }\n}\n\n", "  var result = 1;\n  for (var i = 0;\
    \ i < n; i++){\n    result = (result * 2) % p;\n  }\n  return result;\n}\n", " \
    \ // Convert to binary\n  var bin = n.toString(2);\n  var total = 1;\n  for (var\
    \ i = 0; i < bin.length; i++) {\n    if (bin[i] === '1') {\n      // If there\
    \ is a 1 in the binary representation of n,\n      // multiply the total by 2^i\
    \ mod p\n      total = (total * Math.pow(2, i)) % p;\n    }\n  }\n  return total;\n\
    }\n", "  if(n === 0){\n    return 1;\n  }\n  if(n % 2 === 0){\n    let res = modp(n/2,\
    \ p);\n    return (res * res) % p;\n  }\n  return (2 * modp(n-1, p)) % p;\n}\n",
  "    var powers = [];\n    var t = n;\n    while(t > 0){\n        powers.push(t);\n\
    \        t = t >> 1;\n    }\n    var res = 1;\n    for(var i = powers.length -\
    \ 1; i >= 0; i--){\n        res = mod(res * res, p);\n        if(powers[i] % 2\
    \ == 1){\n            res = mod(res * n, p);\n        }\n    }\n    return res;\n\
    }\n", "\treturn power(2, n, p);\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
