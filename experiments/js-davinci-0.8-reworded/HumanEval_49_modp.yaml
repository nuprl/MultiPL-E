name: HumanEval_49_modp
language: js
prompt: "//Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n\
  // >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n//\
  \ 8\n// >>> modp(100, 101)\n// 1\nfunction modp(n, p){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101,\
  \ 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3,\
  \ 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30,\
  \ 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"
completions: ["\tif(p == 0) return NaN;\n\tif(n == 0) return 1;\n\tvar m = (n % p)\
    \ % 2;\n\tif(m == 0) return 1;\n\telse return 2*modp(n, (p-1)/2) % p;\n}\n", " \
    \   //Calculate the length of the binary representation of the argument n\n  \
    \  let nlen = length(n);\n    //Actual result\n    let res = 1;\n    //Multiples\
    \ of 2^n in base p\n    let multiple = 1;\n    //We will perform the calculations\
    \ for all non-zero bits in n.\n    for(let i = 0; i < nlen; i++){\n        //If\
    \ bit i is set, multiply the result with the corresponding multiple.\n       \
    \ if(getbit(n, i)){\n            res = (res * multiple) % p;\n        }\n    \
    \    //Multiple = 2 * multiple % p\n        multiple = (multiple * 2) % p;\n \
    \   }\n    return res;\n}\n", "\tif(n < 0){\n\t\treturn -modp(-n, p);\n\t}\n\t\
    if(n == 0){\n\t\treturn 1;\n\t}else if(n % 2 == 0){\n\t\treturn modp(n / 2, p)\
    \ * modp(n / 2, p) % p;\n\t}else{\n\t\treturn modp(n / 2, p) * modp(n / 2, p)\
    \ * 2 % p;\n\t}\n}\n", "  if(n<=0) return 1;\n  else if(n==1) return 2;\n  else\
    \ if(n>=p) return modp(n%p, p);\n  else return (2*modp(n-1, p))%p;\n}\n", "\t\
    var result = 1;\n\twhile(n>0){\n\t\tresult = (result*2)%p;\n\t\tn--;\n\t}\n\t\
    return result;\n}\n\n\n", "    var result = 1;\n    while (n > 0){\n        if\
    \ (n & 1) //n is odd\n            result = (result * 2) % p;\n        n >>= 1;\n\
    \    }\n    return result;\n}\n", "\tif(typeof n === 'undefined' || typeof p ===\
    \ 'undefined')\n\t\tthrow Error('Arguments of modp(n, p) are missing');\n\tif(!Number.isInteger(n)\
    \ || !Number.isInteger(p))\n\t\tthrow Error('Arguments of modp(n, p) must be integers');\n\
    \tif(p < 1)\n\t\tthrow Error('p must be a positive integer');\n\tif(n < 0)\n\t\
    \tthrow Error('n must be a non-negative integer');\n\tif(n == 0)\n\t\treturn 1;\n\
    \tif(n == 1)\n\t\treturn n;\n\tif(n == 2)\n\t\treturn n % p;\n\tif(n % 2 == 0)\n\
    \t\treturn modp(n / 2, p) * modp(2, p) % p;\n\telse\n\t\treturn modp(n - 1, p)\
    \ * modp(2, p) % p;\n}\n", "    var result = 1;\n    while (n){\n        if (n\
    \ & 1)\n            result = (result * 2) % p;\n        n >>= 1;\n    }\n    return\
    \ result;\n}\n", "    n = n.toString(2);\n    var output = 1;\n    for(var i =\
    \ 0; i < n.length; i++){\n        if(n[i] === '1'){\n            output = (output\
    \ * 2) % p;\n        }\n        output = (output * output) % p;\n    }\n    return\
    \ output;\n}\n", "    return bigint(2).pow(n).mod(p).toJSNumber();\n}\n", "  \
    \  if(n===0){\n        return 1;\n    }\n    var a = n;\n    var b = p;\n    var\
    \ r = Math.floor(a / b);\n    var s = a - r * b;\n    while(r !== 0){\n      \
    \  a = b;\n        b = s;\n        r = Math.floor(a / b);\n        s = a - r *\
    \ b;\n    }\n    var t = p/b;\n    var f = [];\n    var q = [];\n    var x0 =\
    \ 0;\n    var x1 = 1;\n    var r0 = 0;\n    var r1 = 1;\n    var q0 = 0;\n   \
    \ var q1 = 0;\n    var i = 0;\n    var j = 0;\n    f[0] = 0;\n    f[1] = 1;\n\
    \    q[0] = 0;\n    q[1] = 0;\n    while(true){\n        r0 = r1;\n        r1\
    \ = a - q1 * b;\n        q0 = q1;\n        q1 = Math.floor(a / b);\n        x0\
    \ = x1;\n        x1 = f[i] - q[i] * f[i+1];\n        f[i+2] = x1;\n        q[i+2]\
    \ = q1;\n        i = i + 1;\n        if(r1 === 0){\n            break;\n     \
    \   }\n    }\n    if(n >= 0){\n        return f[i] % t;\n    }\n    else{\n  \
    \      if(f[i]<0){\n            return f[i] + t;\n        }\n        else{\n \
    \           return -f[i] + t;\n        }\n    }\n}\n", "  if(p == 2) return 1;\n\
    \  if(n == 0) return 1;\n  if(n == 1) return 2;\n  if(n % 2 == 0) return modp(n/2,\
    \ p) * modp(n/2, p) % p;\n  return modp(n/2, p) * modp(n/2, p) * 2 % p;\n}\n",
  "    var v = 1;\n    var v2 = 1;\n    while (n > 0){\n        if (n % 2 == 1){\n\
    \            v = (v * v2) % p;\n        }\n        v2 = (v2 * v2) % p;\n     \
    \   n = n >> 1;\n    }\n    return v;\n}\n", "    if(p < 1)\n        return -1;\n\
    \n    if(n < 0){\n        return -1;\n    }\n\n    // initialize r to 1 (2^0 mod\
    \ p = 1)\n    var r = 1;\n\n    // initialize the exponent mask to 1\n    var\
    \ mask = 1;\n\n    // while there are more bits in the exponent\n    while(mask\
    \ <= n){\n        // if the exponent contains a 1 in this place\n        if((n\
    \ & mask) !== 0){\n            // multiply r by 2^k mod p\n            r = (r\
    \ * 2) % p;\n        }\n\n        // move to the next bit\n        mask = mask\
    \ << 1;\n    }\n\n    return r;\n}\n", "\tvar m = 1;\n\twhile(n > 0){\n\t\tif(n\
    \ % 2 == 1){\n\t\t\tm = (m * 2) % p;\n\t\t}\n\t\tn = Math.floor(n / 2);\n\t}\n\
    \treturn m;\n}\n", "  // your code here\n  let result = 1;\n  for (let i = 0;\
    \ i < n; i++) {\n    result = result * 2 % p;\n  }\n  return result;\n}\n", " \
    \   if(n === 0){\n        return 1;\n    }\n    if(n % 2 === 0){\n        return\
    \ modp(n / 2, p) ** 2 % p;\n    }else{\n        return (modp(n - 1, p) * 2) %\
    \ p;\n    }\n}\n", "    var x = 1;\n    var y = n % p;\n    while (n > 0){\n \
    \       if (n % 2 != 0){\n            x = (x * y) % p;\n        }\n        y =\
    \ (y * y) % p;\n        n = Math.floor(n / 2);\n    }\n    return x;\n}\n", " \
    \   var nn = 1;\n    for(var i = 0; i < n; i++){\n        nn = (nn * 2) % p;\n\
    \    }\n    return nn;\n}\n", "    if(p <= 0) return 1;\n    if(n == 0) return\
    \ 1;\n    if(n % 2 == 0) return (modp(n / 2, p) * modp(n / 2, p)) % p;\n    else\
    \ return (2 * modp(n / 2, p) * modp(n / 2, p)) % p;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
