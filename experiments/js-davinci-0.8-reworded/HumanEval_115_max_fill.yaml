name: HumanEval_115_max_fill
language: js
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid, capacity){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
  \ 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0, 1, 1], [0, 0, 0, 0], [1,\
  \ 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0, 0, 0], [0,\
  \ 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4);\n\
  \  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n}\n\ntest();"
completions: ["    var max = grid.length * grid[0].length\n    var max_row = grid.length\n\
    \    var max_col = grid[0].length\n    var count = 0\n    for(var row = 0; row\
    \ < max_row; row++){\n        for(var col = 0; col < max_col; col++){\n      \
    \      if(grid[row][col] == 1){\n                grid[row][col] = 0\n        \
    \        count += 1\n                for(var adj_row = row; adj_row < max_row;\
    \ adj_row++){\n                    for(var adj_col = col; adj_col < max_col; adj_col++){\n\
    \                        if(grid[adj_row][adj_col] == 1){\n                  \
    \          grid[adj_row][adj_col] = 0\n                        }\n           \
    \         }\n                }\n            }\n        }\n    }\n    return max\
    \ - count\n}\n", "    var fills = 0;\n    for(var i = 0; i < grid.length; i++){\n\
    \        for(var j = 0; j < grid[i].length; j++){\n            if(grid[i][j] ===\
    \ 1){\n                //start fill\n                if(capacity >= grid[i].length){\n\
    \                    fills += 1;\n                }\n                else{\n \
    \                   var filled = 0;\n                    for(var k = j; k < j\
    \ + capacity; k++){\n                        if(k < grid[i].length){\n       \
    \                     if(grid[i][k] === 1){\n                                filled++;\n\
    \                            }\n                        }\n                  \
    \  }\n                    if(filled === capacity){\n                        fills\
    \ += 1;\n                    }\n                }\n            }\n        }\n\
    \    }\n    return fills;\n}", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++){\n    for (let j = 0; j < grid[i].length; j++){\n      if (grid[i][j] ===\
    \ 1){\n        grid[i][j] = 0;\n        count++;\n        let currentRow = i;\n\
    \        let currentColumn = j;\n        for (let x = 0; x < capacity; x++){\n\
    \          if (currentRow + 1 < grid.length && grid[currentRow + 1][currentColumn]\
    \ === 1){\n            grid[currentRow + 1][currentColumn] = 0;\n            currentRow++;\n\
    \          }\n          else if (currentColumn + 1 < grid[i].length && grid[currentRow][currentColumn\
    \ + 1] === 1){\n            grid[currentRow][currentColumn + 1] = 0;\n       \
    \     currentColumn++;\n          }\n        }\n      }\n    }\n  }\n  return\
    \ count;\n}\n", "    //count how many 1's in each row\n    var min = 0;\n    for(var\
    \ i = 0; i < grid.length; i++){\n        var sum = 0;\n        for(var j = 0;\
    \ j < grid[i].length; j++){\n            sum += grid[i][j];\n        }\n     \
    \   //if sum > 0\n        if(sum > 0){\n            //add sum to min\n       \
    \     min += sum;\n            //subtract 1 from min\n            min -= 1;\n\
    \        }\n    }\n    //multiply min by capacity\n    min *= capacity;\n    //return\
    \ min\n    return min;\n}", "    let bucket = 0;\n    let counter = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                bucket++;\n            }\n\
    \        }\n        if(bucket > capacity){\n            counter += bucket - capacity;\n\
    \            bucket = capacity;\n        }else if(bucket < capacity){\n      \
    \      bucket = capacity - bucket;\n        }\n    }\n    return counter;\n}",
  "  let n = grid.length\n  let m = grid[0].length\n  let max_fill = 0;\n  for (let\
    \ i = 0; i < n; i++) {\n    let counter = 0;\n    for (let j = 0; j < m; j++)\
    \ {\n      if (grid[i][j] == 1) {\n        if (i - 1 >= 0 && grid[i - 1][j] ==\
    \ 1) {\n          counter += capacity;\n        } else {\n          counter +=\
    \ 1;\n        }\n      }\n    }\n    max_fill += counter\n  }\n  return max_fill\n\
    }\n\ngrid = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]]\ncapacity = 1", "    if(grid.length\
    \ === 0) return 0;\n    let n = grid.length;\n    let m = grid[0].length;\n  \
    \  let maxElem = 0;\n    for(let i = 0; i < n; i++){\n        let count = 0;\n\
    \        for(let j = 0; j < m; j++){\n            if(grid[i][j] === 1) count++;\n\
    \        }\n        maxElem = Math.max(maxElem, count);\n    }\n    return Math.ceil(maxElem\
    \ / capacity) * n;\n}\n", "    // your code here\n}", "    // your code here\n\
    }\n", "    var n = grid.length;\n    var m = grid[0].length;\n    var output =\
    \ 0;\n    for(var i = 0; i < n; i++){\n        var total_water = 0;\n        for(var\
    \ j = 0; j < m; j++){\n            if(grid[i][j] === 1){\n                total_water++;\n\
    \            }\n        }\n        output += (total_water / capacity) + (total_water\
    \ % capacity);\n    }\n    return output;\n}\n", "    let num = 0;\n    for(let\
    \ i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            if(grid[i][j] === 1){\n                let count = 0;\n         \
    \       for(let k = i; k < grid.length; k++){\n                    if(grid[k][j]\
    \ === 1){\n                        count ++;\n                    }\n        \
    \        }\n                while(count >= capacity){\n                    count\
    \ -= capacity;\n                    num++;\n                }\n            }\n\
    \        }\n    }\n    return num;\n}\n", "  let max = 0;\n  let count = 0;\n\
    \  let rows = grid.length;\n  let cols = grid[0].length;\n  while(max < capacity){\n\
    \    max = 0;\n    let currentRow = 0;\n    let currentCol = 0;\n    for(let i\
    \ = 0; i < rows; i++){\n      for(let j = 0; j < cols; j++){\n        if(grid[i][j]\
    \ > max){\n          max = grid[i][j];\n          currentRow = i;\n          currentCol\
    \ = j;\n        }\n      }\n    }\n    if(max <= capacity){\n      for(let i =\
    \ 0; i < rows; i++){\n        for(let j = 0; j < cols; j++){\n          if(grid[i][j]\
    \ > 0){\n            grid[i][j] = 0;\n          }\n        }\n      }\n      for(let\
    \ i = 0; i < rows; i++){\n        for(let j = 0; j < cols; j++){\n          if(grid[i][j]\
    \ < capacity){\n            grid[i][j]++;\n          }\n        }\n      }\n \
    \     count++;\n    }\n  }\n  return count;\n}", "    // your code here\n}\n",
  "    let depth = 0;\n    const wells = [];\n    for (const [rowIndex, row] of grid.entries())\
    \ {\n        wells.push([]);\n        for (const [colIndex, col] of row.entries())\
    \ {\n            wells[rowIndex].push({ quantity: col, fill_count: 0 });\n   \
    \     }\n    }\n    while (true) {\n        let new_depth = 0;\n        for (const\
    \ [rowIndex, row] of wells.entries()) {\n            for (const [colIndex, col]\
    \ of row.entries()) {\n                if (col.quantity > 0) {\n             \
    \       const neighbors = getNeighbors(rowIndex, colIndex, wells);\n         \
    \           const depth_of_neighbors = neighbors.reduce((sum, neighbor) => sum\
    \ + neighbor.quantity, 0);\n                    const new_quantity = col.quantity\
    \ + depth_of_neighbors;\n                    if (new_quantity > capacity) {\n\
    \                        const depth_to_fill = capacity - col.quantity;\n    \
    \                    wells[rowIndex][colIndex].quantity = capacity;\n        \
    \                wells[rowIndex][colIndex].fill_count += 1;\n                \
    \        for (const neighbor of neighbors) {\n                            if (neighbor.quantity\
    \ > 0) {\n                                const new_depth_of_neighbor = neighbor.quantity\
    \ - depth_to_fill;\n                                wells[neighbor.rowIndex][neighbor.colIndex].quantity\
    \ = new_depth_of_neighbor > 0 ? new_depth_of_neighbor : 0;\n                 \
    \               wells[neighbor.rowIndex][neighbor.colIndex].fill_count += 1;\n\
    \                            }\n                        }\n                  \
    \  } else {\n                        wells[rowIndex][colIndex].quantity = new_quantity;\n\
    \                    }\n                    new_depth = Math.max(new_depth, wells[rowIndex][colIndex].quantity);\n\
    \                }\n            }\n        }\n        if (new_depth === depth)\
    \ {\n            break;\n        }\n        depth = new_depth;\n    }\n    return\
    \ wells.reduce((sum, row) => sum + row.reduce((sum,", "  let count = 0;\n  let\
    \ index = 0;\n  let done = false;\n  let deep = [];\n  for(let i = 0; i < grid.length;\
    \ i++){\n    for(let j = 0; j < grid[i].length; j++){\n      deep.push(grid[i][j]);\n\
    \    }\n  }\n  while(!done){\n    if(deep[index] == 1){\n      if(capacity <=\
    \ 0){\n        count++;\n        capacity = 2;\n      }\n      deep[index] = 0;\n\
    \      capacity--;\n    }\n    index++;\n    if(index > deep.length){\n      done\
    \ = true;\n    }\n  }\n  return count;\n}", "\tvar n = grid.length;\n\tvar m =\
    \ grid[0].length;\n\tvar count = 0;\n\t//fill the first column\n\tfor(var i =\
    \ 0; i < n; i++){\n\t\tif(grid[i][0] == 1){\n\t\t\tcount += capacity;\n\t\t\t\
    grid[i][0] = 0;\n\t\t}\n\t}\n\t//fill the second column\n\tfor(var i = 0; i <\
    \ n; i++){\n\t\tif(grid[i][1] == 1){\n\t\t\tcount += capacity;\n\t\t\tgrid[i][1]\
    \ = 0;\n\t\t}\n\t}\n\t//fill the rest of the matrix\n\tfor(var j = 2; j < m; j++){\n\
    \t\tfor(var i = 0; i < n; i++){\n\t\t\tif(grid[i][j] == 1){\n\t\t\t\tcount +=\
    \ capacity;\n\t\t\t\tgrid[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\
    max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1); //6\nmax_fill([[0, 0,\
    \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2); //5\nmax_fill([[0, 0,\
    \ 0], [0, 0, 0]], 5); //0", "\tlet counter = 0;\n\tfor(let i = 0; i < grid.length;\
    \ i++){\n\t\tfor(let j = 0; j < grid[i].length; j++){\n\t\t\tif(grid[i][j] ===\
    \ 1){\n\t\t\t\tgrid[i][j] = 0;\n\t\t\t\tcounter++;\n\t\t\t\twhile(capacity > 0){\n\
    \t\t\t\t\tif(grid[i-1] && grid[i-1][j] === 1){\n\t\t\t\t\t\tgrid[i-1][j] = 0;\n\
    \t\t\t\t\t\tcapacity--;\n\t\t\t\t\t}\n\t\t\t\t\tif(grid[i+1] && grid[i+1][j] ===\
    \ 1){\n\t\t\t\t\t\tgrid[i+1][j] = 0;\n\t\t\t\t\t\tcapacity--;\n\t\t\t\t\t}\n\t\
    \t\t\t\tif(grid[i][j-1] === 1){\n\t\t\t\t\t\tgrid[i][j-1] = 0;\n\t\t\t\t\t\tcapacity--;\n\
    \t\t\t\t\t}\n\t\t\t\t\tif(grid[i][j+1] === 1){\n\t\t\t\t\t\tgrid[i][j+1] = 0;\n\
    \t\t\t\t\t\tcapacity--;\n\t\t\t\t\t}\n\t\t\t\t\tcapacity--;\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn counter;\n}", "    let cell = [0, 0];\n    let bucket\
    \ = 0;\n    let sum = 0;\n    for (let i = 0; i < grid.length; i++) {\n      \
    \  for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] ===\
    \ 1) {\n                bucket += 1;\n            }\n        }\n    }\n    while\
    \ (bucket > 0) {\n        cell = find_lowest_cell(grid);\n        if (cell[0]\
    \ === -1) {\n            break;\n        }\n        grid[cell[0]][cell[1]] = 0;\n\
    \        grid = spread_water(grid, cell[0], cell[1], capacity);\n        sum +=\
    \ 1;\n        bucket -= 1;\n    }\n    return sum;\n}", "    let count = 0;\n\
    \    for(let i = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            if(grid[i][j] === 1){\n                grid[i][j] = 0;\n\
    \                count++;\n                if(j + 1 < grid[i].length && grid[i][j\
    \ + 1] === 1) grid[i][j + 1] = 0;\n                if(i + 1 < grid.length && grid[i\
    \ + 1][j] === 1){\n                    grid[i + 1][j] = 0;\n                 \
    \   if(j + 1 < grid[i].length && grid[i + 1][j + 1] === 1) grid[i + 1][j + 1]\
    \ = 0;\n                }\n            }\n        }\n    }\n    return count;\n\
    }", "  let total = 0;\n  let cur_level = 0;\n  let total_cap = 0;\n  let level\
    \ = 0;\n  while(cur_level < grid.length){\n    let cur_row = grid[cur_level];\n\
    \    let cur_water = 0;\n    let row_cap = 0;\n    for(let i = 0; i < cur_row.length;\
    \ i++){\n      if(cur_row[i] === 1){\n        cur_water++;\n      }\n      else{\n\
    \        row_cap++;\n      }\n    }\n    if(row_cap > 0){\n      total_cap +=\
    \ capacity * row_cap;\n    }\n    if(cur_water < row_cap){\n      level += row_cap\
    \ - cur_water;\n    }\n    else{\n      total += row_cap;\n    }\n    cur_level++;\n\
    \  }\n  if(total_cap < level){\n    return -1;\n  }\n  else{\n    return total;\n\
    \  }\n}"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
