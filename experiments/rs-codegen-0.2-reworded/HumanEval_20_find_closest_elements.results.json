{
  "name": "HumanEval_20_find_closest_elements",
  "language": "rs",
  "prompt": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n",
  "tests": "}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[0] - min_value;\n  let max_diff = numbers[0] - max_value;\n  for i in numbers.iter() {\n    let diff = i - numbers[0];\n    if diff < min_diff {\n      min_diff = diff;\n      min_index = i;\n    } else if diff > max_diff {\n      max_diff = diff;\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpayyesrr3.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpayyesrr3.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpayyesrr3.rs:13:19\n   |\n13 |     } else if i > max_value {\n   |                   ^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpayyesrr3.rs:14:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n14 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpayyesrr3.rs:20:10\n   |\n20 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpayyesrr3.rs:21:19\n   |\n17 |   let min_index = 0;\n   |                   - expected due to this value\n...\n21 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpayyesrr3.rs:22:17\n   |\n22 |     } else if i == max_val",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpwc3glisi.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwc3glisi.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwc3glisi.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwc3glisi.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpwc3glisi.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwc3glisi.rs:22:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n22 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpwc3glisi.rs:24:10\n   |\n24 |     if i == max_value {\n   |          ^^ no implementation fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if (min_diff < max_diff) {\n    return (min_value, numbers[min_index]);\n  } else {\n    return (numbers[max_index], max_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp__u4m_uk.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp__u4m_uk.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp__u4m_uk.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev + 1]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_value_index_prev + 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmph6wwqylv.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmph6wwqylv.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmph6wwqylv.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    } else if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    } else if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplt15a9ej.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplt15a9ej.rs:13:15\n   |\n13 |     } else if (numbers[i] > max_value) {\n   |               ^                      ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (numbers[i] > max_value) {\n13 +     } else if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplt15a9ej.rs:20:8\n   |\n20 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (numbers[i] == min_value) {\n20 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplt15a9ej.rs:22:15\n   |\n22 |     } else if (numbers[i] == max_value) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (numbers[i] == max_value) {\n22 +     } else if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmplt15a9ej.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmplt15a9ej.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `Sl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_number);\n  let max_diff = abs(numbers[max_index] - max_number);\n  let min_index_diff = abs(numbers[min_index] - numbers[max_index]);\n  let max_index_diff = abs(numbers[max_index] - numbers[min_index]);\n  if min_diff < max_diff {\n    return (min_number, max_number);\n  } else if min_index_diff < max_index_diff {\n    return (min_number, numbers[max_index]);\n  } else {\n    return (numbers[min_index], max_number);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpwylv4_5u.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpwylv4_5u.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpwylv4_5u.rs:30:24\n   |\n30 |   let min_index_diff = abs(numbers[min_index] - numbers[max_index]);\n   |                        ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpwylv4_5u.rs:31:24\n   |\n31 |   let max_index_diff = abs(numbers[max_index] - numbers[min_index]);\n   |                        ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwylv4_5u.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwylv4_5u.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwylv4_5u.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwylv4_5u.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = math.abs(numbers[min_index] - min_value);\n  let max_diff = math.abs(numbers[max_index] - max_value);\n  let min_index_diff = math.abs(numbers[min_index] - numbers[max_index]);\n  if (min_diff < max_diff) {\n    return (min_value, numbers[max_index]);\n  } else {\n    return (numbers[min_index], max_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find value `math` in this scope\n  --> /tmp/tmpdim2ifkv.rs:28:18\n   |\n28 |   let min_diff = math.abs(numbers[min_index] - min_value);\n   |                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `math` in this scope\n  --> /tmp/tmpdim2ifkv.rs:29:18\n   |\n29 |   let max_diff = math.abs(numbers[max_index] - max_value);\n   |                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `math` in this scope\n  --> /tmp/tmpdim2ifkv.rs:30:24\n   |\n30 |   let min_index_diff = math.abs(numbers[min_index] - numbers[max_index]);\n   |                        ^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdim2ifkv.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdim2ifkv.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdim2ifkv.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdim2ifkv.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdim2ifkv.rs:31:6\n   |\n31 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parent",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvmrl0qxr.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvmrl0qxr.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvmrl0qxr.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvmrl0qxr.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvmrl0qxr.rs:32:8\n   |\n32 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < 0) {\n32 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvmrl0qxr.rs:35:8\n   |\n35 |     if (diff > min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > min_diff) {\n35 +     if diff > min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvmrl0qxr.rs:39:8\n   |\n39 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if (diff < 0) {\n39 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvmrl0qxr.rs:42:8\n   |\n42",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    let value = i;\n    if value < min_value {\n      min_value = value;\n      min_index = i;\n    }\n    if value > max_value {\n      max_value = value;\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:14:16\n   |\n14 |     if value < min_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:15:19\n   |\n9  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       min_value = value;\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       min_value = *value;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:16:19\n   |\n8  |   let min_index = 0;\n   |                   - expected due to this value\n...\n16 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:18:16\n   |\n18 |     if value > max_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:19:19\n   |\n11 |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n19 |       max_value = value;\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max_value = *value;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:20:19\n   |\n10 |   let max_index = 0;\n   |                   - expected due to this value\n...\n20 |       max_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let min_number = numbers[0];\n    let max_number = numbers[0];\n    for i in numbers.iter() {\n        if i < min_number {\n            min_number = i;\n        }\n        if i > max_number {\n            max_number = i;\n        }\n    }\n    let min_index = 0;\n    let max_index = 0;\n    for i in numbers.iter() {\n        if i == min_number {\n            min_index = i;\n        }\n        if i == max_number {\n            max_index = i;\n        }\n    }\n    let min_diff = abs(min_number - numbers[0]);\n    let max_diff = abs(max_number - numbers[0]);\n    for i in numbers.iter() {\n        let diff = abs(i - numbers[0]);\n        if diff < min_diff {\n            min_diff = diff;\n            min_index = i;\n        }\n        if diff < max_diff {\n            max_diff = diff;\n            max_index = i;\n        }\n    }\n    return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp7jefbpl6.rs:28:20\n   |\n28 |     let min_diff = abs(min_number - numbers[0]);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp7jefbpl6.rs:29:20\n   |\n29 |     let max_diff = abs(max_number - numbers[0]);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp7jefbpl6.rs:31:20\n   |\n31 |         let diff = abs(i - numbers[0]);\n   |                    ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jefbpl6.rs:11:16\n   |\n11 |         if i < min_number {\n   |                ^^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jefbpl6.rs:12:26\n   |\n8  |     let min_number = numbers[0];\n   |                      ---------- expected due to this value\n...\n12 |             min_number = i;\n   |                          ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |             min_number = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jefbpl6.rs:14:16\n   |\n14 |         if i > max_number {\n   |                ^^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7jefbpl6.rs:15:26\n   |\n9  |     let max_number = numbers[0];\n   |                      ---------- expected due to this value\n...\n15 |             max_number = i;\n   |                          ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |             max_number = *i;\n   |                          +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmp7jefbpl6.rs:21:14\n   |\n21 |         if i == min_number {\n   |              ^^ no implementat",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0\n  let min_value = numbers[0]\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] < min_value {\n      min_value = numbers[i]\n      min_index = i\n    }\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  return (numbers[min_index], numbers[max_index])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpaxksyqph.rs:8:20\n  |\n8 |   let min_index = 0\n  |                    ^ help: add `;` here\n9 |   let min_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpaxksyqph.rs:9:29\n   |\n9  |   let min_value = numbers[0]\n   |                             ^ help: add `;` here\n10 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpaxksyqph.rs:10:20\n   |\n10 |   let max_index = 0\n   |                    ^ help: add `;` here\n11 |   let max_value = numbers[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpaxksyqph.rs:11:29\n   |\n11 |   let max_value = numbers[0]\n   |                             ^ help: add `;` here\n12 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpaxksyqph.rs:14:29\n   |\n14 |       min_value = numbers[i]\n   |                             ^ help: add `;` here\n15 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpaxksyqph.rs:18:29\n   |\n18 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpaxksyqph.rs:13:8\n   |\n13 |     if numbers[i] < min_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpaxksyqph.rs:14:19\n   |\n14 |       min_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for (let i = 1; i < numbers.len(); i++) {\n    let value = numbers[i];\n    if (value < min_value) {\n      min_value = value;\n      min_index = i;\n    }\n    if (value > max_value) {\n      max_value = value;\n      max_index = i;\n    }\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4_a59bb6.rs:12:8\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4_a59bb6.rs:12:12\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4_a59bb6.rs:12:14\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4_a59bb6.rs:12:13\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4_a59bb6.rs:12:14\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    } else if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    } else if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_index_index = numbers.indexOf(min_index);\n  let max_index_index = numbers.indexOf(max_index);\n  let min_index_index_index = numbers.indexOf(min_index_index);\n  let max_index_index_index = numbers.indexOf(max_index_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf21gl5_j.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf21gl5_j.rs:13:15\n   |\n13 |     } else if (numbers[i] > max_value) {\n   |               ^                      ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (numbers[i] > max_value) {\n13 +     } else if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf21gl5_j.rs:20:8\n   |\n20 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (numbers[i] == min_value) {\n20 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf21gl5_j.rs:22:15\n   |\n22 |     } else if (numbers[i] == max_value) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (numbers[i] == max_value) {\n22 +     } else if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf21gl5_j.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf21gl5_j.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `Sl",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if min_diff < max_diff {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmplkelglm_.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmplkelglm_.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmplkelglm_.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if min_diff < max_diff {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmplkelglm_.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmplkelglm_.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmplkelglm_.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0\n  let min_value = numbers[0]\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] < min_value {\n      min_value = numbers[i]\n      min_index = i\n    }\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  return (numbers[min_index], numbers[max_index])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpaxksyqph.rs:8:20\n  |\n8 |   let min_index = 0\n  |                    ^ help: add `;` here\n9 |   let min_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpaxksyqph.rs:9:29\n   |\n9  |   let min_value = numbers[0]\n   |                             ^ help: add `;` here\n10 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpaxksyqph.rs:10:20\n   |\n10 |   let max_index = 0\n   |                    ^ help: add `;` here\n11 |   let max_value = numbers[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpaxksyqph.rs:11:29\n   |\n11 |   let max_value = numbers[0]\n   |                             ^ help: add `;` here\n12 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpaxksyqph.rs:14:29\n   |\n14 |       min_value = numbers[i]\n   |                             ^ help: add `;` here\n15 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpaxksyqph.rs:18:29\n   |\n18 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpaxksyqph.rs:13:8\n   |\n13 |     if numbers[i] < min_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpaxksyqph.rs:14:19\n   |\n14 |       min_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_number);\n  let max_diff = abs(numbers[max_index] - max_number);\n  if min_diff > max_diff {\n    let temp = min_number;\n    min_number = max_number;\n    max_number = temp;\n    let temp_index = min_index;\n    min_index = max_index;\n    max_index = temp_index;\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpvrhucggz.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpvrhucggz.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_number);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrhucggz.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrhucggz.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrhucggz.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvrhucggz.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpvrhucggz.rs:21:10\n   |\n21 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_index_index = numbers.indexOf(min_index);\n  let max_index_index = numbers.indexOf(max_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_index_index_index = numbers.indexOf(min_index_index);\n  let max_index_index_index = numbers.indexOf(max_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_index_index_index_index = numbers.indexOf(min_index_index_index);\n  let max_index_index_index_index = numbers.indexOf(max_index_index_index);\n  let min_value_index_index_index_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_woat43v.rs:42:41\n   |\n42 |   let min_value_index_index_index_index_\n   |                                         ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_woat43v.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_woat43v.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_woat43v.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_woat43v.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp_woat43v.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp_woat43v.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpo4aoxcwc.rs:21:10\n   |\n21 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:22:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n22 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpo4aoxcwc.rs:24:10\n   |\n24 |     if i == max_number {\n   |          ^^ ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    } else if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    } else if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[0] - numbers[min_index];\n  let max_diff = numbers[0] - numbers[max_index];\n  let min_diff_index = 0;\n  let max_diff_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_diff_index = i;\n    } else if (i == max_number) {\n      max_diff_index = i;\n    }\n  }\n  let min_diff_diff = numbers[0] - numbers[min_diff_index];\n  let max_diff_diff = numbers[0] - numbers[max_diff_index];\n  if (min_diff_diff < max_diff_diff) {\n    return (min_number, max_number);\n  } else {\n    return (max_number, min_number);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf9p1uli.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf9p1uli.rs:13:15\n   |\n13 |     } else if (i > max_number) {\n   |               ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i > max_number) {\n13 +     } else if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf9p1uli.rs:20:8\n   |\n20 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i == min_number) {\n20 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf9p1uli.rs:22:15\n   |\n22 |     } else if (i == max_number) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == max_number) {\n22 +     } else if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf9p1uli.rs:31:8\n   |\n31 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n31 -     if (i == min_number) {\n31 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf9p1uli.rs:33:15\n   |\n33 |     } else if (i == max_number) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n33 -     } else if (i == max_number) {\n33 +     } else if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf9p1uli.rs:39:6\n   |\n39 |   if (min_diff_diff < max_diff_diff) {\n   |      ^                             ^\n   |\nhelp: remove these parentheses\n   |\n39 -   if (min_diff_diff < max_diff_diff) {\n39 +   if min_diff_diff < max_diff_diff {\n   | \n\nerror[E0308]: mismatched types",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if min_diff < max_diff {\n    return (min_value, numbers[min_index]);\n  } else {\n    return (numbers[max_index], max_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpneybik71.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpneybik71.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneybik71.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneybik71.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneybik71.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneybik71.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpneybik71.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_number;\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_closest = min_number;\n  let max_closest = max_number;\n  if (min_diff < max_diff) {\n    min_closest = numbers[min_index];\n    max_closest = numbers[max_index];\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdrjv3qlc.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdrjv3qlc.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdrjv3qlc.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdrjv3qlc.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdrjv3qlc.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdrjv3qlc.rs:35:8\n   |\n35 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > max_diff) {\n35 +     if diff > max_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdrjv3qlc.rs:41:6\n   |\n41 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n41 -   if (min_diff < max_diff) {\n41 +   if min_diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdrjv3qlc.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  if (min_diff < max_diff) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if (min_diff < max_diff) {\n    return (min_value, numbers[min_index]);\n  } else {\n    return (numbers[max_index], max_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp__u4m_uk.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp__u4m_uk.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp__u4m_uk.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp__u4m_uk.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if min_diff < max_diff {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmplkelglm_.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmplkelglm_.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmplkelglm_.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index < max_value_index) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsofkef_b.rs:28:6\n   |\n28 |   if (min_value_index < max_value_index) {\n   |      ^                                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -   if (min_value_index < max_value_index) {\n28 +   if min_value_index < max_value_index {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsofkef_b.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsofkef_b.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsofkef_b.rs:13:19\n   |\n13 |     } else if i > max_value {\n   |                   ^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsofkef_b.rs:14:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n14 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpsofkef_b.rs:20:10\n   |\n20 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_index - 2]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_index - 2]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_index + 2]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_index + 2]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_index + 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_index + 1]);\n  let min_value_index_prev_prev = numbers.indexOf(numbers[min_index - 1]);\n  let max_value_index_prev_prev = numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_teoxo38.rs:41:42\n   |\n41 |   let max_value_index_prev_prev = numbers\n   |                                          ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_teoxo38.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_teoxo38.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_teoxo38.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_teoxo38.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp_teoxo38.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp_teoxo38.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_prev_prev = numbers.indexOf(numbers[min_value_index_prev - 1]);\n  let max_value_index_prev_prev = numbers.indexOf(numbers[max_value_index_prev - 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev + 1]);\n  let max_value\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpud4eq4mu.rs:41:16\n   |\n41 |   let max_value\n   |                ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud4eq4mu.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud4eq4mu.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud4eq4mu.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud4eq4mu.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpud4eq4mu.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud4eq4mu.rs:22:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n22 |       min_index = i;\n   |                   ^ expected integer, f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_diff_index = 0;\n  let max_diff_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff == min_diff) {\n      min_diff_index = i;\n    }\n    if (diff == max_diff) {\n      max_diff_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptq84siq_.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptq84siq_.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptq84siq_.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptq84siq_.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptq84siq_.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptq84siq_.rs:35:8\n   |\n35 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > max_diff) {\n35 +     if diff > max_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptq84siq_.rs:43:8\n   |\n43 |     if (diff == min_diff) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n43 -     if (diff == min_diff) {\n43 +     if diff == min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptq84siq_.rs:46:8\n   |\n46 |     if (diff == max_diff) {\n   |        ^                ^\n   |\nhelp: remove thes",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_number;\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    let diff = i - max_number;\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp974g77zu.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp974g77zu.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp974g77zu.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp974g77zu.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp974g77zu.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp974g77zu.rs:36:8\n   |\n36 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if (diff > max_diff) {\n36 +     if diff > max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp974g77zu.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp974g77zu.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:32:8\n   |\n32 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < 0) {\n32 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:35:8\n   |\n35 |     if (diff > min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > min_diff) {\n35 +     if diff > min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:39:8\n   |\n39 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if (diff < 0) {\n39 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:42:8\n   |\n42",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if diff < min_diff {\n      min_diff = diff;\n    }\n    let diff = i - max_value;\n    if diff > max_diff {\n      max_diff = diff;\n    }\n  }\n  let min_value_index = 0;\n  let max_value_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_value_index = i;\n    }\n    if i == max_value {\n      max_value_index = i;\n    }\n  }\n  return (min_value_index, max_value_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpvunrpwmq.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvunrpwmq.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvunrpwmq.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvunrpwmq.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpvunrpwmq.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvunrpwmq.rs:22:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n22 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpvunrpwmq.rs:24:10\n   |\n24 |     if i == max_value {\n   |          ^^ no implementation fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_index + 1]);\n  if (min_value_index_next > max_value_index) {\n    return (min_value, max_value);\n  } else if (max_value_index_next > min_value_index) {\n    return (max_value, min_value);\n  } else {\n    return (numbers[min_index], numbers[max_index]);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpatxu9imt.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpatxu9imt.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpatxu9imt.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpatxu9imt.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpatxu9imt.rs:32:6\n   |\n32 |   if (min_value_index_next > max_value_index) {\n   |      ^                                      ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_value_index_next > max_value_index) {\n32 +   if min_value_index_next > max_value_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpatxu9imt.rs:34:13\n   |\n34 |   } else if (max_value_index_next > min_value_index) {\n   |             ^                                      ^\n   |\nhelp: remove these parentheses\n   |\n34 -   } else if (max_value_index_next > min_value_index) {\n34 +   } else if max_value_index_next > min_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpatxu9imt.rs:11:9\n   |\n11 |    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    } else if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    } else if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_number;\n  let max_diff = numbers[max_index] - max_number;\n  let min_closest = min_number;\n  let max_closest = max_number;\n  if (min_diff < max_diff) {\n    min_closest = numbers[min_index];\n    max_closest = numbers[max_index];\n  } else {\n    min_closest = numbers[max_index];\n    max_closest = numbers[min_index];\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmyd7b9_9.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmyd7b9_9.rs:13:15\n   |\n13 |     } else if (i > max_number) {\n   |               ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i > max_number) {\n13 +     } else if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmyd7b9_9.rs:20:8\n   |\n20 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i == min_number) {\n20 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmyd7b9_9.rs:22:15\n   |\n22 |     } else if (i == max_number) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == max_number) {\n22 +     } else if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmyd7b9_9.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmyd7b9_9.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmyd7b9_9.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    let value = i.next();\n    if value < min_value {\n      min_value = value;\n      min_index = i.next();\n    }\n    if value > max_value {\n      max_value = value;\n      max_index = i.next();\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0599]: no method named `next` found for reference `&f64` in the current scope\n  --> /tmp/tmpx6itn5k4.rs:13:19\n   |\n13 |     let value = i.next();\n   |                   ^^^^ method not found in `&f64`\n\nerror[E0599]: no method named `next` found for reference `&f64` in the current scope\n  --> /tmp/tmpx6itn5k4.rs:16:21\n   |\n16 |       min_index = i.next();\n   |                     ^^^^ method not found in `&f64`\n\nerror[E0599]: no method named `next` found for reference `&f64` in the current scope\n  --> /tmp/tmpx6itn5k4.rs:20:21\n   |\n20 |       max_index = i.next();\n   |                     ^^^^ method not found in `&f64`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  let min_index_diff = abs(numbers[min_index] - numbers[max_index]);\n  let min_diff_index = 0;\n  let max_diff_index = 0;\n  for i in numbers.iter() {\n    let diff = abs(numbers[i] - numbers[min_index]);\n    if (diff < min_diff) {\n      min_diff = diff;\n      min_diff_index = i;\n    }\n    diff = abs(numbers[i] - numbers[max_index]);\n    if (diff < max_diff) {\n      max_diff = diff;\n      max_diff_index = i;\n    }\n  }\n  let min_index_diff_index = 0;\n  let max_index_diff_index = 0;\n  for i in numbers.iter() {\n    let diff = abs(numbers[i] - numbers[min_index]);\n    if (diff < min_diff_index) {\n      min_diff_index = diff;\n      min_index_diff_index = i;\n    }\n    diff = abs(numbers[i] - numbers[max_index]);\n    if (diff < max_diff_index) {\n      max_diff_index = diff;\n      max_index_diff_index = i;\n    }\n  }\n  let min\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0q2kdsen.rs:59:10\n   |\n59 |   let min\n   |          ^ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0q2kdsen.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0q2kdsen.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0q2kdsen.rs:30:24\n   |\n30 |   let min_index_diff = abs(numbers[min_index] - numbers[max_index]);\n   |                        ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0q2kdsen.rs:34:16\n   |\n34 |     let diff = abs(numbers[i] - numbers[min_index]);\n   |                ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0q2kdsen.rs:39:12\n   |\n39 |     diff = abs(numbers[i] - numbers[max_index]);\n   |            ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0q2kdsen.rs:48:16\n   |\n48 |     let diff = abs(numbers[i] - numbers[min_index]);\n   |                ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0q2kdsen.rs:53:12\n   |\n53 |     diff = abs(numbers[i] - numbers[max_index]);\n   |            ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0q2kdsen.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0q2kdsen.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_i = numbers.indexOf(min_value);\n  let max_value_index_i = numbers.indexOf(max_value);\n  let min_value_index_j = numbers.indexOf(min_value);\n  let max_value_index_j = numbers.indexOf(max_value);\n  let min_value_index_k = numbers.indexOf(min_value);\n  let max_value_index_k = numbers.indexOf(max_value);\n  let min_value_index_l = numbers.indexOf(min_value);\n  let max_value_index_l = numbers.indexOf(max_value);\n  let min_value_index_m = numbers.indexOf(min_value);\n  let max_value_index_m = numbers.indexOf(max_value);\n  let min_value_index_n = numbers.indexOf(min_value);\n  let max_value_index_n = numbers.indexOf(max_value);\n  let min_value_index_o = numbers.indexOf(min_value);\n  let max_value_index_o = numbers.indexOf(max_value);\n  let min_value_index_p = numbers.indexOf(min_value);\n  let\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmp53zwjaf4.rs:46:1\n   |\n46 | }\n   | ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp53zwjaf4.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp53zwjaf4.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp53zwjaf4.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp53zwjaf4.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp53zwjaf4.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp53zwjaf4.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value_index = 0;\n  let max_value_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_value_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_value_index = i;\n    }\n  }\n  let min_value_diff = 0.0;\n  let max_value_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_value_index];\n    if (diff < min_value_diff) {\n      min_value_diff = diff;\n    }\n    if (diff > max_value_diff) {\n      max_value_diff = diff;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  let min_diff = 0.0;\n  let max_diff =\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected expression, found `}`\n  --> /tmp/tmpt4men3v3.rs:64:1\n   |\n64 | }\n   | ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4men3v3.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4men3v3.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4men3v3.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4men3v3.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4men3v3.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4men3v3.rs:35:8\n   |\n35 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > max_diff) {\n35 +     if diff > max_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4men3v3.rs:42:8\n   |\n42 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove thes",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  let min_closest = numbers[min_index];\n  let max_closest = numbers[max_index];\n  if min_diff < max_diff {\n    min_closest = numbers[min_index];\n    max_closest = numbers[max_index];\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp73z_rlg5.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp73z_rlg5.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp73z_rlg5.rs:13:19\n   |\n13 |     } else if i > max_value {\n   |                   ^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp73z_rlg5.rs:14:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n14 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmp73z_rlg5.rs:20:10\n   |\n20 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp73z_rlg5.rs:21:19\n   |\n17 |   let min_index = 0;\n   |                   - expected due to this value\n...\n21 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmp73z_rlg5.rs:22:17\n   |\n22 |     } else if i == max_val",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if (min_diff < max_diff) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnxliip9p.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnxliip9p.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnxliip9p.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnxliip9p.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnxliip9p.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnxliip9p.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnxliip9p.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnxliip9p.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp99pcixb9.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp99pcixb9.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp99pcixb9.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp99pcixb9.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99pcixb9.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99pcixb9.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99pcixb9.rs:14:13\n   |\n14 |     if (i > max_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99pcixb9.rs:15:20\n   |\n9  |   let max_numb",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:32:8\n   |\n32 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < 0) {\n32 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:35:8\n   |\n35 |     if (diff > min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > min_diff) {\n35 +     if diff > min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:39:8\n   |\n39 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if (diff < 0) {\n39 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6k9x6yg8.rs:42:8\n   |\n42",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  let min_value_index_2 = numbers.indexOf(min_value);\n  let max_value_index_2 = numbers.indexOf(max_value);\n  if (min_value_index_2 > max_value_index_2) {\n    let temp = min_value_index_2;\n    min_value_index_2 = max_value_index_2;\n    max_value_index_2 = temp;\n  }\n  let min_value_index_3 = numbers.indexOf(min_value);\n  let max_value_index_3 = numbers.indexOf(max_value);\n  if (min_value_index_3 > max_value_index_3) {\n    let temp = min_value_index_3;\n    min_value_index_3 = max_value_index_3;\n    max_value_index_3 = temp;\n  }\n  let min_value_index_4 = numbers.indexOf(min_value);\n  let max_value_index_4 = numbers.index\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpvps86sth.rs:50:40\n   |\n50 |   let max_value_index_4 = numbers.index\n   |                                        ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvps86sth.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvps86sth.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvps86sth.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvps86sth.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvps86sth.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvps86sth.rs:37:6\n   |\n37 |   if (min_value_index_2 > max_value_index_2) {\n   |      ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n37 -   if (min_value_index_2 > max_value_index_2) {\n37 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0\n  let min_value = numbers[0]\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    let value = i\n    if value < min_value {\n      min_value = value\n      min_index = i\n    }\n    if value > max_value {\n      max_value = value\n      max_index = i\n    }\n  }\n  return (min_value, max_value)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp43bfvpzn.rs:8:20\n  |\n8 |   let min_index = 0\n  |                    ^ help: add `;` here\n9 |   let min_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp43bfvpzn.rs:9:29\n   |\n9  |   let min_value = numbers[0]\n   |                             ^ help: add `;` here\n10 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp43bfvpzn.rs:10:20\n   |\n10 |   let max_index = 0\n   |                    ^ help: add `;` here\n11 |   let max_value = numbers[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp43bfvpzn.rs:11:29\n   |\n11 |   let max_value = numbers[0]\n   |                             ^ help: add `;` here\n12 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp43bfvpzn.rs:13:18\n   |\n13 |     let value = i\n   |                  ^ help: add `;` here\n14 |     if value < min_value {\n   |     -- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp43bfvpzn.rs:15:24\n   |\n15 |       min_value = value\n   |                        ^ help: add `;` here\n16 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp43bfvpzn.rs:19:24\n   |\n19 |       max_value = value\n   |                        ^ help: add `;` here\n20 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43bfvpzn.rs:14:16\n   |\n14 |     if value < min_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43bfvpzn.rs:15:19\n   |\n9  |   let min_value = numbers[0]\n   |                   ---------- expected due to this value\n...\n15 |       min_value = value\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider deref",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpo4aoxcwc.rs:21:10\n   |\n21 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:22:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n22 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpo4aoxcwc.rs:24:10\n   |\n24 |     if i == max_number {\n   |          ^^ ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  return (min_value_index, max_value_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpszx3qnjj.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpszx3qnjj.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: requi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > min_diff {\n      min_diff = diff;\n    }\n    let diff = i - max_value;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > max_diff {\n      max_diff = diff;\n    }\n  }\n  let min_index_diff = 0.0;\n  let max_index_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_index;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > min_index_diff {\n      min_index_diff = diff;\n    }\n    let diff = i - max_index;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > max_index_diff {\n      max_index_diff = diff;\n    }\n  }\n  let min_diff_diff = 0.0;\n  let max_diff_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_diff;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > min_diff_diff {\n      min_diff_diff = diff;\n    }\n    let diff =\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkaz2d2cx.rs:84:3\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - unclosed delimiter\n...\n66 |   for i in numbers.iter() {\n   |                           - this delimiter might not be properly closed...\n...\n75 | }\n   | - ...as it matches this but it has different indentation\n...\n84 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpkaz2d2cx.rs:75:1\n   |\n75 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkaz2d2cx.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkaz2d2cx.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkaz2d2cx.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkaz2d2cx.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpkaz2d2cx.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_number;\n  let max_diff = numbers[max_index] - max_number;\n  let min_closest = min_number;\n  let max_closest = max_number;\n  if (min_diff < max_diff) {\n    min_closest = min_number;\n    max_closest = max_number;\n  } else {\n    min_closest = max_number;\n    max_closest = min_number;\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpudnkewkh.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpudnkewkh.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpudnkewkh.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpudnkewkh.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpudnkewkh.rs:32:6\n   |\n32 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff < max_diff) {\n32 +   if min_diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudnkewkh.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudnkewkh.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpudnkewkh.rs:14:13\n   |\n14 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if diff < min_diff {\n      min_diff = diff;\n    }\n    let diff = i - max_value;\n    if diff > max_diff {\n      max_diff = diff;\n    }\n  }\n  let min_value_index = 0;\n  let max_value_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_value_index = i;\n    }\n    if i == max_value {\n      max_value_index = i;\n    }\n  }\n  let min_diff_index = 0;\n  let max_diff_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if diff < min_diff {\n      min_diff_index = i;\n    }\n    let diff = i - max_value;\n    if diff > max_diff {\n      max_diff_index = i;\n    }\n  }\n  let min_value_index_index = 0;\n  let max_value_index_index = 0;\n  for i in numbers.iter() {\n    if i == min_value_index {\n      min_value_index_index = i;\n    }\n    if i == max_value_index {\n      max_value_index_index = i;\n    }\n  \n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp15ld_5lk.rs:81:3\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - unclosed delimiter\n...\n64 |   for i in numbers.iter() {\n   |                           - this delimiter might not be properly closed...\n...\n72 | }\n   | - ...as it matches this but it has different indentation\n...\n81 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15ld_5lk.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15ld_5lk.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15ld_5lk.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp15ld_5lk.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmp15ld_5lk.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i6",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    let value = i;\n    if value < min_value {\n      min_value = value;\n      min_index = i;\n    }\n    if value > max_value {\n      max_value = value;\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:14:16\n   |\n14 |     if value < min_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:15:19\n   |\n9  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       min_value = value;\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       min_value = *value;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:16:19\n   |\n8  |   let min_index = 0;\n   |                   - expected due to this value\n...\n16 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:18:16\n   |\n18 |     if value > max_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:19:19\n   |\n11 |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n19 |       max_value = value;\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max_value = *value;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:20:19\n   |\n10 |   let max_index = 0;\n   |                   - expected due to this value\n...\n20 |       max_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for number in numbers {\n    if number < min_number {\n      min_number = number;\n    }\n    if number > max_number {\n      max_number = number;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for index in range(1, numbers.len()) {\n    let number = numbers[index];\n    if number < min_number {\n      min_number = number;\n      min_index = index;\n    }\n    if number > max_number {\n      max_number = number;\n      max_index = index;\n    }\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpdilg7cnr.rs:20:16\n   |\n20 |   for index in range(1, numbers.len()) {\n   |                ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  let min_closest = numbers[min_index];\n  let max_closest = numbers[max_index];\n  if min_diff < max_diff {\n    return (min_closest, max_closest);\n  } else {\n    return (max_closest, min_closest);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpw7erp7rh.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpw7erp7rh.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw7erp7rh.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw7erp7rh.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw7erp7rh.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw7erp7rh.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpw7erp7rh.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    } else if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    } else if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(min_number - numbers[0]);\n  let max_diff = abs(max_number - numbers[0]);\n  for i in numbers.iter() {\n    let diff = abs(i - numbers[0]);\n    if diff < min_diff {\n      min_diff = diff;\n      min_index = i;\n    } else if diff < max_diff {\n      max_diff = diff;\n      max_index = i;\n    }\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp4sjt932v.rs:26:18\n   |\n26 |   let min_diff = abs(min_number - numbers[0]);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp4sjt932v.rs:27:18\n   |\n27 |   let max_diff = abs(max_number - numbers[0]);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp4sjt932v.rs:29:16\n   |\n29 |     let diff = abs(i - numbers[0]);\n   |                ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4sjt932v.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4sjt932v.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4sjt932v.rs:13:19\n   |\n13 |     } else if i > max_number {\n   |                   ^^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4sjt932v.rs:14:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n14 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmp4sjt932v.rs:20:10\n   |\n20 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  if (min_diff > max_diff) {\n    let temp = min_value;\n    min_value = max_value;\n    max_value = temp;\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqdbbgem9.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqdbbgem9.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqdbbgem9.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqdbbgem9.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqdbbgem9.rs:32:8\n   |\n32 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < 0) {\n32 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqdbbgem9.rs:35:8\n   |\n35 |     if (diff > min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > min_diff) {\n35 +     if diff > min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqdbbgem9.rs:39:8\n   |\n39 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if (diff < 0) {\n39 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqdbbgem9.rs:42:8\n   |\n42",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  let min_diff_index = min_index;\n  let max_diff_index = max_index;\n  if (min_diff > max_diff) {\n    min_diff_index = max_index;\n    max_diff_index = min_index;\n  }\n  return (numbers[min_diff_index], numbers[max_diff_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:32:6\n   |\n32 |   if (min_diff > max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff > max_diff) {\n32 +   if min_diff > max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp34z12sbn.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp34z12sbn.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[0] - numbers[min_index];\n  let max_diff = numbers[0] - numbers[max_index];\n  let min_diff_index = 0;\n  let max_diff_index = 0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[0];\n    if (diff < min_diff) {\n      min_diff = diff;\n      min_diff_index = i;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n      max_diff_index = i;\n    }\n  }\n  let min_index_index = 0;\n  let max_index_index = 0;\n  for i in numbers.iter() {\n    if (i == min_index) {\n      min_index_index = i;\n    }\n    if (i == max_index) {\n      max_index_index = i;\n    }\n  }\n  let min_index_diff = numbers[min_index] - numbers[min_index_index];\n  let max_index_diff = numbers[max_index] - numbers[max_index_index];\n  let min_index_diff_index = 0;\n  let max_index_diff_index = 0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < min_index_diff) {\n      min_index_diff = diff;\n      min_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpky01ilwg.rs:71:3\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - unclosed delimiter\n...\n57 |   for i in numbers.iter() {\n   |                           - unclosed delimiter\n58 |     let diff = numbers[i] - numbers[min_index];\n59 |     if (diff < min_index_diff) {\n   |                                - this delimiter might not be properly closed...\n...\n62 | }\n   | - ...as it matches this but it has different indentation\n...\n71 | }\n   |   ^\n\nerror[E0425]: cannot find value `min_` in this scope\n  --> /tmp/tmpky01ilwg.rs:61:7\n   |\n61 |       min_\n   |       ^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpky01ilwg.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpky01ilwg.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpky01ilwg.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpky01ilwg.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpky01ilwg.rs:34:8\n   |\n34 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n34 -     if (diff < mi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_index_index = numbers.indexOf(min_index);\n  let max_index_index = numbers.indexOf(max_index);\n  let min_index_index_index = numbers.indexOf(min_index_index);\n  let max_index_index_index = numbers.indexOf(max_index_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpjcxvm594.rs:42:1\n   |\n42 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpjcxvm594.rs:41:64\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n41 |   let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index\n   |                                                                ^ unclosed delimiter\n42 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjcxvm594.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjcxvm594.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjcxvm594.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjcxvm594.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpjcxvm594.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    let diff_abs = abs(diff);\n    if (diff_abs < abs(diff - max_value)) {\n      min_index = i;\n      max_index = max_value;\n    } else {\n      min_index = min_value;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpuzttr1ch.rs:22:20\n   |\n22 |     let diff_abs = abs(diff);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpuzttr1ch.rs:23:20\n   |\n23 |     if (diff_abs < abs(diff - max_value)) {\n   |                    ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuzttr1ch.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuzttr1ch.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuzttr1ch.rs:23:8\n   |\n23 |     if (diff_abs < abs(diff - max_value)) {\n   |        ^                                ^\n   |\nhelp: remove these parentheses\n   |\n23 -     if (diff_abs < abs(diff - max_value)) {\n23 +     if diff_abs < abs(diff - max_value) {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuzttr1ch.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuzttr1ch.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuzttr1ch.rs:14:13\n   |\n14 |     if (i > max_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.find(i => i == min_value);\n  let max_value_index = numbers.find(i => i == max_value);\n  let min_value_index_index = numbers.find(i => i == min_value_index);\n  let max_value_index_index = numbers.find(i => i == max_value_index);\n  let min_value_index_index_index = numbers.find(i => i == min_value_index_index);\n  let max_value_index_index_index = numbers.find(i => i == max_value_index_index);\n  let min_value_index_index_index_index = numbers.find(i => i == min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.find(i => i == max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.find(i => i == min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.find(i => i == max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.find(i => i == min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.find(i => i == max_value_index_index_index\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp0biwypw3.rs:28:40\n   |\n28 |   let min_value_index = numbers.find(i => i == min_value);\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp0biwypw3.rs:39:67\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n39 |   let max_value_index_index_index_index_index_index = numbers.find(i => i == max_value_index_index_index\n   |                                                                   ^ unclosed delimiter\n40 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  let min_closest = min_value;\n  let max_closest = max_value;\n  if (min_diff < max_diff) {\n    min_closest = numbers[min_index];\n    max_closest = numbers[max_index];\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeh4hai7l.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeh4hai7l.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeh4hai7l.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeh4hai7l.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeh4hai7l.rs:32:6\n   |\n32 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff < max_diff) {\n32 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpeh4hai7l.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpeh4hai7l.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for number in numbers {\n    if number < min_number {\n      min_number = number;\n    }\n    if number > max_number {\n      max_number = number;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in 0..numbers.len() {\n    let number = numbers[i];\n    if number == min_number {\n      min_index = i;\n    }\n    if number == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_number;\n  let max_diff = numbers[max_index] - max_number;\n  let min_closest = numbers[min_index];\n  let max_closest = numbers[max_index];\n  if min_diff < max_diff {\n    min_closest, max_closest = max_closest, min_closest;\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `:`, found `=`\n  --> /tmp/tmp9_p1ub6k.rs:34:30\n   |\n34 |     min_closest, max_closest = max_closest, min_closest;\n   |                             -^\n   |                             |\n   |                             help: replace equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n  --> /tmp/tmp9_p1ub6k.rs:34:56\n   |\n33 |   if min_diff < max_diff {\n   |                 -------- while parsing this struct\n34 |     min_closest, max_closest = max_closest, min_closest;\n   |                                                        ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n  --> /tmp/tmp9_p1ub6k.rs:33:17\n   |\n33 |     if min_diff < max_diff {\n   |  _________________^\n34 | |     min_closest, max_closest = max_closest, min_closest;\n35 | |   }\n   | |___^\n   |\nhelp: surround the struct literal with parentheses\n   |\n33 ~   if min_diff < (max_diff {\n34 |     min_closest, max_closest = max_closest, min_closest;\n35 ~   })\n   |\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmp9_p1ub6k.rs:36:3\n   |\n33 |   if min_diff < max_diff {\n   |   -- this `if` expression has a condition, but no block\n...\n36 |   return (min_closest, max_closest);\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n36 |   { return (min_closest, max_closest); }\n   |   +                                    +\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_index_index = numbers.indexOf(min_index);\n  let max_index_index = numbers.indexOf(max_index);\n  let min_index_index_index = numbers.indexOf(min_index_index);\n  let max_index_index_index = numbers.indexOf(max_index_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpjcxvm594.rs:42:1\n   |\n42 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpjcxvm594.rs:41:64\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n41 |   let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index\n   |                                                                ^ unclosed delimiter\n42 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjcxvm594.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjcxvm594.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjcxvm594.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjcxvm594.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpjcxvm594.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmpzr7flb4s.rs:41:1\n   |\n41 | }\n   | ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let min_number = numbers[0];\n    let max_number = numbers[0];\n    for i in numbers.iter() {\n        if i < min_number {\n            min_number = i;\n        }\n        if i > max_number {\n            max_number = i;\n        }\n    }\n    let min_index = 0;\n    let max_index = 0;\n    for i in numbers.iter() {\n        if i == min_number {\n            min_index = i;\n        }\n        if i == max_number {\n            max_index = i;\n        }\n    }\n    let min_diff = abs(numbers[min_index] - min_number);\n    let max_diff = abs(numbers[max_index] - max_number);\n    let min_closest = numbers[min_index];\n    let max_closest = numbers[max_index];\n    if min_diff < max_diff {\n        min_closest, max_closest = max_closest, min_closest;\n    }\n    return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `:`, found `=`\n  --> /tmp/tmpcry2d37r.rs:33:34\n   |\n33 |         min_closest, max_closest = max_closest, min_closest;\n   |                                 -^\n   |                                 |\n   |                                 help: replace equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n  --> /tmp/tmpcry2d37r.rs:33:60\n   |\n32 |     if min_diff < max_diff {\n   |                   -------- while parsing this struct\n33 |         min_closest, max_closest = max_closest, min_closest;\n   |                                                            ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n  --> /tmp/tmpcry2d37r.rs:32:19\n   |\n32 |       if min_diff < max_diff {\n   |  ___________________^\n33 | |         min_closest, max_closest = max_closest, min_closest;\n34 | |     }\n   | |_____^\n   |\nhelp: surround the struct literal with parentheses\n   |\n32 ~     if min_diff < (max_diff {\n33 |         min_closest, max_closest = max_closest, min_closest;\n34 ~     })\n   |\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpcry2d37r.rs:35:5\n   |\n32 |     if min_diff < max_diff {\n   |     -- this `if` expression has a condition, but no block\n...\n35 |     return (min_closest, max_closest);\n   |     ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n35 |     { return (min_closest, max_closest); }\n   |     +                                    +\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpcry2d37r.rs:28:20\n   |\n28 |     let min_diff = abs(numbers[min_index] - min_number);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpcry2d37r.rs:29:20\n   |\n29 |     let max_diff = abs(numbers[max_index] - max_number);\n   |                    ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcry2d37r.rs:11:16\n   |\n11 |         if i < min_number {\n   |                ^^^^^^^^^^\n   |                |\n   |                expecte",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_index + 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_index - 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_index - 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_index + 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_index - 1] + 1);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_index + 1] - 1);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_index + 1] - 1);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_index + 1] + 1);\n  let min_value_index_prev_next_next = numbers.indexOf(numbers[min_index - 1] + 1) + 1;\n  let max_value_index_prev_next_prev = numbers.indexOf(numbers[max_index + 1] - 1) - 1;\n  let min_value_index_prev_next_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0ssaw4i8.rs:40:33\n   |\n40 |   let min_value_index_prev_next_\n   |                                 ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0ssaw4i8.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0ssaw4i8.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0ssaw4i8.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0ssaw4i8.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0ssaw4i8.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0ssaw4i8.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpeqcwd_s_.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeqcwd_s_.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeqcwd_s_.rs:13:19\n   |\n13 |     } else if i > max_value {\n   |                   ^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeqcwd_s_.rs:14:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n14 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpeqcwd_s_.rs:20:10\n   |\n20 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeqcwd_s_.rs:21:19\n   |\n17 |   let min_index = 0;\n   |                   - expected due to this value\n...\n21 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpeqcwd_s_.rs:22:17\n   |\n22 |     } else if i == max_val",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  let min_index_2 = 0;\n  let max_index_2 = 0;\n  for i in numbers.iter() {\n    if abs(i - min_value) < min_diff {\n      min_index_2 = i;\n    }\n    if abs(i - max_value) < max_diff {\n      max_index_2 = i;\n    }\n  }\n  let min_diff_2 = abs(numbers[min_index_2] - min_value);\n  let max_diff_2 = abs(numbers[max_index_2] - max_value);\n  let min_index_3 = 0;\n  let max_index_3 = 0;\n  for i in numbers.iter() {\n    if abs(i - min_value) < min_diff_2 {\n      min_index_3 = i;\n    }\n    if abs(i - max_value) < max_diff_2 {\n      max_index_3 = i;\n    }\n  }\n  let min_diff_3 = abs(numbers[min_index_3] - min_value);\n  let max_diff_3 = abs(numbers[max_index_3] - max_value);\n  let min_index_4 = 0;\n  let max_index_4 = 0;\n  for i in numbers.iter() {\n    if\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnuz3q4sq.rs:67:3\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - unclosed delimiter\n...\n56 |   for i in numbers.iter() {\n   |                           - this delimiter might not be properly closed...\n57 |     if\n58 | }\n   | - ...as it matches this but it has different indentation\n...\n67 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpnuz3q4sq.rs:58:1\n   |\n58 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnuz3q4sq.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnuz3q4sq.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnuz3q4sq.rs:33:8\n   |\n33 |     if abs(i - min_value) < min_diff {\n   |        ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnuz3q4sq.rs:36:8\n   |\n36 |     if abs(i - max_value) < max_diff {\n   |        ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnuz3q4sq.rs:40:20\n   |\n40 |   let min_diff_2 = abs(numbers[min_index_2] - min_value);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnuz3q4sq.rs:41:20\n   |\n41 |   let max_diff_2 = abs(numbers[max_index_2] - max_value);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnuz3q4sq.rs:45:8\n   |\n45 |     if abs(i - min_value) < min_diff_2 {\n   |        ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpnuz3q4sq.rs:48:8\n   |\n48 |     if abs(i - max_value) < max_diff_2 {\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index < max_value_index) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprc7h21se.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprc7h21se.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprc7h21se.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprc7h21se.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprc7h21se.rs:30:6\n   |\n30 |   if (min_value_index < max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index < max_value_index) {\n30 +   if min_value_index < max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprc7h21se.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_other = numbers[min_index];\n  let max_other = numbers[max_index];\n  for i in numbers.iter() {\n    if (numbers[i] == min_other) {\n      min_other = numbers[max_index];\n    }\n    if (numbers[i] == max_other) {\n      max_other = numbers[min_index];\n    }\n  }\n  return (min_other, max_other);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj5k_3qi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj5k_3qi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj5k_3qi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj5k_3qi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj5k_3qi.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj5k_3qi.rs:35:8\n   |\n35 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > max_diff) {\n35 +     if diff > max_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj5k_3qi.rs:42:8\n   |\n42 |     if (numbers[i] == min_other) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n42 -     if (numbers[i] == min_other) {\n42 +     if numbers[i] == min_other {\n   | \n\nwarni",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_number;\n    if diff < min_diff {\n      min_diff = diff;\n      min_index = i;\n    }\n    let diff = i - max_number;\n    if diff > max_diff {\n      max_diff = diff;\n      max_index = i;\n    }\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpbp9km8fy.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbp9km8fy.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbp9km8fy.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbp9km8fy.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpbp9km8fy.rs:21:10\n   |\n21 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbp9km8fy.rs:22:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n22 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpbp9km8fy.rs:24:10\n   |\n24 |     if i == max_number {\n   |          ^^ ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0\n  let min_value = numbers[0]\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    let value = i\n    if value < min_value {\n      min_value = value\n      min_index = i\n    }\n    if value > max_value {\n      max_value = value\n      max_index = i\n    }\n  }\n  return (min_value, max_value)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp43bfvpzn.rs:8:20\n  |\n8 |   let min_index = 0\n  |                    ^ help: add `;` here\n9 |   let min_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp43bfvpzn.rs:9:29\n   |\n9  |   let min_value = numbers[0]\n   |                             ^ help: add `;` here\n10 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp43bfvpzn.rs:10:20\n   |\n10 |   let max_index = 0\n   |                    ^ help: add `;` here\n11 |   let max_value = numbers[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp43bfvpzn.rs:11:29\n   |\n11 |   let max_value = numbers[0]\n   |                             ^ help: add `;` here\n12 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp43bfvpzn.rs:13:18\n   |\n13 |     let value = i\n   |                  ^ help: add `;` here\n14 |     if value < min_value {\n   |     -- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp43bfvpzn.rs:15:24\n   |\n15 |       min_value = value\n   |                        ^ help: add `;` here\n16 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp43bfvpzn.rs:19:24\n   |\n19 |       max_value = value\n   |                        ^ help: add `;` here\n20 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43bfvpzn.rs:14:16\n   |\n14 |     if value < min_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43bfvpzn.rs:15:19\n   |\n9  |   let min_value = numbers[0]\n   |                   ---------- expected due to this value\n...\n15 |       min_value = value\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider deref",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff < min_value {\n      min_value = diff;\n      min_index = i;\n    }\n    let diff = max_value - i;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff < max_value {\n      max_value = diff;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:22:15\n   |\n22 |     if diff < 0 {\n   |               ^\n   |               |\n   |               expected `f64`, found integer\n   |               help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:27:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n27 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:30:15\n   |\n30 |     if diff < 0 {\n   |               ^\n   |               |\n   |               expected `f64`, found integer\n   |               help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:35:19\n   |\n19 |   let max_index = 0;\n   |                   - expected due to this value\n...\n3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    } else if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff < min_value) {\n      min_value = diff;\n      min_index = i;\n    }\n    diff = i - max_value;\n    if (diff > 0) {\n      diff = -diff;\n    }\n    if (diff > max_value) {\n      max_value = diff;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw6207k5m.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw6207k5m.rs:13:15\n   |\n13 |     } else if (i > max_value) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i > max_value) {\n13 +     } else if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw6207k5m.rs:21:8\n   |\n21 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (diff < 0) {\n21 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw6207k5m.rs:24:8\n   |\n24 |     if (diff < min_value) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (diff < min_value) {\n24 +     if diff < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw6207k5m.rs:29:8\n   |\n29 |     if (diff > 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n29 -     if (diff > 0) {\n29 +     if diff > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw6207k5m.rs:32:8\n   |\n32 |     if (diff > max_value) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff > max_value) {\n32 +     if diff > max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw6207k5m.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw6207k5m.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    diff = i - max_value;\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_diff_index = numbers.indexOf(min_diff);\n  let max_diff_index = numbers.indexOf(max_diff);\n  let min_index_index = numbers.indexOf(min_index);\n  let max_index_index = numbers.indexOf(max_index);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_diff_index_index = numbers.indexOf(min_diff_index);\n  let max_diff_index_index = numbers.indexOf(max_diff_index);\n  let min_index_index_index = numbers.indexOf(min_index_index);\n  let max_index_index_index = numbers.indexOf(max_index_index);\n  let min_value_index_index_index = numbers.indexOf(min\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpsmt6iotx.rs:53:1\n   |\n53 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpsmt6iotx.rs:52:52\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n52 |   let min_value_index_index_index = numbers.indexOf(min\n   |                                                    ^ unclosed delimiter\n53 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsmt6iotx.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsmt6iotx.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsmt6iotx.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsmt6iotx.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsmt6iotx.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsmt6iotx.rs:36:8\n   |\n36 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for (let i = 1; i < numbers.len(); i++) {\n    let value = numbers[i];\n    if (value < min_value) {\n      min_value = value;\n      min_index = i;\n    }\n    if (value > max_value) {\n      max_value = value;\n      max_index = i;\n    }\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4_a59bb6.rs:12:8\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4_a59bb6.rs:12:12\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4_a59bb6.rs:12:14\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4_a59bb6.rs:12:13\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4_a59bb6.rs:12:14\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_number;\n  let max_diff = numbers[max_index] - max_number;\n  let min_closest = numbers[min_index];\n  let max_closest = numbers[max_index];\n  if (min_diff < max_diff) {\n    min_closest = numbers[min_index];\n    max_closest = numbers[max_index];\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppdscjrpp.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppdscjrpp.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppdscjrpp.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppdscjrpp.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppdscjrpp.rs:32:6\n   |\n32 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff < max_diff) {\n32 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmppdscjrpp.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmppdscjrpp.rs:12:20",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_number;\n  let max_diff = numbers[max_index] - max_number;\n  let min_index_diff = numbers[min_index] - numbers[max_index];\n  let max_index_diff = numbers[max_index] - numbers[min_index];\n  if (min_diff < max_diff) {\n    return (numbers[min_index], numbers[max_index]);\n  } else {\n    return (numbers[max_index], numbers[min_index]);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps5_ssxbu.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps5_ssxbu.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps5_ssxbu.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps5_ssxbu.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps5_ssxbu.rs:32:6\n   |\n32 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff < max_diff) {\n32 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmps5_ssxbu.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmps5_ssxbu.rs:12:20",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0\n  let min_value = numbers[0]\n  let max_index = 0\n  let max_value = numbers[0]\n\n  for i in numbers.iter() {\n    let value = i\n    if value < min_value {\n      min_value = value\n      min_index = i\n    }\n    if value > max_value {\n      max_value = value\n      max_index = i\n    }\n  }\n\n  return (min_value, max_value)\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp0gp4zlh6.rs:8:20\n  |\n8 |   let min_index = 0\n  |                    ^ help: add `;` here\n9 |   let min_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp0gp4zlh6.rs:9:29\n   |\n9  |   let min_value = numbers[0]\n   |                             ^ help: add `;` here\n10 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp0gp4zlh6.rs:10:20\n   |\n10 |   let max_index = 0\n   |                    ^ help: add `;` here\n11 |   let max_value = numbers[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp0gp4zlh6.rs:11:29\n   |\n11 |   let max_value = numbers[0]\n   |                             ^ help: add `;` here\n12 | \n13 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp0gp4zlh6.rs:14:18\n   |\n14 |     let value = i\n   |                  ^ help: add `;` here\n15 |     if value < min_value {\n   |     -- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp0gp4zlh6.rs:16:24\n   |\n16 |       min_value = value\n   |                        ^ help: add `;` here\n17 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp0gp4zlh6.rs:20:24\n   |\n20 |       max_value = value\n   |                        ^ help: add `;` here\n21 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0gp4zlh6.rs:15:16\n   |\n15 |     if value < min_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0gp4zlh6.rs:16:19\n   |\n9  |   let min_value = numbers[0]\n   |                   ---------- expected due to this value\n...\n16 |       min_value = value\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(min_value - numbers[0]);\n  let max_diff = abs(max_value - numbers[0]);\n  for i in numbers.iter() {\n    let diff = abs(i - numbers[0]);\n    if diff < min_diff {\n      min_diff = diff;\n      min_index = i;\n    } else if diff < max_diff {\n      max_diff = diff;\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpct36oy0s.rs:26:18\n   |\n26 |   let min_diff = abs(min_value - numbers[0]);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpct36oy0s.rs:27:18\n   |\n27 |   let max_diff = abs(max_value - numbers[0]);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpct36oy0s.rs:29:16\n   |\n29 |     let diff = abs(i - numbers[0]);\n   |                ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct36oy0s.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct36oy0s.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct36oy0s.rs:13:19\n   |\n13 |     } else if i > max_value {\n   |                   ^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpct36oy0s.rs:14:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n14 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpct36oy0s.rs:20:10\n   |\n20 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for (let i = 1; i < numbers.len(); i++) {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n      min_index = i;\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpcr41jm09.rs:12:8\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpcr41jm09.rs:12:12\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpcr41jm09.rs:12:14\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcr41jm09.rs:12:13\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpcr41jm09.rs:12:14\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    } else if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    } else if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphm223l51.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphm223l51.rs:13:15\n   |\n13 |     } else if (i > max_number) {\n   |               ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i > max_number) {\n13 +     } else if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphm223l51.rs:20:8\n   |\n20 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i == min_number) {\n20 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphm223l51.rs:22:15\n   |\n22 |     } else if (i == max_number) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == max_number) {\n22 +     } else if i == max_number {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmphm223l51.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphm223l51.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphm223l51.rs:13:20\n   |\n13 |     } else if (i > max_number) {\n   |                    ^^^^^^^^^^\n   |                    |\n   |                    expected `&f64`, found `f64`\n   |                    help: consider borrowing here: `&max_num",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  let min_diff_index = min_index;\n  let max_diff_index = max_index;\n  if min_diff > max_diff {\n    min_diff_index = max_index;\n    max_diff_index = min_index;\n  }\n  return (numbers[min_diff_index], numbers[max_diff_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpcvwoah_g.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvwoah_g.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvwoah_g.rs:13:19\n   |\n13 |     } else if i > max_value {\n   |                   ^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvwoah_g.rs:14:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n14 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpcvwoah_g.rs:20:10\n   |\n20 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcvwoah_g.rs:21:19\n   |\n17 |   let min_index = 0;\n   |                   - expected due to this value\n...\n21 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpcvwoah_g.rs:22:17\n   |\n22 |     } else if i == max_val",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for number in numbers {\n    if number < min_number {\n      min_number = number;\n    } else if number > max_number {\n      max_number = number;\n    }\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `min_number`\n  --> /tmp/tmpz02fdx7y.rs:12:7\n   |\n8  |   let min_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `min_number`\n   |       help: consider making this binding mutable: `mut min_number`\n...\n12 |       min_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_number`\n  --> /tmp/tmpz02fdx7y.rs:14:7\n   |\n9  |   let max_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `max_number`\n   |       help: consider making this binding mutable: `mut max_number`\n...\n14 |       max_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for number in numbers {\n    if number < min_number {\n      min_number = number;\n    }\n    if number > max_number {\n      max_number = number;\n    }\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `min_number`\n  --> /tmp/tmpmhupple1.rs:12:7\n   |\n8  |   let min_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `min_number`\n   |       help: consider making this binding mutable: `mut min_number`\n...\n12 |       min_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_number`\n  --> /tmp/tmpmhupple1.rs:15:7\n   |\n9  |   let max_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `max_number`\n   |       help: consider making this binding mutable: `mut max_number`\n...\n15 |       max_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value_plus_diff = min_value + min_diff;\n  let max_value_plus_diff = max_value + max_diff;\n  let min_index_plus_diff = min_index + min_diff;\n  let max_index_plus_diff = max_index + max_diff;\n  let min_value_minus_diff = min_value - min_diff;\n  let max_value_minus_diff = max_value - max_diff;\n  let min_index_minus_diff = min_index - min_diff;\n  let max_index_minus_diff = max_index - max_diff;\n  let min_value_plus_min_diff = min_value + min_diff;\n  let max_value_plus_max_diff = max_value + max_diff;\n  let min_index_plus_min_diff = min_index + min_diff;\n  let max_index_plus_max_diff = max_index + max_diff;\n  let min_value_minus_min_diff = min_value - min_diff;\n  let max_value_minus_max_diff\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp1tf4q_lw.rs:52:31\n   |\n52 |   let max_value_minus_max_diff\n   |                               ^ help: add `;` here\n53 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1tf4q_lw.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1tf4q_lw.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1tf4q_lw.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1tf4q_lw.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1tf4q_lw.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1tf4q_lw.rs:35:8\n   |\n35 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > max_diff) {\n35 +     if diff > max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1tf4q_lw.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev + 1]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_value_index_prev + 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmph6wwqylv.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmph6wwqylv.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmph6wwqylv.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let min_val = numbers[0];\n    let max_val = numbers[0];\n    for i in numbers.iter() {\n        if i < min_val {\n            min_val = i;\n        }\n        if i > max_val {\n            max_val = i;\n        }\n    }\n    let min_index = 0;\n    let max_index = 0;\n    for i in numbers.iter() {\n        if i == min_val {\n            min_index = i;\n        }\n        if i == max_val {\n            max_index = i;\n        }\n    }\n    return (min_val, max_val);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpm92ct1op.rs:11:16\n   |\n11 |         if i < min_val {\n   |                ^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm92ct1op.rs:12:23\n   |\n8  |     let min_val = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |             min_val = i;\n   |                       ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |             min_val = *i;\n   |                       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm92ct1op.rs:14:16\n   |\n14 |         if i > max_val {\n   |                ^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&max_val`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm92ct1op.rs:15:23\n   |\n9  |     let max_val = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |             max_val = i;\n   |                       ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |             max_val = *i;\n   |                       +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpm92ct1op.rs:21:14\n   |\n21 |         if i == min_val {\n   |              ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm92ct1op.rs:22:25\n   |\n18 |     let min_index = 0;\n   |                     - expected due to this value\n...\n22 |             min_index = i;\n   |                         ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpm92ct1o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let min_value = numbers[0];\n    let max_value = numbers[0];\n    for i in numbers.iter() {\n        if (i < min_value) {\n            min_value = i;\n        }\n        if (i > max_value) {\n            max_value = i;\n        }\n    }\n    let min_index = 0;\n    let max_index = 0;\n    for i in numbers.iter() {\n        if (i == min_value) {\n            min_index = i;\n        }\n        if (i == max_value) {\n            max_index = i;\n        }\n    }\n    let min_diff = abs(numbers[min_index] - min_value);\n    let max_diff = abs(numbers[max_index] - max_value);\n    let min_index_2 = 0;\n    let max_index_2 = 0;\n    for i in numbers.iter() {\n        if (abs(i - min_value) < min_diff) {\n            min_index_2 = i;\n        }\n        if (abs(i - max_value) < max_diff) {\n            max_index_2 = i;\n        }\n    }\n    let min_diff_2 = abs(numbers[min_index_2] - min_value);\n    let max_diff_2 = abs(numbers[max_index_2] - max_value);\n    let min_index_3 = 0;\n    let max_index_3 = 0;\n    for i in numbers.iter() {\n        if (abs(i - min_value) < min_diff_2) {\n            min_index_3 = i;\n        }\n        if (abs(i - max_value) < max_diff_2) {\n            max_index_3 = i;\n        }\n    }\n    let min_diff_3 = abs(numbers[min_index_3] - min_value);\n    let max_diff_3 = abs(numbers[max_index_3] - max_value);\n    let min_index_4 = 0;\n    let max_index_4\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpmdvu5hq7.rs:55:20\n   |\n55 |     let max_index_4\n   |                    ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:28:20\n   |\n28 |     let min_diff = abs(numbers[min_index] - min_value);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:29:20\n   |\n29 |     let max_diff = abs(numbers[max_index] - max_value);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:33:13\n   |\n33 |         if (abs(i - min_value) < min_diff) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:36:13\n   |\n36 |         if (abs(i - max_value) < max_diff) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:40:22\n   |\n40 |     let min_diff_2 = abs(numbers[min_index_2] - min_value);\n   |                      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:41:22\n   |\n41 |     let max_diff_2 = abs(numbers[max_index_2] - max_value);\n   |                      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:45:13\n   |\n45 |         if (abs(i - min_value) < min_diff_2) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:48:13\n   |\n48 |         if (abs(i - max_value) < max_diff_2) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5hq7.rs:52:22\n   |\n52 |     let min_diff_3 = abs(numbers[min_index_3] - min_value);\n   |                      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpmdvu5",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    } else if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    } else if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphm223l51.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphm223l51.rs:13:15\n   |\n13 |     } else if (i > max_number) {\n   |               ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i > max_number) {\n13 +     } else if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphm223l51.rs:20:8\n   |\n20 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i == min_number) {\n20 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphm223l51.rs:22:15\n   |\n22 |     } else if (i == max_number) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == max_number) {\n22 +     } else if i == max_number {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmphm223l51.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphm223l51.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphm223l51.rs:13:20\n   |\n13 |     } else if (i > max_number) {\n   |                    ^^^^^^^^^^\n   |                    |\n   |                    expected `&f64`, found `f64`\n   |                    help: consider borrowing here: `&max_num",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmpzr7flb4s.rs:41:1\n   |\n41 | }\n   | ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    } else if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    } else if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_number);\n  let max_diff = abs(numbers[max_index] - max_number);\n  if min_diff < max_diff {\n    return (min_number, max_number);\n  } else {\n    return (max_number, min_number);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmppw0sdvgg.rs:26:18\n   |\n26 |   let min_diff = abs(numbers[min_index] - min_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmppw0sdvgg.rs:27:18\n   |\n27 |   let max_diff = abs(numbers[max_index] - max_number);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppw0sdvgg.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppw0sdvgg.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppw0sdvgg.rs:13:19\n   |\n13 |     } else if i > max_number {\n   |                   ^^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppw0sdvgg.rs:14:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n14 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmppw0sdvgg.rs:20:10\n   |\n20 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0\n  let min_value = numbers[0]\n  let max_index = 0\n  let max_value = numbers[0]\n\n  for i in numbers.iter() {\n    if numbers[i] < min_value {\n      min_value = numbers[i]\n      min_index = i\n    }\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n\n  return (numbers[min_index], numbers[max_index])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp0qj48vkt.rs:8:20\n  |\n8 |   let min_index = 0\n  |                    ^ help: add `;` here\n9 |   let min_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp0qj48vkt.rs:9:29\n   |\n9  |   let min_value = numbers[0]\n   |                             ^ help: add `;` here\n10 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp0qj48vkt.rs:10:20\n   |\n10 |   let max_index = 0\n   |                    ^ help: add `;` here\n11 |   let max_value = numbers[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp0qj48vkt.rs:11:29\n   |\n11 |   let max_value = numbers[0]\n   |                             ^ help: add `;` here\n12 | \n13 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmp0qj48vkt.rs:15:29\n   |\n15 |       min_value = numbers[i]\n   |                             ^ help: add `;` here\n16 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp0qj48vkt.rs:19:29\n   |\n19 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n20 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0qj48vkt.rs:14:8\n   |\n14 |     if numbers[i] < min_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0qj48vkt.rs:15:19\n   |\n15 |       min_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not impleme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[0] - numbers[min_index];\n  let max_diff = numbers[0] - numbers[max_index];\n  let min_diff_index = 0;\n  let max_diff_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_diff_index = i;\n    }\n    if (i == max_number) {\n      max_diff_index = i;\n    }\n  }\n  let min_diff_diff = numbers[0] - numbers[min_diff_index];\n  let max_diff_diff = numbers[0] - numbers[max_diff_index];\n  if (min_diff < max_diff) {\n    return (min_number, max_number);\n  } else {\n    return (min_number, min_number);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm7vnzs92.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm7vnzs92.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm7vnzs92.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm7vnzs92.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm7vnzs92.rs:33:8\n   |\n33 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n33 -     if (i == min_number) {\n33 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm7vnzs92.rs:36:8\n   |\n36 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if (i == max_number) {\n36 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm7vnzs92.rs:42:6\n   |\n42 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n42 -   if (min_diff < max_diff) {\n42 +   if min_diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm7vnzs92.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    let diff_abs = abs(diff);\n    if diff_abs < abs(max_value - min_value) {\n      min_index = i;\n      max_index = i;\n    } else if diff_abs == abs(max_value - min_value) {\n      if diff > 0 {\n        min_index = i;\n        max_index = i;\n      } else {\n        min_index = i;\n      }\n    } else {\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpv_l960he.rs:22:20\n   |\n22 |     let diff_abs = abs(diff);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpv_l960he.rs:23:19\n   |\n23 |     if diff_abs < abs(max_value - min_value) {\n   |                   ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpv_l960he.rs:26:27\n   |\n26 |     } else if diff_abs == abs(max_value - min_value) {\n   |                           ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_l960he.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_l960he.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_l960he.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_l960he.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_l960he.rs:24:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n24 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0308]: mismatched types\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_result = numbers[min_index];\n  let max_result = numbers[max_index];\n  if (min_diff > max_diff) {\n    min_result = numbers[max_index];\n    max_result = numbers[min_index];\n  }\n  return (min_result, max_result);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbbz3xlyq.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbbz3xlyq.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbbz3xlyq.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbbz3xlyq.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbbz3xlyq.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbbz3xlyq.rs:36:8\n   |\n36 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if (diff > max_diff) {\n36 +     if diff > max_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbbz3xlyq.rs:42:6\n   |\n42 |   if (min_diff > max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n42 -   if (min_diff > max_diff) {\n42 +   if min_diff > max_diff {\n   | \n\nerror[E0277]: the type `[f64]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  if (min_diff < max_diff) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    } else if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n      min_index = i;\n    } else if (i > max_value) {\n      max_value = i;\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpoeplbrl4.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpoeplbrl4.rs:13:15\n   |\n13 |     } else if (i > max_value) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i > max_value) {\n13 +     } else if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpoeplbrl4.rs:20:8\n   |\n20 |     if (i < min_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i < min_value) {\n20 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpoeplbrl4.rs:23:15\n   |\n23 |     } else if (i > max_value) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n23 -     } else if (i > max_value) {\n23 +     } else if i > max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoeplbrl4.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoeplbrl4.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoeplbrl4.rs:13:20\n   |\n13 |     } else if (i > max_value) {\n   |                    ^^^^^^^^^\n   |                    |\n   |                    expected `&f64`, found `f64`\n   |                    help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  let min_closest = numbers[min_index];\n  let max_closest = numbers[max_index];\n  if (min_diff < max_diff) {\n    min_closest = numbers[min_index];\n    max_closest = numbers[max_index];\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpslp9pbt7.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpslp9pbt7.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpslp9pbt7.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpslp9pbt7.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpslp9pbt7.rs:32:6\n   |\n32 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff < max_diff) {\n32 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpslp9pbt7.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpslp9pbt7.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_plus_one = min_value_index + 1;\n  let max_value_index_plus_one = max_value_index + 1;\n  let min_value_index_minus_one = min_value_index - 1;\n  let max_value_index_minus_one = max_value_index - 1;\n  let min_value_index_plus_two = min_value_index + 2;\n  let max_value_index_plus_two = max_value_index + 2;\n  let min_value_index_minus_two = min_value_index - 2;\n  let max_value_index_minus_two = max_value_index - 2;\n  let min_value_index_plus_three = min_value_index + 3;\n  let max_value_index_plus_three = max_value_index + 3;\n  let min_value_index_minus_three = min_value_index - 3;\n  let max_value_index_minus_three = max_value_index - 3;\n  let min_value_index_plus_four = min_value_index + 4;\n  let max_value_index_plus_four = max_value_index + 4;\n  let min_value_index_minus_four = min_value_index - 4;\n  let max_value_index\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpphz3bt39.rs:45:22\n   |\n45 |   let max_value_index\n   |                      ^ help: add `;` here\n46 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpphz3bt39.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpphz3bt39.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpphz3bt39.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpphz3bt39.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpphz3bt39.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpphz3bt39.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpphz3bt39.rs:14:13\n   |\n14 |     if (i > max_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmpzr7flb4s.rs:41:1\n   |\n41 | }\n   | ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff < min_value {\n      min_value = diff;\n      min_index = i;\n    }\n    let diff = max_value - i;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff < max_value {\n      max_value = diff;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:22:15\n   |\n22 |     if diff < 0 {\n   |               ^\n   |               |\n   |               expected `f64`, found integer\n   |               help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:27:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n27 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:30:15\n   |\n30 |     if diff < 0 {\n   |               ^\n   |               |\n   |               expected `f64`, found integer\n   |               help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:35:19\n   |\n19 |   let max_index = 0;\n   |                   - expected due to this value\n...\n3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_number);\n  let max_diff = abs(numbers[max_index] - max_number);\n  if min_diff < max_diff {\n    return (min_number, max_number);\n  } else {\n    return (max_number, min_number);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmppfjcpt6l.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmppfjcpt6l.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_number);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfjcpt6l.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfjcpt6l.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfjcpt6l.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfjcpt6l.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmppfjcpt6l.rs:21:10\n   |\n21 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    let diff = i - max_value;\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_closest = 0.0;\n  let max_closest = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < min_diff) {\n      min_diff = diff;\n      min_closest = i;\n    }\n    let diff = i - max_value;\n    if (diff > max_diff) {\n      max_diff = diff;\n      max_closest = i;\n    }\n  }\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpin9xgwpv.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpin9xgwpv.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpin9xgwpv.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpin9xgwpv.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpin9xgwpv.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpin9xgwpv.rs:36:8\n   |\n36 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if (diff > max_diff) {\n36 +     if diff > max_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpin9xgwpv.rs:44:8\n   |\n44 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n44 -     if (diff < min_diff) {\n44 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpin9xgwpv.rs:49:8\n   |\n49 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these pare",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    let value = i;\n    if value < min_value {\n      min_value = value;\n      min_index = i;\n    }\n    if value > max_value {\n      max_value = value;\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:14:16\n   |\n14 |     if value < min_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:15:19\n   |\n9  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       min_value = value;\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       min_value = *value;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:16:19\n   |\n8  |   let min_index = 0;\n   |                   - expected due to this value\n...\n16 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:18:16\n   |\n18 |     if value > max_value {\n   |                ^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:19:19\n   |\n11 |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n19 |       max_value = value;\n   |                   ^^^^^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max_value = *value;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ii2idlv.rs:20:19\n   |\n10 |   let max_index = 0;\n   |                   - expected due to this value\n...\n20 |       max_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  return (min_value_index, max_value_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpszx3qnjj.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpszx3qnjj.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: requi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_val = numbers[0];\n  let max_val = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_val) {\n      min_val = i;\n    }\n    if (i > max_val) {\n      max_val = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_val) {\n      min_index = i;\n    }\n    if (i == max_val) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_val;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    let diff = i - max_val;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_diff_index = 0;\n  let max_diff_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_val;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff < min_diff) {\n      min_diff_index = i;\n    }\n    let diff = i - max_val;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff < max_diff) {\n      max_diff_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj50fwqms.rs:11:8\n   |\n11 |     if (i < min_val) {\n   |        ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_val) {\n11 +     if i < min_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj50fwqms.rs:14:8\n   |\n14 |     if (i > max_val) {\n   |        ^           ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_val) {\n14 +     if i > max_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj50fwqms.rs:21:8\n   |\n21 |     if (i == min_val) {\n   |        ^            ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_val) {\n21 +     if i == min_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj50fwqms.rs:24:8\n   |\n24 |     if (i == max_val) {\n   |        ^            ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_val) {\n24 +     if i == max_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj50fwqms.rs:32:8\n   |\n32 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < 0) {\n32 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj50fwqms.rs:35:8\n   |\n35 |     if (diff > min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > min_diff) {\n35 +     if diff > min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj50fwqms.rs:39:8\n   |\n39 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if (diff < 0) {\n39 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj50fwqms.rs:42:8\n   |\n42 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n42 -     if (diff > max_diff) {\n42 +     if diff > max_diff {\n   | \n\nwarnin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if min_diff < max_diff {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmplkelglm_.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmplkelglm_.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkelglm_.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmplkelglm_.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index == max_value_index) {\n    return (min_value, max_value);\n  }\n  if (min_value_index > max_value_index) {\n    return (max_value, min_value);\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzid4kbsa.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzid4kbsa.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzid4kbsa.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzid4kbsa.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzid4kbsa.rs:30:6\n   |\n30 |   if (min_value_index == max_value_index) {\n   |      ^                                  ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index == max_value_index) {\n30 +   if min_value_index == max_value_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzid4kbsa.rs:33:6\n   |\n33 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n33 -   if (min_value_index > max_value_index) {\n33 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzid4kbsa.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n      min_index = i;\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjakyjftr.rs:13:8\n   |\n13 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (numbers[i] < min_value) {\n13 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjakyjftr.rs:17:8\n   |\n17 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (numbers[i] > max_value) {\n17 +     if numbers[i] > max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpjakyjftr.rs:13:9\n   |\n13 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpjakyjftr.rs:14:19\n   |\n14 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjakyjftr.rs:15:19\n   |\n8  |   let min_index = 0;\n   |                   - expected due to this value\n...\n15 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpjakyjftr.rs:17:9\n   |\n17 |     if (numbers[i] > max_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    } else if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    } else if (i == max_value) {\n      max_index = i;\n    }\n  }\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9ky5gujn.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9ky5gujn.rs:13:15\n   |\n13 |     } else if (i > max_value) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i > max_value) {\n13 +     } else if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9ky5gujn.rs:20:8\n   |\n20 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i == min_value) {\n20 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9ky5gujn.rs:22:15\n   |\n22 |     } else if (i == max_value) {\n   |               ^              ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == max_value) {\n22 +     } else if i == max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ky5gujn.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ky5gujn.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ky5gujn.rs:13:20\n   |\n13 |     } else if (i > max_value) {\n   |                    ^^^^^^^^^\n   |                    |\n   |                    expected `&f64`, found `f64`\n   |                    help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatch",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for number in numbers {\n    if number < min_number {\n      min_number = number;\n    } else if number > max_number {\n      max_number = number;\n    }\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `min_number`\n  --> /tmp/tmpz02fdx7y.rs:12:7\n   |\n8  |   let min_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `min_number`\n   |       help: consider making this binding mutable: `mut min_number`\n...\n12 |       min_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_number`\n  --> /tmp/tmpz02fdx7y.rs:14:7\n   |\n9  |   let max_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `max_number`\n   |       help: consider making this binding mutable: `mut max_number`\n...\n14 |       max_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for number in numbers {\n    if number < min_number {\n      min_number = number;\n    }\n    if number > max_number {\n      max_number = number;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in 0..numbers.len() - 1 {\n    let number = numbers[i];\n    if number == min_number {\n      min_index = i;\n    }\n    if number == max_number {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `min_number`\n  --> /tmp/tmpp6xnpn9a.rs:12:7\n   |\n8  |   let min_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `min_number`\n   |       help: consider making this binding mutable: `mut min_number`\n...\n12 |       min_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_number`\n  --> /tmp/tmpp6xnpn9a.rs:15:7\n   |\n9  |   let max_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `max_number`\n   |       help: consider making this binding mutable: `mut max_number`\n...\n15 |       max_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpp6xnpn9a.rs:20:15\n    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    |                          ------- move occurs because `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n10  |   for number in numbers {\n    |                 ------- `numbers` moved due to this implicit call to `.into_iter()`\n...\n20  |   for i in 0..numbers.len() - 1 {\n    |               ^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n    |\n10  |   for number in &numbers {\n    |                 +\n\nerror[E0384]: cannot assign twice to immutable variable `min_index`\n  --> /tmp/tmpp6xnpn9a.rs:23:7\n   |\n18 |   let min_index = 0;\n   |       ---------\n   |       |\n   |       first assignment to `min_index`\n   |       help: consider making this binding mutable: `mut min_index`\n...\n23 |       min_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpp6xnpn9a.rs:2",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_number);\n  let max_diff = abs(numbers[max_index] - max_number);\n  let min_index_next = 0;\n  let max_index_next = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index_next = i;\n    }\n    if i == max_number {\n      max_index_next = i;\n    }\n  }\n  let min_diff_next = abs(numbers[min_index_next] - min_number);\n  let max_diff_next = abs(numbers[max_index_next] - max_number);\n  if (min_diff_next < min_diff) {\n    min_diff = min_diff_next;\n    min_index = min_index_next;\n  }\n  if (max_diff_next < max_diff) {\n    max_diff = max_diff_next;\n    max_index = max_index_next;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp9v55pag7.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp9v55pag7.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp9v55pag7.rs:40:23\n   |\n40 |   let min_diff_next = abs(numbers[min_index_next] - min_number);\n   |                       ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp9v55pag7.rs:41:23\n   |\n41 |   let max_diff_next = abs(numbers[max_index_next] - max_number);\n   |                       ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9v55pag7.rs:42:6\n   |\n42 |   if (min_diff_next < min_diff) {\n   |      ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n42 -   if (min_diff_next < min_diff) {\n42 +   if min_diff_next < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9v55pag7.rs:46:6\n   |\n46 |   if (max_diff_next < max_diff) {\n   |      ^                        ^\n   |\nhelp: remove these parentheses\n   |\n46 -   if (max_diff_next < max_diff) {\n46 +   if max_diff_next < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9v55pag7.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9v55pag7.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number =",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_value_index = 0;\n  let max_value_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_value_index = i;\n    }\n    if (i == max_value) {\n      max_value_index = i;\n    }\n  }\n  return (min_value_index, max_value_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftkkyqrl.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftkkyqrl.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftkkyqrl.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftkkyqrl.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftkkyqrl.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftkkyqrl.rs:35:8\n   |\n35 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > max_diff) {\n35 +     if diff > max_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftkkyqrl.rs:42:8\n   |\n42 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n42 -     if (i == min_value) {\n42 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftkkyqrl.rs:45:8\n   |\n45 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parenthese",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff < min_value) {\n      min_value = diff;\n      min_index = i;\n    }\n    diff = i - max_value;\n    if (diff > 0) {\n      diff = -diff;\n    }\n    if (diff > max_value) {\n      max_value = diff;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:22:8\n   |\n22 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n22 -     if (diff < 0) {\n22 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:25:8\n   |\n25 |     if (diff < min_value) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (diff < min_value) {\n25 +     if diff < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:30:8\n   |\n30 |     if (diff > 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n30 -     if (diff > 0) {\n30 +     if diff > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:33:8\n   |\n33 |     if (diff > max_value) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n33 -     if (diff > max_value) {\n33 +     if diff > max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8kas9ycl.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8kas9ycl.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = abs(i - min_value);\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    let diff = abs(i - max_value);\n    if (diff < max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_index_value = numbers[min_index];\n  let max_index_value = numbers[max_index];\n  return (min_index_value, max_index_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmphiidrs5x.rs:31:16\n   |\n31 |     let diff = abs(i - min_value);\n   |                ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmphiidrs5x.rs:35:16\n   |\n35 |     let diff = abs(i - max_value);\n   |                ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphiidrs5x.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphiidrs5x.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphiidrs5x.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphiidrs5x.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphiidrs5x.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphiidrs5x.rs:36:8\n   |\n36 |     if (diff < max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if (diff < max_diff) {\n36 +     if diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmphiidrs5x.rs:11:13\n   |\n11 |     if (i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpqlsr3kva.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqlsr3kva.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqlsr3kva.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqlsr3kva.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpqlsr3kva.rs:21:10\n   |\n21 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqlsr3kva.rs:22:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n22 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpqlsr3kva.rs:24:10\n   |\n24 |     if i == max_number {\n   |          ^^ ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0\n  let min_value = numbers[0]\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] < min_value {\n      min_value = numbers[i]\n      min_index = i\n    }\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  return (numbers[min_index], numbers[max_index])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpaxksyqph.rs:8:20\n  |\n8 |   let min_index = 0\n  |                    ^ help: add `;` here\n9 |   let min_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpaxksyqph.rs:9:29\n   |\n9  |   let min_value = numbers[0]\n   |                             ^ help: add `;` here\n10 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpaxksyqph.rs:10:20\n   |\n10 |   let max_index = 0\n   |                    ^ help: add `;` here\n11 |   let max_value = numbers[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpaxksyqph.rs:11:29\n   |\n11 |   let max_value = numbers[0]\n   |                             ^ help: add `;` here\n12 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpaxksyqph.rs:14:29\n   |\n14 |       min_value = numbers[i]\n   |                             ^ help: add `;` here\n15 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpaxksyqph.rs:18:29\n   |\n18 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpaxksyqph.rs:13:8\n   |\n13 |     if numbers[i] < min_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpaxksyqph.rs:14:19\n   |\n14 |       min_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = abs(i - min_number);\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    let diff = abs(i - max_number);\n    if (diff < max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_closest = numbers[min_index];\n  let max_closest = numbers[max_index];\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpptlrjspl.rs:31:16\n   |\n31 |     let diff = abs(i - min_number);\n   |                ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpptlrjspl.rs:35:16\n   |\n35 |     let diff = abs(i - max_number);\n   |                ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpptlrjspl.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpptlrjspl.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpptlrjspl.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpptlrjspl.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpptlrjspl.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpptlrjspl.rs:36:8\n   |\n36 |     if (diff < max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if (diff < max_diff) {\n36 +     if diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpptlrjspl.rs:11:13\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  let min_value_index_2 = numbers.indexOf(min_value);\n  let max_value_index_2 = numbers.indexOf(max_value);\n  if (min_value_index_2 > max_value_index_2) {\n    let temp = min_value_index_2;\n    min_value_index_2 = max_value_index_2;\n    max_value_index_2 = temp;\n  }\n  let min_value_index_3 = numbers.indexOf(min_value);\n  let max_value_index_3 = numbers.indexOf(max_value);\n  if (min_value_index_3 > max_value_index_3) {\n    let temp = min_value_index_3;\n    min_value_index_3 = max_value_index_3;\n    max_value_index_3 = temp;\n  }\n  let min_value_index_4 = numbers.indexOf(min_value);\n  let max_value_index_4 = numbers.indexOf(max_value);\n  if (min_value_index_4 > max_value_index_4) {\n    let\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz4_op9nq.rs:60:3\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - unclosed delimiter\n...\n49 |   if (min_value_index_4 > max_value_index_4) {\n   |                                              - this delimiter might not be properly closed...\n50 |     let\n51 | }\n   | - ...as it matches this but it has different indentation\n...\n60 | }\n   |   ^\n\nerror: expected pattern, found `}`\n  --> /tmp/tmpz4_op9nq.rs:51:1\n   |\n51 | }\n   | ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz4_op9nq.rs:28:6\n   |\n28 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -   if (min_value_index > max_value_index) {\n28 +   if min_value_index > max_value_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz4_op9nq.rs:35:6\n   |\n35 |   if (min_value_index_2 > max_value_index_2) {\n   |      ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n35 -   if (min_value_index_2 > max_value_index_2) {\n35 +   if min_value_index_2 > max_value_index_2 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz4_op9nq.rs:42:6\n   |\n42 |   if (min_value_index_3 > max_value_index_3) {\n   |      ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n42 -   if (min_value_index_3 > max_value_index_3) {\n42 +   if min_value_index_3 > max_value_index_3 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz4_op9nq.rs:49:6\n   |\n49 |   if (min_value_index_4 > max_value_index_4) {\n   |      ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n49 -   if (min_value_index_4 > max_value_index_4) {\n49 +   if min_value_index_4 > max_value_index_4 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz4_",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    } else if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    } else if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_plus_one = min_value_index + 1;\n  let max_value_index_minus_one = max_value_index - 1;\n  let min_value_index_plus_two = min_value_index + 2;\n  let max_value_index_minus_two = max_value_index - 2;\n  let min_value_index_plus_three = min_value_index + 3;\n  let max_value_index_minus_three = max_value_index - 3;\n  let min_value_index_plus_four = min_value_index + 4;\n  let max_value_index_minus_four = max_value_index - 4;\n  let min_value_index_plus_five = min_value_index + 5;\n  let max_value_index_minus_five = max_value_index - 5;\n  let min_value_index_plus_six = min_value_index + 6;\n  let max_value_index_minus_six = max_value_index - 6;\n  let min_value_index_plus_seven = min_value_index + 7;\n  let max_value_index_minus_seven = max_value_index - 7;\n  let min_value_index_plus_eight = min_value_index + 8;\n  let max_value_index_minus\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp7f74v72s.rs:43:28\n   |\n43 |   let max_value_index_minus\n   |                            ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7f74v72s.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7f74v72s.rs:13:15\n   |\n13 |     } else if (i > max_value) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i > max_value) {\n13 +     } else if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7f74v72s.rs:20:8\n   |\n20 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i == min_value) {\n20 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7f74v72s.rs:22:15\n   |\n22 |     } else if (i == max_value) {\n   |               ^              ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == max_value) {\n22 +     } else if i == max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f74v72s.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f74v72s.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7f74v72s.rs:13:20\n   |\n13 |     } else if (i > max_value) {\n   |              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_index - 2]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_index - 2]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_index + 2]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_index + 2]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_index + 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_index + 1]);\n  let min_value_index_prev_prev = numbers.indexOf(numbers[min_index - 2]);\n  let max_value_index_prev_prev = numbers\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpeqbs2124.rs:41:42\n   |\n41 |   let max_value_index_prev_prev = numbers\n   |                                          ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeqbs2124.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeqbs2124.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeqbs2124.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeqbs2124.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpeqbs2124.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpeqbs2124.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for (let i = 1; i < numbers.len(); i++) {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n      min_index = i;\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpcr41jm09.rs:12:8\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpcr41jm09.rs:12:12\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpcr41jm09.rs:12:14\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcr41jm09.rs:12:13\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpcr41jm09.rs:12:14\n   |\n12 |   for (let i = 1; i < numbers.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev + 1]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_value_index_prev + 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmph6wwqylv.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmph6wwqylv.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmph6wwqylv.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_number);\n  let max_diff = abs(numbers[max_index] - max_number);\n  let min_index_2 = 0;\n  let max_index_2 = 0;\n  for i in numbers.iter() {\n    if (abs(i - min_number) < min_diff) {\n      min_index_2 = i;\n    }\n    if (abs(i - max_number) < max_diff) {\n      max_index_2 = i;\n    }\n  }\n  return (numbers[min_index_2], numbers[max_index_2]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp1mw2xor7.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp1mw2xor7.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp1mw2xor7.rs:33:9\n   |\n33 |     if (abs(i - min_number) < min_diff) {\n   |         ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp1mw2xor7.rs:36:9\n   |\n36 |     if (abs(i - max_number) < max_diff) {\n   |         ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1mw2xor7.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1mw2xor7.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1mw2xor7.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1mw2xor7.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1mw2xor7.rs:33:8\n   |\n33 |     if (abs(i - min_number) < min_diff) {\n   |        ^                              ^\n   |\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n      min_index = i;\n    }\n  }\n  for i in numbers.iter() {\n    let diff = i - max_value;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1059nm2.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1059nm2.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1059nm2.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1059nm2.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1059nm2.rs:32:8\n   |\n32 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < 0) {\n32 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1059nm2.rs:35:8\n   |\n35 |     if (diff > min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > min_diff) {\n35 +     if diff > min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1059nm2.rs:42:8\n   |\n42 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n42 -     if (diff < 0) {\n42 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1059nm2.rs:45:8\n   |\n45 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n45 -     if (diff > max_diff) {\n45 +     if",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let min_value = numbers[0];\n    let max_value = numbers[0];\n    for i in numbers.iter() {\n        if (i < min_value) {\n            min_value = i;\n        } else if (i > max_value) {\n            max_value = i;\n        }\n    }\n    let min_index = 0;\n    let max_index = 0;\n    for i in numbers.iter() {\n        if (i == min_value) {\n            min_index = i;\n        } else if (i == max_value) {\n            max_index = i;\n        }\n    }\n    let min_diff = 0.0;\n    let max_diff = 0.0;\n    for i in numbers.iter() {\n        let diff = i - min_value;\n        if (diff < min_diff) {\n            min_diff = diff;\n        }\n        diff = i - max_value;\n        if (diff > max_diff) {\n            max_diff = diff;\n        }\n    }\n    let min_value_index = numbers.indexOf(min_value);\n    let max_value_index = numbers.indexOf(max_value);\n    let min_diff_index = numbers.indexOf(min_diff);\n    let max_diff_index = numbers.indexOf(max_diff);\n    let min_value_index_index = numbers.indexOf(min_value_index);\n    let max_value_index_index = numbers.indexOf(max_value_index);\n    let min_diff_index_index = numbers.indexOf(min_diff_index);\n    let max_diff_index_index = numbers.indexOf(max_diff_index);\n    let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n    let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n    let min_diff_index_index_index = numbers.indexOf(min_diff_index_index);\n    let max_diff_index_index_index = numbers.indexOf(max_diff_index\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpj76iw06f.rs:50:1\n   |\n50 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpj76iw06f.rs:49:53\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n49 |     let max_diff_index_index_index = numbers.indexOf(max_diff_index\n   |                                                     ^ unclosed delimiter\n50 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj76iw06f.rs:11:12\n   |\n11 |         if (i < min_value) {\n   |            ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -         if (i < min_value) {\n11 +         if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj76iw06f.rs:13:19\n   |\n13 |         } else if (i > max_value) {\n   |                   ^             ^\n   |\nhelp: remove these parentheses\n   |\n13 -         } else if (i > max_value) {\n13 +         } else if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj76iw06f.rs:20:12\n   |\n20 |         if (i == min_value) {\n   |            ^              ^\n   |\nhelp: remove these parentheses\n   |\n20 -         if (i == min_value) {\n20 +         if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj76iw06f.rs:22:19\n   |\n22 |         } else if (i == max_value) {\n   |                   ^              ^\n   |\nhelp: remove these parentheses\n   |\n22 -         } else if (i == max_value) {\n22 +         } else if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj76iw06f.rs:30:12\n   |\n30 |         if (diff < min_diff) {\n   |            ^               ^\n   |\nhelp: remove these parentheses\n   |\n30 -         if (",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_value);\n  let max_diff = abs(numbers[max_index] - max_value);\n  if min_diff < max_diff {\n    return (min_value, numbers[min_index]);\n  } else {\n    return (numbers[max_index], max_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpneybik71.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_value);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpneybik71.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_value);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneybik71.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneybik71.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneybik71.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpneybik71.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpneybik71.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  return (min_value_index, max_value_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpszx3qnjj.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpszx3qnjj.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpszx3qnjj.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: requi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let min_value = numbers[0];\n    let max_value = numbers[0];\n    for i in numbers.iter() {\n        if (i > max_value) {\n            max_value = i;\n        }\n        if (i < min_value) {\n            min_value = i;\n        }\n    }\n    let min_index = 0;\n    let max_index = 0;\n    for i in numbers.iter() {\n        if (i == min_value) {\n            min_index = i;\n        }\n        if (i == max_value) {\n            max_index = i;\n        }\n    }\n    let min_diff = math.abs(numbers[min_index] - min_value);\n    let max_diff = math.abs(numbers[max_index] - max_value);\n    let min_index_diff = math.abs(numbers[min_index] - numbers[max_index]);\n    if (min_diff < max_diff) {\n        return (min_value, max_value);\n    } else if (min_diff == max_diff) {\n        if (min_index_diff < max_index_diff) {\n            return (min_value, max_value);\n        } else {\n            return (min_value, min_value);\n        }\n    } else {\n        return (max_value, min_value);\n    }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find value `math` in this scope\n  --> /tmp/tmpmpi58xbf.rs:28:20\n   |\n28 |     let min_diff = math.abs(numbers[min_index] - min_value);\n   |                    ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `math` in this scope\n  --> /tmp/tmpmpi58xbf.rs:29:20\n   |\n29 |     let max_diff = math.abs(numbers[max_index] - max_value);\n   |                    ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `math` in this scope\n  --> /tmp/tmpmpi58xbf.rs:30:26\n   |\n30 |     let min_index_diff = math.abs(numbers[min_index] - numbers[max_index]);\n   |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `max_index_diff` in this scope\n  --> /tmp/tmpmpi58xbf.rs:34:30\n   |\n34 |         if (min_index_diff < max_index_diff) {\n   |                              ^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `min_index_diff`\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmpi58xbf.rs:11:12\n   |\n11 |         if (i > max_value) {\n   |            ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -         if (i > max_value) {\n11 +         if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmpi58xbf.rs:14:12\n   |\n14 |         if (i < min_value) {\n   |            ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -         if (i < min_value) {\n14 +         if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmpi58xbf.rs:21:12\n   |\n21 |         if (i == min_value) {\n   |            ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -         if (i == min_value) {\n21 +         if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmpi58xbf.rs:24:12\n   |\n24 |         if (i == max_value) {\n   |            ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -         if (i == max_value) {\n24 +         if i == ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmpzr7flb4s.rs:41:1\n   |\n41 | }\n   | ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    diff = i - max_value;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_index_diff = 0.0;\n  let max_index_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_index;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_index_diff) {\n      min_index_diff = diff;\n    }\n    diff = i - max_index;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_index_diff) {\n      max_index_diff = diff;\n    }\n  }\n  let min_diff_diff = 0.0;\n  let max_diff_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_diff;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_x_uzruj.rs:81:3\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - unclosed delimiter\n...\n66 |   for i in numbers.iter() {\n   |                           - this delimiter might not be properly closed...\n...\n72 | }\n   | - ...as it matches this but it has different indentation\n...\n81 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp_x_uzruj.rs:72:1\n   |\n71 |     if (diff\n   |     -- this `if` expression has a condition, but no block\n72 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp_x_uzruj.rs:71:8\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n71 |     if (diff\n   |        ^ unclosed delimiter\n72 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_x_uzruj.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_x_uzruj.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_x_uzruj.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_x_uzruj.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwa",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0;\n  let min_value = numbers[0];\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n      min_index = i;\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjakyjftr.rs:13:8\n   |\n13 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (numbers[i] < min_value) {\n13 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjakyjftr.rs:17:8\n   |\n17 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (numbers[i] > max_value) {\n17 +     if numbers[i] > max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpjakyjftr.rs:13:9\n   |\n13 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpjakyjftr.rs:14:19\n   |\n14 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjakyjftr.rs:15:19\n   |\n8  |   let min_index = 0;\n   |                   - expected due to this value\n...\n15 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpjakyjftr.rs:17:9\n   |\n17 |     if (numbers[i] > max_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp99pcixb9.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp99pcixb9.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp99pcixb9.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp99pcixb9.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99pcixb9.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99pcixb9.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99pcixb9.rs:14:13\n   |\n14 |     if (i > max_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99pcixb9.rs:15:20\n   |\n9  |   let max_numb",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index == max_value_index) {\n    return (min_value, max_value);\n  }\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  if (min_value_index_index == max_value_index_index) {\n    return (min_value, max_value);\n  }\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  if (min_value_index_index_index == max_value_index_index_index) {\n    return (min_value, max_value);\n  }\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  if (min_value_index_index_index_index == max_value_index_index_index_index) {\n    return (min_value, max_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp8sm8y14l.rs:56:3\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - unclosed delimiter\n...\n45 |   if (min_value_index_index_index_index == max_value_index_index_index_index) {\n   |                                                                               - this delimiter might not be properly closed...\n46 |     return (min_value, max_\n47 | }\n   | - ...as it matches this but it has different indentation\n...\n56 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp8sm8y14l.rs:46:12\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n46 |     return (min_value, max_\n   |            ^ unclosed delimiter\n47 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `max_` in this scope\n  --> /tmp/tmp8sm8y14l.rs:46:24\n   |\n46 |     return (min_value, max_\n   |                        ^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8sm8y14l.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8sm8y14l.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8sm8y14l.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_prev_prev = numbers.indexOf(numbers[min_value_index_prev - 1]);\n  let max_value_index_prev_prev = numbers.indexOf(numbers[max_value_index_prev - 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev +\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmpdto1ajju.rs:41:1\n   |\n41 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpdto1ajju.rs:40:58\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n40 |   let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev +\n   |                                                          ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdto1ajju.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdto1ajju.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdto1ajju.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdto1ajju.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdto1ajju.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdto1ajju.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expec",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev + 1]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_value_index_prev + 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_prev_prev = numbers.indexOf(numbers[min_value_index_prev -\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmpgr0kddm1.rs:41:1\n   |\n41 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpgr0kddm1.rs:40:58\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n40 |   let min_value_index_prev_prev = numbers.indexOf(numbers[min_value_index_prev -\n   |                                                          ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgr0kddm1.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgr0kddm1.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expec",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_number;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff < max_number - min_number {\n      max_index = i;\n    }\n    if diff > max_number - min_number {\n      min_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpn6nbtj70.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6nbtj70.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6nbtj70.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6nbtj70.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6nbtj70.rs:22:15\n   |\n22 |     if diff < 0 {\n   |               ^\n   |               |\n   |               expected `f64`, found integer\n   |               help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6nbtj70.rs:26:19\n   |\n19 |   let max_index = 0;\n   |                   - expected due to this value\n...\n26 |       max_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn6nbtj70.rs:29:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n29 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror: aborting due to 7 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  let min_diff_index = min_index;\n  let max_diff_index = max_index;\n  if (min_diff > max_diff) {\n    min_diff_index = max_index;\n    max_diff_index = min_index;\n  }\n  return (numbers[min_diff_index], numbers[max_diff_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp34z12sbn.rs:32:6\n   |\n32 |   if (min_diff > max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff > max_diff) {\n32 +   if min_diff > max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp34z12sbn.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp34z12sbn.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  if (min_diff < max_diff) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    } else if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    } else if i == max_number {\n      max_index = i;\n    }\n  }\n  return (min_number, max_number);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpqd1z_ekj.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqd1z_ekj.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqd1z_ekj.rs:13:19\n   |\n13 |     } else if i > max_number {\n   |                   ^^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqd1z_ekj.rs:14:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n14 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpqd1z_ekj.rs:20:10\n   |\n20 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqd1z_ekj.rs:21:19\n   |\n17 |   let min_index = 0;\n   |                   - expected due to this value\n...\n21 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpqd1z_ekj.rs:22:17\n   |\n22 |     } e",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = abs(i - min_value);\n    if (diff < min_diff) {\n      min_diff = diff;\n    }\n    let diff = abs(i - max_value);\n    if (diff < max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_closest = numbers[min_index];\n  let max_closest = numbers[max_index];\n  return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmppv5laqfq.rs:31:16\n   |\n31 |     let diff = abs(i - min_value);\n   |                ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmppv5laqfq.rs:35:16\n   |\n35 |     let diff = abs(i - max_value);\n   |                ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppv5laqfq.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppv5laqfq.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppv5laqfq.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppv5laqfq.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppv5laqfq.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppv5laqfq.rs:36:8\n   |\n36 |     if (diff < max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if (diff < max_diff) {\n36 +     if diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmppv5laqfq.rs:11:13\n   |\n11 |     if (i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev + 1]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_value_index_prev + 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_prev_prev = numbers.indexOf(numbers[min_value_index_prev -\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmpgr0kddm1.rs:41:1\n   |\n41 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpgr0kddm1.rs:40:58\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n40 |   let min_value_index_prev_prev = numbers.indexOf(numbers[min_value_index_prev -\n   |                                                          ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgr0kddm1.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgr0kddm1.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expec",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev + 1]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_value_index_prev + 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmph6wwqylv.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph6wwqylv.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmph6wwqylv.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmph6wwqylv.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    let min_number = numbers[0];\n    let max_number = numbers[0];\n    for i in numbers.iter() {\n        if i < min_number {\n            min_number = i;\n        }\n        if i > max_number {\n            max_number = i;\n        }\n    }\n    let min_index = 0;\n    let max_index = 0;\n    for i in numbers.iter() {\n        if i == min_number {\n            min_index = i;\n        }\n        if i == max_number {\n            max_index = i;\n        }\n    }\n    let min_diff = 0.0;\n    let max_diff = 0.0;\n    for i in numbers.iter() {\n        let diff = abs(i - min_number);\n        if diff < min_diff {\n            min_diff = diff;\n        }\n        let diff = abs(i - max_number);\n        if diff < max_diff {\n            max_diff = diff;\n        }\n    }\n    let min_closest = numbers[min_index];\n    let max_closest = numbers[max_index];\n    return (min_closest, max_closest);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmprbr9wf2g.rs:31:20\n   |\n31 |         let diff = abs(i - min_number);\n   |                    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmprbr9wf2g.rs:35:20\n   |\n35 |         let diff = abs(i - max_number);\n   |                    ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprbr9wf2g.rs:11:16\n   |\n11 |         if i < min_number {\n   |                ^^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprbr9wf2g.rs:12:26\n   |\n8  |     let min_number = numbers[0];\n   |                      ---------- expected due to this value\n...\n12 |             min_number = i;\n   |                          ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |             min_number = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprbr9wf2g.rs:14:16\n   |\n14 |         if i > max_number {\n   |                ^^^^^^^^^^\n   |                |\n   |                expected `&f64`, found `f64`\n   |                help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprbr9wf2g.rs:15:26\n   |\n9  |     let max_number = numbers[0];\n   |                      ---------- expected due to this value\n...\n15 |             max_number = i;\n   |                          ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |             max_number = *i;\n   |                          +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmprbr9wf2g.rs:21:14\n   |\n21 |         if i == min_number {\n   |              ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  if (min_value_index_index > max_value_index_index) {\n    let temp = min_value_index_index;\n    min_value_index_index = max_value_index_index;\n    max_value_index_index = temp;\n  }\n  return (numbers[min_value_index_index], numbers[max_value_index_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2w7tsw_m.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2w7tsw_m.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2w7tsw_m.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2w7tsw_m.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2w7tsw_m.rs:32:6\n   |\n32 |   if (min_value_index_index > max_value_index_index) {\n   |      ^                                             ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_value_index_index > max_value_index_index) {\n32 +   if min_value_index_index > max_value_index_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp2w7tsw_m.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpo4aoxcwc.rs:21:10\n   |\n21 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4aoxcwc.rs:22:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n22 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpo4aoxcwc.rs:24:10\n   |\n24 |     if i == max_number {\n   |          ^^ ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  if (min_diff < max_diff) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy9__2wav.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy9__2wav.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy9__2wav.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy9__2wav.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy9__2wav.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy9__2wav.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy9__2wav.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy9__2wav.rs:14:13\n   |\n14 |     if (i > max_value) ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_next = numbers.indexOf(numbers[min_value_index + 1]);\n  let max_value_index_next = numbers.indexOf(numbers[max_value_index + 1]);\n  let min_value_index_prev = numbers.indexOf(numbers[min_value_index - 1]);\n  let max_value_index_prev = numbers.indexOf(numbers[max_value_index - 1]);\n  let min_value_index_prev_next = numbers.indexOf(numbers[min_value_index_prev + 1]);\n  let max_value_index_prev_next = numbers.indexOf(numbers[max_value_index_prev + 1]);\n  let min_value_index_next_next = numbers.indexOf(numbers[min_value_index_next + 1]);\n  let max_value_index_next_next = numbers.indexOf(numbers[max_value_index_next + 1]);\n  let min_value_index_next_prev = numbers.indexOf(numbers[min_value_index_next - 1]);\n  let max_value_index_next_prev = numbers.indexOf(numbers[max_value_index_next - 1]);\n  let min_value_index_prev_prev = numbers.indexOf(numbers[min_value_index_prev -\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmpgr0kddm1.rs:41:1\n   |\n41 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpgr0kddm1.rs:40:58\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n40 |   let min_value_index_prev_prev = numbers.indexOf(numbers[min_value_index_prev -\n   |                                                          ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgr0kddm1.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgr0kddm1.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgr0kddm1.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expec",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  if (min_value_index > max_value_index) {\n    let temp = min_value_index;\n    min_value_index = max_value_index;\n    max_value_index = temp;\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9hr2idy.rs:30:6\n   |\n30 |   if (min_value_index > max_value_index) {\n   |      ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_value_index > max_value_index) {\n30 +   if min_value_index > max_value_index {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpf9hr2idy.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_number;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    let diff = i - max_number;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  let min_result = min_number;\n  let max_result = max_number;\n  if (min_diff < max_diff) {\n    min_result = min_index;\n    max_result = max_index;\n  }\n  return (min_result, max_result);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4hkfx9ib.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4hkfx9ib.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4hkfx9ib.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4hkfx9ib.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4hkfx9ib.rs:32:8\n   |\n32 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < 0) {\n32 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4hkfx9ib.rs:35:8\n   |\n35 |     if (diff > min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > min_diff) {\n35 +     if diff > min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4hkfx9ib.rs:39:8\n   |\n39 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if (diff < 0) {\n39 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4hkfx9ib.rs:42:8\n   |\n42 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n42 -     if (diff > max_dif",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.indexOf(min_value);\n  let max_value_index = numbers.indexOf(max_value);\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmpzr7flb4s.rs:41:1\n   |\n41 | }\n   | ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzr7flb4s.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmpzr7flb4s.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[min_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > min_diff) {\n      min_diff = diff;\n    }\n    diff = numbers[i] - numbers[max_index];\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n    }\n  }\n  return (numbers[min_index], numbers[max_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnjdpqbd9.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnjdpqbd9.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnjdpqbd9.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnjdpqbd9.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnjdpqbd9.rs:32:8\n   |\n32 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < 0) {\n32 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnjdpqbd9.rs:35:8\n   |\n35 |     if (diff > min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (diff > min_diff) {\n35 +     if diff > min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnjdpqbd9.rs:39:8\n   |\n39 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if (diff < 0) {\n39 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnjdpqbd9.rs:42:8\n   |\n42",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  if (min_diff < max_diff) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_val = numbers[0];\n  let max_val = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_val) {\n      min_val = numbers[i];\n    }\n    if (numbers[i] > max_val) {\n      max_val = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_val) {\n      min_index = i;\n    }\n    if (numbers[i] == max_val) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_val;\n  let max_diff = numbers[max_index] - max_val;\n  let min_diff_index = min_index;\n  let max_diff_index = max_index;\n  if (min_diff > max_diff) {\n    min_diff_index = max_index;\n    max_diff_index = min_index;\n  }\n  return (numbers[min_diff_index], numbers[max_diff_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6ugv3txb.rs:11:8\n   |\n11 |     if (numbers[i] < min_val) {\n   |        ^                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_val) {\n11 +     if numbers[i] < min_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6ugv3txb.rs:14:8\n   |\n14 |     if (numbers[i] > max_val) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_val) {\n14 +     if numbers[i] > max_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6ugv3txb.rs:21:8\n   |\n21 |     if (numbers[i] == min_val) {\n   |        ^                     ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_val) {\n21 +     if numbers[i] == min_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6ugv3txb.rs:24:8\n   |\n24 |     if (numbers[i] == max_val) {\n   |        ^                     ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_val) {\n24 +     if numbers[i] == max_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6ugv3txb.rs:32:6\n   |\n32 |   if (min_diff > max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff > max_diff) {\n32 +   if min_diff > max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp6ugv3txb.rs:11:9\n   |\n11 |     if (numbers[i] < min_val) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp6ugv3txb.rs:12:17\n   |\n12 |       min_val = numbers[i];\n   |        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_value) {\n      min_index = i;\n    }\n    if (i == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < min_diff) {\n      min_diff = diff;\n      min_index = i;\n    }\n    let diff = i - max_value;\n    if (diff > max_diff) {\n      max_diff = diff;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9yn1kp4q.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9yn1kp4q.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9yn1kp4q.rs:21:8\n   |\n21 |     if (i == min_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_value) {\n21 +     if i == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9yn1kp4q.rs:24:8\n   |\n24 |     if (i == max_value) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_value) {\n24 +     if i == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9yn1kp4q.rs:32:8\n   |\n32 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (diff < min_diff) {\n32 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9yn1kp4q.rs:37:8\n   |\n37 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n37 -     if (diff > max_diff) {\n37 +     if diff > max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9yn1kp4q.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9yn1kp4q.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_number) {\n      min_number = numbers[i];\n    }\n    if (numbers[i] > max_number) {\n      max_number = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_number) {\n      min_index = i;\n    }\n    if (numbers[i] == max_number) {\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:11:8\n   |\n11 |     if (numbers[i] < min_number) {\n   |        ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_number) {\n11 +     if numbers[i] < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:14:8\n   |\n14 |     if (numbers[i] > max_number) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_number) {\n14 +     if numbers[i] > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:21:8\n   |\n21 |     if (numbers[i] == min_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_number) {\n21 +     if numbers[i] == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprmpo2nhn.rs:24:8\n   |\n24 |     if (numbers[i] == max_number) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_number) {\n24 +     if numbers[i] == max_number {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:11:9\n   |\n11 |     if (numbers[i] < min_number) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmprmpo2nhn.rs:12:20\n   |\n12 |       min_number = numbers[i];\n   |                    ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usiz",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[0] - numbers[min_index];\n  let max_diff = numbers[0] - numbers[max_index];\n  let min_diff_index = min_index;\n  let max_diff_index = max_index;\n  for i in numbers.iter() {\n    let diff = numbers[i] - numbers[0];\n    if (diff < min_diff) {\n      min_diff = diff;\n      min_diff_index = i;\n    }\n    if (diff > max_diff) {\n      max_diff = diff;\n      max_diff_index = i;\n    }\n  }\n  return (numbers[min_diff_index], numbers[max_diff_index]);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpibywds_s.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpibywds_s.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpibywds_s.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpibywds_s.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpibywds_s.rs:34:8\n   |\n34 |     if (diff < min_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n34 -     if (diff < min_diff) {\n34 +     if diff < min_diff {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpibywds_s.rs:38:8\n   |\n38 |     if (diff > max_diff) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n38 -     if (diff > max_diff) {\n38 +     if diff > max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpibywds_s.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpibywds_s.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_index = 0\n  let min_value = numbers[0]\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in 0..(numbers.len() - 1) {\n    let value = numbers[i]\n    if value < min_value {\n      min_value = value\n      min_index = i\n    }\n    if value > max_value {\n      max_value = value\n      max_index = i\n    }\n  }\n  return (numbers[min_index], numbers[max_index])\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpy99r8882.rs:8:20\n  |\n8 |   let min_index = 0\n  |                    ^ help: add `;` here\n9 |   let min_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpy99r8882.rs:9:29\n   |\n9  |   let min_value = numbers[0]\n   |                             ^ help: add `;` here\n10 |   let max_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpy99r8882.rs:10:20\n   |\n10 |   let max_index = 0\n   |                    ^ help: add `;` here\n11 |   let max_value = numbers[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpy99r8882.rs:11:29\n   |\n11 |   let max_value = numbers[0]\n   |                             ^ help: add `;` here\n12 |   for i in 0..(numbers.len() - 1) {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpy99r8882.rs:13:27\n   |\n13 |     let value = numbers[i]\n   |                           ^ help: add `;` here\n14 |     if value < min_value {\n   |     -- unexpected token\n\nerror: expected `;`, found `min_index`\n  --> /tmp/tmpy99r8882.rs:15:24\n   |\n15 |       min_value = value\n   |                        ^ help: add `;` here\n16 |       min_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpy99r8882.rs:19:24\n   |\n19 |       max_value = value\n   |                        ^ help: add `;` here\n20 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 7 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers[min_index];\n  let max_value_index = numbers[max_index];\n  let min_value_index_index = numbers.indexOf(min_value_index);\n  let max_value_index_index = numbers.indexOf(max_value_index);\n  let min_value_index_index_index = numbers.indexOf(min_value_index_index);\n  let max_value_index_index_index = numbers.indexOf(max_value_index_index);\n  let min_value_index_index_index_index = numbers.indexOf(min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.indexOf(max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.indexOf(min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.indexOf(max_value_index_index_index_index_index);\n  let min_value_index_\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0w70fmzi.rs:40:23\n   |\n40 |   let min_value_index_\n   |                       ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0w70fmzi.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp0w70fmzi.rs:12:19\n   |\n12 |       min_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_value) {\n      min_value = i;\n    }\n    if (i > max_value) {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if (diff < 0) {\n      diff = -diff;\n    }\n    if (diff < min_value) {\n      min_value = diff;\n      min_index = i;\n    }\n    diff = i - max_value;\n    if (diff > 0) {\n      diff = -diff;\n    }\n    if (diff > max_value) {\n      max_value = diff;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:11:8\n   |\n11 |     if (i < min_value) {\n   |        ^             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_value) {\n11 +     if i < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:14:8\n   |\n14 |     if (i > max_value) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_value) {\n14 +     if i > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:22:8\n   |\n22 |     if (diff < 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n22 -     if (diff < 0) {\n22 +     if diff < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:25:8\n   |\n25 |     if (diff < min_value) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (diff < min_value) {\n25 +     if diff < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:30:8\n   |\n30 |     if (diff > 0) {\n   |        ^        ^\n   |\nhelp: remove these parentheses\n   |\n30 -     if (diff > 0) {\n30 +     if diff > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8kas9ycl.rs:33:8\n   |\n33 |     if (diff > max_value) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n33 -     if (diff > max_value) {\n33 +     if diff > max_value {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8kas9ycl.rs:11:13\n   |\n11 |     if (i < min_value) {\n   |             ^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8kas9ycl.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if (i < min_number) {\n      min_number = i;\n    }\n    if (i > max_number) {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (i == min_number) {\n      min_index = i;\n    }\n    if (i == max_number) {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_number);\n  let max_diff = abs(numbers[max_index] - max_number);\n  let min_closest = numbers[min_index];\n  let max_closest = numbers[max_index];\n  if (min_diff < max_diff) {\n    return (min_closest, max_closest);\n  } else {\n    return (max_closest, min_closest);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0wtav9mx.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp0wtav9mx.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_number);\n   |                  ^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0wtav9mx.rs:11:8\n   |\n11 |     if (i < min_number) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i < min_number) {\n11 +     if i < min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0wtav9mx.rs:14:8\n   |\n14 |     if (i > max_number) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (i > max_number) {\n14 +     if i > max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0wtav9mx.rs:21:8\n   |\n21 |     if (i == min_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (i == min_number) {\n21 +     if i == min_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0wtav9mx.rs:24:8\n   |\n24 |     if (i == max_number) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (i == max_number) {\n24 +     if i == max_number {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0wtav9mx.rs:32:6\n   |\n32 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n32 -   if (min_diff < max_diff) {\n32 +   if min_diff < max_diff {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0wtav9mx.rs:11:13\n   |\n11 |     if (i < min_number) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&f64`, found `f64`\n   |             help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatch",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    }\n    if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = 0.0;\n  let max_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > min_diff {\n      min_diff = diff;\n    }\n    let diff = i - max_value;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > max_diff {\n      max_diff = diff;\n    }\n  }\n  let min_index_diff = 0.0;\n  let max_index_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_index;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > min_index_diff {\n      min_index_diff = diff;\n    }\n    let diff = i - max_index;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > max_index_diff {\n      max_index_diff = diff;\n    }\n  }\n  let min_diff_diff = 0.0;\n  let max_diff_diff = 0.0;\n  for i in numbers.iter() {\n    let diff = i - min_diff;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff > min_diff_diff {\n      min_diff_diff = diff;\n    }\n    let diff =\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkaz2d2cx.rs:84:3\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - unclosed delimiter\n...\n66 |   for i in numbers.iter() {\n   |                           - this delimiter might not be properly closed...\n...\n75 | }\n   | - ...as it matches this but it has different indentation\n...\n84 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpkaz2d2cx.rs:75:1\n   |\n75 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkaz2d2cx.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkaz2d2cx.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkaz2d2cx.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkaz2d2cx.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpkaz2d2cx.rs:21:10\n   |\n21 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if (numbers[i] < min_value) {\n      min_value = numbers[i];\n    }\n    if (numbers[i] > max_value) {\n      max_value = numbers[i];\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if (numbers[i] == min_value) {\n      min_index = i;\n    }\n    if (numbers[i] == max_value) {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[min_index] - min_value;\n  let max_diff = numbers[max_index] - max_value;\n  if (min_diff < max_diff) {\n    return (min_value, max_value);\n  } else {\n    return (max_value, min_value);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292821,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:11:8\n   |\n11 |     if (numbers[i] < min_value) {\n   |        ^                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (numbers[i] < min_value) {\n11 +     if numbers[i] < min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:14:8\n   |\n14 |     if (numbers[i] > max_value) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (numbers[i] > max_value) {\n14 +     if numbers[i] > max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:21:8\n   |\n21 |     if (numbers[i] == min_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (numbers[i] == min_value) {\n21 +     if numbers[i] == min_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:24:8\n   |\n24 |     if (numbers[i] == max_value) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (numbers[i] == max_value) {\n24 +     if numbers[i] == max_value {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7o086cht.rs:30:6\n   |\n30 |   if (min_diff < max_diff) {\n   |      ^                   ^\n   |\nhelp: remove these parentheses\n   |\n30 -   if (min_diff < max_diff) {\n30 +   if min_diff < max_diff {\n   | \n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:11:9\n   |\n11 |     if (numbers[i] < min_value) {\n   |         ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[f64]>` is not implemented for `&f64`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&f64>` for `Vec<f64>`\n\nerror[E0277]: the type `[f64]` cannot be indexed by `&f64`\n  --> /tmp/tmp7o086cht.rs:12:19\n   |\n12 |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_value_index = numbers.find(i => i == min_value);\n  let max_value_index = numbers.find(i => i == max_value);\n  let min_value_index_index = numbers.find(i => i == min_value_index);\n  let max_value_index_index = numbers.find(i => i == max_value_index);\n  let min_value_index_index_index = numbers.find(i => i == min_value_index_index);\n  let max_value_index_index_index = numbers.find(i => i == max_value_index_index);\n  let min_value_index_index_index_index = numbers.find(i => i == min_value_index_index_index);\n  let max_value_index_index_index_index = numbers.find(i => i == max_value_index_index_index);\n  let min_value_index_index_index_index_index = numbers.find(i => i == min_value_index_index_index_index);\n  let max_value_index_index_index_index_index = numbers.find(i => i == max_value_index_index_index_index);\n  let min_value_index_index_index_index_index_index = numbers.find(i => i == min_value_index_index_index_index_index);\n  let max_value_index_index_index_index_index_index = numbers.find(i => i == max_value_index_index_index_index\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp5xbxxdgu.rs:26:40\n   |\n26 |   let min_value_index = numbers.find(i => i == min_value);\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp5xbxxdgu.rs:37:67\n   |\n7  | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n   |                                                           - closing delimiter possibly meant for this\n...\n37 |   let max_value_index_index_index_index_index_index = numbers.find(i => i == max_value_index_index_index_index\n   |                                                                   ^ unclosed delimiter\n38 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    }\n    if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    let diff = i - min_value;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff < min_value {\n      min_value = diff;\n      min_index = i;\n    }\n    let diff = max_value - i;\n    if diff < 0 {\n      diff = -diff;\n    }\n    if diff < max_value {\n      max_value = diff;\n      max_index = i;\n    }\n  }\n  return (min_index, max_index);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:14:12\n   |\n14 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:15:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n15 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:22:15\n   |\n22 |     if diff < 0 {\n   |               ^\n   |               |\n   |               expected `f64`, found integer\n   |               help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:27:19\n   |\n18 |   let min_index = 0;\n   |                   - expected due to this value\n...\n27 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:30:15\n   |\n30 |     if diff < 0 {\n   |               ^\n   |               |\n   |               expected `f64`, found integer\n   |               help: use a float literal: `0.0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgpb672mu.rs:35:19\n   |\n19 |   let max_index = 0;\n   |                   - expected due to this value\n...\n3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for number in numbers {\n    if number < min_number {\n      min_number = number;\n    }\n    if number > max_number {\n      max_number = number;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in 0..numbers.len() {\n    let number = numbers[i];\n    if number < min_number {\n      min_number = number;\n      min_index = i;\n    }\n    if number > max_number {\n      max_number = number;\n      max_index = i;\n    }\n  }\n  let min_value = numbers[min_index];\n  let max_value = numbers[max_index];\n  return (min_value, max_value);\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `min_number`\n  --> /tmp/tmpkng1s1y9.rs:12:7\n   |\n8  |   let min_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `min_number`\n   |       help: consider making this binding mutable: `mut min_number`\n...\n12 |       min_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_number`\n  --> /tmp/tmpkng1s1y9.rs:15:7\n   |\n9  |   let max_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `max_number`\n   |       help: consider making this binding mutable: `mut max_number`\n...\n15 |       max_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `numbers`\n   --> /tmp/tmpkng1s1y9.rs:20:15\n    |\n7   | fn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n    |                          ------- move occurs because `numbers` has type `Vec<f64>`, which does not implement the `Copy` trait\n...\n10  |   for number in numbers {\n    |                 ------- `numbers` moved due to this implicit call to `.into_iter()`\n...\n20  |   for i in 0..numbers.len() {\n    |               ^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<f64>`'s content to avoid moving into the `for` loop\n    |\n10  |   for number in &numbers {\n    |                 +\n\nerror[E0384]: cannot assign twice to immutable variable `min_number`\n  --> /tmp/tmpkng1s1y9.rs:23:7\n   |\n8  |   let min_number = numbers[0];\n   |       ----------\n   |       |\n   |       first assignment to `min_number`\n   |       help: consider making this binding mutable: `mut min_number`\n...\n23 |       min_number = number;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `min_index`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_number = numbers[0];\n  let max_number = numbers[0];\n  for i in numbers.iter() {\n    if i < min_number {\n      min_number = i;\n    }\n    if i > max_number {\n      max_number = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_number {\n      min_index = i;\n    }\n    if i == max_number {\n      max_index = i;\n    }\n  }\n  let min_diff = abs(numbers[min_index] - min_number);\n  let max_diff = abs(numbers[max_index] - max_number);\n  if min_diff < max_diff {\n    return (min_number, max_number);\n  } else {\n    return (max_number, min_number);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmppfjcpt6l.rs:28:18\n   |\n28 |   let min_diff = abs(numbers[min_index] - min_number);\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmppfjcpt6l.rs:29:18\n   |\n29 |   let max_diff = abs(numbers[max_index] - max_number);\n   |                  ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfjcpt6l.rs:11:12\n   |\n11 |     if i < min_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfjcpt6l.rs:12:20\n   |\n8  |   let min_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       min_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_number = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfjcpt6l.rs:14:12\n   |\n14 |     if i > max_number {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&max_number`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppfjcpt6l.rs:15:20\n   |\n9  |   let max_number = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |       max_number = i;\n   |                    ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_number = *i;\n   |                    +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmppfjcpt6l.rs:21:10\n   |\n21 |     if i == min_number {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a supplied vector of numbers (of length at least two) select and return two that are the closest to each\n/// other and return them in order (smaller number, larger number).\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfn find_closest_elements(numbers: Vec<f64>) -> (f64, f64) {\n  let min_value = numbers[0];\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if i < min_value {\n      min_value = i;\n    } else if i > max_value {\n      max_value = i;\n    }\n  }\n  let min_index = 0;\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_index = i;\n    } else if i == max_value {\n      max_index = i;\n    }\n  }\n  let min_diff = numbers[0] - numbers[min_index];\n  let max_diff = numbers[0] - numbers[max_index];\n  let min_diff_index = 0;\n  let max_diff_index = 0;\n  for i in numbers.iter() {\n    if i == min_value {\n      min_diff_index = i;\n    } else if i == max_value {\n      max_diff_index = i;\n    }\n  }\n  if min_diff < max_diff {\n    return (min_value, numbers[min_index]);\n  } else {\n    return (numbers[max_index], numbers[min_index]);\n  }\n}\n\nfn main() {\n    let candidate = find_closest_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2]), (3.9, 4.0));\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0]), (5.0, 5.9));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.2]), (2.0, 2.2));\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0]), (2.0, 2.0));\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1]), (2.2, 3.1));\n}\n",
      "timestamp": 1664292822,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpg46twjb5.rs:11:12\n   |\n11 |     if i < min_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&f64`, found `f64`\n   |            help: consider borrowing here: `&min_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg46twjb5.rs:12:19\n   |\n8  |   let min_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n12 |       min_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       min_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg46twjb5.rs:13:19\n   |\n13 |     } else if i > max_value {\n   |                   ^^^^^^^^^\n   |                   |\n   |                   expected `&f64`, found `f64`\n   |                   help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg46twjb5.rs:14:19\n   |\n9  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n14 |       max_value = i;\n   |                   ^ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_value = *i;\n   |                   +\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpg46twjb5.rs:20:10\n   |\n20 |     if i == min_value {\n   |          ^^ no implementation for `&f64 == f64`\n   |\n   = help: the trait `PartialEq<f64>` is not implemented for `&f64`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg46twjb5.rs:21:19\n   |\n17 |   let min_index = 0;\n   |                   - expected due to this value\n...\n21 |       min_index = i;\n   |                   ^ expected integer, found `&f64`\n\nerror[E0277]: can't compare `&f64` with `f64`\n  --> /tmp/tmpg46twjb5.rs:22:17\n   |\n22 |     } else if i == max_val",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}