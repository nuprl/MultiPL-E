{
  "name": "HumanEval_161_solve",
  "language": "rs",
  "prompt": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n",
  "tests": "}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      r = r.insert(i, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      r = r.insert(i, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplofyx0rq.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplofyx0rq.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplofyx0rq.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmplofyx0rq.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmplofyx0rq.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplofyx0rq.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      let [_, lower, upper] = i;\n      let [lower_, upper_] = lower.to_upper() if lower < 'a' else lower.to_lower();\n      let [lower_, upper_] = upper.to_upper() if upper < 'a' else upper.to_lower();\n      result = result.replace(i, upper_ + upper_);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword `if`\n  --> /tmp/tmppt4jze3u.rs:18:47\n   |\n18 |       let [lower_, upper_] = lower.to_upper() if lower < 'a' else lower.to_lower();\n   |                                               ^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmppt4jze3u.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmppt4jze3u.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  let mut i = 0;\n  while (i < r.len()) {\n    if (r[i].is_upper()) {\n      r = r.substr(0, i) + r.substr(i).to_upper() + r.substr(i + 1);\n    } else if (r[i].is_lower()) {\n      r = r.substr(0, i) + r.substr(i).to_upper() + r.substr(i + 1);\n    }\n    i += 1;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpabs79mma.rs:16:9\n   |\n16 |   while (i < r.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < r.len()) {\n16 +   while i < r.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpabs79mma.rs:17:8\n   |\n17 |     if (r[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (r[i].is_upper()) {\n17 +     if r[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpabs79mma.rs:19:15\n   |\n19 |     } else if (r[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (r[i].is_lower()) {\n19 +     } else if r[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpabs79mma.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut s2 = s.to_lower();\n  let mut s3 = s.to_upper();\n  let mut s4 = s.to_upper();\n  let mut s5 = s.to_lower();\n  let mut s6 = s.to_lower();\n  let mut s7 = s.to_lower();\n  let mut s8 = s.to_lower();\n  let mut s9 = s.to_lower();\n  let mut s10 = s.to_lower();\n  let mut s11 = s.to_lower();\n  let mut s12 = s.to_lower();\n  let mut s13 = s.to_lower();\n  let mut s14 = s.to_lower();\n  let mut s15 = s.to_lower();\n  let mut s16 = s.to_lower();\n  let mut s17 = s.to_lower();\n  let mut s18 = s.to_lower();\n  let mut s19 = s.to_lower();\n  let mut s20 = s.to_lower();\n  let mut s21 = s.to_lower();\n  let mut s22 = s.to_lower();\n  let mut s23 = s.to_lower();\n  let mut s24 = s.to_lower();\n  let mut s25 = s.to_lower();\n  let mut s26 = s.to_lower();\n  let mut s27 = s.to_lower();\n  let mut s28 = s.to_lower();\n  let mut s29 = s.to_lower();\n  let mut s30 = s.to_lower();\n  let mut s31 = s.to_lower();\n  let mut s32 = s.to_lower();\n  let mut s33 = s.to_lower();\n  let mut s34 = s.to_lower();\n  let mut s35 = s.to_lower();\n  let mut s36 = s.to_lower();\n  let mut s37 = s.to_lower();\n  let mut s38 = s.to_lower();\n  let mut s39 = s.to_lower();\n  let mut s40 = s.to_lower();\n  let mut s41\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_eh_1f9m.rs:53:14\n   |\n53 |   let mut s41\n   |              ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:14:18\n   |\n14 |   let mut s2 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:15:18\n   |\n15 |   let mut s3 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:16:18\n   |\n16 |   let mut s4 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:17:18\n   |\n17 |   let mut s5 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:18:18\n   |\n18 |   let mut s6 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:19:18\n   |\n19 |   let mut s7 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:20:18\n   |\n20 |   let mut s8 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_l",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp32xmpjuw.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp32xmpjuw.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut s_copy = s\n  let mut s_lower = s\n  let mut s_upper = s\n  let mut s_reversed = s\n  let mut s_reversed_lower = s\n  let mut s_reversed_upper = s\n  let mut s_reversed_reversed = s\n  let mut s_reversed_reversed_lower = s\n  let mut s_reversed_reversed_upper = s\n  let mut s_reversed_reversed_reversed = s\n  let mut s_reversed_reversed_reversed_lower = s\n  let mut s_reversed_reversed_reversed_upper = s\n  let mut s_reversed_reversed_reversed_reversed = s\n  let mut s_reversed_reversed_reversed_reversed_lower = s\n  let mut s_reversed_reversed_reversed_reversed_upper = s\n  let mut s_reversed_reversed_reversed_reversed_reversed = s\n  let mut s_reversed_reversed_reversed_reversed_reversed_lower = s\n  let mut s_reversed_reversed_reversed_reversed_reversed_upper = s\n  let mut s_reversed_reversed_reversed_reversed_reversed_reversed = s\n  let mut s_reversed_reversed_reversed_reversed_reversed_reversed_lower = s\n  let mut s_reversed_reversed_reversed_reversed_reversed_reversed_upper = s\n  let mut s_reversed_reversed_reversed_reversed_reversed_reversed_reversed = s\n  let mut s_reversed_reversed_reversed_reversed_reversed_reversed_reversed_lower = s\n  let mut s_reversed_revers\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:14:21\n   |\n14 |   let mut s_copy = s\n   |                     ^ help: add `;` here\n15 |   let mut s_lower = s\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:15:22\n   |\n15 |   let mut s_lower = s\n   |                      ^ help: add `;` here\n16 |   let mut s_upper = s\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:16:22\n   |\n16 |   let mut s_upper = s\n   |                      ^ help: add `;` here\n17 |   let mut s_reversed = s\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:17:25\n   |\n17 |   let mut s_reversed = s\n   |                         ^ help: add `;` here\n18 |   let mut s_reversed_lower = s\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:18:31\n   |\n18 |   let mut s_reversed_lower = s\n   |                               ^ help: add `;` here\n19 |   let mut s_reversed_upper = s\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:19:31\n   |\n19 |   let mut s_reversed_upper = s\n   |                               ^ help: add `;` here\n20 |   let mut s_reversed_reversed = s\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:20:34\n   |\n20 |   let mut s_reversed_reversed = s\n   |                                  ^ help: add `;` here\n21 |   let mut s_reversed_reversed_lower = s\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:21:40\n   |\n21 |   let mut s_reversed_reversed_lower = s\n   |                                        ^ help: add `;` here\n22 |   let mut s_reversed_reversed_upper = s\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5gzgqw46.rs:22:40\n   |\n22 |   let mut s_reversed_reversed_upper = s\n   |                                        ^ help: add `;` here\n23 |   let mut s_reversed_r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower()\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower()\n      let u = i.to_upper()\n      if l == u {\n        result = result.replace(i, l)\n      } else {\n        result = result.replace(i, u)\n      }\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpfpfmpn39.rs:14:32\n   |\n14 |   let mut result = s.to_lower()\n   |                                ^ help: add `;` here\n15 |   for i in s.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpfpfmpn39.rs:17:27\n   |\n17 |       let l = i.to_lower()\n   |                           ^ help: add `;` here\n18 |       let u = i.to_upper()\n   |       --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpfpfmpn39.rs:18:27\n   |\n18 |       let u = i.to_upper()\n   |                           ^ help: add `;` here\n19 |       if l == u {\n   |       -- unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpfpfmpn39.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpfpfmpn39.rs:14:22\n   |\n14 |   let mut result = s.to_lower()\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpfpfmpn39.rs:17:17\n   |\n17 |       let l = i.to_lower()\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpfpfmpn39.rs:18:17\n   |\n18 |       let u = i.to_upper()\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmphfcy2xd9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      if is_lower(i) {\n        result = result.replace(i, upper(i));\n      } else {\n        result = result.replace(i, lower(i));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp7w37_ap9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmp7w37_ap9.rs:17:10\n   |\n17 |       if is_lower(i) {\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `upper` in this scope\n  --> /tmp/tmp7w37_ap9.rs:18:36\n   |\n18 |         result = result.replace(i, upper(i));\n   |                                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lower` in this scope\n  --> /tmp/tmp7w37_ap9.rs:20:36\n   |\n20 |         result = result.replace(i, lower(i));\n   |                                    ^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp7w37_ap9.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let l = s.len();\n      let r = l - i - 1;\n      let lc = c.to_upper();\n      let rc = c.to_lower();\n      if lc == rc {\n        result = result.substr(0, i) + lc + result.substr(i + 1, r);\n      } else {\n        result = result.substr(0, i) + rc + result.substr(i + 1, r);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmplppfgo3b.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmplppfgo3b.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplppfgo3b.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplppfgo3b.rs:17:15\n   |\n17 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(s[i], s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(s[i], s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpws71yv_2.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:17:21\n   |\n17 |       r = r.replace(s[i], s[i].to_lower());\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:17:27\n   |\n17 |       r = r.replace(s[i], s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Inde",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy7qifssk.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy7qifssk.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy7qifssk.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpy7qifssk.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7qifssk.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7qifssk.rs:18:31\n   |\n18 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy7qifssk.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy7qifssk.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy7qifssk.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpy7qifssk.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7qifssk.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7qifssk.rs:18:31\n   |\n18 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpw660qqz3.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw660qqz3.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw660qqz3.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpw660qqz3.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw660qqz3.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw660qqz3.rs:18:37\n   |\n18 |       result = result.replace(i, 1, s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp32xmpjuw.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp32xmpjuw.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      let u = s[i].to_upper();\n      if l == u {\n        res = res.replace(i, 1, l);\n      } else {\n        res = res.replace(i, 1, u);\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp4lmw6h_w.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp4lmw6h_w.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:18:15\n   |\n18 |       let u = s[i].to_upper();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while i < s.len() {\n    if s[i].is_upper() {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpfun9cgvh.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:17:8\n   |\n17 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:18:31\n   |\n18 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:19:15\n   |\n19 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<Rang",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpx5f7mkdk.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpx5f7mkdk.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmptgogtc1g.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptgogtc1g.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptgogtc1g.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptgogtc1g.rs:19:27\n   |\n19 |       r = r.replace(i, 1, s[i].to_upper());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String a",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s;\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1vfjneaf.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1vfjneaf.rs:17:31\n   |\n17 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp1vfjneaf.rs:17:17\n    |\n17  |       res = res.replace(i, 1, s[i].to_lower());\n    |                 ^^^^^^^ -  -  --------------- supplied 3 arguments\n    |                 |\n    |                 expected 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1vfjneaf.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      r = r.replace(i, i.to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp8qrfdgf0.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8qrfdgf0.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8qrfdgf0.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `to_upper` found for type `usize` in the current scope\n  --> /tmp/tmp8qrfdgf0.rs:17:26\n   |\n17 |       r = r.replace(i, i.to_upper());\n   |                          ^^^^^^^^ method not found in `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      if s[i].is_upper() {\n        r = r.replace(i, i, s[i].to_lower());\n      } else {\n        r = r.replace(i, i, s[i].to_upper());\n      }\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpax75dxx8.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpax75dxx8.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpax75dxx8.rs:17:10\n   |\n17 |       if s[i].is_upper() {\n   |          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpax75dxx8.rs:18:29\n   |\n18 |         r = r.replace(i, i, s[i].to_lower());\n   |                             ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<Rang",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      r = r.replace(l, l.to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp34ecr7gd.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp34ecr7gd.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34ecr7gd.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34ecr7gd.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      if s[i].is_upper() {\n        res = res.replace(i, 1, s[i].to_lower());\n      } else {\n        res = res.replace(i, 1, s[i].to_upper());\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp3l0hvsgz.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:17:10\n   |\n17 |       if s[i].is_upper() {\n   |          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:18:33\n   |\n18 |         res = res.replace(i, 1, s[i].to_lower());\n   |                                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as In",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while i < s.len() {\n    if s[i].is_upper() {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if s[i].is_lower() {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp036r4x1p.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp036r4x1p.rs:17:8\n   |\n17 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp036r4x1p.rs:18:31\n   |\n18 |       result = result.replace(s[i], s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp036r4x1p.rs:18:37\n   |\n18 |       result = result.replace(s[i], s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk0yn3mll.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk0yn3mll.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk0yn3mll.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk0yn3mll.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk0yn3mll.rs:18:37\n   |\n18 |       result = result.replace(i, 1, s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.bounds(1, s.len()).map(|(i, l) => {\n    if s[i].is_upper() {\n      return s[i].to_lower()\n    } else {\n      return s[i].to_upper()\n    }\n  }).collect(|_| s)\n  return r\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected one of `,` or `:`, found `=>`\n  --> /tmp/tmp08smmhys.rs:14:48\n   |\n14 |   let mut r = s.bounds(1, s.len()).map(|(i, l) => {\n   |                                                ^^ expected one of `,` or `:`\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      if is_lower(i) {\n        result = result.replace(i, uppercase(i));\n      } else {\n        result = result.replace(i, lowercase(i));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpxkm4n338.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmpxkm4n338.rs:17:10\n   |\n17 |       if is_lower(i) {\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `uppercase` in this scope\n  --> /tmp/tmpxkm4n338.rs:18:36\n   |\n18 |         result = result.replace(i, uppercase(i));\n   |                                    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lowercase` in this scope\n  --> /tmp/tmpxkm4n338.rs:20:36\n   |\n20 |         result = result.replace(i, lowercase(i));\n   |                                    ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in range(0, len(s)) {\n    if is_letter(s[i]) {\n      if s[i].is_upper() {\n        result[i] = s[i].to_lower();\n      } else {\n        result[i] = s[i].to_upper();\n      }\n    }\n  }\n  return result.to_string();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpdddbqhpp.rs:15:12\n   |\n15 |   for i in range(0, len(s)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpdddbqhpp.rs:15:21\n   |\n15 |   for i in range(0, len(s)) {\n   |                     ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpdddbqhpp.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpdddbqhpp.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpw660qqz3.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw660qqz3.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw660qqz3.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpw660qqz3.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw660qqz3.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw660qqz3.rs:18:37\n   |\n18 |       result = result.replace(i, 1, s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in range(0, len(s)) {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let upper = is_upper(c);\n      let lower = is_lower(c);\n      if upper {\n        result = result.replace(c, upper);\n      } else if lower {\n        result = result.replace(c, lower);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpm1vka9zj.rs:15:12\n   |\n15 |   for i in range(0, len(s)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpm1vka9zj.rs:15:21\n   |\n15 |   for i in range(0, len(s)) {\n   |                     ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpm1vka9zj.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_upper` in this scope\n  --> /tmp/tmpm1vka9zj.rs:18:19\n   |\n18 |       let upper = is_upper(c);\n   |                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmpm1vka9zj.rs:19:19\n   |\n19 |       let lower = is_lower(c);\n   |                   ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpm1vka9zj.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while i < len(s) {\n    if is_letter(s[i]) {\n      let ch = s[i];\n      let upper = is_upper(ch);\n      let lower = is_lower(ch);\n      if upper {\n        result = result.replace(ch, ch.to_upper());\n      } else if lower {\n        result = result.replace(ch, ch.to_lower());\n      }\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpscvy53g5.rs:16:13\n   |\n16 |   while i < len(s) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpscvy53g5.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_upper` in this scope\n  --> /tmp/tmpscvy53g5.rs:19:19\n   |\n19 |       let upper = is_upper(ch);\n   |                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmpscvy53g5.rs:20:19\n   |\n20 |       let lower = is_lower(ch);\n   |                   ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpscvy53g5.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpscvy53g5.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpscvy53g5.rs:18:16\n   |\n18 |       let ch = s[i];\n   |                ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeF",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      let u = s[i].to_upper();\n      if l == u {\n        res = res.replace(i, 1, l);\n      } else {\n        res = res.replace(i, 1, u);\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp4lmw6h_w.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp4lmw6h_w.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:18:15\n   |\n18 |       let u = s[i].to_upper();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while i < len(s) {\n    if is_letter(s[i]) {\n      let mut j = i + 1;\n      while j < len(s) && is_letter(s[j]) {\n        result = result.replace(j, 1, s[j].to_upper());\n        j += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpe9vkdthz.rs:16:13\n   |\n16 |   while i < len(s) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpe9vkdthz.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpe9vkdthz.rs:19:17\n   |\n19 |       while j < len(s) && is_letter(s[j]) {\n   |                 ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpe9vkdthz.rs:19:27\n   |\n19 |       while j < len(s) && is_letter(s[j]) {\n   |                           ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpe9vkdthz.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpe9vkdthz.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpe9vkdthz.rs:19:37\n   |\n19 |       while j < len(s) && is_letter(s[j]) {\n   |                                     ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      res[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      res[i] = s[i].to_upper();\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp87mgm1_b.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp87mgm1_b.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp87mgm1_b.rs:17:16\n   |\n17 |       res[i] = s[i].to_lower();\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp87mgm1_b.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      if is_lower(i) {\n        result = result.replace(i, upper(i));\n      } else {\n        result = result.replace(i, lower(i));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp7w37_ap9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmp7w37_ap9.rs:17:10\n   |\n17 |       if is_lower(i) {\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `upper` in this scope\n  --> /tmp/tmp7w37_ap9.rs:18:36\n   |\n18 |         result = result.replace(i, upper(i));\n   |                                    ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lower` in this scope\n  --> /tmp/tmp7w37_ap9.rs:20:36\n   |\n20 |         result = result.replace(i, lower(i));\n   |                                    ^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp7w37_ap9.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp__7oxofb.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp__7oxofb.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp__7oxofb.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmphfcy2xd9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let c = i.to_upper();\n      result = result.replace(c, c.to_lower());\n    }\n  }\n  return result.to_upper();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpb3l2vd1d.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpb3l2vd1d.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpb3l2vd1d.rs:17:17\n   |\n17 |       let c = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while i < len(s) {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let l = lowercase(c);\n      let u = uppercase(c);\n      result = result.replace(c, l);\n      result = result.replace(c, u);\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp5g2ljty0.rs:16:13\n   |\n16 |   while i < len(s) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp5g2ljty0.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lowercase` in this scope\n  --> /tmp/tmp5g2ljty0.rs:19:15\n   |\n19 |       let l = lowercase(c);\n   |               ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `uppercase` in this scope\n  --> /tmp/tmp5g2ljty0.rs:20:15\n   |\n20 |       let u = uppercase(c);\n   |               ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp5g2ljty0.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp5g2ljty0.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp5g2ljty0.rs:18:15\n   |\n18 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut s2 = s.to_lower();\n  let mut s3 = s.to_upper();\n  let mut s4 = s.to_upper();\n  let mut s5 = s.to_lower();\n  let mut s6 = s.to_lower();\n  let mut s7 = s.to_upper();\n  let mut s8 = s.to_lower();\n  let mut s9 = s.to_upper();\n  let mut s10 = s.to_lower();\n  let mut s11 = s.to_upper();\n  let mut s12 = s.to_lower();\n  let mut s13 = s.to_upper();\n  let mut s14 = s.to_lower();\n  let mut s15 = s.to_upper();\n  let mut s16 = s.to_lower();\n  let mut s17 = s.to_upper();\n  let mut s18 = s.to_lower();\n  let mut s19 = s.to_upper();\n  let mut s20 = s.to_lower();\n  let mut s21 = s.to_upper();\n  let mut s22 = s.to_lower();\n  let mut s23 = s.to_upper();\n  let mut s24 = s.to_lower();\n  let mut s25 = s.to_upper();\n  let mut s26 = s.to_lower();\n  let mut s27 = s.to_upper();\n  let mut s28 = s.to_lower();\n  let mut s29 = s.to_upper();\n  let mut s30 = s.to_lower();\n  let mut s31 = s.to_upper();\n  let mut s32 = s.to_lower();\n  let mut s33 = s.to_upper();\n  let mut s34 = s.to_lower();\n  let mut s35 = s.to_upper();\n  let mut s36 = s.to_lower();\n  let mut s37 = s.to_upper();\n  let mut s38 = s.to_lower();\n  let mut s39 = s.to_upper();\n  let mut s40 = s.to_lower();\n  let mut s41\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp8q9to3m6.rs:53:14\n   |\n53 |   let mut s41\n   |              ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8q9to3m6.rs:14:18\n   |\n14 |   let mut s2 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp8q9to3m6.rs:15:18\n   |\n15 |   let mut s3 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp8q9to3m6.rs:16:18\n   |\n16 |   let mut s4 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8q9to3m6.rs:17:18\n   |\n17 |   let mut s5 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8q9to3m6.rs:18:18\n   |\n18 |   let mut s6 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp8q9to3m6.rs:19:18\n   |\n19 |   let mut s7 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8q9to3m6.rs:20:18\n   |\n20 |   let mut s8 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpuzbqdd0c.rs:17:13\n    |\n17  |       r = r.replace(i, 1, s[i].to_lower());\n    |             ^^^^^^^ -  -  --------------- supplied 3 arguments\n    |             |\n    |             expected 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  let mut c = s.to_upper();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, c[i]);\n    } else {\n      r = r.replace(i, 1, s[i]);\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpqb3obdj9.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpqb3obdj9.rs:15:17\n   |\n15 |   let mut c = s.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqb3obdj9.rs:17:8\n   |\n17 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqb3obdj9.rs:20:27\n   |\n20 |       r = r.replace(i, 1, s[i]);\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpog_ruarg.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpog_ruarg.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpog_ruarg.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpog_ruarg.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpog_ruarg.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpog_ruarg.rs:18:31\n   |\n18 |       result = result.replace(s[i], s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    let c = s[i];\n    if (c.is_upper()) {\n      result = result.replace(c, c.to_lower());\n    } else if (c.is_lower()) {\n      result = result.replace(c, c.to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpm_pcvleg.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm_pcvleg.rs:18:8\n   |\n18 |     if (c.is_upper()) {\n   |        ^            ^\n   |\nhelp: remove these parentheses\n   |\n18 -     if (c.is_upper()) {\n18 +     if c.is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm_pcvleg.rs:20:15\n   |\n20 |     } else if (c.is_lower()) {\n   |               ^            ^\n   |\nhelp: remove these parentheses\n   |\n20 -     } else if (c.is_lower()) {\n20 +     } else if c.is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpm_pcvleg.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpm_pcvleg.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpm_pcvleg.rs:17:13\n   |\n17 |     let c = s[i];\n   |             ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: abort",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower()\n  let mut i = 0\n  while i < len(result) {\n    if is_letter(result[i]) {\n      let mut j = i + 1\n      while j < len(result) and is_letter(result[j]) {\n        result[j] = to_upper(result[j])\n        j += 1\n      }\n      i = j\n    } else {\n      i += 1\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpvh4tjifp.rs:14:32\n   |\n14 |   let mut result = s.to_lower()\n   |                                ^ help: add `;` here\n15 |   let mut i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpvh4tjifp.rs:15:16\n   |\n15 |   let mut i = 0\n   |                ^ help: add `;` here\n16 |   while i < len(result) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpvh4tjifp.rs:18:24\n   |\n18 |       let mut j = i + 1\n   |                        ^ help: add `;` here\n19 |       while j < len(result) and is_letter(result[j]) {\n   |       ----- unexpected token\n\nerror: `and` is not a logical operator\n  --> /tmp/tmpvh4tjifp.rs:19:29\n   |\n19 |       while j < len(result) and is_letter(result[j]) {\n   |                             ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpvh4tjifp.rs:20:40\n   |\n20 |         result[j] = to_upper(result[j])\n   |                                        ^ help: add `;` here\n21 |         j += 1\n   |         - unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpvh4tjifp.rs:16:13\n   |\n16 |   while i < len(result) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpvh4tjifp.rs:17:8\n   |\n17 |     if is_letter(result[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpvh4tjifp.rs:19:17\n   |\n19 |       while j < len(result) and is_letter(result[j]) {\n   |                 ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpvh4tjifp.rs:19:33\n   |\n19 |       while j < len(result) and is_letter(result[j]) {\n   |                                 ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      if s[i].is_upper() {\n        res = res.replace(i, 1, s[i].to_lower());\n      } else {\n        res = res.replace(i, 1, s[i].to_upper());\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp38sdvjdb.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp38sdvjdb.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp38sdvjdb.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp38sdvjdb.rs:17:10\n   |\n17 |       if s[i].is_upper() {\n   |          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp38sdvjdb.rs:18:33\n   |\n18 |         res = res.replace(i, 1, s[i].to_lower());\n   |                                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while(i < s.len()) {\n    if(s[i].is_upper()) {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if(s[i].is_lower()) {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk_lgt6f3.rs:16:8\n   |\n16 |   while(i < s.len()) {\n   |        ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while(i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk_lgt6f3.rs:17:7\n   |\n17 |     if(s[i].is_upper()) {\n   |       ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if(s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk_lgt6f3.rs:19:14\n   |\n19 |     } else if(s[i].is_lower()) {\n   |              ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if(s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpk_lgt6f3.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk_lgt6f3.rs:17:8\n   |\n17 |     if(s[i].is_upper()) {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk_lgt6f3.rs:18:31\n   |\n18 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let lower = to_lower(i);\n      let upper = to_upper(i);\n      if lower < upper {\n        result = result.replace(lower, upper);\n      } else {\n        result = result.replace(upper, lower);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmph94dfmml.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmph94dfmml.rs:17:19\n   |\n17 |       let lower = to_lower(i);\n   |                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmph94dfmml.rs:18:19\n   |\n18 |       let upper = to_upper(i);\n   |                   ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpokiheivh.rs:14:21\n   |\n14 |   let mut result = s\n   |                     ^ help: add `;` here\n15 |   for i in s.chars() {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpokiheivh.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmpokiheivh.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.copy();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < s.len) {\n    if (s[i].is_upper()) {\n      result[j] = s[i].to_lower();\n      j += 1;\n    } else if (s[i].is_lower()) {\n      result[j] = s[i].to_upper();\n      j += 1;\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpujpcdgzx.rs:17:9\n   |\n17 |   while (i < s.len) {\n   |         ^         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -   while (i < s.len) {\n17 +   while i < s.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpujpcdgzx.rs:18:8\n   |\n18 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n18 -     if (s[i].is_upper()) {\n18 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpujpcdgzx.rs:21:15\n   |\n21 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     } else if (s[i].is_lower()) {\n21 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `copy` found for struct `String` in the current scope\n  --> /tmp/tmpujpcdgzx.rs:14:22\n   |\n14 |   let mut result = s.copy();\n   |                      ^^^^ method not found in `String`\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpujpcdgzx.rs:17:16\n   |\n17 |   while (i < s.len) {\n   |                ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n17 |   while (i < s.len()) {\n   |                   ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpujpcdgzx.rs:18:9\n   |\n18 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      if is_lower(c) {\n        res = res.replace(c, uppercase(c));\n      } else {\n        res = res.replace(c, lowercase(c));\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp_g34asf6.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmp_g34asf6.rs:18:10\n   |\n18 |       if is_lower(c) {\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `uppercase` in this scope\n  --> /tmp/tmp_g34asf6.rs:19:30\n   |\n19 |         res = res.replace(c, uppercase(c));\n   |                              ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `lowercase` in this scope\n  --> /tmp/tmp_g34asf6.rs:21:30\n   |\n21 |         res = res.replace(c, lowercase(c));\n   |                              ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_g34asf6.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_g34asf6.rs:17:15\n   |\n17 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Inde",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp43fbacil.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp43fbacil.rs:17:37\n   |\n17 |       result = result.replace(i, 1, s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp43fbacil.rs:17:23\n    |\n17  |       result = result.replace(i, 1, s[i].to_lower());\n    |                       ^^^^^^^ -  -  --------------- supplied 3 arguments\n    |                       |\n    |                       expected 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp43fbacil.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let lc = c.to_lower();\n      let uc = c.to_upper();\n      if lc == uc {\n        result = result.replace(c, c);\n      } else {\n        result = result.replace(lc, uc);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpp33sr3zq.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpp33sr3zq.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp33sr3zq.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp33sr3zq.rs:17:15\n   |\n17 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = String::from(s);\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbdfmpqbu.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbdfmpqbu.rs:17:31\n   |\n17 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpbdfmpqbu.rs:17:17\n    |\n17  |       res = res.replace(i, 1, s[i].to_lower());\n    |                 ^^^^^^^ -  -  --------------- supplied 3 arguments\n    |                 |\n    |                 expected 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbdfmpqbu.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Id",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.copy();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let l = s.len();\n      let r = l - i - 1;\n      let lc = to_lower(c);\n      let rc = to_upper(c);\n      let lr = to_lower(r);\n      let rr = to_upper(r);\n      let lc_r = lc + rr;\n      let rc_r = rc + rr;\n      let lr_c = lr + rc;\n      let rr_c = rr + rc;\n      let lc_rc = lc_r + rc;\n      let rc_lc = rc_r + lc;\n      let lr_rc = lr_c + rc;\n      let rr_lc = rr_c + lc;\n      let lc_rr = lc_rc + rr;\n      let rc_lr = rc_lc + lr;\n      let lr_rr = lr_rc + rr;\n      let rr_lr = rr_lc + lr;\n      let lc_lr = lc_rr + lr;\n      let rc_rr = rc_lr + rr;\n      let lr_lc = lr_rr + lc;\n      let rr_lc = rr_lr + lc;\n      let lc_rr_r = lc_lr + rr;\n      let rc_lr_r = rc_rr + lr;\n      let lr_rr_r = lr_lc + rr;\n      let rr_lr_r = rr_lc + lr;\n      let lc_rr_lc = lc_rr_r + lc;\n      let rc_lr_lc = rc_lr_r + lc;\n      let lr_rr_lc = lr_rr_r + lc;\n      let rr_lr_lc = rr_lr_r + lc;\n      let lc_rr_lr = lc_rr_lc + rr\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7ctpqn7y.rs:61:3\n   |\n13 | fn solve(s: String) -> String {\n   |                               - unclosed delimiter\n14 |   let mut result = s.copy();\n15 |   for i in 0..s.len() {\n   |                       - unclosed delimiter\n16 |     if is_letter(s[i]) {\n   |                        - this delimiter might not be properly closed...\n...\n49 | }\n   | - ...as it matches this but it has different indentation\n...\n61 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp7ctpqn7y.rs:48:35\n   |\n48 |       let lc_rr_lr = lc_rr_lc + rr\n   |                                   ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp7ctpqn7y.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmp7ctpqn7y.rs:20:16\n   |\n20 |       let lc = to_lower(c);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmp7ctpqn7y.rs:21:16\n   |\n21 |       let rc = to_upper(c);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmp7ctpqn7y.rs:22:16\n   |\n22 |       let lr = to_lower(r);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmp7ctpqn7y.rs:23:16\n   |\n23 |       let rr = to_upper(r);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `copy` found for struct `String` in the current scope\n  --> /tmp/tmp7ctpqn7y.rs:14:22\n   |\n14 |   let mut result = s.copy();\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7ctpqn7y.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      if c.is_upper() {\n        r = r.replace(c, c.to_lower());\n      } else {\n        r = r.replace(c, c.to_upper());\n      }\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpm7jdb2nb.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpm7jdb2nb.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm7jdb2nb.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm7jdb2nb.rs:17:15\n   |\n17 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower()\n  for i in s.chars() {\n    if is_letter(i) {\n      let [_, lower, upper] = i\n      if lower == upper {\n        result = result.replace(i, upper)\n      } else {\n        result = result.replace(i, upper)\n      }\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpf5_85qe8.rs:14:32\n   |\n14 |   let mut result = s.to_lower()\n   |                                ^ help: add `;` here\n15 |   for i in s.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpf5_85qe8.rs:17:32\n   |\n17 |       let [_, lower, upper] = i\n   |                                ^ help: add `;` here\n18 |       if lower == upper {\n   |       -- unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpf5_85qe8.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpf5_85qe8.rs:14:22\n   |\n14 |   let mut result = s.to_lower()\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0529]: expected an array or slice, found `char`\n  --> /tmp/tmpf5_85qe8.rs:17:11\n   |\n17 |       let [_, lower, upper] = i\n   |           ^^^^^^^^^^^^^^^^^ pattern cannot match with input type `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0529, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  let mut i = 0;\n  while (i < r.len()) {\n    if (is_letter(r[i])) {\n      let l = i;\n      let r = i + 1;\n      while (r < r.len() && is_letter(r[0])) {\n        r += 1;\n      }\n      let lc = r - l;\n      let rc = r - l;\n      for (let j = 0; j < lc; j += 1) {\n        let c = r[j];\n        r[j] = r[rc - j];\n        r[rc - j] = c;\n      }\n      i = r;\n    } else {\n      i += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpuxj1rv3b.rs:25:12\n   |\n25 |       for (let j = 0; j < lc; j += 1) {\n   |            ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `j`\n  --> /tmp/tmpuxj1rv3b.rs:25:16\n   |\n25 |       for (let j = 0; j < lc; j += 1) {\n   |               -^ expected one of `)`, `,`, `@`, or `|`\n   |               |\n   |               help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpuxj1rv3b.rs:25:18\n   |\n25 |       for (let j = 0; j < lc; j += 1) {\n   |                  ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpuxj1rv3b.rs:25:17\n   |\n25 |       for (let j = 0; j < lc; j += 1) {\n   |                 ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpuxj1rv3b.rs:25:18\n   |\n25 |       for (let j = 0; j < lc; j += 1) {\n   |                  ^ expected expression\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpuxj1rv3b.rs:17:9\n   |\n17 |     if (is_letter(r[i])) {\n   |         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpuxj1rv3b.rs:20:29\n   |\n20 |       while (r < r.len() && is_letter(r[0])) {\n   |                             ^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpuxj1rv3b.rs:16:9\n   |\n16 |   while (i < r.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < r.len()) {\n16 +   while i < r.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuxj1rv3b.rs:17:8\n   |\n17 |     if (is_letter(r[i])) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (is_letter(r[i])) {\n17 +     if is_letter(r[i]) {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpuxj1rv3b.rs:20:13\n   |\n20 |       whil",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  let mut i = 0;\n  while i < len(s) {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let l = to_lower(c);\n      let u = to_upper(c);\n      if l == u {\n        result = result.replace(i, 1, l);\n      } else {\n        result = result.replace(i, 1, u);\n      }\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp_vr_klkp.rs:16:13\n   |\n16 |   while i < len(s) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp_vr_klkp.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmp_vr_klkp.rs:19:15\n   |\n19 |       let l = to_lower(c);\n   |               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmp_vr_klkp.rs:20:15\n   |\n20 |       let u = to_upper(c);\n   |               ^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_vr_klkp.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_vr_klkp.rs:18:15\n   |\n18 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3463f7xm.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3463f7xm.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3463f7xm.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp3463f7xm.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmp3463f7xm.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp3463f7xm.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      let u = s[i].to_upper();\n      if l == u {\n        result = result.replace(i, 1, &l);\n      } else {\n        result = result.replace(i, 1, &u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp6_1uu1xi.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6_1uu1xi.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6_1uu1xi.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6_1uu1xi.rs:18:15\n   |\n18 |       let u = s[i].to_upper();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower()\n  for i in s.chars() {\n    if is_letter(i) {\n      if is_lower(i) {\n        result = result.replace(i, i.to_upper())\n      } else {\n        result = result.replace(i, i.to_lower())\n      }\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpglbvwacx.rs:14:32\n   |\n14 |   let mut result = s.to_lower()\n   |                                ^ help: add `;` here\n15 |   for i in s.chars() {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpglbvwacx.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmpglbvwacx.rs:17:10\n   |\n17 |       if is_lower(i) {\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpglbvwacx.rs:14:22\n   |\n14 |   let mut result = s.to_lower()\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpglbvwacx.rs:18:38\n   |\n18 |         result = result.replace(i, i.to_upper())\n   |                                      ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpglbvwacx.rs:20:38\n   |\n20 |         result = result.replace(i, i.to_lower())\n   |                                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpuzbqdd0c.rs:17:13\n    |\n17  |       r = r.replace(i, 1, s[i].to_lower());\n    |             ^^^^^^^ -  -  --------------- supplied 3 arguments\n    |             |\n    |             expected 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let [lower, upper] = s[i].to_lower(), s[i].to_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n  --> /tmp/tmpvrwjg30g.rs:17:43\n   |\n17 |       let [lower, upper] = s[i].to_lower(), s[i].to_upper();\n   |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpvrwjg30g.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpvrwjg30g.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvrwjg30g.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut s2 = s.to_lower()\n  let mut s3 = s.to_upper()\n  if s2.find_first_of(\"abcdefghijklmnopqrstuvwxyz\") == -1 {\n    return s3\n  }\n  return s2\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpcrq8qmxl.rs:14:28\n   |\n14 |   let mut s2 = s.to_lower()\n   |                            ^ help: add `;` here\n15 |   let mut s3 = s.to_upper()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpcrq8qmxl.rs:15:28\n   |\n15 |   let mut s3 = s.to_upper()\n   |                            ^ help: add `;` here\n16 |   if s2.find_first_of(\"abcdefghijklmnopqrstuvwxyz\") == -1 {\n   |   -- unexpected token\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpcrq8qmxl.rs:14:18\n   |\n14 |   let mut s2 = s.to_lower()\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpcrq8qmxl.rs:15:18\n   |\n15 |   let mut s3 = s.to_upper()\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let [lower, upper] = s[i].to_lower(), s[i].to_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `,`\n  --> /tmp/tmpvrwjg30g.rs:17:43\n   |\n17 |       let [lower, upper] = s[i].to_lower(), s[i].to_upper();\n   |                                           ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpvrwjg30g.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpvrwjg30g.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvrwjg30g.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(i, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp1jblli9z.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp1jblli9z.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while i < len(s) {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let lc = to_lower(c);\n      let uc = to_upper(c);\n      if lc == uc {\n        result = result.replace(lc, c);\n      } else {\n        result = result.replace(lc, uc);\n      }\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmptm8ve860.rs:16:13\n   |\n16 |   while i < len(s) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmptm8ve860.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmptm8ve860.rs:19:16\n   |\n19 |       let lc = to_lower(c);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmptm8ve860.rs:20:16\n   |\n20 |       let uc = to_upper(c);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmptm8ve860.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmptm8ve860.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmptm8ve860.rs:18:15\n   |\n18 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp32xmpjuw.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp32xmpjuw.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      if s[i].is_upper() {\n        r = r.chop(1).ascii_uppercase().pad_left(1) + r.chop(1);\n      } else {\n        r = r.chop(1).ascii_lowercase().pad_left(1) + r.chop(1);\n      }\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpb98t_2bp.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb98t_2bp.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb98t_2bp.rs:17:10\n   |\n17 |       if s[i].is_upper() {\n   |          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `chop` found for struct `String` in the current scope\n  --> /tmp/tmpb98t_2bp.rs:18:15\n   |\n18 |         r = r.chop(1).ascii_uppercase().pad_left(1) + r.chop(1);\n   |               ^^^^ method not found in `String`\n\nerror[E0599]: no method named `chop` found for struct `String` in the current scope\n  --> /tmp/tmpb98t_2bp.rs:18:57\n   |\n18 |         r = r.chop(1).ascii_uppercase().pad_left(1) + r.chop(1);\n   |                                                         ^^^^ method not found in `String`\n\nerror[E0599]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      if is_lower(i) {\n        res = res.replace(i, to_upper(i));\n      } else {\n        res = res.replace(i, to_lower(i));\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpywexdb3_.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmpywexdb3_.rs:17:10\n   |\n17 |       if is_lower(i) {\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmpywexdb3_.rs:18:30\n   |\n18 |         res = res.replace(i, to_upper(i));\n   |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmpywexdb3_.rs:20:30\n   |\n20 |         res = res.replace(i, to_lower(i));\n   |                              ^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.bounds(1, len(s))\n  let mut i = 0\n  let mut j = 0\n  let mut c = 0\n  let mut c1 = 0\n  let mut c2 = 0\n  let mut c3 = 0\n  let mut c4 = 0\n  let mut c5 = 0\n  let mut c6 = 0\n  let mut c7 = 0\n  let mut c8 = 0\n  let mut c9 = 0\n  let mut c10 = 0\n  let mut c11 = 0\n  let mut c12 = 0\n  let mut c13 = 0\n  let mut c14 = 0\n  let mut c15 = 0\n  let mut c16 = 0\n  let mut c17 = 0\n  let mut c18 = 0\n  let mut c19 = 0\n  let mut c20 = 0\n  let mut c21 = 0\n  let mut c22 = 0\n  let mut c23 = 0\n  let mut c24 = 0\n  let mut c25 = 0\n  let mut c26 = 0\n  let mut c27 = 0\n  let mut c28 = 0\n  let mut c29 = 0\n  let mut c30 = 0\n  let mut c31 = 0\n  let mut c32 = 0\n  let mut c33 = 0\n  let mut c34 = 0\n  let mut c35 = 0\n  let mut c36 = 0\n  let mut c37 = 0\n  let mut c38 = 0\n  let mut c39 = 0\n  let mut c40 = 0\n  let mut c41 = 0\n  let mut c42 = 0\n  let mut c43 = 0\n  let mut c44 = 0\n  let mut c45 = 0\n  let mut c46 = 0\n  let mut c47 = 0\n  let mut c48 = 0\n  let mut c49 = 0\n  let mut c50 = 0\n  let mut c51 = 0\n  let mut c52 = 0\n  let mut c53 = 0\n  let mut c54 = 0\n  let mut c55 = 0\n  let mut c56 = 0\n  let mut c57 = 0\n  let mut c58 = 0\n  let mut c59 = 0\n  let\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:14:34\n   |\n14 |   let mut r = s.bounds(1, len(s))\n   |                                  ^ help: add `;` here\n15 |   let mut i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:15:16\n   |\n15 |   let mut i = 0\n   |                ^ help: add `;` here\n16 |   let mut j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:16:16\n   |\n16 |   let mut j = 0\n   |                ^ help: add `;` here\n17 |   let mut c = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:17:16\n   |\n17 |   let mut c = 0\n   |                ^ help: add `;` here\n18 |   let mut c1 = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:18:17\n   |\n18 |   let mut c1 = 0\n   |                 ^ help: add `;` here\n19 |   let mut c2 = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:19:17\n   |\n19 |   let mut c2 = 0\n   |                 ^ help: add `;` here\n20 |   let mut c3 = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:20:17\n   |\n20 |   let mut c3 = 0\n   |                 ^ help: add `;` here\n21 |   let mut c4 = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:21:17\n   |\n21 |   let mut c4 = 0\n   |                 ^ help: add `;` here\n22 |   let mut c5 = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:22:17\n   |\n22 |   let mut c5 = 0\n   |                 ^ help: add `;` here\n23 |   let mut c6 = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:23:17\n   |\n23 |   let mut c6 = 0\n   |                 ^ help: add `;` here\n24 |   let mut c7 = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxnxpe9lw.rs:24:17\n   |\n24 |   let mut ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while i < s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let lc = to_lower(c);\n      let uc = to_upper(c);\n      if c == lc {\n        res = res.replace(i, 1, uc);\n      } else {\n        res = res.replace(i, 1, uc);\n      }\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp8cvillcp.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmp8cvillcp.rs:19:16\n   |\n19 |       let lc = to_lower(c);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmp8cvillcp.rs:20:16\n   |\n20 |       let uc = to_upper(c);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8cvillcp.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8cvillcp.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8cvillcp.rs:18:15\n   |\n18 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(i, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp1jblli9z.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp1jblli9z.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpw660qqz3.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw660qqz3.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw660qqz3.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpw660qqz3.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw660qqz3.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw660qqz3.rs:18:37\n   |\n18 |       result = result.replace(i, 1, s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpv34jddbx.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.iter() {\n    if is_letter(i) {\n      let mut tmp = i.to_upper();\n      result = result.replace(tmp, i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpgjx62hf6.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpgjx62hf6.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpgjx62hf6.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmphfcy2xd9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      r = r.replace(s[i], to_upper(s[i]));\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp8wgn_1li.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmp8wgn_1li.rs:17:27\n   |\n17 |       r = r.replace(s[i], to_upper(s[i]));\n   |                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8wgn_1li.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8wgn_1li.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8wgn_1li.rs:17:21\n   |\n17 |       r = r.replace(s[i], to_upper(s[i]));\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result.to_upper();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpryurmz58.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpryurmz58.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmpryurmz58.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpx5f7mkdk.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpx5f7mkdk.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      let u = s[i].to_upper();\n      if l == u {\n        result = result.replace(i, 1, l);\n      } else {\n        result = result.replace(i, 1, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpua22sec1.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpua22sec1.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpua22sec1.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpua22sec1.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpua22sec1.rs:18:15\n   |\n18 |       let u = s[i].to_upper();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `S",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmphfcy2xd9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to_lower();\n      let mut r = result.chars();\n      let mut l = i.to_upper();\n      let mut r = result.chars();\n      let mut l = i.to\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpy020pnej.rs:71:3\n   |\n13 | fn solve(s: String) -> String {\n   |                               - unclosed delimiter\n14 |   let mut result = s.to_lower();\n15 |   for i in s.chars() {\n   |                      - unclosed delimiter\n16 |     if is_letter(i) {\n   |                     - this delimiter might not be properly closed...\n...\n59 | }\n   | - ...as it matches this but it has different indentation\n...\n71 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpy020pnej.rs:58:23\n   |\n58 |       let mut l = i.to\n   |                       ^ help: add `;` here\n59 | }\n   | - unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpy020pnej.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpy020pnej.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpy020pnej.rs:18:21\n   |\n18 |       let mut l = i.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpy020pnej.rs:20:21\n   |\n20 |       let mut l = i.to_upper();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpy020pnej.rs:22:21\n   |\n22 |       let mut l = i.to_lower();\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpy020pnej.rs:24:21\n   |\n24 |       let mut l ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpv34jddbx.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower()\n  for i in s.iter() {\n    if is_letter(i) {\n      let [_, c] = i\n      let [l, u] = c\n      let [_, _] = l\n      let [_, _] = u\n      result = result.replace(i, String::from(c))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp2y7hrtsl.rs:14:32\n   |\n14 |   let mut result = s.to_lower()\n   |                                ^ help: add `;` here\n15 |   for i in s.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2y7hrtsl.rs:17:21\n   |\n17 |       let [_, c] = i\n   |                     ^ help: add `;` here\n18 |       let [l, u] = c\n   |       --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2y7hrtsl.rs:18:21\n   |\n18 |       let [l, u] = c\n   |                     ^ help: add `;` here\n19 |       let [_, _] = l\n   |       --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2y7hrtsl.rs:19:21\n   |\n19 |       let [_, _] = l\n   |                     ^ help: add `;` here\n20 |       let [_, _] = u\n   |       --- unexpected token\n\nerror: expected `;`, found `result`\n  --> /tmp/tmp2y7hrtsl.rs:20:21\n   |\n20 |       let [_, _] = u\n   |                     ^ help: add `;` here\n21 |       result = result.replace(i, String::from(c))\n   |       ------ unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp2y7hrtsl.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp2y7hrtsl.rs:14:22\n   |\n14 |   let mut result = s.to_lower()\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp2y7hrtsl.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 8 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about a",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.copy();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `copy` found for struct `String` in the current scope\n  --> /tmp/tmpn11rr5s6.rs:14:22\n   |\n14 |   let mut result = s.copy();\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn11rr5s6.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn11rr5s6.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn11rr5s6.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i;\n      result = result.replace(lower, upper);\n    }\n  }\n  return result.to_upper();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpyg2y77a5.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpyg2y77a5.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0529]: expected an array or slice, found `char`\n  --> /tmp/tmpyg2y77a5.rs:17:11\n   |\n17 |       let [lower, upper] = i;\n   |           ^^^^^^^^^^^^^^ pattern cannot match with input type `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0529, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp__7oxofb.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp__7oxofb.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp__7oxofb.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(i, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp1jblli9z.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp1jblli9z.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s\n  for i in s.iter() {\n    if is_letter(i) {\n      let l = i.to_lower()\n      let u = i.to_upper()\n      if l == u {\n        result = result.replace(i, l)\n      } else {\n        result = result.replace(i, u)\n      }\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpw1w577js.rs:14:21\n   |\n14 |   let mut result = s\n   |                     ^ help: add `;` here\n15 |   for i in s.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpw1w577js.rs:17:27\n   |\n17 |       let l = i.to_lower()\n   |                           ^ help: add `;` here\n18 |       let u = i.to_upper()\n   |       --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpw1w577js.rs:18:27\n   |\n18 |       let u = i.to_upper()\n   |                           ^ help: add `;` here\n19 |       if l == u {\n   |       -- unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpw1w577js.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpw1w577js.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp43fbacil.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp43fbacil.rs:17:37\n   |\n17 |       result = result.replace(i, 1, s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp43fbacil.rs:17:23\n    |\n17  |       result = result.replace(i, 1, s[i].to_lower());\n    |                       ^^^^^^^ -  -  --------------- supplied 3 arguments\n    |                       |\n    |                       expected 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp43fbacil.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(s[i], s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(s[i], s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpws71yv_2.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:17:21\n   |\n17 |       r = r.replace(s[i], s[i].to_lower());\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:17:27\n   |\n17 |       r = r.replace(s[i], s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Inde",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      r = r.replace(s[i], s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpbmqg4cq4.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpbmqg4cq4.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:17:21\n   |\n17 |       r = r.replace(s[i], s[i].to_upper());\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:17:27\n   |\n17 |       r = r.replace(s[i], s[i].to_upper());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpv34jddbx.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      if s[i].is_upper() {\n        result = result.replace(i, 1, s[i].to_lower());\n      } else {\n        result = result.replace(i, 1, s[i].to_upper());\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpaaoj_12k.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpaaoj_12k.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpaaoj_12k.rs:17:10\n   |\n17 |       if s[i].is_upper() {\n   |          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpaaoj_12k.rs:18:39\n   |\n18 |         result = result.replace(i, 1, s[i].to_lower());\n   |                                       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = String::from(s);\n  let mut i = 0;\n  while (i < result.len) {\n    if (result[i].is_upper()) {\n      result = result.slice(0, i).concat(result.slice(i).to_lower());\n    } else if (result[i].is_lower()) {\n      result = result.slice(0, i).concat(result.slice(i).to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3cbqgkdi.rs:16:9\n   |\n16 |   while (i < result.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < result.len) {\n16 +   while i < result.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3cbqgkdi.rs:17:8\n   |\n17 |     if (result[i].is_upper()) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (result[i].is_upper()) {\n17 +     if result[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3cbqgkdi.rs:19:15\n   |\n19 |     } else if (result[i].is_lower()) {\n   |               ^                    ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (result[i].is_lower()) {\n19 +     } else if result[i].is_lower() {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp3cbqgkdi.rs:16:21\n   |\n16 |   while (i < result.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |   while (i < result.len()) {\n   |                        ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp3cbqgkdi.rs:17:9\n   |\n17 |     if (result[i].is_upper()) {\n   |         ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `slice` found for struct `String` in the current scope\n  --> /tmp/tmp3cbqgkdi.rs:18:23\n   |\n18 |       result = result.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp6s6gzlsg.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp6s6gzlsg.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        r = r.replace(i, l);\n      } else {\n        r = r.replace(i, u);\n      }\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmplu90thxm.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmplu90thxm.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphlpuawj7.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphlpuawj7.rs:17:7\n   |\n17 |       result[i] = s[i].to_lower();\n   |       ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphlpuawj7.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpagkhow2p.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpagkhow2p.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpagkhow2p.rs:17:31\n   |\n17 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpagkhow2p.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<Rang",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.copy();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `copy` found for struct `String` in the current scope\n  --> /tmp/tmpn11rr5s6.rs:14:22\n   |\n14 |   let mut result = s.copy();\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn11rr5s6.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn11rr5s6.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn11rr5s6.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.copy();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      result.set_at(i, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result.set_at(i, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqm09l8h_.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqm09l8h_.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqm09l8h_.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `copy` found for struct `String` in the current scope\n  --> /tmp/tmpqm09l8h_.rs:14:22\n   |\n14 |   let mut result = s.copy();\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqm09l8h_.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqm09l8h_.rs:18:24\n   |\n18 |       result.set_at(i, s[i].to_lower());\n   |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while i < len(s) {\n    if is_letter(s[i]) {\n      let mut j = i + 1;\n      while j < len(s) && is_letter(s[j]) {\n        result = result.replace(j, j, s[j].to_upper());\n        j += 1;\n      }\n      i = j - 1;\n    } else {\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpl42zbfwb.rs:16:13\n   |\n16 |   while i < len(s) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpl42zbfwb.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpl42zbfwb.rs:19:17\n   |\n19 |       while j < len(s) && is_letter(s[j]) {\n   |                 ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpl42zbfwb.rs:19:27\n   |\n19 |       while j < len(s) && is_letter(s[j]) {\n   |                           ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpl42zbfwb.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpl42zbfwb.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpl42zbfwb.rs:19:37\n   |\n19 |       while j < len(s) && is_letter(s[j]) {\n   |                                     ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      r = r.replace(s[i], l);\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmplmgko570.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmplmgko570.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplmgko570.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplmgko570.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplmgko570.rs:18:21\n   |\n18 |       r = r.replace(s[i], l);\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      if s[i].is_upper() {\n        res = res.replace(i, 1, s[i].to_lower());\n      } else {\n        res = res.replace(i, 1, s[i].to_upper());\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp3l0hvsgz.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:17:10\n   |\n17 |       if s[i].is_upper() {\n   |          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:18:33\n   |\n18 |         res = res.replace(i, 1, s[i].to_lower());\n   |                                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as In",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut s2 = s.to_lower();\n  let mut s3 = s.to_upper();\n  let mut s4 = s.to_upper();\n  let mut s5 = s.to_lower();\n  let mut s6 = s.to_lower();\n  let mut s7 = s.to_upper();\n  let mut s8 = s.to_upper();\n  let mut s9 = s.to_lower();\n  let mut s10 = s.to_lower();\n  let mut s11 = s.to_upper();\n  let mut s12 = s.to_upper();\n  let mut s13 = s.to_lower();\n  let mut s14 = s.to_lower();\n  let mut s15 = s.to_upper();\n  let mut s16 = s.to_upper();\n  let mut s17 = s.to_lower();\n  let mut s18 = s.to_lower();\n  let mut s19 = s.to_upper();\n  let mut s20 = s.to_upper();\n  let mut s21 = s.to_lower();\n  let mut s22 = s.to_lower();\n  let mut s23 = s.to_upper();\n  let mut s24 = s.to_upper();\n  let mut s25 = s.to_lower();\n  let mut s26 = s.to_lower();\n  let mut s27 = s.to_upper();\n  let mut s28 = s.to_upper();\n  let mut s29 = s.to_lower();\n  let mut s30 = s.to_lower();\n  let mut s31 = s.to_upper();\n  let mut s32 = s.to_upper();\n  let mut s33 = s.to_lower();\n  let mut s34 = s.to_lower();\n  let mut s35 = s.to_upper();\n  let mut s36 = s.to_upper();\n  let mut s37 = s.to_lower();\n  let mut s38 = s.to_lower();\n  let mut s39 = s.to_upper();\n  let mut s40 = s.to_upper();\n  let mut s41\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpv1182lhp.rs:53:14\n   |\n53 |   let mut s41\n   |              ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpv1182lhp.rs:14:18\n   |\n14 |   let mut s2 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpv1182lhp.rs:15:18\n   |\n15 |   let mut s3 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpv1182lhp.rs:16:18\n   |\n16 |   let mut s4 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpv1182lhp.rs:17:18\n   |\n17 |   let mut s5 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpv1182lhp.rs:18:18\n   |\n18 |   let mut s6 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpv1182lhp.rs:19:18\n   |\n19 |   let mut s7 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmpv1182lhp.rs:20:18\n   |\n20 |   let mut s8 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_l",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  let mut i = 0;\n  while i < r.len() {\n    if is_letter(r[i]) {\n      let l = r[i].to_upper();\n      r = r.substr(0, i) + l + r.substr(i + 1);\n      i += 1;\n    } else {\n      i += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpd15mptwv.rs:17:8\n   |\n17 |     if is_letter(r[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpd15mptwv.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      r = r.replace(i, i, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp3rdx718s.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp3rdx718s.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3rdx718s.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3rdx718s.rs:17:27\n   |\n17 |       r = r.replace(i, i, s[i].to_upper());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.copy();\n  let mut i = 0;\n  while (i < s.len) {\n    if (s[i].is_upper()) {\n      result[i] = s[i].to_lower();\n    } else {\n      result[i] = s[i].to_upper();\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqs0unsp_.rs:16:9\n   |\n16 |   while (i < s.len) {\n   |         ^         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len) {\n16 +   while i < s.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqs0unsp_.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nerror[E0599]: no method named `copy` found for struct `String` in the current scope\n  --> /tmp/tmpqs0unsp_.rs:14:22\n   |\n14 |   let mut result = s.copy();\n   |                      ^^^^ method not found in `String`\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpqs0unsp_.rs:16:16\n   |\n16 |   while (i < s.len) {\n   |                ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |   while (i < s.len()) {\n   |                   ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpqs0unsp_.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpqs0unsp_.rs:18:19\n   |\n18 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      let u = s[i].to_upper();\n      if l == u {\n        r = r.replace(i, 1, l);\n      } else {\n        r = r.replace(i, 1, u);\n      }\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpqq_vi2n3.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqq_vi2n3.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqq_vi2n3.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqq_vi2n3.rs:18:15\n   |\n18 |       let u = s[i].to_upper();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      let u = s[i].to_upper();\n      if l == u {\n        r = r.replace(i, 1, l);\n      } else {\n        r = r.replace(i, 1, u);\n      }\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpqq_vi2n3.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqq_vi2n3.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqq_vi2n3.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqq_vi2n3.rs:18:15\n   |\n18 |       let u = s[i].to_upper();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp6s6gzlsg.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp6s6gzlsg.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      res[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      res[i] = s[i].to_upper();\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp87mgm1_b.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp87mgm1_b.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp87mgm1_b.rs:17:16\n   |\n17 |       res[i] = s[i].to_lower();\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp87mgm1_b.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpuzbqdd0c.rs:17:13\n    |\n17  |       r = r.replace(i, 1, s[i].to_lower());\n    |             ^^^^^^^ -  -  --------------- supplied 3 arguments\n    |             |\n    |             expected 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.copy();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      result[i] = s[i].to_lower();\n    } else if (s[i].is_lower()) {\n      result[i] = s[i].to_upper();\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp0dxb2y0p.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0dxb2y0p.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0dxb2y0p.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `copy` found for struct `String` in the current scope\n  --> /tmp/tmp0dxb2y0p.rs:14:22\n   |\n14 |   let mut result = s.copy();\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0dxb2y0p.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0dxb2y0p.rs:18:19\n   |\n18 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      r = r.replace(s[i], s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpbmqg4cq4.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpbmqg4cq4.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:17:21\n   |\n17 |       r = r.replace(s[i], s[i].to_upper());\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:17:27\n   |\n17 |       r = r.replace(s[i], s[i].to_upper());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while i < len(result) {\n    if is_letter(result[i]) {\n      let mut j = i + 1;\n      while j < len(result) && is_letter(result[j]) {\n        result[j] = to_upper(result[j]);\n        j += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpp_fsxdyk.rs:16:13\n   |\n16 |   while i < len(result) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpp_fsxdyk.rs:17:8\n   |\n17 |     if is_letter(result[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpp_fsxdyk.rs:19:17\n   |\n19 |       while j < len(result) && is_letter(result[j]) {\n   |                 ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpp_fsxdyk.rs:19:32\n   |\n19 |       while j < len(result) && is_letter(result[j]) {\n   |                                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmpp_fsxdyk.rs:20:21\n   |\n20 |         result[j] = to_upper(result[j]);\n   |                     ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpp_fsxdyk.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      let [_, c] = i;\n      let [l, u] = [c.to_lower(), c.to_upper()];\n      result = result.replace(i, l);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpj4gaznum.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpj4gaznum.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let lc = c.to_lower();\n      let uc = c.to_upper();\n      if lc == uc {\n        result = result.replace(lc, c);\n      } else {\n        result = result.replace(lc, uc);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpn09risc7.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpn09risc7.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn09risc7.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn09risc7.rs:17:15\n   |\n17 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in s.iter() {\n    if is_letter(i) {\n      if is_lower(i) {\n        r = r.replace(i, to_upper(i));\n      } else {\n        r = r.replace(i, to_lower(i));\n      }\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpy5jy0n26.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmpy5jy0n26.rs:17:10\n   |\n17 |       if is_lower(i) {\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmpy5jy0n26.rs:18:26\n   |\n18 |         r = r.replace(i, to_upper(i));\n   |                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmpy5jy0n26.rs:20:26\n   |\n20 |         r = r.replace(i, to_lower(i));\n   |                          ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpy5jy0n26.rs:15:14\n   |\n15 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmphfcy2xd9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let l = r.len();\n      if c == 'a' {\n        r = r.replace(i, l, 'A');\n      } else {\n        r = r.replace(i, l, 'a');\n      }\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp8o_2p3g_.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8o_2p3g_.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8o_2p3g_.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8o_2p3g_.rs:17:15\n   |\n17 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [_, lower, upper] = i;\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpnjk6u_gx.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpnjk6u_gx.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0529]: expected an array or slice, found `char`\n  --> /tmp/tmpnjk6u_gx.rs:17:11\n   |\n17 |       let [_, lower, upper] = i;\n   |           ^^^^^^^^^^^^^^^^^ pattern cannot match with input type `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0529, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower()\n  let mut i = 0\n  while i < len(result) {\n    if is_letter(result[i]) {\n      let j = i + 1\n      while j < len(result) && is_letter(result[j]) {\n        result[j] = to_upper(result[j])\n        j += 1\n      }\n      i = j\n    } else {\n      i += 1\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpy69bocxv.rs:14:32\n   |\n14 |   let mut result = s.to_lower()\n   |                                ^ help: add `;` here\n15 |   let mut i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpy69bocxv.rs:15:16\n   |\n15 |   let mut i = 0\n   |                ^ help: add `;` here\n16 |   while i < len(result) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpy69bocxv.rs:18:20\n   |\n18 |       let j = i + 1\n   |                    ^ help: add `;` here\n19 |       while j < len(result) && is_letter(result[j]) {\n   |       ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpy69bocxv.rs:20:40\n   |\n20 |         result[j] = to_upper(result[j])\n   |                                        ^ help: add `;` here\n21 |         j += 1\n   |         - unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpy69bocxv.rs:16:13\n   |\n16 |   while i < len(result) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpy69bocxv.rs:17:8\n   |\n17 |     if is_letter(result[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpy69bocxv.rs:19:17\n   |\n19 |       while j < len(result) && is_letter(result[j]) {\n   |                 ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpy69bocxv.rs:19:32\n   |\n19 |       while j < len(result) && is_letter(result[j]) {\n   |                                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmpy69bocxv.rs:20:21\n   |\n20 |         result[j] = to_upper(result[j])\n   |                     ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpy69bocxv.rs:14:22\n   |\n14 |   let mut result = s.to_lower()\n   |   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while i < s.len() {\n    if s[i].is_upper() {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpfun9cgvh.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:17:8\n   |\n17 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:18:31\n   |\n18 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:19:15\n   |\n19 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<Rang",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i;\n      result = result.replace(lower, upper);\n    }\n  }\n  return result.to_upper();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpyg2y77a5.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpyg2y77a5.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0529]: expected an array or slice, found `char`\n  --> /tmp/tmpyg2y77a5.rs:17:11\n   |\n17 |       let [lower, upper] = i;\n   |           ^^^^^^^^^^^^^^ pattern cannot match with input type `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0529, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    let c = s[i];\n    if (c.is_upper()) {\n      result = result.replace(c, c.to_lower());\n    } else if (c.is_lower()) {\n      result = result.replace(c, c.to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpm_pcvleg.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm_pcvleg.rs:18:8\n   |\n18 |     if (c.is_upper()) {\n   |        ^            ^\n   |\nhelp: remove these parentheses\n   |\n18 -     if (c.is_upper()) {\n18 +     if c.is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm_pcvleg.rs:20:15\n   |\n20 |     } else if (c.is_lower()) {\n   |               ^            ^\n   |\nhelp: remove these parentheses\n   |\n20 -     } else if (c.is_lower()) {\n20 +     } else if c.is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpm_pcvleg.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpm_pcvleg.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpm_pcvleg.rs:17:13\n   |\n17 |     let c = s[i];\n   |             ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: abort",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.bounds(1, s.len()).map(|(i, l) => {\n    if s[i].is_upper() {\n      return s[i].to_lower()\n    } else {\n      return s[i].to_upper()\n    }\n  }).collect(|_| s)\n  return r\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected one of `,` or `:`, found `=>`\n  --> /tmp/tmp08smmhys.rs:14:48\n   |\n14 |   let mut r = s.bounds(1, s.len()).map(|(i, l) => {\n   |                                                ^^ expected one of `,` or `:`\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(s[i], s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(s[i], s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpws71yv_2.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:17:21\n   |\n17 |       r = r.replace(s[i], s[i].to_lower());\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpws71yv_2.rs:17:27\n   |\n17 |       r = r.replace(s[i], s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Inde",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while i < s.len() {\n    if s[i].is_upper() {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpfun9cgvh.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:17:8\n   |\n17 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:18:31\n   |\n18 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfun9cgvh.rs:19:15\n   |\n19 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<Rang",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let l = r.len();\n      let r = r.slice(0, i) + c.to_upper() + r.slice(i+1, l);\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpnt_0kdwh.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpnt_0kdwh.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnt_0kdwh.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnt_0kdwh.rs:17:15\n   |\n17 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp6s6gzlsg.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp6s6gzlsg.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  for i in s.iter() {\n    if is_letter(s[i]) {\n      let mut j = i;\n      while(j < s.len() && is_letter(s[j])) {\n        let mut k = j;\n        while(k < s.len() && is_letter(s[k])) {\n          if s[k] > s[j] {\n            s[k] -= 32;\n          } else {\n            s[k] += 32;\n          }\n          k += 1;\n        }\n        j += 1;\n      }\n    }\n  }\n  res = s.to_upper();\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp9lain3xw.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp9lain3xw.rs:19:28\n   |\n19 |       while(j < s.len() && is_letter(s[j])) {\n   |                            ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp9lain3xw.rs:21:30\n   |\n21 |         while(k < s.len() && is_letter(s[k])) {\n   |                              ^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9lain3xw.rs:19:12\n   |\n19 |       while(j < s.len() && is_letter(s[j])) {\n   |            ^                              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -       while(j < s.len() && is_letter(s[j])) {\n19 +       while j < s.len() && is_letter(s[j]) {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9lain3xw.rs:21:14\n   |\n21 |         while(k < s.len() && is_letter(s[k])) {\n   |              ^                              ^\n   |\nhelp: remove these parentheses\n   |\n21 -         while(k < s.len() && is_letter(s[k])) {\n21 +         while k < s.len() && is_letter(s[k]) {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp9lain3xw.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp9lain3xw.rs:16:14\n   |\n16 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n16 |   for i in s.chars() {\n   |              ~~~~~\n\nerror[E0599]: no method named `to_u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      r = r.replace(i, i.to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp8qrfdgf0.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8qrfdgf0.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8qrfdgf0.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `to_upper` found for type `usize` in the current scope\n  --> /tmp/tmp8qrfdgf0.rs:17:26\n   |\n17 |       r = r.replace(i, i.to_upper());\n   |                          ^^^^^^^^ method not found in `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp6s6gzlsg.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp6s6gzlsg.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while i < len(s) {\n    if is_letter(s[i]) {\n      let mut j = i;\n      while j < len(s) and is_letter(s[j]) {\n        if s[j] == s[i] {\n          result = result.replace(j, 1, s[j].to_upper());\n        } else {\n          result = result.replace(j, 1, s[j].to_lower());\n        }\n        j += 1;\n      }\n      i += 1;\n    } else {\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmp_vhynr_c.rs:19:24\n   |\n19 |       while j < len(s) and is_letter(s[j]) {\n   |                        ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp_vhynr_c.rs:16:13\n   |\n16 |   while i < len(s) {\n   |             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp_vhynr_c.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp_vhynr_c.rs:19:17\n   |\n19 |       while j < len(s) and is_letter(s[j]) {\n   |                 ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp_vhynr_c.rs:19:28\n   |\n19 |       while j < len(s) and is_letter(s[j]) {\n   |                            ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_vhynr_c.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_vhynr_c.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmphfcy2xd9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy7qifssk.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy7qifssk.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy7qifssk.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpy7qifssk.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7qifssk.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7qifssk.rs:18:31\n   |\n18 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while (i < s.len()) {\n    if (s[i].is_upper()) {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy7qifssk.rs:16:9\n   |\n16 |   while (i < s.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.len()) {\n16 +   while i < s.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy7qifssk.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy7qifssk.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpy7qifssk.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7qifssk.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy7qifssk.rs:18:31\n   |\n18 |       res = res.replace(i, 1, s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let lower = to_lower(s[i])\n      let upper = to_upper(s[i])\n      if lower == upper {\n        result = result.replace(i, 1, lower)\n      } else {\n        result = result.replace(i, 1, upper)\n      }\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpbui7s85z.rs:14:21\n   |\n14 |   let mut result = s\n   |                     ^ help: add `;` here\n15 |   for i in 0..s.len() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpbui7s85z.rs:17:33\n   |\n17 |       let lower = to_lower(s[i])\n   |                                 ^ help: add `;` here\n18 |       let upper = to_upper(s[i])\n   |       --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpbui7s85z.rs:18:33\n   |\n18 |       let upper = to_upper(s[i])\n   |                                 ^ help: add `;` here\n19 |       if lower == upper {\n   |       -- unexpected token\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpbui7s85z.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmpbui7s85z.rs:17:19\n   |\n17 |       let lower = to_lower(s[i])\n   |                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmpbui7s85z.rs:18:19\n   |\n18 |       let upper = to_upper(s[i])\n   |                   ^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbui7s85z.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbui7s85z.rs:17:28\n   |\n17 |       let lower = to_lower(s[i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      r = r.replace(s[i], s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpbmqg4cq4.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpbmqg4cq4.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:17:21\n   |\n17 |       r = r.replace(s[i], s[i].to_upper());\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqg4cq4.rs:17:27\n   |\n17 |       r = r.replace(s[i], s[i].to_upper());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  for i in s.iter() {\n    if is_letter(s[i]) {\n      let mut j = i;\n      while (j < s.len() && is_letter(s[j])) {\n        let mut k = j;\n        while (k < s.len() && is_letter(s[k])) {\n          if (s[k] >= 'a' && s[k] <= 'z') {\n            result[k] = s[k] - 'a' + 'A';\n          } else if (s[k] >= 'A' && s[k] <= 'Z') {\n            result[k] = s[k] - 'A' + 'a';\n          }\n          k += 1;\n        }\n        j += 1;\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp4i23jsj_.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp4i23jsj_.rs:19:29\n   |\n19 |       while (j < s.len() && is_letter(s[j])) {\n   |                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp4i23jsj_.rs:21:31\n   |\n21 |         while (k < s.len() && is_letter(s[k])) {\n   |                               ^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4i23jsj_.rs:19:13\n   |\n19 |       while (j < s.len() && is_letter(s[j])) {\n   |             ^                              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -       while (j < s.len() && is_letter(s[j])) {\n19 +       while j < s.len() && is_letter(s[j]) {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4i23jsj_.rs:21:15\n   |\n21 |         while (k < s.len() && is_letter(s[k])) {\n   |               ^                              ^\n   |\nhelp: remove these parentheses\n   |\n21 -         while (k < s.len() && is_letter(s[k])) {\n21 +         while k < s.len() && is_letter(s[k]) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4i23jsj_.rs:22:14\n   |\n22 |           if (s[k] >= 'a' && s[k] <= 'z') {\n   |              ^                          ^\n   |\nhelp: remove these parentheses\n   |\n22 -           if (s[k] >= 'a' && s[k] <= 'z') {\n22 +           if s[k] >= 'a' && s[k] <= 'z' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4i23jsj_.rs:24:21\n   |\n24 |           } else if (s[k] >= 'A' && s[k] <= 'Z') {\n   |                     ^                          ^\n   |\nhelp: remove these parentheses\n   |\n24 -           } else if (s[k] >= 'A' && s[k] <= 'Z') {\n24 +           } else if s[k] >= 'A' && s[k] <= 'Z'",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      if s[i] >= 'a' && s[i] <= 'z' {\n        res[i] = s[i] - 'a' + 'A';\n      } else {\n        res[i] = s[i] - 'A' + 'a';\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpivopxt9m.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpivopxt9m.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpivopxt9m.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpivopxt9m.rs:17:10\n   |\n17 |       if s[i] >= 'a' && s[i] <= 'z' {\n   |          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpivopxt9m.rs:17:25\n   |\n17 |       if s[i] >= 'a' && s[i] <= 'z' {\n   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not imple",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpx5f7mkdk.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp__7oxofb.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp__7oxofb.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp__7oxofb.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      r = r.replace(i, i.to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp8qrfdgf0.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp8qrfdgf0.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8qrfdgf0.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `to_upper` found for type `usize` in the current scope\n  --> /tmp/tmp8qrfdgf0.rs:17:26\n   |\n17 |       r = r.replace(i, i.to_upper());\n   |                          ^^^^^^^^ method not found in `usize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmphfcy2xd9.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmphfcy2xd9.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let l = c.to_lower();\n      let u = c.to_upper();\n      if l == u {\n        result = result.replace(c, c);\n      } else {\n        result = result.replace(c, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp_9rptznj.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_9rptznj.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_9rptznj.rs:17:15\n   |\n17 |       let c = s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  let mut i = 0;\n  while (i < r.len()) {\n    if (r[i].is_upper()) {\n      r = r.substr(0, i) + r.substr(i).to_upper() + r.substr(i + 1);\n    } else if (r[i].is_lower()) {\n      r = r.substr(0, i) + r.substr(i).to_upper() + r.substr(i + 1);\n    }\n    i += 1;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpabs79mma.rs:16:9\n   |\n16 |   while (i < r.len()) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < r.len()) {\n16 +   while i < r.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpabs79mma.rs:17:8\n   |\n17 |     if (r[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (r[i].is_upper()) {\n17 +     if r[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpabs79mma.rs:19:15\n   |\n19 |     } else if (r[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (r[i].is_lower()) {\n19 +     } else if r[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpabs79mma.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if s[i].is_lower() {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpqyqu7h46.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqyqu7h46.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqyqu7h46.rs:17:31\n   |\n17 |       result = result.replace(s[i], s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqyqu7h46.rs:17:37\n   |\n17 |       result = result.replace(s[i], s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  let mut i = 0;\n  while i < r.len() {\n    if is_letter(r[i]) {\n      if is_lower(r[i]) {\n        r[i] = to_upper(r[i]);\n      } else {\n        r[i] = to_lower(r[i]);\n      }\n    }\n    i += 1;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpgv2yixkk.rs:17:8\n   |\n17 |     if is_letter(r[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_lower` in this scope\n  --> /tmp/tmpgv2yixkk.rs:18:10\n   |\n18 |       if is_lower(r[i]) {\n   |          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_upper` in this scope\n  --> /tmp/tmpgv2yixkk.rs:19:16\n   |\n19 |         r[i] = to_upper(r[i]);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_lower` in this scope\n  --> /tmp/tmpgv2yixkk.rs:21:16\n   |\n21 |         r[i] = to_lower(r[i]);\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpgv2yixkk.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  let mut c = s.to_upper();\n  let mut r2 = s.to_upper();\n  let mut c2 = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.substr(0, i) + s[i].to_lower() + r.substr(i+1);\n    } else if s[i].is_lower() {\n      c = c.substr(0, i) + s[i].to_upper() + c.substr(i+1);\n    }\n    if s[i].is_lower() {\n      r2 = r2.substr(0, i) + s[i].to_upper() + r2.substr(i+1);\n    } else if s[i].is_upper() {\n      c2 = c2.substr(0, i) + s[i].to_lower() + c2.substr(i+1);\n    }\n  }\n  if r == c {\n    return r;\n  } else if r == c2 {\n    return r2;\n  } else {\n    return s;\n  }\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp5p783wfn.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp5p783wfn.rs:15:17\n   |\n15 |   let mut c = s.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp5p783wfn.rs:16:18\n   |\n16 |   let mut r2 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp5p783wfn.rs:17:18\n   |\n17 |   let mut c2 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5p783wfn.rs:19:8\n   |\n19 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5p783wfn.rs:20:28\n   |\n20 |       r = r.substr(0, i) + s[i].to_lower() + r.substr(i+1);\n   |                            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      r = r.replace(l, l.to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp34ecr7gd.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp34ecr7gd.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34ecr7gd.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34ecr7gd.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3463f7xm.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3463f7xm.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3463f7xm.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp3463f7xm.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmp3463f7xm.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp3463f7xm.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      let u = s[i].to_upper();\n      if l == u {\n        res = res.replace(i, 1, l);\n      } else {\n        res = res.replace(i, 1, u);\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp4lmw6h_w.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp4lmw6h_w.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4lmw6h_w.rs:18:15\n   |\n18 |       let u = s[i].to_upper();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    let c = s[i];\n    if (c.is_upper()) {\n      result = result.replace(c, c.to_lower());\n    } else if (c.is_lower()) {\n      result = result.replace(c, c.to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpm_pcvleg.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm_pcvleg.rs:18:8\n   |\n18 |     if (c.is_upper()) {\n   |        ^            ^\n   |\nhelp: remove these parentheses\n   |\n18 -     if (c.is_upper()) {\n18 +     if c.is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm_pcvleg.rs:20:15\n   |\n20 |     } else if (c.is_lower()) {\n   |               ^            ^\n   |\nhelp: remove these parentheses\n   |\n20 -     } else if (c.is_lower()) {\n20 +     } else if c.is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpm_pcvleg.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpm_pcvleg.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpm_pcvleg.rs:17:13\n   |\n17 |     let c = s[i];\n   |             ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: abort",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let l = i.to_lower();\n      let u = i.to_upper();\n      if l == u {\n        result = result.replace(i, l);\n      } else {\n        result = result.replace(i, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpx5f7mkdk.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:17:17\n   |\n17 |       let l = i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for type `char` in the current scope\n  --> /tmp/tmpx5f7mkdk.rs:18:17\n   |\n18 |       let u = i.to_upper();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in s.chars() {\n    if is_letter(i) {\n      let [_, lower, upper] = i;\n      if lower == upper {\n        result = result.replace(i, upper);\n      } else {\n        result = result.replace(i, lower);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp4t9dhkb_.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0529]: expected an array or slice, found `char`\n  --> /tmp/tmp4t9dhkb_.rs:17:11\n   |\n17 |       let [_, lower, upper] = i;\n   |           ^^^^^^^^^^^^^^^^^ pattern cannot match with input type `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0529.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpv34jddbx.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower()\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i\n      let [l, u] = lower, upper\n      result[i] = u if l == 'a' else l\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp0866gjg0.rs:14:32\n   |\n14 |   let mut result = s.to_lower()\n   |                                ^ help: add `;` here\n15 |   for i in s.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp0866gjg0.rs:17:29\n   |\n17 |       let [lower, upper] = i\n   |                             ^ help: add `;` here\n18 |       let [l, u] = lower, upper\n   |       --- unexpected token\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `,`\n  --> /tmp/tmp0866gjg0.rs:18:25\n   |\n18 |       let [l, u] = lower, upper\n   |                         ^ expected one of 8 possible tokens\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp0866gjg0.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp0866gjg0.rs:14:22\n   |\n14 |   let mut result = s.to_lower()\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0529]: expected an array or slice, found `char`\n  --> /tmp/tmp0866gjg0.rs:17:11\n   |\n17 |       let [lower, upper] = i\n   |           ^^^^^^^^^^^^^^ pattern cannot match with input type `char`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0425, E0529, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      r = r.replace(l, l.to_upper());\n    }\n  }\n  return r.to_upper();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpk3jo8ttv.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpk3jo8ttv.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk3jo8ttv.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpk3jo8ttv.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result[i] = s[i].to_lower();\n    } else if s[i].is_lower() {\n      result[i] = s[i].to_upper();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprtir_i37.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:17:19\n   |\n17 |       result[i] = s[i].to_lower();\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprtir_i37.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = String::from(s);\n  let mut i = 0;\n  while (i < len(s)) {\n    if is_letter(s[i]) {\n      let j = i + 1;\n      while (j < len(s) && is_letter(s[j])) {\n        let temp = s[j];\n        s[j] = s[j].to_upper();\n        s[j] = s[j].to_lower();\n        s[j] = temp;\n        j += 1;\n      }\n      result = result.concat(s[i]);\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpa6d_aicy.rs:16:14\n   |\n16 |   while (i < len(s)) {\n   |              ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpa6d_aicy.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpa6d_aicy.rs:19:18\n   |\n19 |       while (j < len(s) && is_letter(s[j])) {\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpa6d_aicy.rs:19:28\n   |\n19 |       while (j < len(s) && is_letter(s[j])) {\n   |                            ^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa6d_aicy.rs:16:9\n   |\n16 |   while (i < len(s)) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < len(s)) {\n16 +   while i < len(s) {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa6d_aicy.rs:19:13\n   |\n19 |       while (j < len(s) && is_letter(s[j])) {\n   |             ^                             ^\n   |\nhelp: remove these parentheses\n   |\n19 -       while (j < len(s) && is_letter(s[j])) {\n19 +       while j < len(s) && is_letter(s[j]) {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpa6d_aicy.rs:17:18\n   |\n17 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result.to_upper();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpryurmz58.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpryurmz58.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmpryurmz58.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      result = result.replace(s[i], s[i].to_lower());\n    } else {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpszbo1fbz.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpszbo1fbz.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpszbo1fbz.rs:17:31\n   |\n17 |       result = result.replace(s[i], s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpszbo1fbz.rs:17:37\n   |\n17 |       result = result.replace(s[i], s[i].to_lower());\n   |                                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [lower, upper] = i.to_lower_upper();\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp__7oxofb.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp__7oxofb.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower_upper` found for type `char` in the current scope\n  --> /tmp/tmp__7oxofb.rs:17:30\n   |\n17 |       let [lower, upper] = i.to_lower_upper();\n   |                              ^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      if s[i].is_upper() {\n        res = res.replace(i, 1, s[i].to_lower());\n      } else {\n        res = res.replace(i, 1, s[i].to_upper());\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp3l0hvsgz.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:17:10\n   |\n17 |       if s[i].is_upper() {\n   |          ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3l0hvsgz.rs:18:33\n   |\n18 |         res = res.replace(i, 1, s[i].to_lower());\n   |                                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as In",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3463f7xm.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3463f7xm.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3463f7xm.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp3463f7xm.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmp3463f7xm.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp3463f7xm.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    let c = s[i];\n    if (c.is_upper()) {\n      result = result.replace(c, c.to_lower());\n    } else if (c.is_lower()) {\n      result = result.replace(c, c.to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpm_pcvleg.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm_pcvleg.rs:18:8\n   |\n18 |     if (c.is_upper()) {\n   |        ^            ^\n   |\nhelp: remove these parentheses\n   |\n18 -     if (c.is_upper()) {\n18 +     if c.is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm_pcvleg.rs:20:15\n   |\n20 |     } else if (c.is_lower()) {\n   |               ^            ^\n   |\nhelp: remove these parentheses\n   |\n20 -     } else if (c.is_lower()) {\n20 +     } else if c.is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpm_pcvleg.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpm_pcvleg.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpm_pcvleg.rs:17:13\n   |\n17 |     let c = s[i];\n   |             ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: abort",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s;\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpuzbqdd0c.rs:17:13\n    |\n17  |       r = r.replace(i, 1, s[i].to_lower());\n    |             ^^^^^^^ -  -  --------------- supplied 3 arguments\n    |             |\n    |             expected 2 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuzbqdd0c.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  for i in s.chars() {\n    if is_letter(i) {\n      let [_, lower, upper] = i;\n      result = result.replace(lower, upper);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpnjk6u_gx.rs:16:8\n   |\n16 |     if is_letter(i) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpnjk6u_gx.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0529]: expected an array or slice, found `char`\n  --> /tmp/tmpnjk6u_gx.rs:17:11\n   |\n17 |       let [_, lower, upper] = i;\n   |           ^^^^^^^^^^^^^^^^^ pattern cannot match with input type `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0529, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      result = result.replace(s[i], s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      result = result.replace(s[i], s[i].to_upper());\n    }\n    i += 1;\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj58fc1s.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj58fc1s.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpjj58fc1s.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjj58fc1s.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut r = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      r = r.replace(i, 1, s[i].to_lower());\n    } else if s[i].is_lower() {\n      r = r.replace(i, 1, s[i].to_upper());\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpv34jddbx.rs:14:17\n   |\n14 |   let mut r = s.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:17:27\n   |\n17 |       r = r.replace(i, 1, s[i].to_lower());\n   |                           ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv34jddbx.rs:18:15\n   |\n18 |     } else if s[i].is_lower() {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s;\n  for i in 0..s.len() {\n    if is_letter(s[i]) {\n      let l = s[i].to_lower();\n      let u = s[i].to_upper();\n      if l == u {\n        result = result.replace(i, 1, l);\n      } else {\n        result = result.replace(i, 1, u);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpnji46n8k.rs:16:8\n   |\n16 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnji46n8k.rs:16:18\n   |\n16 |     if is_letter(s[i]) {\n   |                  ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnji46n8k.rs:17:15\n   |\n17 |       let l = s[i].to_lower();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnji46n8k.rs:18:15\n   |\n18 |       let u = s[i].to_upper();\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut result = s.to_lower();\n  let mut i = 0;\n  while (i < len(s)) {\n    if (is_letter(s[i])) {\n      let j = i + 1;\n      while (j < len(s) && is_letter(s[j])) {\n        result[j] = s[j].to_upper();\n        j += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return result.to_string();\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpvkhbr6ue.rs:16:14\n   |\n16 |   while (i < len(s)) {\n   |              ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpvkhbr6ue.rs:17:9\n   |\n17 |     if (is_letter(s[i])) {\n   |         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpvkhbr6ue.rs:19:18\n   |\n19 |       while (j < len(s) && is_letter(s[j])) {\n   |                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmpvkhbr6ue.rs:19:28\n   |\n19 |       while (j < len(s) && is_letter(s[j])) {\n   |                            ^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvkhbr6ue.rs:16:9\n   |\n16 |   while (i < len(s)) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < len(s)) {\n16 +   while i < len(s) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvkhbr6ue.rs:17:8\n   |\n17 |     if (is_letter(s[i])) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (is_letter(s[i])) {\n17 +     if is_letter(s[i]) {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvkhbr6ue.rs:19:13\n   |\n19 |       while (j < len(s) && is_letter(s[j])) {\n   |             ^                             ^\n   |\nhelp: remove these parentheses\n   |\n19 -       while (j < len(s) && is_letter(s[j])) {\n19 +       while j < len(s) && is_letter(s[j]) {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpvkhbr6ue.rs:14:22\n   |\n14 |   let mut result = s.to_lower();\n   |                      ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpvkhbr6ue.rs:17:19\n   |\n17 |     if (",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut s2 = s.to_lower();\n  let mut s3 = s.to_upper();\n  let mut s4 = s.to_upper();\n  let mut s5 = s.to_lower();\n  let mut s6 = s.to_lower();\n  let mut s7 = s.to_lower();\n  let mut s8 = s.to_lower();\n  let mut s9 = s.to_lower();\n  let mut s10 = s.to_lower();\n  let mut s11 = s.to_lower();\n  let mut s12 = s.to_lower();\n  let mut s13 = s.to_lower();\n  let mut s14 = s.to_lower();\n  let mut s15 = s.to_lower();\n  let mut s16 = s.to_lower();\n  let mut s17 = s.to_lower();\n  let mut s18 = s.to_lower();\n  let mut s19 = s.to_lower();\n  let mut s20 = s.to_lower();\n  let mut s21 = s.to_lower();\n  let mut s22 = s.to_lower();\n  let mut s23 = s.to_lower();\n  let mut s24 = s.to_lower();\n  let mut s25 = s.to_lower();\n  let mut s26 = s.to_lower();\n  let mut s27 = s.to_lower();\n  let mut s28 = s.to_lower();\n  let mut s29 = s.to_lower();\n  let mut s30 = s.to_lower();\n  let mut s31 = s.to_lower();\n  let mut s32 = s.to_lower();\n  let mut s33 = s.to_lower();\n  let mut s34 = s.to_lower();\n  let mut s35 = s.to_lower();\n  let mut s36 = s.to_lower();\n  let mut s37 = s.to_lower();\n  let mut s38 = s.to_lower();\n  let mut s39 = s.to_lower();\n  let mut s40 = s.to_lower();\n  let mut s41\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_eh_1f9m.rs:53:14\n   |\n53 |   let mut s41\n   |              ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:14:18\n   |\n14 |   let mut s2 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:15:18\n   |\n15 |   let mut s3 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_upper` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:16:18\n   |\n16 |   let mut s4 = s.to_upper();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_uppercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:17:18\n   |\n17 |   let mut s5 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:18:18\n   |\n18 |   let mut s6 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:19:18\n   |\n19 |   let mut s7 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp_eh_1f9m.rs:20:18\n   |\n20 |   let mut s8 = s.to_lower();\n   |                  ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `to_l",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  while (i < s.length()) {\n    if (s[i].is_upper()) {\n      res = res.replace(i, 1, s[i].to_lower());\n    } else if (s[i].is_lower()) {\n      res = res.replace(i, 1, s[i].to_upper());\n    }\n    i += 1;\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprd1_z8_i.rs:16:9\n   |\n16 |   while (i < s.length()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (i < s.length()) {\n16 +   while i < s.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprd1_z8_i.rs:17:8\n   |\n17 |     if (s[i].is_upper()) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (s[i].is_upper()) {\n17 +     if s[i].is_upper() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprd1_z8_i.rs:19:15\n   |\n19 |     } else if (s[i].is_lower()) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (s[i].is_lower()) {\n19 +     } else if s[i].is_lower() {\n   | \n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmprd1_z8_i.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmprd1_z8_i.rs:16:16\n   |\n16 |   while (i < s.length()) {\n   |                ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmprd1_z8_i.rs:17:9\n   |\n17 |     if (s[i].is_upper()) {\n   |         ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as I",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  let mut i = 0;\n  for i in s.iter() {\n    if is_letter(s[i]) {\n      let c = s[i];\n      let lc = c.to_lower();\n      let uc = c.to_upper();\n      if lc == uc {\n        res = res.replace(i, 1, lc);\n      } else {\n        res = res.replace(i, 1, lc);\n      }\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_letter` in this scope\n  --> /tmp/tmp3x9sy9_y.rs:17:8\n   |\n17 |     if is_letter(s[i]) {\n   |        ^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmp3x9sy9_y.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp3x9sy9_y.rs:16:14\n   |\n16 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n16 |   for i in s.chars() {\n   |              ~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a string s.\n/// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n/// otherwise keep it as it is.\n/// If the string contains no letters, reverse the string.\n/// The function should return the resulted string.\n/// Examples\n/// >>> solve(String::from(\"1234\"))\n/// String::from(\"4321\")\n/// >>> solve(String::from(\"ab\"))\n/// String::from(\"AB\")\n/// >>> solve(String::from(\"#a@C\"))\n/// String::from(\"#A@c\")\nfn solve(s: String) -> String {\n  let mut res = s.to_lower();\n  for i in 0..s.len() {\n    if s[i].is_upper() {\n      res = res.replace(s[i], s[i].to_lower());\n    } else {\n      res = res.replace(s[i], s[i].to_upper());\n    }\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = solve;\n    assert_eq!(candidate(String::from(\"AsDf\")), String::from(\"aSdF\"));\n    assert_eq!(candidate(String::from(\"1234\")), String::from(\"4321\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"AB\"));\n    assert_eq!(candidate(String::from(\"#a@C\")), String::from(\"#A@c\"));\n    assert_eq!(candidate(String::from(\"#AsdfW^45\")), String::from(\"#aSDFw^45\"));\n    assert_eq!(candidate(String::from(\"#6@2\")), String::from(\"2@6#\"));\n    assert_eq!(candidate(String::from(\"#$a^D\")), String::from(\"#$A^d\"));\n    assert_eq!(candidate(String::from(\"#ccc\")), String::from(\"#CCC\"));\n}\n",
      "timestamp": 1664292659,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_lower` found for struct `String` in the current scope\n  --> /tmp/tmpkjyo3lqt.rs:14:19\n   |\n14 |   let mut res = s.to_lower();\n   |                   ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkjyo3lqt.rs:16:8\n   |\n16 |     if s[i].is_upper() {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkjyo3lqt.rs:17:25\n   |\n17 |       res = res.replace(s[i], s[i].to_lower());\n   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkjyo3lqt.rs:17:31\n   |\n17 |       res = res.replace(s[i], s[i].to_lower());\n   |                               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n        ",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}