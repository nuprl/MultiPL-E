{
  "name": "HumanEval_78_hex_key",
  "language": "rs",
  "prompt": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n",
  "tests": "}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n            count += 2;\n        } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n            count += 3;\n        } else if (digit == 'B' || digit == 'D') {\n            count += 4;\n        } else if (digit == 'D') {\n            count += 5;\n        } else {\n            count += 6;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpx8tvwiik.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:29:19\n   |\n29 | ...if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9'...\n   |       ^                                                                                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n29 +         } else if digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:31:19\n   |\n31 |         } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n   |                   ^                                                            ^\n   |\nhelp: remove these parenthes",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let num_len = num.len();\n    for (let i = 0; i < num_len; i++) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n            count += 2;\n        } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n            count += 3;\n        } else if (digit == 'B' || digit == 'D') {\n            count += 4;\n        } else if (digit == 'D' || digit == 'E') {\n            count += 5;\n        } else if (digit == 'E' || digit == 'F') {\n            count += 6;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp9ypx95x1.rs:25:10\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp9ypx95x1.rs:25:14\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp9ypx95x1.rs:25:16\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp9ypx95x1.rs:25:15\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp9ypx95x1.rs:25:16\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpc5gl769l.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= '0' && i <= '9' {\n      count += 1;\n    } else if i >= 'A' && i <= 'F' {\n      count += 2;\n    } else if i >= 'a' && i <= 'f' {\n      count += 2;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:26:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n26 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:28:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n28 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:30:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n30 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n            count += 2;\n        } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n            count += 3;\n        } else if (digit == 'B' || digit == 'D') {\n            count += 4;\n        } else if (digit == 'D') {\n            count += 5;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp_lykk4ed.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_lykk4ed.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_lykk4ed.rs:29:19\n   |\n29 | ...if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9'...\n   |       ^                                                                                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n29 +         } else if digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_lykk4ed.rs:31:19\n   |\n31 |         } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n   |                   ^                                                            ^\n   |\nhelp: remove these parenthes",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if is_prime(i) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgtmcraif.rs:25:12\n   |\n25 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n            continue;\n        }\n        if (digit == '1') {\n            i += 1;\n            continue;\n        }\n        if (digit == '2') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '3') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '4') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '5') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '6') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '7') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '8') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '9') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'A') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'B') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'C') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'D') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'E') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'F') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfd4lou12.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:31:12\n   |\n31 |         if (digit == '1') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == '1') {\n31 +         if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:35:12\n   |\n35 |         if (digit == '2') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         if (digit == '2') {\n35 +         if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:40:12\n   |\n40 |         if (digit == '3') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n40 -         if (digit == '3') {\n40 +         if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:45:12\n   |\n45 |         if (digit == '4') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n45 -         if (digit == '4') {\n45 +         if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:50:12\n   |\n50 |         if (digit == '5') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n50 -         if (digit == '5') {\n50 +         if digit == '5' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:55:12\n   |\n55 |         if (digit == '6') {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let num_len = num.len();\n    for (let i = 0; i < num_len; i++) {\n        let digit = num[i];\n        if (digit == '0') {\n            continue;\n        }\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        } else {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp04r8xa0b.rs:25:10\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp04r8xa0b.rs:25:14\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp04r8xa0b.rs:25:16\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp04r8xa0b.rs:25:15\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp04r8xa0b.rs:25:16\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmputrwo_0j.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c.is_upper() {\n            count += 1;\n        }\n    }\n    let digits = 0;\n    for c in num {\n        if c.is_upper() {\n            digits += 1;\n            if digits == 2 {\n                count += 1;\n            }\n            if digits == 3 {\n                count += 1;\n            }\n            if digits == 5 {\n                count += 1;\n            }\n            if digits == 7 {\n                count += 1;\n            }\n            if digits == 11 {\n                count += 1;\n            }\n            if digits == 13 {\n                count += 1;\n            }\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpys25k8m0.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpys25k8m0.rs:30:14\n   |\n30 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.length) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphi6eh663.rs:25:11\n   |\n25 |     while (i < num.length) {\n   |           ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.length) {\n25 +     while i < num.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphi6eh663.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmphi6eh663.rs:25:20\n   |\n25 |     while (i < num.length) {\n   |                    ^^^^^^ unknown field\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmphi6eh663.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0609.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n            continue;\n        }\n        if (digit == '1') {\n            i += 1;\n            continue;\n        }\n        if (digit == '2') {\n            i += 1;\n            continue;\n        }\n        if (digit == '3') {\n            i += 1;\n            continue;\n        }\n        if (digit == '4') {\n            i += 1;\n            continue;\n        }\n        if (digit == '5') {\n            i += 1;\n            continue;\n        }\n        if (digit == '6') {\n            i += 1;\n            continue;\n        }\n        if (digit == '7') {\n            i += 1;\n            continue;\n        }\n        if (digit == '8') {\n            i += 1;\n            continue;\n        }\n        if (digit == '9') {\n            i += 1;\n            continue;\n        }\n        if (digit == 'A') {\n            i += 1;\n            continue;\n        }\n        if (digit == 'B') {\n            i += 1;\n            continue;\n        }\n        if (digit == 'C') {\n            i += 1;\n            continue;\n        }\n        if (digit == 'D') {\n            i += 1;\n            continue;\n        }\n        if (digit == 'E') {\n            i += 1;\n            continue;\n        }\n        if (digit == 'F') {\n            i += 1;\n            continue;\n        }\n        count += 1;\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpo9q__qhp.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9q__qhp.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9q__qhp.rs:31:12\n   |\n31 |         if (digit == '1') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == '1') {\n31 +         if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9q__qhp.rs:35:12\n   |\n35 |         if (digit == '2') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         if (digit == '2') {\n35 +         if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9q__qhp.rs:39:12\n   |\n39 |         if (digit == '3') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n39 -         if (digit == '3') {\n39 +         if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9q__qhp.rs:43:12\n   |\n43 |         if (digit == '4') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n43 -         if (digit == '4') {\n43 +         if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9q__qhp.rs:47:12\n   |\n47 |         if (digit == '5') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n47 -         if (digit == '5') {\n47 +         if digit == '5' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9q__qhp.rs:51:12\n   |\n51 |         if (digit == '6') {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == \"0\") {\n            i += 1;\n            continue;\n        }\n        if (digit == \"1\") {\n            count += 1;\n            i += 1;\n            continue;\n        }\n        if (digit == \"2\") {\n            count += 2;\n            i += 1;\n            continue;\n        }\n        if (digit == \"3\") {\n            count += 3;\n            i += 1;\n            continue;\n        }\n        if (digit == \"4\") {\n            count += 4;\n            i += 1;\n            continue;\n        }\n        if (digit == \"5\") {\n            count += 5;\n            i += 1;\n            continue;\n        }\n        if (digit == \"6\") {\n            count += 6;\n            i += 1;\n            continue;\n        }\n        if (digit == \"7\") {\n            count += 7;\n            i += 1;\n            continue;\n        }\n        if (digit == \"8\") {\n            count += 8;\n            i += 1;\n            continue;\n        }\n        if (digit == \"9\") {\n            count += 9;\n            i += 1;\n            continue;\n        }\n        if (digit == \"A\") {\n            count += 10;\n            i += 1;\n            continue;\n        }\n        if (digit == \"B\") {\n            count += 11;\n            i += 1;\n            continue;\n        }\n        if (digit == \"C\") {\n            count += 12;\n            i += 1;\n            continue;\n        }\n        if (digit == \"D\") {\n            count += 13;\n            i += 1;\n            continue;\n        }\n        if (digit == \"E\") {\n            count += 14;\n            i += 1;\n            continue;\n        }\n        if (digit == \"F\") {\n            count += 15;\n            i += 1;\n            continue;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp7dppumpu.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:27:12\n   |\n27 |         if (digit == \"0\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == \"0\") {\n27 +         if digit == \"0\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:31:12\n   |\n31 |         if (digit == \"1\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == \"1\") {\n31 +         if digit == \"1\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:36:12\n   |\n36 |         if (digit == \"2\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n36 -         if (digit == \"2\") {\n36 +         if digit == \"2\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:41:12\n   |\n41 |         if (digit == \"3\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n41 -         if (digit == \"3\") {\n41 +         if digit == \"3\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:46:12\n   |\n46 |         if (digit == \"4\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n46 -         if (digit == \"4\") {\n46 +         if digit == \"4\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:51:12\n   |\n51 |         if (digit == \"5\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n51 -         if (digit == \"5\") {\n51 +         if digit == \"5\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:56:12\n   |\n56 |         if (digit == \"6\") {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= 'A' && i <= 'F' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp4c5pq0re.rs:26:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n26 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n            continue;\n        }\n        if (digit == '1') {\n            i += 1;\n            continue;\n        }\n        if (digit == '2') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '3') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '4') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '5') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '6') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '7') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '8') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '9') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'A') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'B') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'C') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'D') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'E') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'F') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfd4lou12.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:31:12\n   |\n31 |         if (digit == '1') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == '1') {\n31 +         if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:35:12\n   |\n35 |         if (digit == '2') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         if (digit == '2') {\n35 +         if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:40:12\n   |\n40 |         if (digit == '3') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n40 -         if (digit == '3') {\n40 +         if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:45:12\n   |\n45 |         if (digit == '4') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n45 -         if (digit == '4') {\n45 +         if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:50:12\n   |\n50 |         if (digit == '5') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n50 -         if (digit == '5') {\n50 +         if digit == '5' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:55:12\n   |\n55 |         if (digit == '6') {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpc5gl769l.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == \"0\") {\n            i += 1;\n            continue;\n        }\n        if (digit == \"1\") {\n            count += 1;\n            i += 1;\n            continue;\n        }\n        if (digit == \"2\") {\n            count += 2;\n            i += 1;\n            continue;\n        }\n        if (digit == \"3\") {\n            count += 3;\n            i += 1;\n            continue;\n        }\n        if (digit == \"4\") {\n            count += 4;\n            i += 1;\n            continue;\n        }\n        if (digit == \"5\") {\n            count += 5;\n            i += 1;\n            continue;\n        }\n        if (digit == \"6\") {\n            count += 6;\n            i += 1;\n            continue;\n        }\n        if (digit == \"7\") {\n            count += 7;\n            i += 1;\n            continue;\n        }\n        if (digit == \"8\") {\n            count += 8;\n            i += 1;\n            continue;\n        }\n        if (digit == \"9\") {\n            count += 9;\n            i += 1;\n            continue;\n        }\n        if (digit == \"A\") {\n            count += 10;\n            i += 1;\n            continue;\n        }\n        if (digit == \"B\") {\n            count += 11;\n            i += 1;\n            continue;\n        }\n        if (digit == \"C\") {\n            count += 12;\n            i += 1;\n            continue;\n        }\n        if (digit == \"D\") {\n            count += 13;\n            i += 1;\n            continue;\n        }\n        if (digit == \"E\") {\n            count += 14;\n            i += 1;\n            continue;\n        }\n        if (digit == \"F\") {\n            count += 15;\n            i += 1;\n            continue;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp7dppumpu.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:27:12\n   |\n27 |         if (digit == \"0\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == \"0\") {\n27 +         if digit == \"0\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:31:12\n   |\n31 |         if (digit == \"1\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == \"1\") {\n31 +         if digit == \"1\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:36:12\n   |\n36 |         if (digit == \"2\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n36 -         if (digit == \"2\") {\n36 +         if digit == \"2\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:41:12\n   |\n41 |         if (digit == \"3\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n41 -         if (digit == \"3\") {\n41 +         if digit == \"3\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:46:12\n   |\n46 |         if (digit == \"4\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n46 -         if (digit == \"4\") {\n46 +         if digit == \"4\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:51:12\n   |\n51 |         if (digit == \"5\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n51 -         if (digit == \"5\") {\n51 +         if digit == \"5\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:56:12\n   |\n56 |         if (digit == \"6\") {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= '0' && i <= '9' {\n      count += 1;\n    } else if i >= 'A' && i <= 'F' {\n      count += 2;\n    } else if i >= 'a' && i <= 'f' {\n      count += 2;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:26:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n26 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:28:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n28 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:30:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n30 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == \"0\") {\n            i += 1;\n            continue;\n        }\n        if (digit == \"1\") {\n            count += 1;\n            i += 1;\n            continue;\n        }\n        if (digit == \"2\") {\n            count += 2;\n            i += 1;\n            continue;\n        }\n        if (digit == \"3\") {\n            count += 3;\n            i += 1;\n            continue;\n        }\n        if (digit == \"4\") {\n            count += 4;\n            i += 1;\n            continue;\n        }\n        if (digit == \"5\") {\n            count += 5;\n            i += 1;\n            continue;\n        }\n        if (digit == \"6\") {\n            count += 6;\n            i += 1;\n            continue;\n        }\n        if (digit == \"7\") {\n            count += 7;\n            i += 1;\n            continue;\n        }\n        if (digit == \"8\") {\n            count += 8;\n            i += 1;\n            continue;\n        }\n        if (digit == \"9\") {\n            count += 9;\n            i += 1;\n            continue;\n        }\n        if (digit == \"A\") {\n            count += 10;\n            i += 1;\n            continue;\n        }\n        if (digit == \"B\") {\n            count += 11;\n            i += 1;\n            continue;\n        }\n        if (digit == \"C\") {\n            count += 12;\n            i += 1;\n            continue;\n        }\n        if (digit == \"D\") {\n            count += 13;\n            i += 1;\n            continue;\n        }\n        if (digit == \"E\") {\n            count += 14;\n            i += 1;\n            continue;\n        }\n        if (digit == \"F\") {\n            count += 15;\n            i += 1;\n            continue;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp7dppumpu.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:27:12\n   |\n27 |         if (digit == \"0\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == \"0\") {\n27 +         if digit == \"0\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:31:12\n   |\n31 |         if (digit == \"1\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == \"1\") {\n31 +         if digit == \"1\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:36:12\n   |\n36 |         if (digit == \"2\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n36 -         if (digit == \"2\") {\n36 +         if digit == \"2\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:41:12\n   |\n41 |         if (digit == \"3\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n41 -         if (digit == \"3\") {\n41 +         if digit == \"3\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:46:12\n   |\n46 |         if (digit == \"4\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n46 -         if (digit == \"4\") {\n46 +         if digit == \"4\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:51:12\n   |\n51 |         if (digit == \"5\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n51 -         if (digit == \"5\") {\n51 +         if digit == \"5\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7dppumpu.rs:56:12\n   |\n56 |         if (digit == \"6\") {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for c in num {\n    if c >= 'A' && c <= 'F' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp_lex4edw.rs:24:12\n   |\n24 |   for c in num {\n   |            ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let curr = 0;\n    for (let i = 0; i < num.len; i++) {\n        if (num[i] == '0') {\n            curr = 0;\n        } else if (num[i] == '1') {\n            curr = 1;\n        } else if (num[i] == '2') {\n            curr = 2;\n        } else if (num[i] == '3') {\n            curr = 3;\n        } else if (num[i] == '4') {\n            curr = 4;\n        } else if (num[i] == '5') {\n            curr = 5;\n        } else if (num[i] == '6') {\n            curr = 6;\n        } else if (num[i] == '7') {\n            curr = 7;\n        } else if (num[i] == '8') {\n            curr = 8;\n        } else if (num[i] == '9') {\n            curr = 9;\n        } else if (num[i] == 'A') {\n            curr = 10;\n        } else if (num[i] == 'B') {\n            curr = 11;\n        } else if (num[i] == 'C') {\n            curr = 12;\n        } else if (num[i] == 'D') {\n            curr = 13;\n        } else if (num[i] == 'E') {\n            curr = 14;\n        } else if (num[i] == 'F') {\n            curr = 15;\n        }\n        if (curr > 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpsbvbrv9d.rs:25:10\n   |\n25 |     for (let i = 0; i < num.len; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpsbvbrv9d.rs:25:14\n   |\n25 |     for (let i = 0; i < num.len; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpsbvbrv9d.rs:25:16\n   |\n25 |     for (let i = 0; i < num.len; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpsbvbrv9d.rs:25:15\n   |\n25 |     for (let i = 0; i < num.len; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpsbvbrv9d.rs:25:16\n   |\n25 |     for (let i = 0; i < num.len; i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' and c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmpolbqbvu2.rs:25:21\n   |\n25 |         if c >= 'A' and c <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpolbqbvu2.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' and i <= '9' {\n            count += 1;\n        } else if i >= 'A' and i <= 'F' {\n            count += 2;\n        } else if i >= 'a' and i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:25:21\n   |\n25 |         if i >= '0' and i <= '9' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:27:28\n   |\n27 |         } else if i >= 'A' and i <= 'F' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:29:28\n   |\n29 |         } else if i >= 'a' and i <= 'f' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        } else if i == 'B' {\n            count += 3;\n        } else if i == 'D' {\n            count += 4;\n        } else if i == 'E' {\n            count += 5;\n        } else if i == 'F' {\n            count += 6;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmn70167w.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmn70167w.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmn70167w.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmn70167w.rs:32:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n32 |             count += 3;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmn70167w.rs:34:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n34 |             count += 4;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmn70167w.rs:36:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assig",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i.is_uppercase() {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp05e0u3e4.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n            digit == '4' || digit == '5' || digit == '6' || digit == '7' ||\n            digit == '8' || digit == '9' || digit == 'A' || digit == 'B' ||\n            digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp55_k041p.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55_k041p.rs:27:12\n   |\n27 |         if (digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n   |            ^\n...\n30 |             digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |                                                                         ^\n   |\nhelp: remove these parentheses\n   |\n27 ~         if digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n28 |             digit == '4' || digit == '5' || digit == '6' || digit == '7' ||\n29 |             digit == '8' || digit == '9' || digit == 'A' || digit == 'B' ||\n30 ~             digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp55_k041p.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp55_k041p.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' and c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmpolbqbvu2.rs:25:21\n   |\n25 |         if c >= 'A' and c <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpolbqbvu2.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let n = num.to_i();\n    let i = 0;\n    while (i < n) {\n        let digit = n % 16;\n        if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n            count += 1;\n        }\n        n /= 16;\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1tc0qpf8.rs:26:11\n   |\n26 |     while (i < n) {\n   |           ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -     while (i < n) {\n26 +     while i < n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1tc0qpf8.rs:28:12\n   |\n28 |         if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n   |            ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n28 -         if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n28 +         if digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13 {\n   | \n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n  --> /tmp/tmp1tc0qpf8.rs:24:17\n   |\n24 |     let n = num.to_i();\n   |                 ^^^^ method not found in `String`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' and i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmplayzy2vd.rs:25:21\n   |\n25 |         if i >= 'A' and i <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n            count += 2;\n        } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n            count += 3;\n        } else if (digit == 'B' || digit == 'D') {\n            count += 4;\n        } else if (digit == 'D') {\n            count += 5;\n        } else {\n            count += 6;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpx8tvwiik.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:29:19\n   |\n29 | ...if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9'...\n   |       ^                                                                                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n29 +         } else if digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:31:19\n   |\n31 |         } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n   |                   ^                                                            ^\n   |\nhelp: remove these parenthes",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c.is_upper() {\n            count += 1;\n        }\n    }\n    let count_2 = 0;\n    for c in num {\n        if c.is_upper() {\n            count_2 += 1;\n        }\n        if c.is_upper() && count_2 == 2 {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpq_c7or7i.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpq_c7or7i.rs:30:14\n   |\n30 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' && i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpewns5pdw.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == \"0\") {\n            i += 1;\n            continue;\n        }\n        if (digit == \"1\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"2\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"3\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"4\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"5\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"6\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"7\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"8\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"9\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"A\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"B\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"C\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"D\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"E\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == \"F\") {\n            i += 1;\n            count += 1;\n            continue;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj1139fc.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj1139fc.rs:27:12\n   |\n27 |         if (digit == \"0\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == \"0\") {\n27 +         if digit == \"0\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj1139fc.rs:31:12\n   |\n31 |         if (digit == \"1\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == \"1\") {\n31 +         if digit == \"1\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj1139fc.rs:36:12\n   |\n36 |         if (digit == \"2\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n36 -         if (digit == \"2\") {\n36 +         if digit == \"2\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj1139fc.rs:41:12\n   |\n41 |         if (digit == \"3\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n41 -         if (digit == \"3\") {\n41 +         if digit == \"3\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj1139fc.rs:46:12\n   |\n46 |         if (digit == \"4\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n46 -         if (digit == \"4\") {\n46 +         if digit == \"4\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj1139fc.rs:51:12\n   |\n51 |         if (digit == \"5\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n51 -         if (digit == \"5\") {\n51 +         if digit == \"5\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj1139fc.rs:56:12\n   |\n56 |         if (digit == \"6\") {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n            count += 2;\n        } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n            count += 3;\n        } else if (digit == 'B' || digit == 'D') {\n            count += 4;\n        } else if (digit == 'D') {\n            count += 5;\n        } else {\n            count += 6;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpx8tvwiik.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:29:19\n   |\n29 | ...if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9'...\n   |       ^                                                                                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n29 +         } else if digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx8tvwiik.rs:31:19\n   |\n31 |         } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n   |                   ^                                                            ^\n   |\nhelp: remove these parenthes",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c.is_upper() {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp84ghd2lr.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if is_prime(i) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgtmcraif.rs:25:12\n   |\n25 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\") {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpueiumor9.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpueiumor9.rs:27:12\n   |\n27 |         if (digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\") {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\") {\n27 +         if digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\" {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpueiumor9.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpueiumor9.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if is_prime(i) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgtmcraif.rs:25:12\n   |\n25 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        if (num[i] == '0') {\n            i += 1;\n        } else if (num[i] == '1') {\n            i += 1;\n        } else if (num[i] == '2') {\n            i += 1;\n        } else if (num[i] == '3') {\n            i += 1;\n        } else if (num[i] == '4') {\n            i += 1;\n        } else if (num[i] == '5') {\n            i += 1;\n        } else if (num[i] == '6') {\n            i += 1;\n        } else if (num[i] == '7') {\n            i += 1;\n        } else if (num[i] == '8') {\n            i += 1;\n        } else if (num[i] == '9') {\n            i += 1;\n        } else if (num[i] == 'A') {\n            i += 1;\n        } else if (num[i] == 'B') {\n            i += 1;\n        } else if (num[i] == 'C') {\n            i += 1;\n        } else if (num[i] == 'D') {\n            i += 1;\n        } else if (num[i] == 'E') {\n            i += 1;\n        } else if (num[i] == 'F') {\n            i += 1;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyfdmerls.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyfdmerls.rs:26:12\n   |\n26 |         if (num[i] == '0') {\n   |            ^             ^\n   |\nhelp: remove these parentheses\n   |\n26 -         if (num[i] == '0') {\n26 +         if num[i] == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyfdmerls.rs:28:19\n   |\n28 |         } else if (num[i] == '1') {\n   |                   ^             ^\n   |\nhelp: remove these parentheses\n   |\n28 -         } else if (num[i] == '1') {\n28 +         } else if num[i] == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyfdmerls.rs:30:19\n   |\n30 |         } else if (num[i] == '2') {\n   |                   ^             ^\n   |\nhelp: remove these parentheses\n   |\n30 -         } else if (num[i] == '2') {\n30 +         } else if num[i] == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyfdmerls.rs:32:19\n   |\n32 |         } else if (num[i] == '3') {\n   |                   ^             ^\n   |\nhelp: remove these parentheses\n   |\n32 -         } else if (num[i] == '3') {\n32 +         } else if num[i] == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyfdmerls.rs:34:19\n   |\n34 |         } else if (num[i] == '4') {\n   |                   ^             ^\n   |\nhelp: remove these parentheses\n   |\n34 -         } else if (num[i] == '4') {\n34 +         } else if num[i] == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyfdmerls.rs:36:19\n   |\n36 |         } else if (num[i] == '5') {\n   |                   ^             ^\n   |\nhelp: remove these parentheses\n   |\n36 -         } else if (num[i] == '5') {\n36 +     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n            continue;\n        }\n        if (digit == '1') {\n            i += 1;\n            continue;\n        }\n        if (digit == '2') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '3') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '4') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '5') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '6') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '7') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '8') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '9') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'A') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'B') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'C') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'D') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'E') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'F') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfd4lou12.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:31:12\n   |\n31 |         if (digit == '1') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == '1') {\n31 +         if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:35:12\n   |\n35 |         if (digit == '2') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         if (digit == '2') {\n35 +         if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:40:12\n   |\n40 |         if (digit == '3') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n40 -         if (digit == '3') {\n40 +         if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:45:12\n   |\n45 |         if (digit == '4') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n45 -         if (digit == '4') {\n45 +         if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:50:12\n   |\n50 |         if (digit == '5') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n50 -         if (digit == '5') {\n50 +         if digit == '5' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:55:12\n   |\n55 |         if (digit == '6') {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' and c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmpolbqbvu2.rs:25:21\n   |\n25 |         if c >= 'A' and c <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpolbqbvu2.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpc5gl769l.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n        } else if (digit == '1') {\n            i += 1;\n        } else if (digit == '2') {\n            i += 1;\n        } else if (digit == '3') {\n            i += 1;\n        } else if (digit == '4') {\n            i += 1;\n        } else if (digit == '5') {\n            i += 1;\n        } else if (digit == '6') {\n            i += 1;\n        } else if (digit == '7') {\n            i += 1;\n        } else if (digit == '8') {\n            i += 1;\n        } else if (digit == '9') {\n            i += 1;\n        } else if (digit == 'A') {\n            i += 1;\n        } else if (digit == 'B') {\n            i += 1;\n        } else if (digit == 'C') {\n            i += 1;\n        } else if (digit == 'D') {\n            i += 1;\n        } else if (digit == 'E') {\n            i += 1;\n        } else if (digit == 'F') {\n            i += 1;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvwu0awsr.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:29:19\n   |\n29 |         } else if (digit == '1') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '1') {\n29 +         } else if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:31:19\n   |\n31 |         } else if (digit == '2') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         } else if (digit == '2') {\n31 +         } else if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:33:19\n   |\n33 |         } else if (digit == '3') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n33 -         } else if (digit == '3') {\n33 +         } else if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:35:19\n   |\n35 |         } else if (digit == '4') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         } else if (digit == '4') {\n35 +         } else if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:37:19\n   |\n37 |         } else if (digit == '5') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n37 -         } else if (digit == '5') {\n37 +         } else if digit == ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n        } else if (digit == '1') {\n            i += 1;\n        } else if (digit == '2') {\n            i += 1;\n        } else if (digit == '3') {\n            i += 1;\n        } else if (digit == '4') {\n            i += 1;\n        } else if (digit == '5') {\n            i += 1;\n        } else if (digit == '6') {\n            i += 1;\n        } else if (digit == '7') {\n            i += 1;\n        } else if (digit == '8') {\n            i += 1;\n        } else if (digit == '9') {\n            i += 1;\n        } else if (digit == 'A') {\n            i += 1;\n        } else if (digit == 'B') {\n            i += 1;\n        } else if (digit == 'C') {\n            i += 1;\n        } else if (digit == 'D') {\n            i += 1;\n        } else if (digit == 'E') {\n            i += 1;\n        } else if (digit == 'F') {\n            i += 1;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvwu0awsr.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:29:19\n   |\n29 |         } else if (digit == '1') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '1') {\n29 +         } else if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:31:19\n   |\n31 |         } else if (digit == '2') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         } else if (digit == '2') {\n31 +         } else if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:33:19\n   |\n33 |         } else if (digit == '3') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n33 -         } else if (digit == '3') {\n33 +         } else if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:35:19\n   |\n35 |         } else if (digit == '4') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         } else if (digit == '4') {\n35 +         } else if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:37:19\n   |\n37 |         } else if (digit == '5') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n37 -         } else if (digit == '5') {\n37 +         } else if digit == ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp4vhf3hdp.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp4vhf3hdp.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp4vhf3hdp.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 3;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' && i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpewns5pdw.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num.chars() {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpoy0ob05z.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpoy0ob05z.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpoy0ob05z.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 3;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' and i <= '9' {\n            count += 1;\n        } else if i >= 'A' and i <= 'F' {\n            count += 2;\n        } else if i >= 'a' and i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:25:21\n   |\n25 |         if i >= '0' and i <= '9' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:27:28\n   |\n27 |         } else if i >= 'A' and i <= 'F' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:29:28\n   |\n29 |         } else if i >= 'a' and i <= 'f' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= '0' && i <= '9' {\n      count += 1;\n    } else if i >= 'A' && i <= 'F' {\n      count += 2;\n    } else if i >= 'a' && i <= 'f' {\n      count += 2;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:26:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n26 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:28:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n28 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:30:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n30 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n            digit == '4' || digit == '5' || digit == '6' || digit == '7' ||\n            digit == '8' || digit == '9' || digit == 'A' || digit == 'B' ||\n            digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp55_k041p.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55_k041p.rs:27:12\n   |\n27 |         if (digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n   |            ^\n...\n30 |             digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |                                                                         ^\n   |\nhelp: remove these parentheses\n   |\n27 ~         if digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n28 |             digit == '4' || digit == '5' || digit == '6' || digit == '7' ||\n29 |             digit == '8' || digit == '9' || digit == 'A' || digit == 'B' ||\n30 ~             digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp55_k041p.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp55_k041p.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else if c >= 'a' && c <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp65hpna32.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpc5gl769l.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i.is_upper() {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpubeu7d1r.rs:25:14\n   |\n25 |         if i.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' && i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpewns5pdw.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if is_prime(i) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgtmcraif.rs:25:12\n   |\n25 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if is_prime(i) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgtmcraif.rs:25:12\n   |\n25 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for c in num {\n    if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp9acqi4xa.rs:24:12\n   |\n24 |   for c in num {\n   |            ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' && i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpewns5pdw.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' and c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmpolbqbvu2.rs:25:21\n   |\n25 |         if c >= 'A' and c <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpolbqbvu2.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= '0' && i <= '9' {\n      count += 1;\n    } else if i >= 'A' && i <= 'F' {\n      count += 2;\n    } else if i >= 'a' && i <= 'f' {\n      count += 2;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:26:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n26 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:28:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n28 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:30:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n30 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= 'A' && i <= 'F' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp4c5pq0re.rs:26:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n26 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for (let i = 0; i < num.len; i++) {\n    let digit = num[i];\n    if (digit == \"0\") {\n      continue;\n    }\n    if (digit == \"1\") {\n      count += 1;\n      continue;\n    }\n    if (digit == \"2\") {\n      count += 2;\n      continue;\n    }\n    if (digit == \"3\") {\n      count += 3;\n      continue;\n    }\n    if (digit == \"4\") {\n      count += 4;\n      continue;\n    }\n    if (digit == \"5\") {\n      count += 5;\n      continue;\n    }\n    if (digit == \"6\") {\n      count += 6;\n      continue;\n    }\n    if (digit == \"7\") {\n      count += 7;\n      continue;\n    }\n    if (digit == \"8\") {\n      count += 8;\n      continue;\n    }\n    if (digit == \"9\") {\n      count += 9;\n      continue;\n    }\n    if (digit == \"A\") {\n      count += 10;\n      continue;\n    }\n    if (digit == \"B\") {\n      count += 11;\n      continue;\n    }\n    if (digit == \"C\") {\n      count += 12;\n      continue;\n    }\n    if (digit == \"D\") {\n      count += 13;\n      continue;\n    }\n    if (digit == \"E\") {\n      count += 14;\n      continue;\n    }\n    if (digit == \"F\") {\n      count += 15;\n      continue;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp9av4w8h0.rs:24:8\n   |\n24 |   for (let i = 0; i < num.len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp9av4w8h0.rs:24:12\n   |\n24 |   for (let i = 0; i < num.len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp9av4w8h0.rs:24:14\n   |\n24 |   for (let i = 0; i < num.len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp9av4w8h0.rs:24:13\n   |\n24 |   for (let i = 0; i < num.len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp9av4w8h0.rs:24:14\n   |\n24 |   for (let i = 0; i < num.len; i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= '0' and i <= '9' {\n      count += 1;\n    } else if i >= 'A' and i <= 'F' {\n      count += 2;\n    } else if i >= 'a' and i <= 'f' {\n      count += 2;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmplu8nwqad.rs:25:17\n   |\n25 |     if i >= '0' and i <= '9' {\n   |                 ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmplu8nwqad.rs:27:24\n   |\n27 |     } else if i >= 'A' and i <= 'F' {\n   |                        ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmplu8nwqad.rs:29:24\n   |\n29 |     } else if i >= 'a' and i <= 'f' {\n   |                        ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' && i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpewns5pdw.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 1;\n        } else if i >= 'a' && i <= 'f' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < num.len) {\n    let digit = num[i];\n    if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcpofbafm.rs:25:9\n   |\n25 |   while (i < num.len) {\n   |         ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -   while (i < num.len) {\n25 +   while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcpofbafm.rs:27:8\n   |\n27 |     if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |        ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -     if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +     if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpcpofbafm.rs:25:18\n   |\n25 |   while (i < num.len) {\n   |                  ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |   while (i < num.len()) {\n   |                     ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpcpofbafm.rs:26:17\n   |\n26 |     let digit = num[i];\n   |                 ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= '0' && i <= '9' {\n      count += 1;\n    } else if i >= 'A' && i <= 'F' {\n      count += 2;\n    } else if i >= 'a' && i <= 'f' {\n      count += 2;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:26:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n26 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:28:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n28 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:30:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n30 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' and c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmpolbqbvu2.rs:25:21\n   |\n25 |         if c >= 'A' and c <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpolbqbvu2.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n            continue;\n        }\n        if (digit == '1') {\n            i += 1;\n            continue;\n        }\n        if (digit == '2') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '3') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '4') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '5') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '6') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '7') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '8') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == '9') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'A') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'B') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'C') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'D') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'E') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n        if (digit == 'F') {\n            i += 1;\n            count += 1;\n            continue;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfd4lou12.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:31:12\n   |\n31 |         if (digit == '1') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (digit == '1') {\n31 +         if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:35:12\n   |\n35 |         if (digit == '2') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         if (digit == '2') {\n35 +         if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:40:12\n   |\n40 |         if (digit == '3') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n40 -         if (digit == '3') {\n40 +         if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:45:12\n   |\n45 |         if (digit == '4') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n45 -         if (digit == '4') {\n45 +         if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:50:12\n   |\n50 |         if (digit == '5') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n50 -         if (digit == '5') {\n50 +         if digit == '5' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfd4lou12.rs:55:12\n   |\n55 |         if (digit == '6') {\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let n = num.to_i();\n    for i in 0..n {\n        if num[i] == '0' || num[i] == '1' || num[i] == '2' || num[i] == '3' || num[i] == '4' || num[i] == '5' || num[i] == '6' || num[i] == '7' || num[i] == '8' || num[i] == '9' || num[i] == 'A' || num[i] == 'B' || num[i] == 'C' || num[i] == 'D' || num[i] == 'E' || num[i] == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for struct `String` in the current scope\n  --> /tmp/tmp9mnjzpzn.rs:24:17\n   |\n24 |     let n = num.to_i();\n   |                 ^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp9mnjzpzn.rs:26:12\n   |\n26 | ...   if num[i] == '0' || num[i] == '1' || num[i] == '2' || num[i] == '3' || num[i] == '4' || num[i] == '5' || num[i] == '6' || num[i] ==...\n   |          ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp9mnjzpzn.rs:26:29\n   |\n26 | ...   if num[i] == '0' || num[i] == '1' || num[i] == '2' || num[i] == '3' || num[i] == '4' || num[i] == '5' || num[i] == '6' || num[i] ==...\n   |                           ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp9mnjzpzn.rs:26:46\n   |\n26 | ...   if num[i] == '0' || num[i] == '1' || num[i] == '2' || num[i] == '3' || num[i] == '4' || num[i] == '5' || num[i] == '6' || num[i] ==.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n        } else if (digit == '1') {\n            i += 1;\n        } else if (digit == '2') {\n            i += 1;\n        } else if (digit == '3') {\n            i += 1;\n        } else if (digit == '4') {\n            i += 1;\n        } else if (digit == '5') {\n            i += 1;\n        } else if (digit == '6') {\n            i += 1;\n        } else if (digit == '7') {\n            i += 1;\n        } else if (digit == '8') {\n            i += 1;\n        } else if (digit == '9') {\n            i += 1;\n        } else if (digit == 'A') {\n            i += 1;\n        } else if (digit == 'B') {\n            i += 1;\n        } else if (digit == 'C') {\n            i += 1;\n        } else if (digit == 'D') {\n            i += 1;\n        } else if (digit == 'E') {\n            i += 1;\n        } else if (digit == 'F') {\n            i += 1;\n        } else {\n            i += 1;\n        }\n        count += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpglhevmr9.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpglhevmr9.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpglhevmr9.rs:29:19\n   |\n29 |         } else if (digit == '1') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '1') {\n29 +         } else if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpglhevmr9.rs:31:19\n   |\n31 |         } else if (digit == '2') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         } else if (digit == '2') {\n31 +         } else if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpglhevmr9.rs:33:19\n   |\n33 |         } else if (digit == '3') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n33 -         } else if (digit == '3') {\n33 +         } else if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpglhevmr9.rs:35:19\n   |\n35 |         } else if (digit == '4') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         } else if (digit == '4') {\n35 +         } else if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpglhevmr9.rs:37:19\n   |\n37 |         } else if (digit == '5') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n37 -         } else if (digit == '5') {\n37 +         } else if digit == ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let len = num.length();\n    for (let i = 0; i < len; i++) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        } else if (digit == '0' || digit == '1' || digit == '2' || digit == '3' || digit == '4' || digit == '5' || digit == '6' || digit == '7' || digit == '8' || digit == '9') {\n            count += 2;\n        } else if (digit == '2' || digit == '3' || digit == '5' || digit == '7') {\n            count += 3;\n        } else if (digit == 'B') {\n            count += 4;\n        } else if (digit == 'D') {\n            count += 5;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpwzwukdyt.rs:25:10\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpwzwukdyt.rs:25:14\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpwzwukdyt.rs:25:16\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpwzwukdyt.rs:25:15\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpwzwukdyt.rs:25:16\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpwzwukdyt.rs:24:19\n   |\n24 |     let len = num.length();\n   |                   ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' && i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpewns5pdw.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if is_prime(i) {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpgtmcraif.rs:25:12\n   |\n25 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    let count2 = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count2 += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count2 += 1;\n        }\n    }\n    let count3 = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count3 += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count3 += 1;\n        }\n    }\n    let count4 = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count4 += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count4 += 1;\n        }\n    }\n    let count5 = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count5 += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count5 += 1;\n        }\n    }\n    let count6 = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count6 += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count6 += 1;\n        }\n    }\n    let count7 = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count7 += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count7 += 1;\n        }\n    }\n    let count8 = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count8 += 1;\n        } else if c >= 'A'\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4ehin6w4.rs:94:3\n   |\n22 | fn hex_key(num: String) -> isize {\n   |                                  - unclosed delimiter\n...\n80 |     for c in num {\n   |                  - this delimiter might not be properly closed...\n...\n84 | }\n   | - ...as it matches this but it has different indentation\n...\n94 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp4ehin6w4.rs:84:1\n   |\n83 |         } else if c >= 'A'\n   |                -- this `if` expression has a condition, but no block\n84 | }\n   | ^ expected `{`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp4ehin6w4.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp4ehin6w4.rs:32:14\n   |\n32 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp4ehin6w4.rs:40:14\n   |\n40 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp4ehin6w4.rs:48:14\n   |\n48 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp4ehin6w",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == \"0\") {\n            i += 1;\n        } else if (digit == \"1\") {\n            i += 1;\n        } else if (digit == \"2\") {\n            i += 1;\n        } else if (digit == \"3\") {\n            i += 1;\n        } else if (digit == \"4\") {\n            i += 1;\n        } else if (digit == \"5\") {\n            i += 1;\n        } else if (digit == \"6\") {\n            i += 1;\n        } else if (digit == \"7\") {\n            i += 1;\n        } else if (digit == \"8\") {\n            i += 1;\n        } else if (digit == \"9\") {\n            i += 1;\n        } else if (digit == \"A\") {\n            i += 1;\n        } else if (digit == \"B\") {\n            i += 1;\n        } else if (digit == \"C\") {\n            i += 1;\n        } else if (digit == \"D\") {\n            i += 1;\n        } else if (digit == \"E\") {\n            i += 1;\n        } else if (digit == \"F\") {\n            i += 1;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp0982flbh.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0982flbh.rs:27:12\n   |\n27 |         if (digit == \"0\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == \"0\") {\n27 +         if digit == \"0\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0982flbh.rs:29:19\n   |\n29 |         } else if (digit == \"1\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == \"1\") {\n29 +         } else if digit == \"1\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0982flbh.rs:31:19\n   |\n31 |         } else if (digit == \"2\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         } else if (digit == \"2\") {\n31 +         } else if digit == \"2\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0982flbh.rs:33:19\n   |\n33 |         } else if (digit == \"3\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n33 -         } else if (digit == \"3\") {\n33 +         } else if digit == \"3\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0982flbh.rs:35:19\n   |\n35 |         } else if (digit == \"4\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         } else if (digit == \"4\") {\n35 +         } else if digit == \"4\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0982flbh.rs:37:19\n   |\n37 |         } else if (digit == \"5\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n37 -         } else if (digit == \"5\") {\n37 +         } else if digit == ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpc5gl769l.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpc5gl769l.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let curr = 0;\n    for i in num.chars() {\n        if curr == 0 {\n            curr = i - '0';\n        } else if curr == 1 {\n            curr = i - 'A' + 10;\n        } else if curr == 2 {\n            curr = i - 'a' + 10;\n        } else if curr == 3 {\n            curr = i - 'B' + 11;\n        } else if curr == 4 {\n            curr = i - 'C' + 12;\n        } else if curr == 5 {\n            curr = i - 'D' + 13;\n        } else if curr == 6 {\n            curr = i - 'E' + 14;\n        } else if curr == 7 {\n            curr = i - 'F' + 15;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpt15qifiz.rs:27:22\n   |\n27 |             curr = i - '0';\n   |                    - ^ --- char\n   |                    |\n   |                    char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpt15qifiz.rs:29:22\n   |\n29 |             curr = i - 'A' + 10;\n   |                    - ^ --- char\n   |                    |\n   |                    char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpt15qifiz.rs:31:22\n   |\n31 |             curr = i - 'a' + 10;\n   |                    - ^ --- char\n   |                    |\n   |                    char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpt15qifiz.rs:33:22\n   |\n33 |             curr = i - 'B' + 11;\n   |                    - ^ --- char\n   |                    |\n   |                    char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpt15qifiz.rs:35:22\n   |\n35 |             curr = i - 'C' + 12;\n   |                    - ^ --- char\n   |                    |\n   |                    char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpt15qifiz.rs:37:22\n   |\n37 |             curr = i - 'D' + 13;\n   |                    - ^ --- char\n   |                    |\n   |                    char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpt15qifiz.rs:39:22\n   |\n39 |             curr = i - 'E' + 14;\n   |                    - ^ --- char\n   |                    |\n   |                    char\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpt15qifiz.rs:41:22\n   |\n41 |             curr = i - 'F' + 15;\n   |                    - ^ --- char\n   |                    |\n   |                    char\n\nerror: aborting due to 8 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if is_hex_digit(i) {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_hex_digit` in this scope\n  --> /tmp/tmpezp4tpuc.rs:25:8\n   |\n25 |     if is_hex_digit(i) {\n   |        ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' and c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmpolbqbvu2.rs:25:21\n   |\n25 |         if c >= 'A' and c <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpolbqbvu2.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c == 'A' || c == 'B' || c == 'C' || c == 'D' || c == 'E' || c == 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp2tmc15pp.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' and i <= '9' {\n            count += 1;\n        } else if i >= 'A' and i <= 'F' {\n            count += 1;\n        } else if i >= 'a' and i <= 'f' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmp7k_7d3_l.rs:25:21\n   |\n25 |         if i >= '0' and i <= '9' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmp7k_7d3_l.rs:27:28\n   |\n27 |         } else if i >= 'A' and i <= 'F' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmp7k_7d3_l.rs:29:28\n   |\n29 |         } else if i >= 'a' and i <= 'f' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let len = num.length();\n    for (let i = 0; i < len; i++) {\n        let digit = num[i];\n        if (digit == \"0\" || digit == \"1\" || digit == \"2\" || digit == \"3\" ||\n            digit == \"4\" || digit == \"5\" || digit == \"6\" || digit == \"7\" ||\n            digit == \"8\" || digit == \"9\" || digit == \"A\" || digit == \"B\" ||\n            digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\") {\n            count++;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpuw7lsjw4.rs:25:10\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpuw7lsjw4.rs:25:14\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpuw7lsjw4.rs:25:16\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpuw7lsjw4.rs:25:15\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpuw7lsjw4.rs:25:16\n   |\n25 |     for (let i = 0; i < len; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpuw7lsjw4.rs:24:19\n   |\n24 |     let len = num.length();\n   |                   ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n            digit == '4' || digit == '5' || digit == '6' || digit == '7' ||\n            digit == '8' || digit == '9' || digit == 'A' || digit == 'B' ||\n            digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp55_k041p.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55_k041p.rs:27:12\n   |\n27 |         if (digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n   |            ^\n...\n30 |             digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |                                                                         ^\n   |\nhelp: remove these parentheses\n   |\n27 ~         if digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n28 |             digit == '4' || digit == '5' || digit == '6' || digit == '7' ||\n29 |             digit == '8' || digit == '9' || digit == 'A' || digit == 'B' ||\n30 ~             digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp55_k041p.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp55_k041p.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else if c >= 'a' && c <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp65hpna32.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let num_len = num.len();\n    for (let i = 0; i < num_len; i++) {\n        let digit = num[i];\n        if (digit == \"0\" || digit == \"1\" || digit == \"2\" || digit == \"3\" ||\n            digit == \"4\" || digit == \"5\" || digit == \"6\" || digit == \"7\" ||\n            digit == \"8\" || digit == \"9\" || digit == \"A\" || digit == \"B\" ||\n            digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\") {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpre359pkd.rs:25:10\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpre359pkd.rs:25:14\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpre359pkd.rs:25:16\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpre359pkd.rs:25:15\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpre359pkd.rs:25:16\n   |\n25 |     for (let i = 0; i < num_len; i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpc5gl769l.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' and c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmpolbqbvu2.rs:25:21\n   |\n25 |         if c >= 'A' and c <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpolbqbvu2.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp4vhf3hdp.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp4vhf3hdp.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp4vhf3hdp.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 3;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        if (num[i] == 'A') {\n            count += 1;\n        }\n        if (num[i] == 'B') {\n            count += 1;\n        }\n        if (num[i] == 'C') {\n            count += 1;\n        }\n        if (num[i] == 'D') {\n            count += 1;\n        }\n        if (num[i] == 'E') {\n            count += 1;\n        }\n        if (num[i] == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukadn_p0.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpukadn_p0.rs:26:12\n   |\n26 |         if (num[i] == 'A') {\n   |            ^             ^\n   |\nhelp: remove these parentheses\n   |\n26 -         if (num[i] == 'A') {\n26 +         if num[i] == 'A' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpukadn_p0.rs:29:12\n   |\n29 |         if (num[i] == 'B') {\n   |            ^             ^\n   |\nhelp: remove these parentheses\n   |\n29 -         if (num[i] == 'B') {\n29 +         if num[i] == 'B' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpukadn_p0.rs:32:12\n   |\n32 |         if (num[i] == 'C') {\n   |            ^             ^\n   |\nhelp: remove these parentheses\n   |\n32 -         if (num[i] == 'C') {\n32 +         if num[i] == 'C' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpukadn_p0.rs:35:12\n   |\n35 |         if (num[i] == 'D') {\n   |            ^             ^\n   |\nhelp: remove these parentheses\n   |\n35 -         if (num[i] == 'D') {\n35 +         if num[i] == 'D' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpukadn_p0.rs:38:12\n   |\n38 |         if (num[i] == 'E') {\n   |            ^             ^\n   |\nhelp: remove these parentheses\n   |\n38 -         if (num[i] == 'E') {\n38 +         if num[i] == 'E' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpukadn_p0.rs:41:12\n   |\n41 |         if (num[i] == 'F') {\n   |            ^             ^\n   |\nhelp: remove these parentheses\n   |\n41 -         if (num[i] == 'F') {\n41 +         if num[i] == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpukadn_p0.rs:25:20\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 1;\n        } else if i >= 'a' && i <= 'f' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for c in num {\n    if c >= 'A' && c <= 'F' {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp_lex4edw.rs:24:12\n   |\n24 |   for c in num {\n   |            ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpc5gl769l.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' and i <= '9' {\n            count += 1;\n        } else if i >= 'A' and i <= 'F' {\n            count += 2;\n        } else if i >= 'a' and i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:25:21\n   |\n25 |         if i >= '0' and i <= '9' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:27:28\n   |\n27 |         } else if i >= 'A' and i <= 'F' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:29:28\n   |\n29 |         } else if i >= 'a' and i <= 'f' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else if c >= 'a' && c <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp65hpna32.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n        } else if (digit == '1') {\n            i += 1;\n        } else if (digit == '2') {\n            i += 1;\n        } else if (digit == '3') {\n            i += 1;\n        } else if (digit == '4') {\n            i += 1;\n        } else if (digit == '5') {\n            i += 1;\n        } else if (digit == '6') {\n            i += 1;\n        } else if (digit == '7') {\n            i += 1;\n        } else if (digit == '8') {\n            i += 1;\n        } else if (digit == '9') {\n            i += 1;\n        } else if (digit == 'A') {\n            i += 1;\n        } else if (digit == 'B') {\n            i += 1;\n        } else if (digit == 'C') {\n            i += 1;\n        } else if (digit == 'D') {\n            i += 1;\n        } else if (digit == 'E') {\n            i += 1;\n        } else if (digit == 'F') {\n            i += 1;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvwu0awsr.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:29:19\n   |\n29 |         } else if (digit == '1') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '1') {\n29 +         } else if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:31:19\n   |\n31 |         } else if (digit == '2') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         } else if (digit == '2') {\n31 +         } else if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:33:19\n   |\n33 |         } else if (digit == '3') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n33 -         } else if (digit == '3') {\n33 +         } else if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:35:19\n   |\n35 |         } else if (digit == '4') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         } else if (digit == '4') {\n35 +         } else if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:37:19\n   |\n37 |         } else if (digit == '5') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n37 -         } else if (digit == '5') {\n37 +         } else if digit == ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let n = num.to_i();\n    let i = 0;\n    while (i < n) {\n        let digit = n % 16;\n        if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n            count += 1;\n        }\n        n /= 16;\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1tc0qpf8.rs:26:11\n   |\n26 |     while (i < n) {\n   |           ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n26 -     while (i < n) {\n26 +     while i < n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1tc0qpf8.rs:28:12\n   |\n28 |         if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n   |            ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n28 -         if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13) {\n28 +         if digit == 2 || digit == 3 || digit == 5 || digit == 7 || digit == 11 || digit == 13 {\n   | \n\nerror[E0599]: no method named `to_i` found for struct `String` in the current scope\n  --> /tmp/tmp1tc0qpf8.rs:24:17\n   |\n24 |     let n = num.to_i();\n   |                 ^^^^ method not found in `String`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.length) {\n        let digit = num[i];\n        if (digit == \"0\") {\n            i += 1;\n        } else if (digit == \"1\") {\n            i += 1;\n        } else if (digit == \"2\") {\n            i += 1;\n        } else if (digit == \"3\") {\n            i += 1;\n        } else if (digit == \"4\") {\n            i += 1;\n        } else if (digit == \"5\") {\n            i += 1;\n        } else if (digit == \"6\") {\n            i += 1;\n        } else if (digit == \"7\") {\n            i += 1;\n        } else if (digit == \"8\") {\n            i += 1;\n        } else if (digit == \"9\") {\n            i += 1;\n        } else if (digit == \"A\") {\n            i += 1;\n        } else if (digit == \"B\") {\n            i += 1;\n        } else if (digit == \"C\") {\n            i += 1;\n        } else if (digit == \"D\") {\n            i += 1;\n        } else if (digit == \"E\") {\n            i += 1;\n        } else if (digit == \"F\") {\n            i += 1;\n        } else {\n            i += 1;\n        }\n        count += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy_ohp8mz.rs:25:11\n   |\n25 |     while (i < num.length) {\n   |           ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.length) {\n25 +     while i < num.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy_ohp8mz.rs:27:12\n   |\n27 |         if (digit == \"0\") {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == \"0\") {\n27 +         if digit == \"0\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy_ohp8mz.rs:29:19\n   |\n29 |         } else if (digit == \"1\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == \"1\") {\n29 +         } else if digit == \"1\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy_ohp8mz.rs:31:19\n   |\n31 |         } else if (digit == \"2\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         } else if (digit == \"2\") {\n31 +         } else if digit == \"2\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy_ohp8mz.rs:33:19\n   |\n33 |         } else if (digit == \"3\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n33 -         } else if (digit == \"3\") {\n33 +         } else if digit == \"3\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy_ohp8mz.rs:35:19\n   |\n35 |         } else if (digit == \"4\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         } else if (digit == \"4\") {\n35 +         } else if digit == \"4\" {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy_ohp8mz.rs:37:19\n   |\n37 |         } else if (digit == \"5\") {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n37 -         } else if (digit == \"5\") {\n37 +         } else ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n  let count = 0;\n  for i in num.chars() {\n    if i >= '0' && i <= '9' {\n      count += 1;\n    } else if i >= 'A' && i <= 'F' {\n      count += 2;\n    } else if i >= 'a' && i <= 'f' {\n      count += 2;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:26:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n26 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:28:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n28 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmphucha1e6.rs:30:7\n   |\n23 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n30 |       count += 2;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else if c >= 'a' && c <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp65hpna32.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' && i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpewns5pdw.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n            digit == '4' || digit == '5' || digit == '6' || digit == '7' ||\n            digit == '8' || digit == '9' || digit == 'A' || digit == 'B' ||\n            digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp55_k041p.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55_k041p.rs:27:12\n   |\n27 |         if (digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n   |            ^\n...\n30 |             digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |                                                                         ^\n   |\nhelp: remove these parentheses\n   |\n27 ~         if digit == '0' || digit == '1' || digit == '2' || digit == '3' ||\n28 |             digit == '4' || digit == '5' || digit == '6' || digit == '7' ||\n29 |             digit == '8' || digit == '9' || digit == 'A' || digit == 'B' ||\n30 ~             digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp55_k041p.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp55_k041p.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' and i <= '9' {\n            count += 1;\n        } else if i >= 'A' and i <= 'F' {\n            count += 2;\n        } else if i >= 'a' and i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:25:21\n   |\n25 |         if i >= '0' and i <= '9' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:27:28\n   |\n27 |         } else if i >= 'A' and i <= 'F' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmppya52ikg.rs:29:28\n   |\n29 |         } else if i >= 'a' and i <= 'f' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi359xp3v.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi359xp3v.rs:27:12\n   |\n27 |         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F') {\n27 +         if digit == 'A' || digit == 'B' || digit == 'C' || digit == 'D' || digit == 'E' || digit == 'F' {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpi359xp3v.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpi359xp3v.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= 'A' && c <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpuztu6oqd.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num.chars() {\n        if c >= '0' && c <= '9' {\n            count += 1;\n        } else if c >= 'A' && c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpoy0ob05z.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpoy0ob05z.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpoy0ob05z.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 3;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for c in num {\n        if c >= '0' and c <= '9' {\n            count += 1;\n        } else if c >= 'A' and c <= 'F' {\n            count += 2;\n        } else {\n            count += 3;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmpjzuhei50.rs:25:21\n   |\n25 |         if c >= '0' and c <= '9' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmpjzuhei50.rs:27:28\n   |\n27 |         } else if c >= 'A' and c <= 'F' {\n   |                            ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpjzuhei50.rs:24:14\n   |\n24 |     for c in num {\n   |              ^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' and i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error: `and` is not a logical operator\n  --> /tmp/tmplayzy2vd.rs:25:21\n   |\n25 |         if i >= 'A' and i <= 'F' {\n   |                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == '0') {\n            i += 1;\n        } else if (digit == '1') {\n            i += 1;\n        } else if (digit == '2') {\n            i += 1;\n        } else if (digit == '3') {\n            i += 1;\n        } else if (digit == '4') {\n            i += 1;\n        } else if (digit == '5') {\n            i += 1;\n        } else if (digit == '6') {\n            i += 1;\n        } else if (digit == '7') {\n            i += 1;\n        } else if (digit == '8') {\n            i += 1;\n        } else if (digit == '9') {\n            i += 1;\n        } else if (digit == 'A') {\n            i += 1;\n        } else if (digit == 'B') {\n            i += 1;\n        } else if (digit == 'C') {\n            i += 1;\n        } else if (digit == 'D') {\n            i += 1;\n        } else if (digit == 'E') {\n            i += 1;\n        } else if (digit == 'F') {\n            i += 1;\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvwu0awsr.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:27:12\n   |\n27 |         if (digit == '0') {\n   |            ^            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == '0') {\n27 +         if digit == '0' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:29:19\n   |\n29 |         } else if (digit == '1') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n29 -         } else if (digit == '1') {\n29 +         } else if digit == '1' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:31:19\n   |\n31 |         } else if (digit == '2') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n31 -         } else if (digit == '2') {\n31 +         } else if digit == '2' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:33:19\n   |\n33 |         } else if (digit == '3') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n33 -         } else if (digit == '3') {\n33 +         } else if digit == '3' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:35:19\n   |\n35 |         } else if (digit == '4') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n35 -         } else if (digit == '4') {\n35 +         } else if digit == '4' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvwu0awsr.rs:37:19\n   |\n37 |         } else if (digit == '5') {\n   |                   ^            ^\n   |\nhelp: remove these parentheses\n   |\n37 -         } else if (digit == '5') {\n37 +         } else if digit == ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= 'A' && i <= 'F' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpewns5pdw.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    let i = 0;\n    while (i < num.len) {\n        let digit = num[i];\n        if (digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\") {\n            count += 1;\n        }\n        i += 1;\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpueiumor9.rs:25:11\n   |\n25 |     while (i < num.len) {\n   |           ^           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n25 -     while (i < num.len) {\n25 +     while i < num.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpueiumor9.rs:27:12\n   |\n27 |         if (digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\") {\n   |            ^                                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n27 -         if (digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\") {\n27 +         if digit == \"A\" || digit == \"B\" || digit == \"C\" || digit == \"D\" || digit == \"E\" || digit == \"F\" {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpueiumor9.rs:25:20\n   |\n25 |     while (i < num.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n25 |     while (i < num.len()) {\n   |                       ++\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpueiumor9.rs:26:21\n   |\n26 |         let digit = num[i];\n   |                     ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0615.\nFor more information about an error, try ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 2;\n        } else if i >= 'a' && i <= 'f' {\n            count += 2;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx6uov6r9.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 2;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You have been tasked to write a function that receives \n/// a hexadecimal number as a string and counts the number of hexadecimal \n/// digits that are primes (prime number, or a prime, is a natural number \n/// greater than 1 that is not a product of two smaller natural numbers).\n/// Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n/// Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n/// So you have to determine a number of the following digits: 2, 3, 5, 7, \n/// B (=decimal 11), D (=decimal 13).\n/// Note: you may assume the input is always correct or empty string, \n/// and symbols A,B,C,D,E,F are always uppercase.\n/// Examples:\n/// >>> hex_key(String::from(\"AB\"))\n/// 1\n/// >>> hex_key(String::from(\"1077E\"))\n/// 2\n/// >>> hex_key(String::from(\"ABED1A33\"))\n/// 4\n/// >>> hex_key(String::from(\"123456789ABCDEF0\"))\n/// 6\n/// >>> hex_key(String::from(\"2020\"))\n/// 2\nfn hex_key(num: String) -> isize {\n    let count = 0;\n    for i in num.chars() {\n        if i >= '0' && i <= '9' {\n            count += 1;\n        } else if i >= 'A' && i <= 'F' {\n            count += 1;\n        } else if i >= 'a' && i <= 'f' {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = hex_key;\n    assert_eq!(candidate(String::from(\"AB\")), 1);\n    assert_eq!(candidate(String::from(\"1077E\")), 2);\n    assert_eq!(candidate(String::from(\"ABED1A33\")), 4);\n    assert_eq!(candidate(String::from(\"2020\")), 2);\n    assert_eq!(candidate(String::from(\"123456789ABCDEF0\")), 6);\n    assert_eq!(candidate(String::from(\"112233445566778899AABBCCDDEEFF00\")), 12);\n}\n",
      "timestamp": 1664292802,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:26:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n26 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:28:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n28 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpf6m8xzcr.rs:30:13\n   |\n23 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n30 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}