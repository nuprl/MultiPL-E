{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "rs",
  "prompt": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n",
  "tests": "}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let closest_vowel = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        let c = word[i];\n        if (vowels.indexOf(c) >= 0) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                closest_vowel = c;\n                break;\n            }\n        } else if (consonants.indexOf(c) >= 0) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                closest_vowel = c;\n                break;\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpzc16n9ce.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpzc16n9ce.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpzc16n9ce.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpzc16n9ce.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpzc16n9ce.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else if (vowel_index < consonant_index) {\n        return vowels[vowel_index + 1]\n    } else {\n        return vowels[vowel_index - 1]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplmlkyyvs.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplmlkyyvs.rs:22:15\n   |\n22 |     } else if (vowel_index < consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index < consonant_index) {\n22 +     } else if vowel_index < consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmplmlkyyvs.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplmlkyyvs.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmplmlkyyvs.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        let c = word[i];\n        if (vowels.indexOf(c) >= 0) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                result = c;\n                break;\n            }\n        } else if (consonants.indexOf(c) >= 0) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                result = c;\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmphsobacst.rs:21:10\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmphsobacst.rs:21:14\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmphsobacst.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmphsobacst.rs:21:15\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmphsobacst.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < consonant_index) {\n        return word[word.length - 1];\n    } else if (vowel_index > consonant_index) {\n        return word[word.length - 2];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcg35a9rs.rs:20:8\n   |\n20 |     if (vowel_index < consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < consonant_index) {\n20 +     if vowel_index < consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcg35a9rs.rs:22:15\n   |\n22 |     } else if (vowel_index > consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index > consonant_index) {\n22 +     } else if vowel_index > consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpcg35a9rs.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpcg35a9rs.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpcg35a9rs.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  -",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index_plus_1 = consonants.indexOf(word[consonant_index + 1]);\n    let vowel_index_plus_1 = vowels.indexOf(word[vowel_index + 1]);\n    let consonant_count_plus_1 = 0;\n    let vowel_count_plus_1 = 0;\n    for (let i = 0; i < word.length; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index_plus_1) {\n            consonant_count_plus_1 += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index_plus_1) {\n            vowel_count_plus_1 += 1;\n        }\n    }\n    if (consonant_count_plus_1 == 0 || vowel_count_plus_1 == 0) {\n        return \"\";\n    }\n    let consonant_index_plus_2 = consonants.indexOf(word[consonant\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp5fog5oe0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp5fog5oe0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp5fog5oe0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp5fog5oe0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp5fog5oe0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |                ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp5fog5oe0.rs:48:57\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n48 |     let consonant_index_plus_2 = consonants.indexOf(word[consonant\n   |                                                         ^ unclosed delimiter\n49 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp5fog5oe0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp5fog5oe0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [String::from(\"a\"), String::from(\"e\"), String::from(\"i\"), String::from(\"o\"), String::from(\"u\")];\n    let consonants = word.chars().filter(c => c != \" \").to_list();\n    let consonant_index = consonants.indexOf(consonants.last());\n    let vowel_index = consonant_index + 1;\n    if (vowel_index >= vowels.length) {\n        return \"\"\n    }\n    return vowels[vowel_index]\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp_sr171x_.rs:17:44\n   |\n17 |     let consonants = word.chars().filter(c => c != \" \").to_list();\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpzqt79prf.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpzqt79prf.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpzqt79prf.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpzqt79prf.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpzqt79prf.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let vowels_index = 0;\n    let consonants_index = 0;\n    let result = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        if (vowels.contains(word[i])) {\n            vowels_count += 1;\n            vowels_index = i;\n        } else if (consonants.contains(word[i])) {\n            consonants_count += 1;\n            consonants_index = i;\n        }\n    }\n    if (vowels_count == 0 || consonants_count == 0) {\n        return \"\";\n    }\n    if (vowels_count == 1) {\n        return word[vowels_index];\n    }\n    if (vowels_count == 2) {\n        if (vowels_index - 1 >= 0 && consonants_index - 1 >= 0) {\n            if (word[vowels_index - 1] == word[vowels_index]) {\n                return word[vowels_index];\n            }\n        }\n        if (vowels_index + 1 < word.length() && consonants_index + 1 < word.length()) {\n            if (word[vowels_index + 1] == word[vowels_index]) {\n                return word[vowels_index];\n            }\n        }\n    }\n    if (vowels_count == 3) {\n        if (vowels_index - 2 >= 0 && consonants_index - 1 >= 0) {\n            if (word[vowels_index - 2] == word[vowels_index]) {\n                return word[vow\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpt03lad8b.rs:71:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n50 |     if (vowels_count == 3) {\n   |                            - unclosed delimiter\n51 |         if (vowels_index - 2 >= 0 && consonants_index - 1 >= 0) {\n   |                                                                 - unclosed delimiter\n52 |             if (word[vowels_index - 2] == word[vowels_index]) {\n   |                                                               - this delimiter might not be properly closed...\n53 |                 return word[vow\n54 | }\n   | - ...as it matches this but it has different indentation\n...\n71 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpt03lad8b.rs:23:10\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpt03lad8b.rs:23:14\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpt03lad8b.rs:23:16\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpt03lad8b.rs:23:15\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpt03lad8b.rs:23:16\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpt03lad8b.rs:53:28\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n53 |                 return word[vow\n   |                ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n    let consonant_index = consonants.indexOf(word.chars().find(c => !vowels.includes(c)));\n    if (consonant_index === -1) {\n        return \"\"\n    }\n    let vowel_index = consonants[consonant_index + 1].indexOf(word.chars().find(c => !vowels.includes(c))) + 1;\n    return word.chars().slice(vowel_index, consonant_index + 1).join(\"\");\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpnbplg9kk.rs:17:44\n   |\n17 |     let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpey7we3g0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpey7we3g0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpey7we3g0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpey7we3g0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpey7we3g0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpvo78eavm.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpvo78eavm.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvo78eavm.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvo78eavm.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvo78eavm.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpvo78eavm.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpvo78eavm.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let vowels_index = 0;\n    let consonants_index = 0;\n    let result = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        if (vowels.indexOf(word[i]) !== -1) {\n            vowels_count += 1;\n            vowels_index = i;\n        } else if (consonants.indexOf(word[i]) !== -1) {\n            consonants_count += 1;\n            consonants_index = i;\n        }\n    }\n    if (vowels_count === 0 || consonants_count === 0) {\n        return \"\";\n    }\n    if (vowels_count > consonants_count) {\n        result = word[vowels_index + 1];\n    } else {\n        result = word[consonants_index + 1];\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpa71xa020.rs:23:10\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpa71xa020.rs:23:14\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpa71xa020.rs:23:16\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpa71xa020.rs:23:15\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpa71xa020.rs:23:16\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        if (vowels.indexOf(word[i]) > -1) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.indexOf(word[i]) > -1) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmprbps9euc.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmprbps9euc.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmprbps9euc.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmprbps9euc.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmprbps9euc.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else if (vowel_index - consonant_index == 1) {\n        return vowels[vowel_index]\n    } else {\n        return vowels[vowel_index - 1]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkf8tchcb.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkf8tchcb.rs:22:15\n   |\n22 |     } else if (vowel_index - consonant_index == 1) {\n   |               ^                                  ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index - consonant_index == 1) {\n22 +     } else if vowel_index - consonant_index == 1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpkf8tchcb.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpkf8tchcb.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpkf8tchcb.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index_plus_one = consonant_index + 1;\n    let vowel_index_plus_one = vowel_index + 1;\n    let consonant_count_plus_one = consonant_count + 1;\n    let vowel_count_plus_one = vowel_count + 1;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index_plus_one) {\n            consonant_count_plus_one += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index_plus_one) {\n            vowel_count_plus_one += 1;\n        }\n    }\n    if (consonant_count_plus_one == 0 || vowel_count_plus_one == 0) {\n        return \"\";\n    }\n    let consonant_index_minus_one = consonant_index - 1;\n    let vowel_index_minus_one\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmph6mnk7r3.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmph6mnk7r3.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmph6mnk7r3.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmph6mnk7r3.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmph6mnk7r3.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmph6mnk7r3.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmph6mnk7r3.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else if (vowel_index - consonant_index == 1) {\n        return vowels[vowel_index]\n    } else {\n        return vowels[vowel_index - 1]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkf8tchcb.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkf8tchcb.rs:22:15\n   |\n22 |     } else if (vowel_index - consonant_index == 1) {\n   |               ^                                  ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index - consonant_index == 1) {\n22 +     } else if vowel_index - consonant_index == 1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpkf8tchcb.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpkf8tchcb.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpkf8tchcb.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (consonant_count == 0) {\n        return word[word.length - 1];\n    }\n    let closest_vowel = \"\";\n    let closest_distance = 99999;\n    for (let i = 0; i < vowels.length; i++) {\n        let distance = Math.abs(vowels.indexOf(word[word.length - 1]) - i);\n        if (distance < closest_distance) {\n            closest_vowel = vowels[i];\n            closest_distance = distance;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpwx87x5kv.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpwx87x5kv.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpwx87x5kv.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpwx87x5kv.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpwx87x5kv.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpwx87x5kv.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwx87x5kv.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .map(c => c.toLowerCase())\n        .filter(c => c != \"a\" && c != \"e\" && c != \"i\" && c != \"o\" && c != \"u\");\n    let consonant_index = consonants.indexOf(consonants.last());\n    let vowel_index = consonants.indexOf(vowels.last());\n    let vowel = vowels[vowel_index];\n    let consonant = consonants[consonant_index];\n    if (vowel_index > consonant_index) {\n        return vowel;\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpv6n3o1ri.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count > vowel_count) {\n        return vowels[vowel_index + 1];\n    } else if (consonant_count < vowel_count) {\n        return vowels[vowel_index - 1];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpd1yv87dd.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpd1yv87dd.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpd1yv87dd.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpd1yv87dd.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpd1yv87dd.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpd1yv87dd.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpd1yv87dd.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index >= 0 && consonant_index >= 0) {\n        let consonant_index_plus_1 = consonant_index + 1;\n        let vowel_index_plus_1 = vowel_index + 1;\n        if (vowel_index_plus_1 < word.length) {\n            return word[vowel_index_plus_1];\n        } else if (consonant_index_plus_1 < word.length) {\n            return word[consonant_index_plus_1];\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmch10i8t.rs:20:8\n   |\n20 |     if (vowel_index >= 0 && consonant_index >= 0) {\n   |        ^                                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index >= 0 && consonant_index >= 0) {\n20 +     if vowel_index >= 0 && consonant_index >= 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmch10i8t.rs:23:12\n   |\n23 |         if (vowel_index_plus_1 < word.length) {\n   |            ^                                ^\n   |\nhelp: remove these parentheses\n   |\n23 -         if (vowel_index_plus_1 < word.length) {\n23 +         if vowel_index_plus_1 < word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmch10i8t.rs:25:19\n   |\n25 |         } else if (consonant_index_plus_1 < word.length) {\n   |                   ^                                    ^\n   |\nhelp: remove these parentheses\n   |\n25 -         } else if (consonant_index_plus_1 < word.length) {\n25 +         } else if consonant_index_plus_1 < word.length {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpmch10i8t.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpmch10i8t.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as In",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .filter(c => vowels.indexOf(c) == -1)\n        .map(c => c.toLowerCase())\n        .sort();\n    let consonant_index = consonants.indexOf(\"a\");\n    let vowel_index = consonants.indexOf(\"a\", consonant_index + 1);\n    if (vowel_index == -1) {\n        return \"\";\n    } else {\n        return vowels[vowel_index];\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp5bxrzg1q.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (consonant_index < 0 || vowel_index < 0) {\n        return \"\"\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (consonant_index_plus_1 >= word.length || vowel_index_plus_1 >= word.length) {\n        return \"\"\n    }\n    let consonant_index_plus_2 = consonant_index_plus_1 + 1;\n    let vowel_index_plus_2 = vowel_index_plus_1 + 1;\n    if (consonant_index_plus_2 >= word.length || vowel_index_plus_2 >= word.length) {\n        return \"\"\n    }\n    if (vowels.indexOf(word[consonant_index_plus_1]) >= 0 && vowels.indexOf(word[vowel_index_plus_1]) >= 0) {\n        return word[consonant_index_plus_1]\n    } else if (vowels.indexOf(word[consonant_index_plus_2]) >= 0 && vowels.indexOf(word[vowel_index_plus_2]) >= 0) {\n        return word[consonant_index_plus_2]\n    } else {\n        return \"\"\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_medjyrr.rs:20:8\n   |\n20 |     if (consonant_index < 0 || vowel_index < 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (consonant_index < 0 || vowel_index < 0) {\n20 +     if consonant_index < 0 || vowel_index < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_medjyrr.rs:25:8\n   |\n25 |     if (consonant_index_plus_1 >= word.length || vowel_index_plus_1 >= word.length) {\n   |        ^                                                                          ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (consonant_index_plus_1 >= word.length || vowel_index_plus_1 >= word.length) {\n25 +     if consonant_index_plus_1 >= word.length || vowel_index_plus_1 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_medjyrr.rs:30:8\n   |\n30 |     if (consonant_index_plus_2 >= word.length || vowel_index_plus_2 >= word.length) {\n   |        ^                                                                          ^\n   |\nhelp: remove these parentheses\n   |\n30 -     if (consonant_index_plus_2 >= word.length || vowel_index_plus_2 >= word.length) {\n30 +     if consonant_index_plus_2 >= word.length || vowel_index_plus_2 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_medjyrr.rs:33:8\n   |\n33 |     if (vowels.indexOf(word[consonant_index_plus_1]) >= 0 && vowels.indexOf(word[vowel_index_plus_1]) >= 0) {\n   |        ^                                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n33 -     if (vowels.indexOf(word[consonant_index_plus_1]) >= 0 && vowels.indexOf(word[vowel_index_plus_1]) >= 0) {\n33 +     if vowels.indexOf(word[consonant_index_plus_1]) >= 0 && vowels.indexOf(word[vowel_index_plus_1]) >= 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > -1) {\n            vowel_count += 1;\n        }\n        if (vowel_count == 2) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpejezq5o9.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpejezq5o9.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpejezq5o9.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpejezq5o9.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpejezq5o9.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpejezq5o9.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpejezq5o9.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => !vowels.includes(c))\n        .map(c => c.toLowerCase())\n        .sort();\n    let consonant_index = consonants.indexOf(word.toLowerCase());\n    if (consonant_index === -1) {\n        return \"\";\n    }\n    let vowel_index = consonant_index + 1;\n    if (vowel_index >= word.length) {\n        return \"\";\n    }\n    return vowels[vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpniet7dai.rs:18:19\n   |\n18 |         .filter(c => !vowels.includes(c))\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let closest_vowel = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpsdwa8axd.rs:21:10\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpsdwa8axd.rs:21:14\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpsdwa8axd.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpsdwa8axd.rs:21:15\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpsdwa8axd.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < consonant_index) {\n        return word[word.length - 1];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3o4ekc5d.rs:20:8\n   |\n20 |     if (vowel_index < consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < consonant_index) {\n20 +     if vowel_index < consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp3o4ekc5d.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp3o4ekc5d.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmp3o4ekc5d.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp3o4ekc5d.rs:19:48\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                                                ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp3o4ekc5d.rs:21:26\n   |\n21 |         return word[word.length - 1];\n   |                          ^^^^^^ unknown ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) >\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp51wd9lc9.rs:68:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n49 |     for (let i = 0; i < word.length - 1; i++) {\n   |                                               - this delimiter might not be properly closed...\n50 |         if (consonants.indexOf(word[i]) >\n51 | }\n   | - ...as it matches this but it has different indentation\n...\n68 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmp51wd9lc9.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp51wd9lc9.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp51wd9lc9.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp51wd9lc9.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp51wd9lc9.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp51wd9lc9.rs:50:12\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n50 |         if (consonants.indexOf(word[i]) >\n   |            ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp51wd9lc9.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpey7we3g0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpey7we3g0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpey7we3g0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpey7we3g0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpey7we3g0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\n        \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"\n    ];\n    let consonants = word.chars().filter(c => c !== \" \").to_list();\n    let consonant_index = consonants.indexOf(word.chars().find(c => c !== \" \"));\n    let vowel_index = consonants[consonant_index + 1].indexOf(word.chars().find(c => c !== \" \"));\n    if (vowel_index === -1) {\n        return \"\";\n    }\n    return vowels[vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpyzfde4lj.rs:19:44\n   |\n19 |     let consonants = word.chars().filter(c => c !== \" \").to_list();\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    if (vowel_index > -1 && consonant_index > -1) {\n        let right_side_vowel = word[word.length - 1];\n        let right_side_vowel_index = vowels.indexOf(right_side_vowel);\n        let right_side_vowel_count = 0;\n        for (let i = consonant_index + 1; i < word.length; i++) {\n            if (vowels.indexOf(word[i]) > -1) {\n                right_side_vowel_count += 1;\n            }\n        }\n        if (right_side_vowel_count > 0) {\n            let left_side_vowel = word[0];\n            let left_side_vowel_index = vowels.indexOf(left_side_vowel);\n            let left_side_vowel_count = 0;\n            for (let i = 0; i < consonant_index; i++) {\n                if (vowels.indexOf(word[i]) > -1) {\n                    left_side_vowel_count += 1;\n                }\n            }\n            if (left_side_vowel_count > 0 && right_side_vowel_count > 0) {\n                if (left_side_vowel_index > right_side_vowel_index) {\n                    closest_vowel = left_side_v\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzj9tc_sy.rs:61:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n23 |     if (vowel_index > -1 && consonant_index > -1) {\n   |                                                   - unclosed delimiter\n...\n32 |         if (right_side_vowel_count > 0) {\n   |                                         - unclosed delimiter\n...\n41 |             if (left_side_vowel_count > 0 && right_side_vowel_count > 0) {\n   |                                                                          - unclosed delimiter\n42 |                 if (left_side_vowel_index > right_side_vowel_index) {\n   |                                                                     - this delimiter might not be properly closed...\n43 |                     closest_vowel = left_side_v\n44 | }\n   | - ...as it matches this but it has different indentation\n...\n61 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpzj9tc_sy.rs:27:14\n   |\n27 |         for (let i = consonant_index + 1; i < word.length; i++) {\n   |              ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpzj9tc_sy.rs:27:18\n   |\n27 |         for (let i = consonant_index + 1; i < word.length; i++) {\n   |                 -^ expected one of `)`, `,`, `@`, or `|`\n   |                 |\n   |                 help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpzj9tc_sy.rs:27:20\n   |\n27 |         for (let i = consonant_index + 1; i < word.length; i++) {\n   |                    ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpzj9tc_sy.rs:27:19\n   |\n27 |         for (let i = consonant_index + 1; i < word.length; i++) {\n   |                   ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpzj9tc_sy.rs:27:20\n   |\n27 |         for (let i = consonant_index + 1; i < word.length",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_index_next = consonants.indexOf(word[1]);\n    let vowel_index_next = vowels.indexOf(word[word.length - 2]);\n    if (vowel_index == -1 || vowel_index_next == -1 || consonant_index_next == -1) {\n        return \"\"\n    }\n    if (vowel_index < vowel_index_next) {\n        return vowels[vowel_index + 1]\n    } else {\n        return vowels[vowel_index_next + 1]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmped1__4x0.rs:22:8\n   |\n22 |     if (vowel_index == -1 || vowel_index_next == -1 || consonant_index_next == -1) {\n   |        ^                                                                         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -     if (vowel_index == -1 || vowel_index_next == -1 || consonant_index_next == -1) {\n22 +     if vowel_index == -1 || vowel_index_next == -1 || consonant_index_next == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmped1__4x0.rs:25:8\n   |\n25 |     if (vowel_index < vowel_index_next) {\n   |        ^                              ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_index < vowel_index_next) {\n25 +     if vowel_index < vowel_index_next {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmped1__4x0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmped1__4x0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmped1__4x0.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let consonant_index = 0;\n    let vowel_index = 0;\n    let result = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        let letter = word[i];\n        if (vowels.indexOf(letter) >= 0) {\n            vowel_count += 1;\n            vowel_index = i;\n        } else if (consonants.indexOf(letter) >= 0) {\n            consonant_count += 1;\n            consonant_index = i;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (consonant_count == 0) {\n        return word[vowel_index + 1];\n    }\n    for (let i = vowel_index + 1; i < word.length(); i++) {\n        let letter = word[i];\n        if (vowels.indexOf(letter) >= 0) {\n            result = letter;\n            break;\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp_sfngj2v.rs:23:10\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp_sfngj2v.rs:23:14\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp_sfngj2v.rs:23:16\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp_sfngj2v.rs:23:15\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp_sfngj2v.rs:23:16\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index >= 0 && consonant_index >= 0) {\n        let consonant_index_plus_1 = consonants.indexOf(word[consonant_index + 1]);\n        if (consonant_index_plus_1 >= 0) {\n            return vowels[vowel_index + 1];\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo1swccs9.rs:20:8\n   |\n20 |     if (vowel_index >= 0 && consonant_index >= 0) {\n   |        ^                                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index >= 0 && consonant_index >= 0) {\n20 +     if vowel_index >= 0 && consonant_index >= 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo1swccs9.rs:22:12\n   |\n22 |         if (consonant_index_plus_1 >= 0) {\n   |            ^                           ^\n   |\nhelp: remove these parentheses\n   |\n22 -         if (consonant_index_plus_1 >= 0) {\n22 +         if consonant_index_plus_1 >= 0 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpo1swccs9.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpo1swccs9.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpo1swccs9.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `leng",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n        if (vowel_count == 1 && consonant_count == 0) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpcpqgkggw.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpcpqgkggw.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpcpqgkggw.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcpqgkggw.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpcpqgkggw.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpcpqgkggw.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpcpqgkggw.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (consonant_count == 0) {\n        return word[word.length - 1];\n    }\n    let closest_vowel = \"\";\n    for (let i = 0; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpku2evggh.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpku2evggh.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpku2evggh.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpku2evggh.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpku2evggh.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpku2evggh.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpku2evggh.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else if (vowel_index - consonant_index == 1) {\n        return vowels[vowel_index]\n    } else {\n        return vowels[vowel_index - 1]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprv8vudf6.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprv8vudf6.rs:22:15\n   |\n22 |     } else if (vowel_index - consonant_index == 1) {\n   |               ^                                  ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index - consonant_index == 1) {\n22 +     } else if vowel_index - consonant_index == 1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmprv8vudf6.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmprv8vudf6.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmprv8vudf6.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[1]);\n   |                              ^^^^^^^ method not found in `[&str;",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1 - consonant_index;\n    let vowel_count = word.length - 1 - vowel_index;\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    let consonant_index_plus_2 = consonant_index + 2;\n    let vowel_index_plus_2 = vowel_index + 2;\n    let consonant_index_plus_3 = consonant_index + 3;\n    let vowel_index_plus_3 = vowel_index + 3;\n    let consonant_index_plus_4 = consonant_index + 4;\n    let vowel_index_plus_4 = vowel_index + 4;\n    let consonant_index_plus_5 = consonant_index + 5;\n    let vowel_index_plus_5 = vowel_index + 5;\n    let consonant_index_plus_6 = consonant_index + 6;\n    let vowel_index_plus_6 = vowel_index + 6;\n    let consonant_index_plus_7 = consonant_index + 7;\n    let vowel_index_plus_7 = vowel_index + 7;\n    let consonant_index_plus_8 = consonant_index + 8;\n    let vowel_index_plus_8 = vowel_index + 8;\n    let consonant_index_plus_9 = consonant_index + 9;\n    let vowel_index_plus_9 = vowel_index + 9;\n    let consonant_index_plus_10 = consonant_index + 10;\n    let\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmp9hx9zndo.rs:42:1\n   |\n42 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp9hx9zndo.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp9hx9zndo.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmp9hx9zndo.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp9hx9zndo.rs:19:48\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                                                ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp9hx9zndo.rs:20:32\n   |\n20 |     let consonant_count = word.length - 1 - consonant_index;\n   |                                ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp9hx9zndo.rs:21:28\n   |\n21 |     let vowel_count = word.length - 1 - vowel_index;\n   |                            ^^^^^^ unknown field\n\nerror: aborting due to 7 previou",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [String::from(\"a\"), String::from(\"e\"), String::from(\"i\"), String::from(\"o\"), String::from(\"u\")];\n    let consonants = word.chars().filter(c => c != \" \").map(c => String::from(c)).to_list();\n    let consonant_index = consonants.indexOf(word.chars().find(c => c != \" \"));\n    if (consonant_index == -1) {\n        return String::from(\"\");\n    }\n    let vowel_index = consonants[consonant_index + 1].indexOf(word.chars().find(c => c != \" \"));\n    if (vowel_index == -1) {\n        return String::from(\"\");\n    }\n    let vowel = vowels[vowel_index];\n    return vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmplp_0dml2.rs:17:44\n   |\n17 |     let consonants = word.chars().filter(c => c != \" \").map(c => String::from(c)).to_list();\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpey7we3g0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpey7we3g0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpey7we3g0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpey7we3g0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpey7we3g0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < 0 || consonant_index < 0) {\n        return \"\";\n    }\n    let consonant_index_next = consonants.indexOf(word[1]);\n    if (consonant_index_next < 0) {\n        return \"\";\n    }\n    let vowel_index_next = vowels.indexOf(word[word.length - 2]);\n    if (vowel_index_next < 0) {\n        return \"\";\n    }\n    let consonant_index_prev = consonants.indexOf(word[word.length - 3]);\n    if (consonant_index_prev < 0) {\n        return \"\";\n    }\n    let vowel_index_prev = vowels.indexOf(word[word.length - 4]);\n    if (vowel_index_prev < 0) {\n        return \"\";\n    }\n    let consonant_index_prev_next = consonants.indexOf(word[word.length - 5]);\n    if (consonant_index_prev_next < 0) {\n        return \"\";\n    }\n    let vowel_index_prev_next = vowels.indexOf(word[word.length - 6]);\n    if (vowel_index_prev_next < 0) {\n        return \"\";\n    }\n    let consonant_index_next_next = consonants.indexOf(word[word.length - 7]);\n    if (consonant_index_next_next < 0) {\n        return \"\";\n    }\n    let vowel_index_next_next = vowels.indexOf(word[word\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmp2l9jjg2g.rs:52:1\n   |\n52 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp2l9jjg2g.rs:51:52\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n51 |     let vowel_index_next_next = vowels.indexOf(word[word\n   |                                                    ^ unclosed delimiter\n52 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2l9jjg2g.rs:20:8\n   |\n20 |     if (vowel_index < 0 || consonant_index < 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < 0 || consonant_index < 0) {\n20 +     if vowel_index < 0 || consonant_index < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2l9jjg2g.rs:24:8\n   |\n24 |     if (consonant_index_next < 0) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (consonant_index_next < 0) {\n24 +     if consonant_index_next < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2l9jjg2g.rs:28:8\n   |\n28 |     if (vowel_index_next < 0) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index_next < 0) {\n28 +     if vowel_index_next < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2l9jjg2g.rs:32:8\n   |\n32 |     if (consonant_index_prev < 0) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (consonant_index_prev < 0) {\n32 +     if consonant_index_prev < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2l9jjg2g.rs:36:8\n   |\n36 |     if (vowel_index_prev < 0) {\n   |        ^                    ^\n   |\nhelp: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count > vowel_count) {\n        return vowels[vowel_count - 1];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmphmhp9co6.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmphmhp9co6.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmphmhp9co6.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmphmhp9co6.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmphmhp9co6.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmphmhp9co6.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmphmhp9co6.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.split(\"\").filter(c => !vowels.includes(c));\n    let consonant_index = consonants.indexOf(consonants.last());\n    let vowel_index = consonants.indexOf(consonants[consonant_index + 1]);\n    return vowels[vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpelm2n_h8.rs:17:46\n   |\n17 |     let consonants = word.split(\"\").filter(c => !vowels.includes(c));\n   |                                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) >= 0) {\n            vowel_count += 1;\n        } else if (consonants.indexOf(word[i]) >= 0) {\n            consonant_count += 1;\n        }\n        if (vowel_count > 0 && consonant_count > 0) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp6oun6fze.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp6oun6fze.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp6oun6fze.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp6oun6fze.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp6oun6fze.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp6oun6fze.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp6oun6fze.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.split(\"\").filter(c => c !== \"\")\n        .map(c => c.toLowerCase())\n        .filter(c => vowels.indexOf(c) === -1);\n    let consonant_index = consonants.length - 1;\n    let vowel_index = consonants.length - 1;\n    while (vowel_index >= 0 && consonant_index >= 0) {\n        if (vowels.indexOf(consonants[consonant_index]) !== -1) {\n            vowel_index--;\n        } else {\n            consonant_index--;\n        }\n    }\n    return vowels[vowel_index + 1];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpbis5kgpy.rs:17:46\n   |\n17 |     let consonants = word.split(\"\").filter(c => c !== \"\")\n   |                                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for i in word.chars() {\n        if (vowels.contains(i)) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                result = i;\n                break;\n            }\n        } else if (consonants.contains(i)) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                result = i;\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7t7640lz.rs:22:12\n   |\n22 |         if (vowels.contains(i)) {\n   |            ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -         if (vowels.contains(i)) {\n22 +         if vowels.contains(i) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7t7640lz.rs:24:16\n   |\n24 |             if (vowels_count > 1) {\n   |                ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -             if (vowels_count > 1) {\n24 +             if vowels_count > 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7t7640lz.rs:28:19\n   |\n28 |         } else if (consonants.contains(i)) {\n   |                   ^                      ^\n   |\nhelp: remove these parentheses\n   |\n28 -         } else if (consonants.contains(i)) {\n28 +         } else if consonants.contains(i) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7t7640lz.rs:30:16\n   |\n30 |             if (consonants_count > 1) {\n   |                ^                    ^\n   |\nhelp: remove these parentheses\n   |\n30 -             if (consonants_count > 1) {\n30 +             if consonants_count > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7t7640lz.rs:25:26\n   |\n20 |     let result = \"\";\n   |                  -- expected due to this value\n...\n25 |                 result = i;\n   |                          ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7t7640lz.rs:31:26\n   |\n20 |     let result = \"\";\n   |                  -- expected due to this value\n...\n31 |                 result = i;\n   |                          ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7t7640lz.rs:36:12\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                       ------ expected `String` because of return type\n...\n36 |     return result;\n   |            ^^^^^^-",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n    let consonant_index = consonants.indexOf(word.chars().find(c => !vowels.includes(c)));\n    let vowel = consonants[consonant_index + 1];\n    return vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp7em604lt.rs:17:44\n   |\n17 |     let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpey7we3g0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpey7we3g0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpey7we3g0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpey7we3g0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpey7we3g0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1 - consonant_index;\n    let vowel_count = word.length - 1 - vowel_index;\n    let result = \"\";\n    if (vowel_count > 0 && consonant_count > 0) {\n        let consonant_index = consonants.indexOf(word[0]);\n        let vowel_index = vowels.indexOf(word[word.length - 1]);\n        let consonant_count = word.length - 1 - consonant_index;\n        let vowel_count = word.length - 1 - vowel_index;\n        let consonant_index = consonants.indexOf(word[0]);\n        let vowel_index = vowels.indexOf(word[word.length - 1]);\n        let consonant_count = word.length - 1 - consonant_index;\n        let vowel_count = word.length - 1 - vowel_index;\n        let consonant_index = consonants.indexOf(word[0]);\n        let vowel_index = vowels.indexOf(word[word.length - 1]);\n        let consonant_count = word.length - 1 - consonant_index;\n        let vowel_count = word.length - 1 - vowel_index;\n        let consonant_index = consonants.indexOf(word[0]);\n        let vowel_index = vowels.indexOf(word[word.length - 1]);\n        let consonant_count = word.length - 1 - consonant_index;\n        let vowel_count = word.length - 1 - vowel_index;\n        let consonant_index = consonants.indexOf(word[0]);\n\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpiggeldjn.rs:59:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n23 |     if (vowel_count > 0 && consonant_count > 0) {\n   |                                                 - this delimiter might not be properly closed...\n...\n42 | }\n   | - ...as it matches this but it has different indentation\n...\n59 | }\n   |   ^\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiggeldjn.rs:23:8\n   |\n23 |     if (vowel_count > 0 && consonant_count > 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n23 -     if (vowel_count > 0 && consonant_count > 0) {\n23 +     if vowel_count > 0 && consonant_count > 0 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpiggeldjn.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpiggeldjn.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpiggeldjn.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(w",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = consonants.length - 1 - consonant_index;\n    let vowel_count = vowels.length - 1 - vowel_index;\n    if (vowel_count < consonant_count) {\n        return word[0];\n    } else if (vowel_count > consonant_count) {\n        return word[word.length - 1];\n    } else {\n        return word[1];\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpumebroh3.rs:22:8\n   |\n22 |     if (vowel_count < consonant_count) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -     if (vowel_count < consonant_count) {\n22 +     if vowel_count < consonant_count {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpumebroh3.rs:24:15\n   |\n24 |     } else if (vowel_count > consonant_count) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n24 -     } else if (vowel_count > consonant_count) {\n24 +     } else if vowel_count > consonant_count {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpumebroh3.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpumebroh3.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpumebroh3.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  -",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        } else {\n            consonant_count = 0;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        } else {\n            vowel_count = 0;\n        }\n        if (consonant_count > 1 && vowel_count > 1) {\n            return word[i];\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpajx6qyux.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpajx6qyux.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpajx6qyux.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpajx6qyux.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpajx6qyux.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpajx6qyux.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpajx6qyux.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[1]);\n    let consonant_count = consonants.length - 1;\n    let vowel_count = vowels.length - 1;\n    let closest_vowel = \"\";\n    if (vowel_index > consonant_index) {\n        closest_vowel = vowels[vowel_index + 1];\n    } else if (vowel_index < consonant_index) {\n        closest_vowel = vowels[vowel_index - 1];\n    } else if (vowel_index == consonant_index) {\n        if (vowel_count > consonant_count) {\n            closest_vowel = vowels[vowel_index + 1];\n        } else if (vowel_count < consonant_count) {\n            closest_vowel = vowels[vowel_index - 1];\n        } else {\n            closest_vowel = \"\";\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuwmjym7w.rs:23:8\n   |\n23 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n23 -     if (vowel_index > consonant_index) {\n23 +     if vowel_index > consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuwmjym7w.rs:25:15\n   |\n25 |     } else if (vowel_index < consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n25 -     } else if (vowel_index < consonant_index) {\n25 +     } else if vowel_index < consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuwmjym7w.rs:27:15\n   |\n27 |     } else if (vowel_index == consonant_index) {\n   |               ^                              ^\n   |\nhelp: remove these parentheses\n   |\n27 -     } else if (vowel_index == consonant_index) {\n27 +     } else if vowel_index == consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuwmjym7w.rs:28:12\n   |\n28 |         if (vowel_count > consonant_count) {\n   |            ^                             ^\n   |\nhelp: remove these parentheses\n   |\n28 -         if (vowel_count > consonant_count) {\n28 +         if vowel_count > consonant_count {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuwmjym7w.rs:30:19\n   |\n30 |         } else if (vowel_count < consonant_count) {\n   |                   ^                             ^\n   |\nhelp: remove these parentheses\n   |\n30 -         } else if (vowel_count < consonant_count) {\n30 +         } else if vowel_count < consonant_count {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpuwmjym7w.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < 0 || consonant_index < 0) {\n        return \"\"\n    }\n    let consonant_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) >= 0) {\n            consonant_count += 1\n        }\n    }\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) >= 0) {\n            vowel_count += 1\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\"\n    }\n    let consonant_index_plus = consonant_index + 1;\n    let vowel_index_plus = vowel_index + 1;\n    if (consonant_index_plus >= word.length - 1 || vowel_index_plus >= word.length - 1) {\n        return \"\"\n    }\n    let consonant_count_plus = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) >= 0) {\n            consonant_count_plus += 1\n        }\n    }\n    let vowel_count_plus = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) >= 0) {\n            vowel_count_plus += 1\n        }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbiv63gm6.rs:71:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n50 |     for (let i = 0; i < word.length - 1; i++) {\n   |                                               - this delimiter might not be properly closed...\n...\n54 | }\n   | - ...as it matches this but it has different indentation\n...\n71 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpbiv63gm6.rs:24:10\n   |\n24 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpbiv63gm6.rs:24:14\n   |\n24 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpbiv63gm6.rs:24:16\n   |\n24 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpbiv63gm6.rs:24:15\n   |\n24 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpbiv63gm6.rs:24:16\n   |\n24 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbiv63gm6.rs:20:8\n   |\n20 |     if (vowel_index < 0 || consonant_index < 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < 0 || consonant_index < 0) {\n20 +     if vowel_index < 0 || consonant_index < 0 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpbiv63gm6.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (consonant_count == 0) {\n        return word[word.length - 1];\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (consonant_count == 0) {\n        return word[0];\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.index\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp_ap8fszd.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp_ap8fszd.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp_ap8fszd.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp_ap8fszd.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp_ap8fszd.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp_ap8fszd.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_ap8fszd.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .filter(c => !vowels.includes(c))\n        .map(c => c.toLowerCase())\n        .sort();\n    let consonant_index = consonants.indexOf(consonants.last());\n    if (consonant_index == -1) {\n        return \"\";\n    }\n    let vowel_index = consonant_index + 1;\n    if (vowel_index == word.length()) {\n        return \"\";\n    }\n    return vowels[vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpp30sml_k.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                break;\n            }\n            result = word[i];\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp7rv42lj4.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp7rv42lj4.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp7rv42lj4.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp7rv42lj4.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp7rv42lj4.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index === -1 || consonant_index === -1) {\n        return \"\";\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (vowel_index_plus_1 === vowels.length) {\n        return \"\";\n    }\n    if (vowel_index_plus_1 === consonant_index_plus_1) {\n        return vowels[vowel_index_plus_1];\n    }\n    return vowels[vowel_index_plus_1];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: invalid comparison operator `===`\n  --> /tmp/tmpn1w2x0hi.rs:20:21\n   |\n20 |     if (vowel_index === -1 || consonant_index === -1) {\n   |                     ^^^ help: `===` is not a valid comparison operator, use `==`\n\nerror: invalid comparison operator `===`\n  --> /tmp/tmpn1w2x0hi.rs:20:47\n   |\n20 |     if (vowel_index === -1 || consonant_index === -1) {\n   |                                               ^^^ help: `===` is not a valid comparison operator, use `==`\n\nerror: invalid comparison operator `===`\n  --> /tmp/tmpn1w2x0hi.rs:25:28\n   |\n25 |     if (vowel_index_plus_1 === vowels.length) {\n   |                            ^^^ help: `===` is not a valid comparison operator, use `==`\n\nerror: invalid comparison operator `===`\n  --> /tmp/tmpn1w2x0hi.rs:28:28\n   |\n28 |     if (vowel_index_plus_1 === consonant_index_plus_1) {\n   |                            ^^^ help: `===` is not a valid comparison operator, use `==`\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn1w2x0hi.rs:20:8\n   |\n20 |     if (vowel_index === -1 || consonant_index === -1) {\n   |        ^                                            ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index === -1 || consonant_index === -1) {\n20 +     if vowel_index === -1 || consonant_index === -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn1w2x0hi.rs:25:8\n   |\n25 |     if (vowel_index_plus_1 === vowels.length) {\n   |        ^                                    ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_index_plus_1 === vowels.length) {\n25 +     if vowel_index_plus_1 === vowels.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn1w2x0hi.rs:28:8\n   |\n28 |     if (vowel_index_plus_1 === consonant_index_plus_1) {\n   |        ^                                             ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index_plus_1 === consonant_index_plus_1) {\n28 +     if vowel_i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index_plus = consonant_index + 1;\n    let vowel_index_plus = vowel_index + 1;\n    if (consonant_index_plus == word.length - 1) {\n        return \"\";\n    }\n    if (vowel_index_plus == word.length - 1) {\n        return vowels[vowel_index_plus];\n    }\n    let consonant_count_plus = 0;\n    let vowel_count_plus = 0;\n    for (let i = word.length - 2; i >= 0; i--) {\n        if (consonants.indexOf(word[i]) > consonant_index_plus) {\n            consonant_count_plus += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index_plus) {\n            vowel_count_plus += 1;\n        }\n    }\n    if (consonant_count_plus == 0 || vowel_count_plus == 0) {\n        return \"\";\n    }\n    let consonant_index_minus = consonant_index - 1;\n    let vowel_index_minus = vowel_index - 1;\n    if (cons\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpmc66jckm.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpmc66jckm.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpmc66jckm.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpmc66jckm.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpmc66jckm.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpmc66jckm.rs:56:8\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n56 |     if (cons\n   |        ^ unclosed delimiter\n57 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for reference `&str` in the current scope\n  --> /tmp/tmpmc66jckm.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `&str`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpmc66jckm.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n      ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpzqt79prf.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpzqt79prf.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpzqt79prf.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpzqt79prf.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpzqt79prf.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpaoc0gw2k.rs:21:10\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpaoc0gw2k.rs:21:14\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpaoc0gw2k.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpaoc0gw2k.rs:21:15\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpaoc0gw2k.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_index) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_index) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp46mgsz10.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp46mgsz10.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp46mgsz10.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp46mgsz10.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp46mgsz10.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp46mgsz10.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp46mgsz10.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else if (vowel_index < consonant_index) {\n        return vowels[vowel_index + 1]\n    } else {\n        return vowels[vowel_index - 1]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplmlkyyvs.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplmlkyyvs.rs:22:15\n   |\n22 |     } else if (vowel_index < consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index < consonant_index) {\n22 +     } else if vowel_index < consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmplmlkyyvs.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplmlkyyvs.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmplmlkyyvs.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let closest_vowel = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpsdwa8axd.rs:21:10\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpsdwa8axd.rs:21:14\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpsdwa8axd.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpsdwa8axd.rs:21:15\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpsdwa8axd.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let result = \"\";\n    if (vowel_index > consonant_index) {\n        result = vowels[vowel_index - consonant_index - 1];\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpu7oqjxkl.rs:21:8\n   |\n21 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n21 -     if (vowel_index > consonant_index) {\n21 +     if vowel_index > consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpu7oqjxkl.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpu7oqjxkl.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpu7oqjxkl.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpu7oqjxkl.rs:19:48\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                                                ^^^^^^ unknown field\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu7oqjxkl.rs:24:12\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                       ------ expe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.split(\"\").filter(c => c != \" \");\n    let consonant_index = consonants.findIndex(c => vowels.includes(c));\n    if (consonant_index == -1) {\n        return \"\"\n    }\n    let vowel_index = consonants[consonant_index + 1].findIndex(v => vowels.includes(v));\n    if (vowel_index == -1) {\n        return \"\"\n    }\n    return consonants[consonant_index + 1][vowel_index]\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpaq9qs_9r.rs:17:46\n   |\n17 |     let consonants = word.split(\"\").filter(c => c != \" \");\n   |                                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[1]);\n    if (vowel_index >= 0 && consonant_index >= 0) {\n        let consonant_index_plus_1 = consonants.indexOf(word[2]);\n        if (consonant_index_plus_1 >= 0) {\n            return vowels[vowel_index + 1];\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp5m504ek.rs:20:8\n   |\n20 |     if (vowel_index >= 0 && consonant_index >= 0) {\n   |        ^                                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index >= 0 && consonant_index >= 0) {\n20 +     if vowel_index >= 0 && consonant_index >= 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp5m504ek.rs:22:12\n   |\n22 |         if (consonant_index_plus_1 >= 0) {\n   |            ^                           ^\n   |\nhelp: remove these parentheses\n   |\n22 -         if (consonant_index_plus_1 >= 0) {\n22 +         if consonant_index_plus_1 >= 0 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpp5m504ek.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpp5m504ek.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpp5m504ek.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0277]: the type `String` cannot be ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index > consonant_index) {\n        return word[word.length - 1];\n    } else if (vowel_index < consonant_index) {\n        return word[0];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm8hfyxey.rs:20:8\n   |\n20 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index > consonant_index) {\n20 +     if vowel_index > consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm8hfyxey.rs:22:15\n   |\n22 |     } else if (vowel_index < consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index < consonant_index) {\n22 +     } else if vowel_index < consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpm8hfyxey.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpm8hfyxey.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpm8hfyxey.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  -",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_index_next = consonants.indexOf(word[1]);\n    let vowel_index_next = vowels.indexOf(word[word.length - 2]);\n    if (consonant_index_next >= consonant_index && vowel_index_next >= vowel_index) {\n        return word[1];\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp15yg6nv.rs:22:8\n   |\n22 |     if (consonant_index_next >= consonant_index && vowel_index_next >= vowel_index) {\n   |        ^                                                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -     if (consonant_index_next >= consonant_index && vowel_index_next >= vowel_index) {\n22 +     if consonant_index_next >= consonant_index && vowel_index_next >= vowel_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpp15yg6nv.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpp15yg6nv.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpp15yg6nv.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpp15yg6nv.rs:19:48\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                                                ^^^^^^ unknown f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    if (consonant_count == 0) {\n        closest_vowel = vowels[vowel_index + 1];\n    } else if (vowel_count == 1) {\n        closest_vowel = vowels[vowel_index];\n    } else {\n        let vowel_index_of_consonant = vowels.indexOf(word[consonant_index]);\n        if (vowel_index_of_consonant > vowel_index) {\n            closest_vowel = vowels[vowel_index_of_consonant - 1];\n        } else {\n            closest_vowel = vowels[vowel_index_of_consonant + 1];\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpp8ioptn0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpp8ioptn0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpp8ioptn0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpp8ioptn0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpp8ioptn0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpp8ioptn0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpp8ioptn0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let consonant_index = 0;\n    let vowel_index = 0;\n    let result = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        let c = word[i];\n        if (vowels.indexOf(c) > -1) {\n            vowel_count += 1;\n            if (vowel_count > 1) {\n                return \"\";\n            }\n            vowel_index = i;\n        } else if (consonants.indexOf(c) > -1) {\n            consonant_count += 1;\n            if (consonant_count > 1) {\n                return \"\";\n            }\n            consonant_index = i;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (vowel_index > consonant_index) {\n        result = word[vowel_index];\n    } else {\n        result = word[consonant_index];\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp48b16gtw.rs:23:10\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp48b16gtw.rs:23:14\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp48b16gtw.rs:23:16\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp48b16gtw.rs:23:15\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp48b16gtw.rs:23:16\n   |\n23 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpey7we3g0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpey7we3g0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpey7we3g0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpey7we3g0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpey7we3g0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_index) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_index) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp46mgsz10.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp46mgsz10.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp46mgsz10.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp46mgsz10.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp46mgsz10.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp46mgsz10.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp46mgsz10.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .filter(c => vowels.indexOf(c) == -1)\n        .map(c => c.toLowerCase())\n        .sort();\n    let consonant_index = consonants.indexOf(consonants.last());\n    if (consonant_index == -1) {\n        return \"\";\n    } else {\n        let vowel_index = consonants.indexOf(consonants[consonant_index + 1]);\n        return vowels[vowel_index];\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpvrwg51vl.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n    let consonant_index = consonants.indexOf(word.chars().find(c => !vowels.includes(c)));\n    let vowel_index = consonant_index + 1;\n    if (vowel_index < 0 || vowel_index >= word.length()) {\n        return \"\"\n    }\n    return word.chars()[vowel_index]\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpp35ejtwr.rs:17:44\n   |\n17 |     let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        } else {\n            consonant_count = 0;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        } else {\n            vowel_count = 0;\n        }\n        if (consonant_count == 2 && vowel_count == 1) {\n            return word[i];\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpwbtccyso.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpwbtccyso.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpwbtccyso.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpwbtccyso.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpwbtccyso.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpwbtccyso.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwbtccyso.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count > consonant_count) {\n        return word[word.length - 1];\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpfqtxd8qj.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpfqtxd8qj.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpfqtxd8qj.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpfqtxd8qj.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpfqtxd8qj.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for reference `&str` in the current scope\n  --> /tmp/tmpfqtxd8qj.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `&str`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpfqtxd8qj.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` fo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n    let consonant_index = consonants.indexOf(word.chars().find(c => !vowels.includes(c)));\n    let vowel_index = consonants.indexOf(word.chars().find(c => vowels.includes(c)));\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else {\n        return word.chars()[vowel_index + 1 + consonant_index]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp_tt6r2lv.rs:17:44\n   |\n17 |     let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index > consonant_index) {\n        return word[word.length - 1];\n    }\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            return word[i];\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp0spredvl.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp0spredvl.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp0spredvl.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp0spredvl.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp0spredvl.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0spredvl.rs:20:8\n   |\n20 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index > consonant_index) {\n20 +     if vowel_index > consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp0spredvl.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp0spredvl.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1;\n    let vowel_count = word.length - 1 - consonant_index;\n    let closest_vowel = \"\";\n    if (vowel_count > 0 && vowel_count <= vowel_index) {\n        closest_vowel = vowels[vowel_count];\n    } else if (vowel_count > vowel_index && vowel_count <= consonant_count) {\n        closest_vowel = vowels[vowel_count - 1];\n    } else if (vowel_count > consonant_count) {\n        closest_vowel = vowels[vowel_count - 1];\n    } else if (vowel_count == 0) {\n        closest_vowel = vowels[vowel_count];\n    } else if (vowel_count == 1) {\n        closest_vowel = vowels[vowel_count];\n    } else if (vowel_count == 2) {\n        closest_vowel = vowels[vowel_count];\n    } else if (vowel_count == 3) {\n        closest_vowel = vowels[vowel_count];\n    } else if (vowel_count == 4) {\n        closest_vowel = vowels[vowel_count];\n    } else if (vowel_count == 5) {\n        closest_vowel = vowels[vowel_count];\n    } else if (vowel\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected `{`, found `}`\n  --> /tmp/tmpe6413vy9.rs:42:1\n   |\n41 |     } else if (vowel\n   |            -- this `if` expression has a condition, but no block\n42 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpe6413vy9.rs:41:15\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n41 |     } else if (vowel\n   |               ^ unclosed delimiter\n42 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpe6413vy9.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpe6413vy9.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpe6413vy9.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpe6413vy9.rs:19:48\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                                                ^^^^^^ unknown field\n\nerror[E0609]: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) < consonant_index) {\n            consonant_count += 1;\n        } else if (vowels.indexOf(word[i]) < vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count > vowel_count) {\n        return vowels[vowel_count - 1];\n    } else {\n        return vowels[vowel_count];\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp_4t1oi0q.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp_4t1oi0q.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp_4t1oi0q.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp_4t1oi0q.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp_4t1oi0q.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp_4t1oi0q.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_4t1oi0q.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_index) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_index) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp46mgsz10.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp46mgsz10.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp46mgsz10.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp46mgsz10.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp46mgsz10.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp46mgsz10.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp46mgsz10.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                result = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                result = word[i];\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpyp4vj3za.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpyp4vj3za.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpyp4vj3za.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpyp4vj3za.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpyp4vj3za.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpyp4vj3za.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpyp4vj3za.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpuhg_ck1y.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpuhg_ck1y.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpuhg_ck1y.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpuhg_ck1y.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpuhg_ck1y.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .filter(c => vowels.indexOf(c) == -1);\n    let consonant_index = consonants.indexOf(consonants.last());\n    let vowel = vowels[consonant_index + 1];\n    return vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp2mpglo8g.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0 || consonant_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            if (vowels.indexOf(word[i]) > vowel_index) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpdgamou99.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpdgamou99.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpdgamou99.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpdgamou99.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpdgamou99.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpdgamou99.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpdgamou99.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp1aqd4p0f.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp1aqd4p0f.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp1aqd4p0f.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp1aqd4p0f.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp1aqd4p0f.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp1aqd4p0f.rs:52:9\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n52 |     for (let i = 0;\n   |         ^ unclosed delimiter\n53 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp1aqd4p0f.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp1aqd4p0f.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < vowel_index; i++) {\n        closest_vowel += vowels[i];\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp1r9excjm.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp1r9excjm.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp1r9excjm.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp1r9excjm.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp1r9excjm.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp1r9excjm.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp1r9excjm.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel_index = consonant_index + 1;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel_index = i;\n        }\n    }\n    return word[closest_vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp_qr_r8ve.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp_qr_r8ve.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp_qr_r8ve.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp_qr_r8ve.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp_qr_r8ve.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp_qr_r8ve.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_qr_r8ve.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        } else if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count > vowel_count) {\n        return vowels[vowel_index + 1];\n    } else {\n        return vowels[vowel_index - 1];\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpoau4lucn.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpoau4lucn.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpoau4lucn.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpoau4lucn.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpoau4lucn.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpoau4lucn.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpoau4lucn.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index > consonant_index) {\n        return word[word.length - 1];\n    } else if (vowel_index < consonant_index) {\n        return word[0];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm8hfyxey.rs:20:8\n   |\n20 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index > consonant_index) {\n20 +     if vowel_index > consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm8hfyxey.rs:22:15\n   |\n22 |     } else if (vowel_index < consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index < consonant_index) {\n22 +     } else if vowel_index < consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpm8hfyxey.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpm8hfyxey.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpm8hfyxey.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  -",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = consonants.length - 1 - consonant_index;\n    let vowel_count = vowels.length - 1 - vowel_index;\n    let consonant_vowel_count = Math.min(vowel_count, consonant_count);\n    let consonant_vowel_index = consonant_count - consonant_vowel_count;\n    let vowel_consonant_count = Math.min(vowel_count, consonant_count);\n    let vowel_consonant_index = vowel_count - vowel_consonant_count;\n    let consonant_vowel_index_plus_1 = consonant_vowel_index + 1;\n    let vowel_consonant_index_plus_1 = vowel_consonant_index + 1;\n    let consonant_vowel_index_minus_1 = consonant_vowel_index - 1;\n    let vowel_consonant_index_minus_1 = vowel_consonant_index - 1;\n    let consonant_vowel_index_plus_2 = consonant_vowel_index + 2;\n    let vowel_consonant_index_plus_2 = vowel_consonant_index + 2;\n    let consonant_vowel_index_minus_2 = consonant_vowel_index - 2;\n    let vowel_consonant_index_minus_2 = vowel_consonant_index - 2;\n    let consonant_vowel_index_plus_3 = consonant_vowel_index + 3;\n    let vowel_conson\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpozcuzh1d.rs:35:21\n   |\n35 |     let vowel_conson\n   |                     ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `Math` in this scope\n  --> /tmp/tmpozcuzh1d.rs:22:33\n   |\n22 |     let consonant_vowel_count = Math.min(vowel_count, consonant_count);\n   |                                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Math` in this scope\n  --> /tmp/tmpozcuzh1d.rs:24:33\n   |\n24 |     let vowel_consonant_count = Math.min(vowel_count, consonant_count);\n   |                                 ^^^^ not found in this scope\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpozcuzh1d.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpozcuzh1d.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpozcuzh1d.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpozcuzh1d.rs:19:48\n   |\n19 |     let vowel_index = vowels.indexOf(w",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        if (vowels.indexOf(word[i]) > -1) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                break;\n            }\n            if (consonants.indexOf(word[i - 1]) > -1) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.indexOf(word[i]) > -1) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                break;\n            }\n            if (vowels.indexOf(word[i - 1]) > -1) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpsys93av_.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpsys93av_.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpsys93av_.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpsys93av_.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpsys93av_.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n        if (vowel_count == 1 && consonant_count == 1) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpwwn5j1jm.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpwwn5j1jm.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpwwn5j1jm.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpwwn5j1jm.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpwwn5j1jm.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpwwn5j1jm.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwwn5j1jm.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n        if (vowel_count == 2 && consonant_count == 0) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp31bhjk44.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp31bhjk44.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp31bhjk44.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp31bhjk44.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp31bhjk44.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp31bhjk44.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp31bhjk44.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else {\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmplap8c44a.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmplap8c44a.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmplap8c44a.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmplap8c44a.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmplap8c44a.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmplap8c44a.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplap8c44a.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n        if (vowel_count == 1 && consonant_count == 1) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpvfvmmj8a.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpvfvmmj8a.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvfvmmj8a.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvfvmmj8a.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvfvmmj8a.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpvfvmmj8a.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpvfvmmj8a.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count > vowel_count) {\n        return word[word.length - 1];\n    } else if (consonant_count < vowel_count) {\n        return word[0];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpxvmn9ydh.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpxvmn9ydh.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpxvmn9ydh.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpxvmn9ydh.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpxvmn9ydh.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpxvmn9ydh.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpxvmn9ydh.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index > consonant_index) {\n        return word[word.length - 1];\n    } else if (vowel_index < consonant_index) {\n        return word[0];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm8hfyxey.rs:20:8\n   |\n20 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index > consonant_index) {\n20 +     if vowel_index > consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm8hfyxey.rs:22:15\n   |\n22 |     } else if (vowel_index < consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index < consonant_index) {\n22 +     } else if vowel_index < consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpm8hfyxey.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpm8hfyxey.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpm8hfyxey.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  -",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_index_next = consonants.indexOf(word[1]);\n    let vowel_index_next = vowels.indexOf(word[word.length - 2]);\n    if (vowel_index > -1 && vowel_index_next > -1 && consonant_index_next > -1) {\n        let consonant_index_next_next = consonants.indexOf(word[2]);\n        if (vowel_index_next > consonant_index_next && vowel_index_next > consonant_index_next_next) {\n            return vowels[vowel_index_next];\n        } else if (vowel_index > consonant_index_next && vowel_index > consonant_index_next_next) {\n            return vowels[vowel_index];\n        } else if (vowel_index_next > consonant_index_next && vowel_index_next > consonant_index) {\n            return vowels[vowel_index_next];\n        } else if (vowel_index > consonant_index_next && vowel_index > consonant_index) {\n            return vowels[vowel_index];\n        } else if (vowel_index_next > consonant_index && vowel_index_next > consonant_index_next) {\n            return vowels[vowel_index_next];\n        } else if (vowel_index > consonant_index && vowel_index > consonant_index_next) {\n            return vowels[vowel_index];\n        } else if (vowel_index_next >\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4jg9gfpq.rs:54:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n22 |     if (vowel_index > -1 && vowel_index_next > -1 && consonant_index_next > -1) {\n   |                                                                                 - this delimiter might not be properly closed...\n...\n37 | }\n   | - ...as it matches this but it has different indentation\n...\n54 | }\n   |   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmp4jg9gfpq.rs:37:1\n   |\n37 | }\n   | ^ expected expression\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp4jg9gfpq.rs:37:1\n   |\n36 |         } else if (vowel_index_next >\n   |                -- this `if` expression has a condition, but no block\n37 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp4jg9gfpq.rs:36:19\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n36 |         } else if (vowel_index_next >\n   |                   ^ unclosed delimiter\n37 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4jg9gfpq.rs:22:8\n   |\n22 |     if (vowel_index > -1 && vowel_index_next > -1 && consonant_index_next > -1) {\n   |        ^                                                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -     if (vowel_index > -1 && vowel_index_next > -1 && consonant_index_next > -1) {\n22 +     if vowel_index > -1 && vowel_index_next > -1 && consonant_index_next > -1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4jg9gfpq.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index > consonant_index) {\n        return word[word.length - 1];\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowels.indexOf(word[consonant_index_plus_1]);\n    if (vowel_index_plus_1 > consonant_index_plus_1) {\n        return word[consonant_index_plus_1];\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyussajy2.rs:20:8\n   |\n20 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index > consonant_index) {\n20 +     if vowel_index > consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyussajy2.rs:25:8\n   |\n25 |     if (vowel_index_plus_1 > consonant_index_plus_1) {\n   |        ^                                           ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_index_plus_1 > consonant_index_plus_1) {\n25 +     if vowel_index_plus_1 > consonant_index_plus_1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpyussajy2.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpyussajy2.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpyussajy2.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `l",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[1]);\n    if (vowel_index < 0 || consonant_index < 0) {\n        return \"\"\n    }\n    let consonant_index_next = consonants.indexOf(word[2]);\n    if (consonant_index_next < 0) {\n        return \"\"\n    }\n    let vowel_index_next = vowels.indexOf(word[3]);\n    if (vowel_index_next < 0) {\n        return \"\"\n    }\n    if (vowel_index_next - vowel_index < consonant_index_next - consonant_index) {\n        return vowels[vowel_index + 1]\n    } else {\n        return vowels[vowel_index_next]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps_0krjqx.rs:20:8\n   |\n20 |     if (vowel_index < 0 || consonant_index < 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < 0 || consonant_index < 0) {\n20 +     if vowel_index < 0 || consonant_index < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps_0krjqx.rs:24:8\n   |\n24 |     if (consonant_index_next < 0) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (consonant_index_next < 0) {\n24 +     if consonant_index_next < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps_0krjqx.rs:28:8\n   |\n28 |     if (vowel_index_next < 0) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index_next < 0) {\n28 +     if vowel_index_next < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps_0krjqx.rs:31:8\n   |\n31 |     if (vowel_index_next - vowel_index < consonant_index_next - consonant_index) {\n   |        ^                                                                       ^\n   |\nhelp: remove these parentheses\n   |\n31 -     if (vowel_index_next - vowel_index < consonant_index_next - consonant_index) {\n31 +     if vowel_index_next - vowel_index < consonant_index_next - consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmps_0krjqx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmps_0krjqx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n    }\n    for (let i = vowel_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel_index = 0;\n    let closest_vowel_distance = Math.abs(vowel_index - consonant_index);\n    for (let i = 1; i < word.length - 1; i++) {\n        let distance = Math.abs(vowel_index - consonants.indexOf(word[i]));\n        if (distance < closest_vowel_distance) {\n            closest_vowel_distance = distance;\n            closest_vowel_index = i;\n        }\n    }\n    return word[closest_vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpshtlppm3.rs:22:10\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpshtlppm3.rs:22:14\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpshtlppm3.rs:22:16\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpshtlppm3.rs:22:15\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpshtlppm3.rs:22:16\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpshtlppm3.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpshtlppm3.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1 - consonant_index;\n    let vowel_count = word.length - 1 - vowel_index;\n    if (vowel_count > consonant_count) {\n        return word[word.length - 1];\n    } else if (vowel_count == consonant_count) {\n        return word[word.length - 2];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprgdcamln.rs:22:8\n   |\n22 |     if (vowel_count > consonant_count) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -     if (vowel_count > consonant_count) {\n22 +     if vowel_count > consonant_count {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprgdcamln.rs:24:15\n   |\n24 |     } else if (vowel_count == consonant_count) {\n   |               ^                              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     } else if (vowel_count == consonant_count) {\n24 +     } else if vowel_count == consonant_count {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmprgdcamln.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmprgdcamln.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmprgdcamln.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n        if (vowel_count > 0 && consonant_count > 0) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpx95_5wc8.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpx95_5wc8.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpx95_5wc8.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpx95_5wc8.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpx95_5wc8.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpx95_5wc8.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpx95_5wc8.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpx9nlwpl6.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpx9nlwpl6.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpx9nlwpl6.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpx9nlwpl6.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpx9nlwpl6.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpx9nlwpl6.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpx9nlwpl6.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_index_next = consonants.indexOf(word[1]);\n    let vowel_index_next = vowels.indexOf(word[word.length - 2]);\n    if (vowel_index_next >= 0 && consonant_index_next >= 0) {\n        return vowels[vowel_index_next];\n    } else if (vowel_index >= 0 && consonant_index_next >= 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index >= 0 && vowel_index_next >= 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index >= 0 && vowel_index_next < 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index_next >= 0 && vowel_index < 0) {\n        return vowels[vowel_index_next];\n    } else if (vowel_index < 0 && vowel_index_next >= 0) {\n        return vowels[vowel_index_next];\n    } else if (vowel_index < 0 && vowel_index_next < 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index >= 0 && vowel_index_next < 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index < 0 && vowel_index_next >= 0) {\n        return vowels[vowel_index_next];\n    } else if (vowel_index < 0 &&\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected expression, found `)`\n  --> /tmp/tmpckqxbl4b.rs:41:1\n   |\n41 | }\n   | ^ expected expression\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpckqxbl4b.rs:41:1\n   |\n40 |     } else if (vowel_index < 0 &&\n   |            -- this `if` expression has a condition, but no block\n41 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpckqxbl4b.rs:40:15\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n40 |     } else if (vowel_index < 0 &&\n   |               ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpckqxbl4b.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpckqxbl4b.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpckqxbl4b.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpckqxbl4b.rs:19:48\n   |\n19 |     let vowel_",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [String::from(\"a\"), String::from(\"e\"), String::from(\"i\"), String::from(\"o\"), String::from(\"u\")];\n    let consonants = word.split(\"\").filter(c => c != \"\")\n        .map(c => c.toLowerCase())\n        .filter(c => c != \"\")\n        .filter(c => vowels.includes(c))\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n        .filter(c => c != \"\")\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp84aro8mi.rs:17:46\n   |\n17 |     let consonants = word.split(\"\").filter(c => c != \"\")\n   |                                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpzqt79prf.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpzqt79prf.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpzqt79prf.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpzqt79prf.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpzqt79prf.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\n        \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\",\n    ];\n    let consonants = [\n        \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\",\n    ];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let consonant_index_next = consonants.indexOf(word[1]);\n    let vowel_index_next = vowels.indexOf(word[word.length - 2]);\n    let consonant_count_next = 0;\n    let vowel_count_next = 0;\n    let result = \"\";\n    while (vowel_index_next >= 0 && vowel_count_next < vowel_count) {\n        vowel_count_next += 1;\n        vowel_index_next -= 1;\n    }\n    while (consonant_index_next >= 0 && consonant_count_next < consonant_count) {\n        consonant_count_next += 1;\n        consonant_index_next -= 1;\n    }\n    if (vowel_index >= 0 && vowel_count < vowel_count_next) {\n        result = vowels[vowel_index];\n    } else if (consonant_index >= 0 && consonant_count < consonant_count_next) {\n        result = consonants[consonant_index];\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyfz7cxl8.rs:31:11\n   |\n31 |     while (vowel_index_next >= 0 && vowel_count_next < vowel_count) {\n   |           ^                                                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n31 -     while (vowel_index_next >= 0 && vowel_count_next < vowel_count) {\n31 +     while vowel_index_next >= 0 && vowel_count_next < vowel_count {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyfz7cxl8.rs:35:11\n   |\n35 |     while (consonant_index_next >= 0 && consonant_count_next < consonant_count) {\n   |           ^                                                                   ^\n   |\nhelp: remove these parentheses\n   |\n35 -     while (consonant_index_next >= 0 && consonant_count_next < consonant_count) {\n35 +     while consonant_index_next >= 0 && consonant_count_next < consonant_count {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyfz7cxl8.rs:39:8\n   |\n39 |     if (vowel_index >= 0 && vowel_count < vowel_count_next) {\n   |        ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n39 -     if (vowel_index >= 0 && vowel_count < vowel_count_next) {\n39 +     if vowel_index >= 0 && vowel_count < vowel_count_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyfz7cxl8.rs:41:15\n   |\n41 |     } else if (consonant_index >= 0 && consonant_count < consonant_count_next) {\n   |               ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n41 -     } else if (consonant_index >= 0 && consonant_count < consonant_count_next) {\n41 +     } else if consonant_index >= 0 && consonant_count < consonant_count_next {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpyfz7cxl8.rs:22:38\n   |\n22 |     let consonant_index = consonants.indexOf(word[0]);\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .map(c => c.toLowerCase())\n        .filter(c => vowels.indexOf(c) == -1);\n    let consonant_index = consonants.indexOf(consonants.last());\n    if (consonant_index == -1) {\n        return \"\";\n    }\n    let vowel_index = consonants.slice(consonant_index).indexOf(vowels.last());\n    if (vowel_index == -1) {\n        return \"\";\n    }\n    return vowels[vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpf06gaxyl.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    if (consonant_count == 0) {\n        closest_vowel = vowels[vowel_count - 1];\n    } else {\n        let vowel_index = vowels.indexOf(word[word.length - 1]);\n        let consonant_index = consonants.indexOf(word[0]);\n        let closest_vowel_index = 0;\n        for (let i = 0; i < word.length - 1; i++) {\n            if (vowels.indexOf(word[i]) > vowel_index) {\n                closest_vowel_index = i;\n                break;\n            }\n        }\n        if (closest_vowel_index == 0) {\n            closest_vowel = vowels[vowel_count - 1];\n        } else {\n            closest_vowel = vowels[closest_vowel_index];\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpy3vomrsl.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpy3vomrsl.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpy3vomrsl.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpy3vomrsl.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpy3vomrsl.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpy3vomrsl.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpy3vomrsl.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n            if (vowel_count == 1) {\n                closest_vowel = word[i];\n            }\n        } else if (vowels.indexOf(word[i]) == -1) {\n            consonant_count += 1;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpiy88382d.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpiy88382d.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpiy88382d.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpiy88382d.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpiy88382d.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpiy88382d.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpiy88382d.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => !vowels.includes(c))\n        .map(c => c.toLowerCase())\n        .toSet();\n    let consonant_index = consonants.reduce((acc, c) => {\n        let index = word.indexOf(c);\n        if (index === -1) {\n            return acc;\n        }\n        return index;\n    }, -1);\n    let vowel_index = vowels.reduce((acc, v) => {\n        let index = word.indexOf(v);\n        if (index === -1) {\n            return acc;\n        }\n        return index;\n    }, -1);\n    if (vowel_index === -1 || consonant_index === -1) {\n        return \"\";\n    }\n    let vowel_index_end = vowel_index + 1;\n    let consonant_index_end = consonant_index + 1;\n    let vowel_index_start = vowel_index - 1;\n    let consonant_index_start = consonant_index - 1;\n    if (vowel_index_end >= word.length) {\n        return \"\";\n    }\n    if (vowel_index_start < 0) {\n        return \"\";\n    }\n    if (consonant_index_end >= word.length) {\n        return \"\";\n    }\n    if (consonant_index_start < 0) {\n        return \"\";\n    }\n    if (vowel_index_end < vowel_index_start) {\n        return \"\";\n    }\n    if (vowel_index_start < vowel_index_end) {\n        return word[vowel_index_start];\n    }\n    if (consonant_index_end < consonant_index_start) {\n        return word[consonant_index_start];\n    }\n    return word[consonant_index_end];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpt1mabbzb.rs:18:19\n   |\n18 |         .filter(c => !vowels.includes(c))\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < 0 || consonant_index < 0) {\n        return \"\"\n    } else if (vowel_index - consonant_index < 1) {\n        return \"\"\n    } else {\n        return vowels[vowel_index - consonant_index - 1]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm8uzd15y.rs:20:8\n   |\n20 |     if (vowel_index < 0 || consonant_index < 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < 0 || consonant_index < 0) {\n20 +     if vowel_index < 0 || consonant_index < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm8uzd15y.rs:22:15\n   |\n22 |     } else if (vowel_index - consonant_index < 1) {\n   |               ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index - consonant_index < 1) {\n22 +     } else if vowel_index - consonant_index < 1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpm8uzd15y.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpm8uzd15y.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpm8uzd15y.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else if (vowel_index < consonant_index) {\n        return vowels[vowel_index + 1]\n    } else {\n        return vowels[vowel_index - 1]\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplmlkyyvs.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplmlkyyvs.rs:22:15\n   |\n22 |     } else if (vowel_index < consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index < consonant_index) {\n22 +     } else if vowel_index < consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmplmlkyyvs.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplmlkyyvs.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmplmlkyyvs.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpey7we3g0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpey7we3g0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpey7we3g0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpey7we3g0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpey7we3g0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpey7we3g0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (vowel_index_plus_1 == word.length) {\n        return \"\"\n    }\n    if (vowel_index_plus_1 == word.length - 1) {\n        return vowels[vowel_index_plus_1]\n    }\n    if (vowel_index_plus_1 == consonant_index_plus_1) {\n        return vowels[vowel_index_plus_1]\n    }\n    return \"\"\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_m7g3hia.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_m7g3hia.rs:25:8\n   |\n25 |     if (vowel_index_plus_1 == word.length) {\n   |        ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_index_plus_1 == word.length) {\n25 +     if vowel_index_plus_1 == word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_m7g3hia.rs:28:8\n   |\n28 |     if (vowel_index_plus_1 == word.length - 1) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index_plus_1 == word.length - 1) {\n28 +     if vowel_index_plus_1 == word.length - 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_m7g3hia.rs:31:8\n   |\n31 |     if (vowel_index_plus_1 == consonant_index_plus_1) {\n   |        ^                                            ^\n   |\nhelp: remove these parentheses\n   |\n31 -     if (vowel_index_plus_1 == consonant_index_plus_1) {\n31 +     if vowel_index_plus_1 == consonant_index_plus_1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp_m7g3hia.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp_m7g3hia.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `In",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length; i++) {\n        if (vowels.indexOf(word[i]) > -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) > -1) {\n            consonant_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpdnydhmvz.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpdnydhmvz.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpdnydhmvz.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpdnydhmvz.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpdnydhmvz.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpdnydhmvz.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpdnydhmvz.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = consonants.length - 1 - consonant_index;\n    let vowel_count = vowels.length - 1 - vowel_index;\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    let consonant_index_minus_1 = consonant_index - 1;\n    let vowel_index_minus_1 = vowel_index - 1;\n    let consonant_index_plus_2 = consonant_index + 2;\n    let vowel_index_plus_2 = vowel_index + 2;\n    let consonant_index_minus_2 = consonant_index - 2;\n    let vowel_index_minus_2 = vowel_index - 2;\n    let consonant_index_plus_3 = consonant_index + 3;\n    let vowel_index_plus_3 = vowel_index + 3;\n    let consonant_index_minus_3 = consonant_index - 3;\n    let vowel_index_minus_3 = vowel_index - 3;\n    let consonant_index_plus_4 = consonant_index + 4;\n    let vowel_index_plus_4 = vowel_index + 4;\n    let consonant_index_minus_4 = consonant_index - 4;\n    let vowel_index_minus_4 = vowel_index - 4;\n    let consonant_index_plus_5 = consonant_index + 5;\n    let vowel_index_plus_5 = vowel_index + 5;\n    let consonant_index_minus_5 = consonant_index - 5;\n\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpd4vezb_q.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpd4vezb_q.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpd4vezb_q.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmpd4vezb_q.rs:19:48\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                                                ^^^^^^ unknown field\n\nerror[E0609]: no field `length` on type `[&str; 21]`\n  --> /tmp/tmpd4vezb_q.rs:20:38\n   |\n20 |     let consonant_count = consonants.length - 1 - consonant_index;\n   |                                      ^^^^^^\n\nerror[E0609]: no field `length` on type `[&str; 5]`\n  --> /tmp/tmpd4vezb_q.rs:21:30\n   |\n21 |     let vowel_count = vowels.length - 1 - vowel_index;\n   |                              ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd4vezb_q.rs:15:39\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |    ------------",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index > consonant_index) {\n        return word[word.length - 1];\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (vowel_index_plus_1 < consonant_index_plus_1) {\n        return word[word.length - 1];\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqglopfyb.rs:20:8\n   |\n20 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index > consonant_index) {\n20 +     if vowel_index > consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqglopfyb.rs:25:8\n   |\n25 |     if (vowel_index_plus_1 < consonant_index_plus_1) {\n   |        ^                                           ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_index_plus_1 < consonant_index_plus_1) {\n25 +     if vowel_index_plus_1 < consonant_index_plus_1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpqglopfyb.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpqglopfyb.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpqglopfyb.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `l",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = consonants.length - 1 - consonant_index;\n    let vowel_count = vowels.length - 1 - vowel_index;\n    let result = \"\";\n    if (vowel_count > 0 && consonant_count > 0) {\n        let consonant_index = consonants.indexOf(word[0]);\n        let vowel_index = vowels.indexOf(word[word.length - 1]);\n        let consonant_count = consonants.length - 1 - consonant_index;\n        let vowel_count = vowels.length - 1 - vowel_index;\n        let consonant_index_2 = consonants.indexOf(word[1]);\n        let vowel_index_2 = vowels.indexOf(word[word.length - 2]);\n        let consonant_count_2 = consonants.length - 1 - consonant_index_2;\n        let vowel_count_2 = vowels.length - 1 - vowel_index_2;\n        if (vowel_count_2 > 0 && consonant_count_2 > 0) {\n            let consonant_index_3 = consonants.indexOf(word[2]);\n            let vowel_index_3 = vowels.indexOf(word[word.length - 3]);\n            let consonant_count_3 = consonants.length - 1 - consonant_index_3;\n            let vowel_count_3 = vowels.length - 1 - vowel_index_3;\n            if (vowel_count_3 > 0 && consonant_count_3 > 0) {\n                let consonant_index_4 = consonants.index\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp29dec7hv.rs:56:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n23 |     if (vowel_count > 0 && consonant_count > 0) {\n   |                                                 - unclosed delimiter\n...\n32 |         if (vowel_count_2 > 0 && consonant_count_2 > 0) {\n   |                                                         - unclosed delimiter\n...\n37 |             if (vowel_count_3 > 0 && consonant_count_3 > 0) {\n   |                                                             - this delimiter might not be properly closed...\n38 |                 let consonant_index_4 = consonants.index\n39 | }\n   | - ...as it matches this but it has different indentation\n...\n56 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp29dec7hv.rs:38:57\n   |\n38 |                 let consonant_index_4 = consonants.index\n   |                                                         ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp29dec7hv.rs:23:8\n   |\n23 |     if (vowel_count > 0 && consonant_count > 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n23 -     if (vowel_count > 0 && consonant_count > 0) {\n23 +     if vowel_count > 0 && consonant_count > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp29dec7hv.rs:32:12\n   |\n32 |         if (vowel_count_2 > 0 && consonant_count_2 > 0) {\n   |            ^                                          ^\n   |\nhelp: remove these parentheses\n   |\n32 -         if (vowel_count_2 > 0 && consonant_count_2 > 0) {\n32 +         if vowel_count_2 > 0 && consonant_count_2 > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp29dec7hv.rs:37:16\n   |\n37 |             if (vowel_count_3 > 0 && consonant_count_3 > 0) {\n   |                ^     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index > consonant_index) {\n        return word[word.length - 1];\n    }\n    let i = consonant_index + 1;\n    while (i < word.length - 1) {\n        if (vowels.indexOf(word[i]) > -1) {\n            return word[i];\n        }\n        i += 1;\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp57siu4xy.rs:20:8\n   |\n20 |     if (vowel_index > consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index > consonant_index) {\n20 +     if vowel_index > consonant_index {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp57siu4xy.rs:24:11\n   |\n24 |     while (i < word.length - 1) {\n   |           ^                   ^\n   |\nhelp: remove these parentheses\n   |\n24 -     while (i < word.length - 1) {\n24 +     while i < word.length - 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp57siu4xy.rs:25:12\n   |\n25 |         if (vowels.indexOf(word[i]) > -1) {\n   |            ^                            ^\n   |\nhelp: remove these parentheses\n   |\n25 -         if (vowels.indexOf(word[i]) > -1) {\n25 +         if vowels.indexOf(word[i]) > -1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp57siu4xy.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp57siu4xy.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n    let consonant_index = consonants.indexOf(word.chars().find(c => !vowels.includes(c)));\n    let vowel_index = consonants.indexOf(word.chars().find(c => vowels.includes(c)));\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else {\n        return word.chars().slice(vowel_index, consonant_index + 1).join(\"\");\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmprslau41p.rs:17:44\n   |\n17 |     let consonants = word.chars().filter(c => !vowels.includes(c)).to_list();\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (consonant_index == -1 || vowel_index == -1) {\n        return \"\";\n    }\n    let consonant_index_next = consonants.indexOf(word[consonant_index + 1]);\n    if (consonant_index_next == -1) {\n        return \"\";\n    }\n    let vowel_index_next = vowels.indexOf(word[vowel_index + 1]);\n    if (vowel_index_next == -1) {\n        return \"\";\n    }\n    return word[consonant_index + 1] + word[vowel_index + 1];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplug95hmm.rs:20:8\n   |\n20 |     if (consonant_index == -1 || vowel_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (consonant_index == -1 || vowel_index == -1) {\n20 +     if consonant_index == -1 || vowel_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplug95hmm.rs:24:8\n   |\n24 |     if (consonant_index_next == -1) {\n   |        ^                          ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (consonant_index_next == -1) {\n24 +     if consonant_index_next == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplug95hmm.rs:28:8\n   |\n28 |     if (vowel_index_next == -1) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index_next == -1) {\n28 +     if vowel_index_next == -1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmplug95hmm.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplug95hmm.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (consonant_count == 0) {\n        return word[word.length - 1];\n    }\n    let closest_vowel = word[word.length - 1];\n    for (let i = word.length - 2; i >= 0; i--) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowel_count == vowel_count + 1) {\n            closest_vowel = word[i];\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpjapqfsgh.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpjapqfsgh.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpjapqfsgh.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpjapqfsgh.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpjapqfsgh.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpjapqfsgh.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpjapqfsgh.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) >\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp51wd9lc9.rs:68:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n49 |     for (let i = 0; i < word.length - 1; i++) {\n   |                                               - this delimiter might not be properly closed...\n50 |         if (consonants.indexOf(word[i]) >\n51 | }\n   | - ...as it matches this but it has different indentation\n...\n68 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmp51wd9lc9.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp51wd9lc9.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp51wd9lc9.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp51wd9lc9.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp51wd9lc9.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp51wd9lc9.rs:50:12\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n50 |         if (consonants.indexOf(word[i]) >\n   |            ^ unclosed delimiter\n51 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp51wd9lc9.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpzqt79prf.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpzqt79prf.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpzqt79prf.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpzqt79prf.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpzqt79prf.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n    }\n    for (let i = vowel_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let closest_vowel = \"\";\n    if (vowel_count > consonant_count) {\n        for (let i = consonant_index + 1; i < word.length - 1; i++) {\n            if (vowels.indexOf(word[i]) != -1) {\n                closest_vowel = word[i];\n                break;\n            }\n        }\n    } else {\n        for (let i = vowel_index + 1; i < word.length - 1; i++) {\n            if (consonants.indexOf(word[i]) != -1) {\n                closest_vowel = word[i];\n                break;\n            }\n        }\n    }\n    return closest\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp2b89i7vh.rs:22:10\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp2b89i7vh.rs:22:14\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp2b89i7vh.rs:22:16\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp2b89i7vh.rs:22:15\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp2b89i7vh.rs:22:16\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp2b89i7vh.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp2b89i7vh.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                result = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                result = word[i];\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpyp4vj3za.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpyp4vj3za.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpyp4vj3za.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpyp4vj3za.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpyp4vj3za.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpyp4vj3za.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpyp4vj3za.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n        if (vowel_count == 1 && consonant_count == 0) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpcpqgkggw.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpcpqgkggw.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpcpqgkggw.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcpqgkggw.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpcpqgkggw.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpcpqgkggw.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpcpqgkggw.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        } else {\n            consonant_count = 0;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        } else {\n            vowel_count = 0;\n        }\n        if (consonant_count == 2 && vowel_count == 1) {\n            return word[i];\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpwbtccyso.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpwbtccyso.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpwbtccyso.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpwbtccyso.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpwbtccyso.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpwbtccyso.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwbtccyso.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count++;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count++;\n        }\n    }\n    if (consonant_count > vowel_count) {\n        return vowels[vowel_index + 1];\n    } else {\n        return vowels[vowel_index - 1];\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpior9fezj.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpior9fezj.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpior9fezj.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpior9fezj.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpior9fezj.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpior9fezj.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpior9fezj.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\";\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (vowel_index_plus_1 == word.length) {\n        return \"\";\n    }\n    if (consonant_index_plus_1 == word.length) {\n        return vowels[vowel_index_plus_1];\n    }\n    if (vowel_index_plus_1 == consonant_index_plus_1) {\n        return vowels[vowel_index_plus_1];\n    }\n    let consonant_index_plus_2 = consonant_index_plus_1 + 1;\n    let vowel_index_plus_2 = vowel_index_plus_1 + 1;\n    if (vowel_index_plus_2 == word.length) {\n        return \"\";\n    }\n    if (consonant_index_plus_2 == word.length) {\n        return vowels[vowel_index_plus_2];\n    }\n    if (vowel_index_plus_2 == consonant_index_plus_2) {\n        return vowels[vowel_index_plus_2];\n    }\n    let consonant_index_plus_3 = consonant_index_plus_2 + 1;\n    let vowel_index_plus_3 = vowel_index_plus_2 + 1;\n    if (vowel_index_plus_\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected `{`, found `}`\n  --> /tmp/tmpf_8snxko.rs:48:1\n   |\n47 |     if (vowel_index_plus_\n   |     -- this `if` expression has a condition, but no block\n48 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpf_8snxko.rs:47:8\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n47 |     if (vowel_index_plus_\n   |        ^ unclosed delimiter\n48 | }\n   | ^ mismatched closing delimiter\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf_8snxko.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf_8snxko.rs:25:8\n   |\n25 |     if (vowel_index_plus_1 == word.length) {\n   |        ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_index_plus_1 == word.length) {\n25 +     if vowel_index_plus_1 == word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf_8snxko.rs:28:8\n   |\n28 |     if (consonant_index_plus_1 == word.length) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (consonant_index_plus_1 == word.length) {\n28 +     if consonant_index_plus_1 == word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf_8snxko.rs:31:8\n   |\n31 |     if (vowel_index_plus_1 == consonant_index_plus_1) {\n   |        ^                                            ^\n   |\nhelp: remove these parentheses\n   |\n31 -     if (vowel_index_plus_1 == consonant_index_plus_1) {\n31 +     if vowel_index_plus_1 == consonant_index_plus_1 {\n   | \n\nwarning: unnecessary parentheses aroun",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count++;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count++;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (consonant_count == 0) {\n        return word[word.length - 1];\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count++;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count++;\n        }\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp04bop1g9.rs:71:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n52 |     for (let i = 0; i < word.length - 1; i++) {\n   |                                               - this delimiter might not be properly closed...\n53 |         if\n54 | }\n   | - ...as it matches this but it has different indentation\n...\n71 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmp04bop1g9.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp04bop1g9.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp04bop1g9.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp04bop1g9.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp04bop1g9.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp04bop1g9.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp04bop1g9.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < 0 || consonant_index < 0) {\n        return \"\"\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (vowel_index_plus_1 >= vowels.length || consonant_index_plus_1 >= consonants.length) {\n        return \"\"\n    }\n    return vowels[vowel_index_plus_1]\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp08z48ptu.rs:20:8\n   |\n20 |     if (vowel_index < 0 || consonant_index < 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < 0 || consonant_index < 0) {\n20 +     if vowel_index < 0 || consonant_index < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp08z48ptu.rs:25:8\n   |\n25 |     if (vowel_index_plus_1 >= vowels.length || consonant_index_plus_1 >= consonants.length) {\n   |        ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_index_plus_1 >= vowels.length || consonant_index_plus_1 >= consonants.length) {\n25 +     if vowel_index_plus_1 >= vowels.length || consonant_index_plus_1 >= consonants.length {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp08z48ptu.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp08z48ptu.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let closest_vowel = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpsdwa8axd.rs:21:10\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpsdwa8axd.rs:21:14\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpsdwa8axd.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpsdwa8axd.rs:21:15\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpsdwa8axd.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    let closest_vowel_index = 0;\n    for (let i = word.length - 1; i >= 0; i--) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            closest_vowel_index = i;\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpc8rk0yd7.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpc8rk0yd7.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpc8rk0yd7.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpc8rk0yd7.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpc8rk0yd7.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpc8rk0yd7.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpc8rk0yd7.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1 - consonant_index;\n    let vowel_count = word.length - 1 - vowel_index;\n    if (vowel_count > consonant_count) {\n        return word[vowel_index + 1];\n    } else if (vowel_count < consonant_count) {\n        return word[consonant_index + 1];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpllqigpkn.rs:22:8\n   |\n22 |     if (vowel_count > consonant_count) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -     if (vowel_count > consonant_count) {\n22 +     if vowel_count > consonant_count {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpllqigpkn.rs:24:15\n   |\n24 |     } else if (vowel_count < consonant_count) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n24 -     } else if (vowel_count < consonant_count) {\n24 +     } else if vowel_count < consonant_count {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpllqigpkn.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpllqigpkn.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmpllqigpkn.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  -",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let closest_vowel = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpvzt5vkqo.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpvzt5vkqo.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvzt5vkqo.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvzt5vkqo.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvzt5vkqo.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count > consonant_count) {\n        return vowels[vowel_index + 1];\n    } else {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmplqdqvp0p.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmplqdqvp0p.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmplqdqvp0p.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmplqdqvp0p.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmplqdqvp0p.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmplqdqvp0p.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplqdqvp0p.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.split(\"\").filter(c => c !== \"\").map(c => c.toLowerCase());\n    let consonant_count = consonants.length;\n    let vowel_count = vowels.length;\n    let vowel_index = 0;\n    let consonant_index = 0;\n    let closest_vowel = \"\";\n    while (vowel_count > 0 && consonant_count > 0) {\n        if (vowels[vowel_index] === consonants[consonant_index]) {\n            vowel_index += 1;\n            if (vowel_index === vowel_count) {\n                closest_vowel = vowels[vowel_index - 1];\n                break;\n            }\n        } else {\n            consonant_index += 1;\n            if (consonant_index === consonant_count) {\n                closest_vowel = vowels[vowel_index];\n                break;\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpgu2csxtp.rs:17:46\n   |\n17 |     let consonants = word.split(\"\").filter(c => c !== \"\").map(c => c.toLowerCase());\n   |                                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                result = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                result = word[i];\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpyp4vj3za.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpyp4vj3za.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpyp4vj3za.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpyp4vj3za.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpyp4vj3za.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpyp4vj3za.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpyp4vj3za.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [String::from(\"a\"), String::from(\"e\"), String::from(\"i\"), String::from(\"o\"), String::from(\"u\")];\n    let consonants = word.split(\"\").filter(c => c !== \"\").map(c => c.toLowerCase());\n    let consonant_index = consonants.findIndex(c => c !== \"\");\n    let vowel_index = consonants[consonant_index + 1].findIndex(c => c !== \"\" && vowels.includes(c));\n    if (vowel_index === -1) {\n        return \"\";\n    } else {\n        return vowels[vowel_index];\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmptv9a4ljk.rs:17:46\n   |\n17 |     let consonants = word.split(\"\").filter(c => c !== \"\").map(c => c.toLowerCase());\n   |                                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.split(\"\").filter(c => c != \"\")\n        .map(c => c.toLowerCase())\n        .filter(c => vowels.indexOf(c) == -1);\n    let consonant_index = consonants.indexOf(consonants.pop());\n    let vowel_index = consonants.indexOf(consonants.pop());\n    return vowels[vowel_index] if vowel_index != -1 else \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpwnmn2srf.rs:17:46\n   |\n17 |     let consonants = word.split(\"\").filter(c => c != \"\")\n   |                                              ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n        }\n        if (vowel_count > 0 && consonant_count > 0) {\n            result = word[i];\n            break;\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpw850ua5_.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpw850ua5_.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpw850ua5_.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpw850ua5_.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpw850ua5_.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpw850ua5_.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpw850ua5_.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n        if (vowel_count == 1 && consonant_count == 1) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpvfvmmj8a.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpvfvmmj8a.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvfvmmj8a.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvfvmmj8a.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvfvmmj8a.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpvfvmmj8a.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpvfvmmj8a.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = word.length - 1 - consonant_index;\n    let vowel_count = word.length - 1 - vowel_index;\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    if (vowel_count == 1) {\n        return vowels[vowel_index];\n    }\n    if (consonant_count == 0) {\n        return vowels[vowel_index];\n    }\n    if (consonant_count == 1) {\n        return vowels[vowel_index - 1];\n    }\n    if (consonant_count == 2) {\n        return vowels[vowel_index - 2];\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1inbnhv0.rs:22:8\n   |\n22 |     if (vowel_count == 0) {\n   |        ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -     if (vowel_count == 0) {\n22 +     if vowel_count == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1inbnhv0.rs:25:8\n   |\n25 |     if (vowel_count == 1) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_count == 1) {\n25 +     if vowel_count == 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1inbnhv0.rs:28:8\n   |\n28 |     if (consonant_count == 0) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (consonant_count == 0) {\n28 +     if consonant_count == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1inbnhv0.rs:31:8\n   |\n31 |     if (consonant_count == 1) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n31 -     if (consonant_count == 1) {\n31 +     if consonant_count == 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1inbnhv0.rs:34:8\n   |\n34 |     if (consonant_count == 2) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n34 -     if (consonant_count == 2) {\n34 +     if consonant_count == 2 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp1inbnhv0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp1inbnhv0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < 0 || consonant_index < 0) {\n        return \"\";\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    if (consonant_index_plus_1 >= word.length) {\n        return \"\";\n    }\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (vowel_index_plus_1 >= word.length) {\n        return \"\";\n    }\n    let consonant_index_plus_2 = consonant_index + 2;\n    if (consonant_index_plus_2 >= word.length) {\n        return \"\";\n    }\n    let vowel_index_plus_2 = vowel_index + 2;\n    if (vowel_index_plus_2 >= word.length) {\n        return \"\";\n    }\n    if (vowels.indexOf(word[consonant_index_plus_1]) >= 0 && vowels.indexOf(word[vowel_index_plus_1]) >= 0) {\n        return word[consonant_index_plus_1];\n    }\n    if (vowels.indexOf(word[consonant_index_plus_2]) >= 0 && vowels.indexOf(word[vowel_index_plus_2]) >= 0) {\n        return word[consonant_index_plus_2];\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi5_fvahf.rs:20:8\n   |\n20 |     if (vowel_index < 0 || consonant_index < 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < 0 || consonant_index < 0) {\n20 +     if vowel_index < 0 || consonant_index < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi5_fvahf.rs:24:8\n   |\n24 |     if (consonant_index_plus_1 >= word.length) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (consonant_index_plus_1 >= word.length) {\n24 +     if consonant_index_plus_1 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi5_fvahf.rs:28:8\n   |\n28 |     if (vowel_index_plus_1 >= word.length) {\n   |        ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index_plus_1 >= word.length) {\n28 +     if vowel_index_plus_1 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi5_fvahf.rs:32:8\n   |\n32 |     if (consonant_index_plus_2 >= word.length) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (consonant_index_plus_2 >= word.length) {\n32 +     if consonant_index_plus_2 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi5_fvahf.rs:36:8\n   |\n36 |     if (vowel_index_plus_2 >= word.length) {\n   |        ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n36 -     if (vowel_index_plus_2 >= word.length) {\n36 +     if vowel_index_plus_2 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi5_fvahf.rs:39:8\n   |\n39 |     if (vowels.indexOf(word[consonant_index_plus_1]) >= 0 && vowels.indexOf(word[vowel_index_plus_1]) >= 0) {\n   |        ^                                                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_index_next = consonants.indexOf(word[1]);\n    let vowel_index_next = vowels.indexOf(word[word.length - 2]);\n    if (vowel_index_next >= 0 && consonant_index_next >= 0) {\n        return vowels[vowel_index_next];\n    } else if (vowel_index >= 0 && consonant_index_next >= 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index >= 0 && vowel_index_next >= 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index >= 0 && vowel_index_next < 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index_next >= 0 && vowel_index < 0) {\n        return vowels[vowel_index_next];\n    } else if (vowel_index < 0 && vowel_index_next >= 0) {\n        return vowels[vowel_index_next];\n    } else if (vowel_index < 0 && vowel_index_next < 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index_next < 0 && vowel_index >= 0) {\n        return vowels[vowel_index];\n    } else if (vowel_index_next < 0 && vowel_index < 0) {\n        return vowels[vowel_index_next];\n    } else if (vowel_index >= 0 &&\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected expression, found `)`\n  --> /tmp/tmp5vy99f6c.rs:41:1\n   |\n41 | }\n   | ^ expected expression\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp5vy99f6c.rs:41:1\n   |\n40 |     } else if (vowel_index >= 0 &&\n   |            -- this `if` expression has a condition, but no block\n41 | }\n   | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp5vy99f6c.rs:40:15\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n40 |     } else if (vowel_index >= 0 &&\n   |               ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp5vy99f6c.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp5vy99f6c.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 5]` in the current scope\n  --> /tmp/tmp5vy99f6c.rs:19:30\n   |\n19 |     let vowel_index = vowels.indexOf(word[word.length - 1]);\n   |                              ^^^^^^^ method not found in `[&str; 5]`\n\nerror[E0609]: no field `length` on type `String`\n  --> /tmp/tmp5vy99f6c.rs:19:48\n   |\n19 |     let vowe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < 0 || consonant_index < 0) {\n        return \"\";\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    if (consonant_index_plus_1 >= word.length) {\n        return \"\";\n    }\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (vowel_index_plus_1 >= word.length) {\n        return \"\";\n    }\n    let consonant_index_plus_2 = consonant_index + 2;\n    if (consonant_index_plus_2 >= word.length) {\n        return \"\";\n    }\n    let vowel_index_plus_2 = vowel_index + 2;\n    if (vowel_index_plus_2 >= word.length) {\n        return \"\";\n    }\n    let consonant_index_plus_3 = consonant_index + 3;\n    if (consonant_index_plus_3 >= word.length) {\n        return \"\";\n    }\n    let vowel_index_plus_3 = vowel_index + 3;\n    if (vowel_index_plus_3 >= word.length) {\n        return \"\";\n    }\n    let consonant_index_plus_4 = consonant_index + 4;\n    if (consonant_index_plus_4 >= word.length) {\n        return \"\";\n    }\n    let vowel_index_plus_4 = vowel_index + 4;\n    if (vowel_index_plus_4 >= word.length) {\n        \n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmps0o00s_2.rs:71:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n52 |     if (vowel_index_plus_4 >= word.length) {\n   |                                            - this delimiter might not be properly closed...\n53 |         \n54 | }\n   | - ...as it matches this but it has different indentation\n...\n71 | }\n   |   ^\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps0o00s_2.rs:20:8\n   |\n20 |     if (vowel_index < 0 || consonant_index < 0) {\n   |        ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < 0 || consonant_index < 0) {\n20 +     if vowel_index < 0 || consonant_index < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps0o00s_2.rs:24:8\n   |\n24 |     if (consonant_index_plus_1 >= word.length) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (consonant_index_plus_1 >= word.length) {\n24 +     if consonant_index_plus_1 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps0o00s_2.rs:28:8\n   |\n28 |     if (vowel_index_plus_1 >= word.length) {\n   |        ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index_plus_1 >= word.length) {\n28 +     if vowel_index_plus_1 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps0o00s_2.rs:32:8\n   |\n32 |     if (consonant_index_plus_2 >= word.length) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (consonant_index_plus_2 >= word.length) {\n32 +     if consonant_index_plus_2 >= word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmps0o00s_2.rs:36:8\n   |\n36 |     if (vowel_index_plus_2 >= word.length) {\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (consonant_index == -1 || vowel_index == -1) {\n        return \"\";\n    }\n    let consonant_index_plus_1 = consonant_index + 1;\n    let vowel_index_plus_1 = vowel_index + 1;\n    if (consonant_index_plus_1 == word.length) {\n        return \"\";\n    }\n    if (vowel_index_plus_1 == word.length) {\n        return \"\";\n    }\n    if (vowels.indexOf(word[consonant_index_plus_1]) == -1) {\n        return \"\";\n    }\n    if (vowels.indexOf(word[vowel_index_plus_1]) == -1) {\n        return \"\";\n    }\n    return word[consonant_index_plus_1];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjna19wzy.rs:20:8\n   |\n20 |     if (consonant_index == -1 || vowel_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (consonant_index == -1 || vowel_index == -1) {\n20 +     if consonant_index == -1 || vowel_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjna19wzy.rs:25:8\n   |\n25 |     if (consonant_index_plus_1 == word.length) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (consonant_index_plus_1 == word.length) {\n25 +     if consonant_index_plus_1 == word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjna19wzy.rs:28:8\n   |\n28 |     if (vowel_index_plus_1 == word.length) {\n   |        ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index_plus_1 == word.length) {\n28 +     if vowel_index_plus_1 == word.length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjna19wzy.rs:31:8\n   |\n31 |     if (vowels.indexOf(word[consonant_index_plus_1]) == -1) {\n   |        ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n31 -     if (vowels.indexOf(word[consonant_index_plus_1]) == -1) {\n31 +     if vowels.indexOf(word[consonant_index_plus_1]) == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjna19wzy.rs:34:8\n   |\n34 |     if (vowels.indexOf(word[vowel_index_plus_1]) == -1) {\n   |        ^                                              ^\n   |\nhelp: remove these parentheses\n   |\n34 -     if (vowels.indexOf(word[vowel_index_plus_1]) == -1) {\n34 +     if vowels.indexOf(word[vowel_index_plus_1]) == -1 {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpjna19wzy.rs:18:38\n   |\n18 |     let consonant_i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppcz7rui2.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppcz7rui2.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppcz7rui2.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppcz7rui2.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppcz7rui2.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for reference `&str` in the current scope\n  --> /tmp/tmppcz7rui2.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `&str`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmppcz7rui2.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\n        \"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"\n    ];\n    let consonants = [\n        \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"\n    ];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp357r15zq.rs:26:10\n   |\n26 |     for (let i = 0; i < word.length; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp357r15zq.rs:26:14\n   |\n26 |     for (let i = 0; i < word.length; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp357r15zq.rs:26:16\n   |\n26 |     for (let i = 0; i < word.length; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp357r15zq.rs:26:15\n   |\n26 |     for (let i = 0; i < word.length; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp357r15zq.rs:26:16\n   |\n26 |     for (let i = 0; i < word.length; i++) {\n   |                ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp357r15zq.rs:53:9\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n53 |     for (let i = 0; i < word.length;\n   |         ^ unclosed delimiter\n54 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp357r15zq.rs:22:38\n   |\n22 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp357r15zq.rs:22:46\n   |\n22 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<us",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .filter(c => vowels.indexOf(c) == -1);\n    let consonant_index = consonants.indexOf(word.chars().find(c => vowels.indexOf(c) != -1));\n    let vowel_index = consonants.indexOf(word.chars().find(c => vowels.indexOf(c) != -1), consonant_index + 1);\n    return word.chars().slice(vowel_index, consonant_index + 1).join(\"\");\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpyyym6v4y.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        } else {\n            break;\n        }\n    }\n    for (let i = word.length - 1; i > 0; i--) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        } else {\n            break;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpmo2s2zry.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpmo2s2zry.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpmo2s2zry.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpmo2s2zry.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpmo2s2zry.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpmo2s2zry.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpmo2s2zry.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n    }\n    for (let i = vowel_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let consonant_index_plus_1 = consonants.indexOf(word[consonant_index + 1]);\n    let vowel_index_plus_1 = vowels.indexOf(word[vowel_index + 1]);\n    if (consonant_index_plus_1 == -1 || vowel_index_plus_1 == -1) {\n        return \"\";\n    }\n    let consonant_count_plus_1 = 0;\n    let vowel_count_plus_1 = 0;\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) != -1) {\n            consonant_count_plus_1 += 1;\n        }\n    }\n    for (let i = vowel_index + 1; i < word.length - 1; i++) {\n        if (vowels\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp33s874we.rs:66:3\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - unclosed delimiter\n...\n47 |     for (let i = vowel_index + 1; i < word.length - 1; i++) {\n   |                                                             - this delimiter might not be properly closed...\n48 |         if (vowels\n49 | }\n   | - ...as it matches this but it has different indentation\n...\n66 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmp33s874we.rs:22:10\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp33s874we.rs:22:14\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp33s874we.rs:22:16\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp33s874we.rs:22:15\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp33s874we.rs:22:16\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp33s874we.rs:48:12\n   |\n15 | fn get_closest_vowel(word: String) -> String {\n   |                                              - closing delimiter possibly meant for this\n...\n48 |         if (vowels\n   |            ^ unclosed delimiter\n49 | }\n   | ^ mismatched closing delimiter\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp33s874we.rs:1",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = 0; i < word.length(); i++) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpaoc0gw2k.rs:21:10\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpaoc0gw2k.rs:21:14\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpaoc0gw2k.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpaoc0gw2k.rs:21:15\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpaoc0gw2k.rs:21:16\n   |\n21 |     for (let i = 0; i < word.length(); i++) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_index) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) > -1) {\n            consonant_count += 1;\n            if (consonant_count > consonant_index) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpfywl98xn.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpfywl98xn.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpfywl98xn.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpfywl98xn.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpfywl98xn.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpfywl98xn.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpfywl98xn.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpzqt79prf.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpzqt79prf.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpzqt79prf.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpzqt79prf.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpzqt79prf.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpzqt79prf.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_index_next = consonants.indexOf(word[1]);\n    let vowel_index_next = vowels.indexOf(word[word.length - 2]);\n    if (vowel_index_next >= 0 && consonant_index_next >= 0) {\n        return vowels[vowel_index_next];\n    }\n    if (vowel_index >= 0 && consonant_index_next >= 0) {\n        return vowels[vowel_index];\n    }\n    if (vowel_index >= 0 && vowel_index_next >= 0) {\n        return vowels[vowel_index];\n    }\n    if (vowel_index >= 0 && vowel_index_next < 0) {\n        return vowels[vowel_index];\n    }\n    if (vowel_index_next >= 0 && vowel_index < 0) {\n        return vowels[vowel_index_next];\n    }\n    if (vowel_index < 0 && vowel_index_next >= 0) {\n        return vowels[vowel_index_next];\n    }\n    if (vowel_index < 0 && vowel_index_next < 0) {\n        return \"\";\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe15k56tw.rs:22:8\n   |\n22 |     if (vowel_index_next >= 0 && consonant_index_next >= 0) {\n   |        ^                                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n22 -     if (vowel_index_next >= 0 && consonant_index_next >= 0) {\n22 +     if vowel_index_next >= 0 && consonant_index_next >= 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe15k56tw.rs:25:8\n   |\n25 |     if (vowel_index >= 0 && consonant_index_next >= 0) {\n   |        ^                                             ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (vowel_index >= 0 && consonant_index_next >= 0) {\n25 +     if vowel_index >= 0 && consonant_index_next >= 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe15k56tw.rs:28:8\n   |\n28 |     if (vowel_index >= 0 && vowel_index_next >= 0) {\n   |        ^                                         ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (vowel_index >= 0 && vowel_index_next >= 0) {\n28 +     if vowel_index >= 0 && vowel_index_next >= 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe15k56tw.rs:31:8\n   |\n31 |     if (vowel_index >= 0 && vowel_index_next < 0) {\n   |        ^                                        ^\n   |\nhelp: remove these parentheses\n   |\n31 -     if (vowel_index >= 0 && vowel_index_next < 0) {\n31 +     if vowel_index >= 0 && vowel_index_next < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe15k56tw.rs:34:8\n   |\n34 |     if (vowel_index_next >= 0 && vowel_index < 0) {\n   |        ^                                        ^\n   |\nhelp: remove these parentheses\n   |\n34 -     if (vowel_index_next >= 0 && vowel_index < 0) {\n34 +     if vowel_index_next >= 0 && vowel_index < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe15k56tw.rs:37:8\n   |\n37 |     if (vowel_index < 0",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .filter(c => vowels.indexOf(c) == -1)\n        .map(c => c.toLowerCase())\n        .sort();\n    let consonant_index = consonants.indexOf(\"q\");\n    let vowel_index = consonants[consonant_index + 1] == \"y\" ? 1 : consonants[consonant_index + 1] == \"w\" ? 2 : consonants[consonant_index + 1] == \"x\" ? 3 : consonants[consonant_index + 1] == \"z\" ? 4 : -1;\n    return vowels[vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpdcs6eqgo.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpuhg_ck1y.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpuhg_ck1y.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpuhg_ck1y.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpuhg_ck1y.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpuhg_ck1y.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let result = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        if (vowels.indexOf(word[i]) > -1) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                result = word[i];\n                break;\n            }\n        } else if (consonants.indexOf(word[i]) > -1) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                result = word[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmprbps9euc.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmprbps9euc.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmprbps9euc.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmprbps9euc.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmprbps9euc.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpdqwnmz78.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpdqwnmz78.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpdqwnmz78.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpdqwnmz78.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpdqwnmz78.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpdqwnmz78.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpdqwnmz78.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `indexOf` found for arra",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = word.chars()\n        .filter(c => c != \" \")\n        .map(c => c.toLowerCase())\n        .filter(c => vowels.indexOf(c) == -1);\n    let consonant_index = consonants.indexOf(consonants.last());\n    if (consonant_index == -1) {\n        return \"\";\n    }\n    let vowel_index = consonants.slice(consonant_index).indexOf(vowels.last());\n    return vowels[vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmprey3aour.rs:18:19\n   |\n18 |         .filter(c => c != \" \")\n   |                   ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = \"aeiouAEIOU\";\n    let consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[1]);\n    let consonant_count = word.length - 1;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < consonant_count; i++) {\n        if (vowels.indexOf(word[i]) >= 0) {\n            vowel_count += 1;\n            closest_vowel = word[i];\n        } else if (vowels.indexOf(word[i]) < 0) {\n            if (vowel_count > 0) {\n                vowel_count -= 1;\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpwqu_i9jn.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < consonant_count; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpwqu_i9jn.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < consonant_count; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpwqu_i9jn.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < consonant_count; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpwqu_i9jn.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < consonant_count; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpwqu_i9jn.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < consonant_count; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for reference `&str` in the current scope\n  --> /tmp/tmpwqu_i9jn.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `&str`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpwqu_i9jn.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = 0; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            closest_vowel = word[i];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpmlsgwcpg.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpmlsgwcpg.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpmlsgwcpg.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpmlsgwcpg.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpmlsgwcpg.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpmlsgwcpg.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpmlsgwcpg.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let result = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                result = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                result = word[i];\n            }\n        }\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpyp4vj3za.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpyp4vj3za.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpyp4vj3za.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpyp4vj3za.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpyp4vj3za.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpyp4vj3za.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpyp4vj3za.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0 || consonant_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < vowel_index; i++) {\n        closest_vowel += vowels[i];\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpc2f89wo8.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpc2f89wo8.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpc2f89wo8.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpc2f89wo8.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpc2f89wo8.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpc2f89wo8.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpc2f89wo8.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) != -1) {\n            consonant_count += 1;\n        }\n    }\n    for (let i = vowel_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) != -1) {\n            vowel_count += 1;\n        }\n    }\n    if (consonant_count == 0 || vowel_count == 0) {\n        return \"\";\n    }\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) != -1) {\n            closest_vowel = vowels[vowel_count - 1];\n            break;\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpvginbq3s.rs:22:10\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpvginbq3s.rs:22:14\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvginbq3s.rs:22:16\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvginbq3s.rs:22:15\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvginbq3s.rs:22:16\n   |\n22 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpvginbq3s.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpvginbq3s.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > -1) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.indexOf(word[i]) > -1) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpajagpgja.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpajagpgja.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpajagpgja.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpajagpgja.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpajagpgja.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpajagpgja.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpajagpgja.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let vowels_count = 0;\n    let consonants_count = 0;\n    let closest_vowel = \"\";\n    for (let i = word.length() - 1; i >= 0; i--) {\n        if (vowels.includes(word[i])) {\n            vowels_count += 1;\n            if (vowels_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        } else if (consonants.includes(word[i])) {\n            consonants_count += 1;\n            if (consonants_count > 1) {\n                closest_vowel = word[i];\n                break;\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpvzt5vkqo.rs:21:10\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpvzt5vkqo.rs:21:14\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvzt5vkqo.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvzt5vkqo.rs:21:15\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvzt5vkqo.rs:21:16\n   |\n21 |     for (let i = word.length() - 1; i >= 0; i--) {\n   |                ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index < consonant_index) {\n        return word[word.length - 1];\n    }\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            return word[i];\n        }\n    }\n    return \"\";\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppcaj790d.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppcaj790d.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppcaj790d.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppcaj790d.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppcaj790d.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppcaj790d.rs:20:8\n   |\n20 |     if (vowel_index < consonant_index) {\n   |        ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index < consonant_index) {\n20 +     if vowel_index < consonant_index {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmppcaj790d.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmppcaj790d.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not im",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (consonants.indexOf(word[i]) > consonant_index) {\n            consonant_count += 1;\n        }\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_count += 1;\n        }\n    }\n    if (vowel_count == 0 || consonant_count == 0) {\n        return \"\";\n    }\n    let vowel_index = 0;\n    for (let i = 0; i < word.length - 1; i++) {\n        if (vowels.indexOf(word[i]) > vowel_index) {\n            vowel_index = vowels.indexOf(word[i]);\n        }\n    }\n    return vowels[vowel_index];\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpa6hqd_j0.rs:22:10\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpa6hqd_j0.rs:22:14\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpa6hqd_j0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpa6hqd_j0.rs:22:15\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpa6hqd_j0.rs:22:16\n   |\n22 |     for (let i = 0; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmpa6hqd_j0.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpa6hqd_j0.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `ind",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    if (vowel_index == -1 || consonant_index == -1) {\n        return \"\"\n    } else if (vowel_index == consonant_index) {\n        return \"\"\n    } else if (vowel_index > consonant_index) {\n        return \"\"\n    } else {\n        let i = consonant_index + 1;\n        while (i < vowel_index) {\n            if (vowels.includes(word[i])) {\n                return word[i]\n            }\n            i += 1\n        }\n        return \"\"\n    }\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292971,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp06vyt3sv.rs:20:8\n   |\n20 |     if (vowel_index == -1 || consonant_index == -1) {\n   |        ^                                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (vowel_index == -1 || consonant_index == -1) {\n20 +     if vowel_index == -1 || consonant_index == -1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp06vyt3sv.rs:22:15\n   |\n22 |     } else if (vowel_index == consonant_index) {\n   |               ^                              ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (vowel_index == consonant_index) {\n22 +     } else if vowel_index == consonant_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp06vyt3sv.rs:24:15\n   |\n24 |     } else if (vowel_index > consonant_index) {\n   |               ^                             ^\n   |\nhelp: remove these parentheses\n   |\n24 -     } else if (vowel_index > consonant_index) {\n24 +     } else if vowel_index > consonant_index {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp06vyt3sv.rs:28:15\n   |\n28 |         while (i < vowel_index) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n28 -         while (i < vowel_index) {\n28 +         while i < vowel_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp06vyt3sv.rs:29:16\n   |\n29 |             if (vowels.includes(word[i])) {\n   |                ^                        ^\n   |\nhelp: remove these parentheses\n   |\n29 -             if (vowels.includes(word[i])) {\n29 +             if vowels.includes(word[i]) {\n   | \n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp06vyt3sv.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `Strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a word. Your task is to find the closest vowel that stands between \n/// two consonants from the right side of the word (case sensitive).\n/// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n/// find any vowel met the above condition. \n/// You may assume that the given string contains English letter only.\n/// Example:\n/// >>> get_closest_vowel(String::from(\"yogurt\"))\n/// String::from(\"u\")\n/// >>> get_closest_vowel(String::from(\"FULL\"))\n/// String::from(\"U\")\n/// >>> get_closest_vowel(String::from(\"quick\"))\n/// String::from(\"\")\n/// >>> get_closest_vowel(String::from(\"ab\"))\n/// String::from(\"\")\nfn get_closest_vowel(word: String) -> String {\n    let vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"];\n    let consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let consonant_index = consonants.indexOf(word[0]);\n    let vowel_index = vowels.indexOf(word[word.length - 1]);\n    let consonant_count = 0;\n    let vowel_count = 0;\n    let closest_vowel = \"\";\n    for (let i = consonant_index + 1; i < word.length - 1; i++) {\n        if (vowels.includes(word[i])) {\n            vowel_count += 1;\n            if (vowel_count > vowel_count) {\n                closest_vowel = word[i];\n            }\n        } else if (consonants.includes(word[i])) {\n            consonant_count += 1;\n            if (consonant_count > consonant_count) {\n                closest_vowel = word[i];\n            }\n        }\n    }\n    return closest_vowel;\n}\n\nfn main() {\n    let candidate = get_closest_vowel;\n    assert_eq!(candidate(String::from(\"yogurt\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"full\")), String::from(\"u\"));\n    assert_eq!(candidate(String::from(\"easy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"eAsy\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ali\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"bad\")), String::from(\"a\"));\n    assert_eq!(candidate(String::from(\"most\")), String::from(\"o\"));\n    assert_eq!(candidate(String::from(\"ab\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"ba\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"quick\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"anime\")), String::from(\"i\"));\n    assert_eq!(candidate(String::from(\"Asia\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Above\")), String::from(\"o\"));\n}\n",
      "timestamp": 1664292970,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp4bf2xszx.rs:23:10\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |          ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp4bf2xszx.rs:23:14\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp4bf2xszx.rs:23:15\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp4bf2xszx.rs:23:16\n   |\n23 |     for (let i = consonant_index + 1; i < word.length - 1; i++) {\n   |                ^ expected expression\n\nerror[E0599]: no method named `indexOf` found for array `[&str; 21]` in the current scope\n  --> /tmp/tmp4bf2xszx.rs:18:38\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                      ^^^^^^^ method not found in `[&str; 21]`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp4bf2xszx.rs:18:46\n   |\n18 |     let consonant_index = consonants.indexOf(word[0]);\n   |                                              ^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<s",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}