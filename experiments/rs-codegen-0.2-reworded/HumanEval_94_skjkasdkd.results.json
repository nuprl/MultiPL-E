{
  "name": "HumanEval_94_skjkasdkd",
  "language": "rs",
  "prompt": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n",
  "tests": "}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = 0;\n  while max > 0 {\n    digits += 1;\n    max /= 10;\n  }\n  return sum + digits;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpq61w2vuk.rs:21:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n21 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpq61w2vuk.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `digits`\n  --> /tmp/tmpq61w2vuk.rs:27:5\n   |\n25 |   let digits = 0;\n   |       ------\n   |       |\n   |       first assignment to `digits`\n   |       help: consider making this binding mutable: `mut digits`\n26 |   while max > 0 {\n27 |     digits += 1;\n   |     ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpq61w2vuk.rs:28:5\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n28 |     max /= 10;\n   |     ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpj8l35a5a.rs:26:14\n   |\n26 |     for j in range(i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    sum += i;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpakrycq_b.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpakrycq_b.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  max_prime_sum -= max_prime;\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpfww3yz5_.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:25:3\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n25 |   max_prime_sum -= max_prime;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0\n  for i in lst {\n    if i > max {\n      max = i\n    }\n  }\n  let sum = 0\n  for i in lst {\n    sum += i\n  }\n  return sum\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpa4hw8wb2.rs:17:14\n   |\n17 |   let max = 0\n   |              ^ help: add `;` here\n18 |   for i in lst {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpa4hw8wb2.rs:23:14\n   |\n23 |   let sum = 0\n   |              ^ help: add `;` here\n24 |   for i in lst {\n   |   --- unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    sum += i;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpakrycq_b.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpakrycq_b.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(0, i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpos5cuj4f.rs:26:14\n   |\n26 |     for j in range(0, i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n      max_prime_sum = 0;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpzgatxsvf.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:22:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n22 |       max_prime_sum = 0;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:24:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n24 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % max;\n    sum += d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpysvoqjy8.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpysvoqjy8.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpysvoqjy8.rs:26:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |     sum += d;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0\n  for i in lst {\n    if i > max {\n      max = i\n    }\n  }\n  let sum = 0\n  for i in lst {\n    sum += i\n  }\n  return sum\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpa4hw8wb2.rs:17:14\n   |\n17 |   let max = 0\n   |              ^ help: add `;` here\n18 |   for i in lst {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpa4hw8wb2.rs:23:14\n   |\n23 |   let sum = 0\n   |              ^ help: add `;` here\n24 |   for i in lst {\n   |   --- unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = to_string(max);\n  let sum_of_digits = 0;\n  for i in range(0, len(digits)) {\n    sum_of_digits += digits[i];\n  }\n  return sum_of_digits;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmp1gdbcagq.rs:25:16\n   |\n25 |   let digits = to_string(max);\n   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmp1gdbcagq.rs:27:12\n   |\n27 |   for i in range(0, len(digits)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp1gdbcagq.rs:27:21\n   |\n27 |   for i in range(0, len(digits)) {\n   |                     ^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    if i == max_prime {\n      max_prime_sum += i;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpku8f025q.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpku8f025q.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n19  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n19  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpku8f025q.rs:26:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n26 |       max_prime_sum += i;\n   |       ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0\n  let max_prime_sum = 0\n  for i in lst {\n    if i > max_prime {\n      max_prime = i\n      max_prime_sum = 0\n    }\n    max_prime_sum += i\n  }\n  return max_prime_sum\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpgtflun03.rs:17:20\n   |\n17 |   let max_prime = 0\n   |                    ^ help: add `;` here\n18 |   let max_prime_sum = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpgtflun03.rs:18:24\n   |\n18 |   let max_prime_sum = 0\n   |                        ^ help: add `;` here\n19 |   for i in lst {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_prime_sum`\n  --> /tmp/tmpgtflun03.rs:21:20\n   |\n21 |       max_prime = i\n   |                    ^ help: add `;` here\n22 |       max_prime_sum = 0\n   |       ------------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % max_prime;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmprcm5h9es.rs:20:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n20 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmprcm5h9es.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max_prime = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmprcm5h9es.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % max_prime;\n   |     ^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % max_prime;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmprcm5h9es.rs:20:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n20 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmprcm5h9es.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max_prime = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmprcm5h9es.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % max_prime;\n   |     ^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = to_string(max);\n  let sum_digits = to_string(sum);\n  let max_digits = to_string(max);\n  let sum_digits_max = to_string(sum);\n  let max_digits_sum = to_string(max);\n  let sum_digits_max_digits = to_string(sum);\n  let max_digits_sum_digits = to_string(max);\n  let sum_digits_max_digits_digits = to_string(sum);\n  let max_digits_sum_digits_digits = to_string(max);\n  let sum_digits_max_digits_digits_digits = to_string(sum);\n  let max_digits_sum_digits_digits_digits = to_string(max);\n  let sum_digits_max_digits_digits_digits_digits = to_string(sum);\n  let max_digits_sum_digits_digits_digits_digits = to_string(max);\n  let sum_digits_max_digits_digits_digits_digits_digits = to_string(sum);\n  let max_digits_sum_digits_digits_digits_digits_digits = to_string(max);\n  let sum_digits_max_digits_digits_digits_digits_digits_digits = to_string(sum);\n  let max_digits_sum_digits_digits_digits_digits_digits_digits = to_string(max);\n  let sum_digits_max_digits_digits_digits_digits_digits_digits_digits = to_string(sum);\n  let max_digits_sum_digits_digits_digits_digits_digits_digits_digits = to_string(max);\n  let\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmpon7nyarr.rs:45:1\n   |\n45 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:25:16\n   |\n25 |   let digits = to_string(max);\n   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:26:20\n   |\n26 |   let sum_digits = to_string(sum);\n   |                    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:27:20\n   |\n27 |   let max_digits = to_string(max);\n   |                    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:28:24\n   |\n28 |   let sum_digits_max = to_string(sum);\n   |                        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:29:24\n   |\n29 |   let max_digits_sum = to_string(max);\n   |                        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:30:31\n   |\n30 |   let sum_digits_max_digits = to_string(sum);\n   |                               ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:31:31\n   |\n31 |   let max_digits_sum_digits = to_string(max);\n   |                               ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:32:38\n   |\n32 |   let sum_digits_max_digits_digits = to_string(sum);\n   |                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpon7nyarr.rs:33:38\n   |\n33 |   let max_digits_sum_digits_digits = to_string(max);\n   |                                      ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpxoiv0tn6.rs:21:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n21 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpxoiv0tn6.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let n = i;\n    while n > 0 {\n      sum += n % 10;\n      n /= 10;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmp__qackuk.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmp__qackuk.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp__qackuk.rs:27:7\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n27 |       sum += n % 10;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmp__qackuk.rs:28:7\n   |\n25 |     let n = i;\n   |         -\n   |         |\n   |         first assignment to `n`\n   |         help: consider making this binding mutable: `mut n`\n...\n28 |       n /= 10;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n      max_prime_sum = 0;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpzgatxsvf.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:22:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n22 |       max_prime_sum = 0;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:24:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n24 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % max_prime;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmprcm5h9es.rs:20:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n20 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmprcm5h9es.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max_prime = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmprcm5h9es.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % max_prime;\n   |     ^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = to_string(sum);\n  let result = 0;\n  for i in range(0, digits.len) {\n    result += digits[i] - '0';\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpmaz99xzr.rs:25:16\n   |\n25 |   let digits = to_string(sum);\n   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpmaz99xzr.rs:27:12\n   |\n27 |   for i in range(0, digits.len) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  max_prime_sum %= 10;\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpxxurdji9.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpxxurdji9.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpxxurdji9.rs:25:3\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n25 |   max_prime_sum %= 10;\n   |   ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = 0;\n  while max > 0 {\n    digits += 1;\n    max /= 10;\n  }\n  return sum + digits;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpq61w2vuk.rs:21:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n21 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpq61w2vuk.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `digits`\n  --> /tmp/tmpq61w2vuk.rs:27:5\n   |\n25 |   let digits = 0;\n   |       ------\n   |       |\n   |       first assignment to `digits`\n   |       help: consider making this binding mutable: `mut digits`\n26 |   while max > 0 {\n27 |     digits += 1;\n   |     ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpq61w2vuk.rs:28:5\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n28 |     max /= 10;\n   |     ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    sum += i;\n  }\n  sum = sum % 10;\n  if sum == 0 {\n    sum = 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpws3z4i21.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpws3z4i21.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpws3z4i21.rs:25:3\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n25 |   sum = sum % 10;\n   |   ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpws3z4i21.rs:27:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n27 |     sum = 10;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n      max_prime_sum = 0;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpzgatxsvf.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:22:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n22 |       max_prime_sum = 0;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:24:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n24 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = to_string(sum);\n  let max_digits = to_string(max);\n  let max_digits_len = len(max_digits);\n  let max_digits_count = max_digits_len - 1;\n  let max_digits_index = max_digits_count - 1;\n  let max_digits_index_str = to_string(max_digits_index);\n  let max_digits_index_str_len = len(max_digits_index_str);\n  let max_digits_index_str_count = max_digits_index_str_len - 1;\n  let max_digits_index_str_index = max_digits_index_str_count - 1;\n  let max_digits_index_str_index_str = to_string(max_digits_index_str_index);\n  let max_digits_index_str_index_str_len = len(max_digits_index_str_index_str);\n  let max_digits_index_str_index_str_count = max_digits_index_str_index_str_len - 1;\n  let max_digits_index_str_index_str_index = max_digits_index_str_index_str_count - 1;\n  let max_digits_index_str_index_str_index_str = to_string(max_digits_index_str_index_str_index);\n  let max_digits_index_str_index_str_index_str_len = len(max_digits_index_str_index_str_index_str);\n  let max_digits_index_str_index_str_index_str_count = max_digits_index_str_index_str_index_str_len - 1;\n  let max_digits_index_str_index_str_index_str_index = max_digits_\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpsga_rfxe.rs:41:67\n   |\n41 |   let max_digits_index_str_index_str_index_str_index = max_digits_\n   |                                                                   ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpsga_rfxe.rs:25:16\n   |\n25 |   let digits = to_string(sum);\n   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpsga_rfxe.rs:26:20\n   |\n26 |   let max_digits = to_string(max);\n   |                    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpsga_rfxe.rs:27:24\n   |\n27 |   let max_digits_len = len(max_digits);\n   |                        ^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpsga_rfxe.rs:30:30\n   |\n30 |   let max_digits_index_str = to_string(max_digits_index);\n   |                              ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpsga_rfxe.rs:31:34\n   |\n31 |   let max_digits_index_str_len = len(max_digits_index_str);\n   |                                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpsga_rfxe.rs:34:40\n   |\n34 |   let max_digits_index_str_index_str = to_string(max_digits_index_str_index);\n   |                                        ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpsga_rfxe.rs:35:44\n   |\n35 |   let max_digits_index_str_index_str_len = len(max_digits_index_str_index_str);\n   |                                            ^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpsga_rfxe.rs:38:50\n   |\n38 |   let max_digits_index_str_index_str_index_str = to_string(max_digits_index_str_index_str_index);\n   |                               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % max;\n    sum += d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpysvoqjy8.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpysvoqjy8.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpysvoqjy8.rs:26:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |     sum += d;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % max;\n    sum = sum + d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpz8mc9bhy.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpz8mc9bhy.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpz8mc9bhy.rs:26:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |     sum = sum + d;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0\n  let sum = 0\n  for i in lst {\n    if i > max {\n      max = i\n    }\n    sum += i\n  }\n  return sum\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpqmm7qgq8.rs:17:14\n   |\n17 |   let max = 0\n   |              ^ help: add `;` here\n18 |   let sum = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpqmm7qgq8.rs:18:14\n   |\n18 |   let sum = 0\n   |              ^ help: add `;` here\n19 |   for i in lst {\n   |   --- unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(0, i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpos5cuj4f.rs:26:14\n   |\n26 |     for j in range(0, i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpxoiv0tn6.rs:21:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n21 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpxoiv0tn6.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = 0;\n  while max > 0 {\n    digits += 1;\n    max /= 10;\n  }\n  return sum + digits;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpq61w2vuk.rs:21:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n21 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpq61w2vuk.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `digits`\n  --> /tmp/tmpq61w2vuk.rs:27:5\n   |\n25 |   let digits = 0;\n   |       ------\n   |       |\n   |       first assignment to `digits`\n   |       help: consider making this binding mutable: `mut digits`\n26 |   while max > 0 {\n27 |     digits += 1;\n   |     ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpq61w2vuk.rs:28:5\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n28 |     max /= 10;\n   |     ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % max;\n    sum += d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpysvoqjy8.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpysvoqjy8.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpysvoqjy8.rs:26:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |     sum += d;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n      max_prime_sum = 0;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpzgatxsvf.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:22:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n22 |       max_prime_sum = 0;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:24:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n24 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0\n  for i in lst {\n    if i > max {\n      max = i\n    }\n  }\n  let sum = 0\n  for i in lst {\n    sum += i % 10\n  }\n  return sum\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp8h2w_hn2.rs:17:14\n   |\n17 |   let max = 0\n   |              ^ help: add `;` here\n18 |   for i in lst {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp8h2w_hn2.rs:23:14\n   |\n23 |   let sum = 0\n   |              ^ help: add `;` here\n24 |   for i in lst {\n   |   --- unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  sum = sum % 10;\n  if sum == 0 {\n    sum = 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpoexy1y18.rs:21:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n21 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpoexy1y18.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpoexy1y18.rs:25:3\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n25 |   sum = sum % 10;\n   |   ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpoexy1y18.rs:27:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n27 |     sum = 10;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  max_prime_sum -= max_prime;\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpfww3yz5_.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:25:3\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n25 |   max_prime_sum -= max_prime;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let num = i;\n    while num > 0 {\n      sum += num % 10;\n      num /= 10;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpgmtmrmtj.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpgmtmrmtj.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpgmtmrmtj.rs:27:7\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n27 |       sum += num % 10;\n   |       ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `num`\n  --> /tmp/tmpgmtmrmtj.rs:28:7\n   |\n25 |     let num = i;\n   |         ---\n   |         |\n   |         first assignment to `num`\n   |         help: consider making this binding mutable: `mut num`\n...\n28 |       num /= 10;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % max;\n    sum += d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpysvoqjy8.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpysvoqjy8.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpysvoqjy8.rs:26:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |     sum += d;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(0, i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpos5cuj4f.rs:26:14\n   |\n26 |     for j in range(0, i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  let max_prime_digits = 0;\n  for i in lst {\n    let prime = is_prime(i);\n    if prime {\n      if prime > max_prime {\n        max_prime = prime;\n        max_prime_digits = 0;\n        max_prime_sum = 0;\n      }\n      max_prime_digits = max_prime_digits + 1;\n      max_prime_sum = max_prime_sum + i;\n    }\n  }\n  return max_prime_sum + max_prime_digits;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpwc6kzzf9.rs:21:17\n   |\n21 |     let prime = is_prime(i);\n   |                 ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwc6kzzf9.rs:23:18\n   |\n23 |       if prime > max_prime {\n   |                  ^^^^^^^^^ expected `bool`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwc6kzzf9.rs:24:21\n   |\n17 |   let max_prime = 0;\n   |                   - expected due to this value\n...\n24 |         max_prime = prime;\n   |                     ^^^^^ expected integer, found `bool`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n      max_prime_sum = 0;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpzgatxsvf.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:22:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n22 |       max_prime_sum = 0;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:24:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n24 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    let num = i;\n    while num > 0 {\n      let d = num % 10;\n      if d > max {\n        max = d;\n      }\n      num /= 10;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % 10;\n    if d == max {\n      sum += d;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpffl7vpn3.rs:23:9\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n23 |         max = d;\n   |         ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `num`\n  --> /tmp/tmpffl7vpn3.rs:25:7\n   |\n19 |     let num = i;\n   |         ---\n   |         |\n   |         first assignment to `num`\n   |         help: consider making this binding mutable: `mut num`\n...\n25 |       num /= 10;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpffl7vpn3.rs:29:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n29  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpffl7vpn3.rs:32:7\n   |\n28 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n32 |       sum += d;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(0, i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpos5cuj4f.rs:26:14\n   |\n26 |     for j in range(0, i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % max;\n    sum += d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpysvoqjy8.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpysvoqjy8.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpysvoqjy8.rs:26:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |     sum += d;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    let num = i;\n    while num > 0 {\n      let d = num % 10;\n      if d > max {\n        max = d;\n      }\n      sum += d;\n      num /= 10;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpxkcgoi75.rs:24:9\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n24 |         max = d;\n   |         ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpxkcgoi75.rs:26:7\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |       sum += d;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `num`\n  --> /tmp/tmpxkcgoi75.rs:27:7\n   |\n20 |     let num = i;\n   |         ---\n   |         |\n   |         first assignment to `num`\n   |         help: consider making this binding mutable: `mut num`\n...\n27 |       num /= 10;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    let prime = is_prime(i);\n    if prime > max_prime {\n      max_prime = prime;\n      max_prime_sum = 0;\n    }\n    if prime == max_prime {\n      max_prime_sum += i;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpzi_iuff0.rs:20:17\n   |\n20 |     let prime = is_prime(i);\n   |                 ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  max_prime_sum -= max_prime;\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpfww3yz5_.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:25:3\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n25 |   max_prime_sum -= max_prime;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(0, i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpos5cuj4f.rs:26:14\n   |\n26 |     for j in range(0, i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i_to_digits(i);\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `i_to_digits` in this scope\n  --> /tmp/tmpy8saxgoa.rs:23:22\n   |\n23 |     max_prime_sum += i_to_digits(i);\n   |                      ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(0, i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpos5cuj4f.rs:26:14\n   |\n26 |     for j in range(0, i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(0, i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpos5cuj4f.rs:26:14\n   |\n26 |     for j in range(0, i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = 0;\n  while max > 0 {\n    digits += 1;\n    max /= 10;\n  }\n  return sum + digits;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpq61w2vuk.rs:21:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n21 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpq61w2vuk.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `digits`\n  --> /tmp/tmpq61w2vuk.rs:27:5\n   |\n25 |   let digits = 0;\n   |       ------\n   |       |\n   |       first assignment to `digits`\n   |       help: consider making this binding mutable: `mut digits`\n26 |   while max > 0 {\n27 |     digits += 1;\n   |     ^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpq61w2vuk.rs:28:5\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n28 |     max /= 10;\n   |     ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = to_string(sum);\n  let result = 0;\n  for i in range(0, len(digits)) {\n    result += digits[i] - '0';\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpqo2za7b5.rs:25:16\n   |\n25 |   let digits = to_string(sum);\n   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpqo2za7b5.rs:27:12\n   |\n27 |   for i in range(0, len(digits)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpqo2za7b5.rs:27:21\n   |\n27 |   for i in range(0, len(digits)) {\n   |                     ^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = to_string(sum);\n  let max_digits = to_string(max);\n  if max_digits.len > digits.len {\n    return max_digits.len;\n  } else {\n    return digits.len;\n  }\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpf76d4xc5.rs:25:16\n   |\n25 |   let digits = to_string(sum);\n   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpf76d4xc5.rs:26:20\n   |\n26 |   let max_digits = to_string(max);\n   |                    ^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0\n  for i in lst {\n    if i > max {\n      max = i\n    }\n  }\n  let sum = 0\n  for i in lst {\n    sum += i % 10\n  }\n  return sum\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp8h2w_hn2.rs:17:14\n   |\n17 |   let max = 0\n   |              ^ help: add `;` here\n18 |   for i in lst {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp8h2w_hn2.rs:23:14\n   |\n23 |   let sum = 0\n   |              ^ help: add `;` here\n24 |   for i in lst {\n   |   --- unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let n = i;\n    while n > 0 {\n      sum += n % 10;\n      n /= 10;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmp__qackuk.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmp__qackuk.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp__qackuk.rs:27:7\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n27 |       sum += n % 10;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmp__qackuk.rs:28:7\n   |\n25 |     let n = i;\n   |         -\n   |         |\n   |         first assignment to `n`\n   |         help: consider making this binding mutable: `mut n`\n...\n28 |       n /= 10;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    sum += i;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpakrycq_b.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpakrycq_b.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  max_prime_sum -= max_prime;\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpfww3yz5_.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:25:3\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n25 |   max_prime_sum -= max_prime;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for _ in lst {\n    max = max if max > primes[max] else max;\n  }\n  let sum = 0;\n  for _ in lst {\n    sum += primes[max] * primes[max] / primes[sum];\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found keyword `if`\n  --> /tmp/tmp4c80c8hp.rs:19:15\n   |\n19 |     max = max if max > primes[max] else max;\n   |               ^^ expected one of 8 possible tokens\n\nerror[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmp4c80c8hp.rs:23:12\n   |\n23 |     sum += primes[max] * primes[max] / primes[sum];\n   |            ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmp4c80c8hp.rs:23:26\n   |\n23 |     sum += primes[max] * primes[max] / primes[sum];\n   |                          ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `primes` in this scope\n  --> /tmp/tmp4c80c8hp.rs:23:40\n   |\n23 |     sum += primes[max] * primes[max] / primes[sum];\n   |                                        ^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0\n  for i in lst {\n    if i > max {\n      max = i\n    }\n  }\n  let sum = 0\n  for i in lst {\n    sum += i % 10\n  }\n  return sum\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp8h2w_hn2.rs:17:14\n   |\n17 |   let max = 0\n   |              ^ help: add `;` here\n18 |   for i in lst {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp8h2w_hn2.rs:23:14\n   |\n23 |   let sum = 0\n   |              ^ help: add `;` here\n24 |   for i in lst {\n   |   --- unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n    sum += i;\n  }\n  let digits = to_string(sum);\n  let max_digits = to_string(max);\n  let max_digits_len = len(max_digits);\n  let sum_digits = to_string(sum);\n  let sum_digits_len = len(sum_digits);\n  let max_digits_len_diff = max_digits_len - sum_digits_len;\n  let max_digits_diff = max_digits - sum_digits;\n  let max_digits_diff_len = len(max_digits_diff);\n  let max_digits_diff_len_diff = max_digits_diff_len - max_digits_len_diff;\n  let max_digits_diff_diff = max_digits_diff - max_digits_diff_len_diff;\n  let max_digits_diff_diff_len = len(max_digits_diff_diff);\n  let max_digits_diff_diff_len_diff = max_digits_diff_diff_len - max_digits_diff_len_diff;\n  let max_digits_diff_diff_diff_len = len(max_digits_diff_diff_len_diff);\n  let max_digits_diff_diff_diff_len_diff = max_digits_diff_diff_diff_len - max_digits_diff_diff_len_diff;\n  let max_digits_diff_diff_diff_diff_len = len(max_digits_diff_diff_diff_len_diff);\n  let max_digits_diff_diff_diff_diff_len_diff = max_digits_diff_diff_diff_diff_len - max_digits_diff_diff_diff_len_diff;\n  let max_digits_diff_diff_diff_diff_diff_len = len(max_digits_diff_diff_diff_diff_len_diff);\n  \n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpb4iatvnu.rs:25:16\n   |\n25 |   let digits = to_string(sum);\n   |                ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpb4iatvnu.rs:26:20\n   |\n26 |   let max_digits = to_string(max);\n   |                    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpb4iatvnu.rs:27:24\n   |\n27 |   let max_digits_len = len(max_digits);\n   |                        ^^^ not found in this scope\n\nerror[E0425]: cannot find function `to_string` in this scope\n  --> /tmp/tmpb4iatvnu.rs:28:20\n   |\n28 |   let sum_digits = to_string(sum);\n   |                    ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpb4iatvnu.rs:29:24\n   |\n29 |   let sum_digits_len = len(sum_digits);\n   |                        ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpb4iatvnu.rs:32:29\n   |\n32 |   let max_digits_diff_len = len(max_digits_diff);\n   |                             ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpb4iatvnu.rs:35:34\n   |\n35 |   let max_digits_diff_diff_len = len(max_digits_diff_diff);\n   |                                  ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpb4iatvnu.rs:37:39\n   |\n37 |   let max_digits_diff_diff_diff_len = len(max_digits_diff_diff_len_diff);\n   |                                       ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpb4iatvnu.rs:39:44\n   |\n39 |   let max_digits_diff_diff_diff_diff_len = len(max_digits_diff_diff_diff_len_diff);\n   |                                            ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpb4iatvnu.rs:41:49\n   |\n41 |   let max_digits_diff_diff_diff_diff_diff_len ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    let num = i;\n    while num > 0 {\n      let d = num % 10;\n      if d > max {\n        max = d;\n      }\n      num /= 10;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % 10;\n    if d > max {\n      d = max;\n    }\n    sum += d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpvxvmrum3.rs:23:9\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n23 |         max = d;\n   |         ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `num`\n  --> /tmp/tmpvxvmrum3.rs:25:7\n   |\n19 |     let num = i;\n   |         ---\n   |         |\n   |         first assignment to `num`\n   |         help: consider making this binding mutable: `mut num`\n...\n25 |       num /= 10;\n   |       ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpvxvmrum3.rs:29:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n29  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `d`\n  --> /tmp/tmpvxvmrum3.rs:32:7\n   |\n30 |     let d = i % 10;\n   |         -\n   |         |\n   |         first assignment to `d`\n   |         help: consider making this binding mutable: `mut d`\n31 |     if d > max {\n32 |       d = max;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpvxvmrum3.rs:34:5\n   |\n28 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n34 |     sum += d;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  max_prime_sum -= max_prime;\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpfww3yz5_.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpfww3yz5_.rs:25:3\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n25 |   max_prime_sum -= max_prime;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpj8l35a5a.rs:26:14\n   |\n26 |     for j in range(i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    sum += i;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpakrycq_b.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpakrycq_b.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % max;\n    sum += d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpysvoqjy8.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpysvoqjy8.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpysvoqjy8.rs:26:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |     sum += d;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    let sum = 0;\n    for j in i {\n      sum += j;\n    }\n    if sum > max {\n      max = sum;\n    }\n  }\n  return max;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0277]: `isize` is not an iterator\n  --> /tmp/tmpmqma4hda.rs:20:14\n   |\n20 |     for j in i {\n   |              ^ `isize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `isize`\n   = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n   = note: required because of the requirements on the impl of `IntoIterator` for `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % max_prime;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmprcm5h9es.rs:20:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n20 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmprcm5h9es.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max_prime = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmprcm5h9es.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % max_prime;\n   |     ^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    let d = i % max;\n    sum += d;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpysvoqjy8.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmpysvoqjy8.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpysvoqjy8.rs:26:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n26 |     sum += d;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n      max_prime_sum = 0;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpzgatxsvf.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:22:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n22 |       max_prime_sum = 0;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmpzgatxsvf.rs:24:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n24 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(0, i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpos5cuj4f.rs:26:14\n   |\n26 |     for j in range(0, i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n  }\n  for i in lst {\n    let sum = 0;\n    for j in range(i) {\n      sum += i % 10;\n      i /= 10;\n    }\n    if sum > max_prime_sum {\n      max_prime_sum = sum;\n    }\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpj8l35a5a.rs:26:14\n   |\n26 |     for j in range(i) {\n   |              ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    sum += i;\n  }\n  sum -= max_prime;\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmpbngw9376.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpbngw9376.rs:23:5\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n23 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpbngw9376.rs:25:3\n   |\n18 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n25 |   sum -= max_prime;\n   |   ^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max = 0;\n  for i in lst {\n    if i > max {\n      max = i;\n    }\n  }\n  let sum = 0;\n  for i in lst {\n    sum += i % 10;\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmptxl1r8fg.rs:20:7\n   |\n17 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n20 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `lst`\n   --> /tmp/tmptxl1r8fg.rs:24:12\n    |\n16  | fn skjkasdkd(lst: Vec<isize>) -> isize {\n    |              --- move occurs because `lst` has type `Vec<isize>`, which does not implement the `Copy` trait\n17  |   let max = 0;\n18  |   for i in lst {\n    |            --- `lst` moved due to this implicit call to `.into_iter()`\n...\n24  |   for i in lst {\n    |            ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `lst`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &lst {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptxl1r8fg.rs:25:5\n   |\n23 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n24 |   for i in lst {\n25 |     sum += i % 10;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  let max_prime_sum_digits = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n      max_prime_sum = 0;\n      max_prime_sum_digits = 0;\n    }\n    if i == max_prime {\n      max_prime_sum = max_prime_sum + i;\n      max_prime_sum_digits = max_prime_sum_digits + 1;\n    }\n  }\n  return max_prime_sum_digits;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp627dpw6u.rs:22:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n22 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp627dpw6u.rs:23:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |       max_prime_sum = 0;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum_digits`\n  --> /tmp/tmp627dpw6u.rs:24:7\n   |\n19 |   let max_prime_sum_digits = 0;\n   |       --------------------\n   |       |\n   |       first assignment to `max_prime_sum_digits`\n   |       help: consider making this binding mutable: `mut max_prime_sum_digits`\n...\n24 |       max_prime_sum_digits = 0;\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp627dpw6u.rs:27:7\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n27 |       max_prime_sum = max_prime_sum + i;\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum_digits`\n  --> /tmp/tmp627dpw6u.rs:28:7\n   |\n19 |   let max_prime_sum_digits = 0;\n   |       --------------------\n   |       |\n   |       first assignment to `max_prime_sum_digits`\n   |       help: consider making this binding mutable: `mut max_prime_sum_digits`\n...\n28 |       max_prime_sum_digits = max_prim",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You are given a vector of integers.\n/// You need to find the largest prime value and return the sum of its digits.\n/// Examples:\n/// >>> skjkasdkd(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3])\n/// 10\n/// >>> skjkasdkd(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1])\n/// 25\n/// >>> skjkasdkd(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3])\n/// 13\n/// >>> skjkasdkd(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6])\n/// 11\n/// >>> skjkasdkd(vec![0, 81, 12, 3, 1, 21])\n/// 3\n/// >>> skjkasdkd(vec![0, 8, 1, 2, 1, 7])\n/// 7\nfn skjkasdkd(lst: Vec<isize>) -> isize {\n  let max_prime = 0;\n  let max_prime_sum = 0;\n  for i in lst {\n    if i > max_prime {\n      max_prime = i;\n    }\n    max_prime_sum += i;\n  }\n  return max_prime_sum;\n}\n\nfn main() {\n    let candidate = skjkasdkd;\n    assert_eq!(candidate(vec![0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3]), 10);\n    assert_eq!(candidate(vec![1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1]), 25);\n    assert_eq!(candidate(vec![1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3]), 13);\n    assert_eq!(candidate(vec![0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6]), 11);\n    assert_eq!(candidate(vec![0, 81, 12, 3, 1, 21]), 3);\n    assert_eq!(candidate(vec![0, 8, 1, 2, 1, 7]), 7);\n    assert_eq!(candidate(vec![8191]), 19);\n    assert_eq!(candidate(vec![8191, 123456, 127, 7]), 19);\n    assert_eq!(candidate(vec![127, 97, 8192]), 10);\n}\n",
      "timestamp": 1664293109,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_prime`\n  --> /tmp/tmp32bgjczi.rs:21:7\n   |\n17 |   let max_prime = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_prime`\n   |       help: consider making this binding mutable: `mut max_prime`\n...\n21 |       max_prime = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_prime_sum`\n  --> /tmp/tmp32bgjczi.rs:23:5\n   |\n18 |   let max_prime_sum = 0;\n   |       -------------\n   |       |\n   |       first assignment to `max_prime_sum`\n   |       help: consider making this binding mutable: `mut max_prime_sum`\n...\n23 |     max_prime_sum += i;\n   |     ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}