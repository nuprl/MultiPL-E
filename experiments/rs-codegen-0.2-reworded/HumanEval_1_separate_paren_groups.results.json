{
  "name": "HumanEval_1_separate_paren_groups",
  "language": "rs",
  "prompt": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n      continue;\n    }\n    current += paren;\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp9rmcxsam.rs:27:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n24 |   }\n   |   - ...matches this closing brace\n...\n27 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp9rmcxsam.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      stack.push(String::from(i));\n    } else {\n      result.push(stack.pop());\n    }\n  }\n  result.push(stack.pop());\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmprqqwjls3.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmprqqwjls3.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprqqwjls3.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprqqwjls3.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprqqwjls3.rs:16:15\n   |\n16 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (open_parens == 0) {\n16 +     } else if open_parens == 0 {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if paren_string[i] == ' ' {\n      continue\n    }\n    if open_parens == 0 {\n      result.push(paren_string[i:i+1])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpuxxxigfs.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpuxxxigfs.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpuxxxigfs.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpuxxxigfs.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpuxxxigfs.rs:19:34\n   |\n19 |       result.push(paren_string[i:i+1])\n   |                                  ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n19 |       result.push(paren_string[i::i+1])\n   |                                 ~~\nhelp: a builtin type with a similar name exists\n   |\n19 |       result.push(paren_string[i:i8+1])\n   |                                  ~~\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpuxxxigfs.rs:19:14\n   |\n19 |       result.push(paren_string[i:i+1])\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuxxxigfs.rs:22:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n22 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let paren_stack = Vec::new()\n  let result = Vec::new()\n\n  for i in paren_string.chars() {\n    if paren_stack.len() == 0 {\n      if i == '(' {\n        open_parens += 1\n      } else if i == ')' {\n        open_parens -= 1\n      }\n    } else {\n      if i == '(' {\n        paren_stack.push(i)\n      } else if i == ')' {\n        if paren_stack.last() == '(' {\n          paren_stack.pop()\n        } else {\n          result.push(String::from(paren_stack.join()))\n          paren_stack.clear()\n        }\n      }\n    }\n  }\n\n  if paren_stack.len() > 0 {\n    result.push(String::from(paren_stack.join()))\n  }\n\n  result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp14u8_6u6.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let paren_stack = Vec::new()\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp14u8_6u6.rs:9:31\n   |\n9  |   let paren_stack = Vec::new()\n   |                               ^ help: add `;` here\n10 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp14u8_6u6.rs:10:26\n   |\n10 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n11 | \n12 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found `paren_stack`\n  --> /tmp/tmp14u8_6u6.rs:26:56\n   |\n26 |           result.push(String::from(paren_stack.join()))\n   |                                                        ^ help: add `;` here\n27 |           paren_stack.clear()\n   |           ----------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14u8_6u6.rs:23:34\n   |\n23 |         if paren_stack.last() == '(' {\n   |                                  ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&char>`\n              found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14u8_6u6.rs:24:11\n   |\n23 | /         if paren_stack.last() == '(' {\n24 | |           paren_stack.pop()\n   | |           ^^^^^^^^^^^^^^^^^ expected `()`, found enum `Option`\n25 | |         } else {\n26 | |           result.push(String::from(paren_stack.join()))\n27 | |           paren_stack.clear()\n28 | |         }\n   | |_________- expected this to be `()`\n   |\n   = note: expected unit type `()`\n                   found enum `Option<char>`\nhelp: consider using a semicolon here\n   |\n24 |           paren_stack.pop();\n   |                            +\nhelp: consider using a semicolon here\n   |\n28 |         };\n   |          +\n\nerror[E0599]: the method `join` exists for struct `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmp14u8_6u6.rs:26",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(paren_string[i:i+1])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpjxrsw3da.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjxrsw3da.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpjxrsw3da.rs:16:34\n   |\n16 |       result.push(paren_string[i:i+1])\n   |                                  ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n16 |       result.push(paren_string[i::i+1])\n   |                                 ~~\nhelp: a builtin type with a similar name exists\n   |\n16 |       result.push(paren_string[i:i8+1])\n   |                                  ~~\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpjxrsw3da.rs:16:14\n   |\n16 |       result.push(paren_string[i:i+1])\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxrsw3da.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if is_open_paren(i) {\n      stack.push(String::from(i));\n    } else if is_close_paren(i) {\n      if stack.is_empty() {\n        result.push(String::from(i));\n      } else {\n        let top = stack.last();\n        stack.pop();\n        result.push(top + String::from(i));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpfe4y2y39.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpfe4y2y39.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror[E0425]: cannot find function `is_open_paren` in this scope\n  --> /tmp/tmpfe4y2y39.rs:11:8\n   |\n11 |     if is_open_paren(i) {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_close_paren` in this scope\n  --> /tmp/tmpfe4y2y39.rs:13:15\n   |\n13 |     } else if is_close_paren(i) {\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(\"\"));\n      } else {\n        let top = stack.pop();\n        result.push(top);\n      }\n    }\n  }\n  if !stack.is_empty() {\n    result.push(stack.pop());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpzqu6rzfw.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpzqu6rzfw.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let paren_stack = Vec::new()\n  let result = Vec::new()\n\n  for i in paren_string.chars() {\n    if paren_stack.len() == 0 {\n      if i == '(' {\n        open_parens += 1\n      } else if i == ')' {\n        open_parens -= 1\n      }\n    } else {\n      if i == '(' {\n        paren_stack.push(i)\n      } else if i == ')' {\n        if paren_stack.last() == '(' {\n          paren_stack.pop()\n        } else {\n          result.push(String::from(paren_stack.join()))\n          paren_stack.clear()\n        }\n      }\n    }\n  }\n\n  if paren_stack.len() > 0 {\n    result.push(String::from(paren_stack.join()))\n  }\n\n  result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp14u8_6u6.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let paren_stack = Vec::new()\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp14u8_6u6.rs:9:31\n   |\n9  |   let paren_stack = Vec::new()\n   |                               ^ help: add `;` here\n10 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp14u8_6u6.rs:10:26\n   |\n10 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n11 | \n12 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found `paren_stack`\n  --> /tmp/tmp14u8_6u6.rs:26:56\n   |\n26 |           result.push(String::from(paren_stack.join()))\n   |                                                        ^ help: add `;` here\n27 |           paren_stack.clear()\n   |           ----------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14u8_6u6.rs:23:34\n   |\n23 |         if paren_stack.last() == '(' {\n   |                                  ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&char>`\n              found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14u8_6u6.rs:24:11\n   |\n23 | /         if paren_stack.last() == '(' {\n24 | |           paren_stack.pop()\n   | |           ^^^^^^^^^^^^^^^^^ expected `()`, found enum `Option`\n25 | |         } else {\n26 | |           result.push(String::from(paren_stack.join()))\n27 | |           paren_stack.clear()\n28 | |         }\n   | |_________- expected this to be `()`\n   |\n   = note: expected unit type `()`\n                   found enum `Option<char>`\nhelp: consider using a semicolon here\n   |\n24 |           paren_stack.pop();\n   |                            +\nhelp: consider using a semicolon here\n   |\n28 |         };\n   |          +\n\nerror[E0599]: the method `join` exists for struct `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmp14u8_6u6.rs:26",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"(\" {\n      stack.push(paren);\n    } else if paren == \")\" {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp2ev10ihx.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp2ev10ihx.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n      if (open_parens == 0) {\n        result.push(stack.pop());\n      }\n    } else {\n      stack.push(String::from(i));\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpb9ae67ek.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpb9ae67ek.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb9ae67ek.rs:13:8\n   |\n13 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i == '(') {\n13 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb9ae67ek.rs:15:15\n   |\n15 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (i == ')') {\n15 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb9ae67ek.rs:17:10\n   |\n17 |       if (open_parens == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (open_parens == 0) {\n17 +       if open_parens == 0 {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec::new();\n  let result = Vec::new();\n  paren_string.chars().for_each_char(|c, i| {\n    if c == '(' {\n      stack.push(i);\n    } else if c == ')' {\n      if stack.is_empty() {\n        result.push(String::from(paren_string.substr(stack.pop())));\n      } else {\n        stack.pop();\n      }\n    }\n  });\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no method named `for_each_char` found for struct `Chars` in the current scope\n  --> /tmp/tmp54fc0k1n.rs:10:24\n   |\n10 |   paren_string.chars().for_each_char(|c, i| {\n   |                        ^^^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `substr` found for struct `String` in the current scope\n  --> /tmp/tmp54fc0k1n.rs:15:47\n   |\n15 |         result.push(String::from(paren_string.substr(stack.pop())));\n   |                                               ^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut paren_count = 0;\n  let mut brace_count = 0;\n  let mut open_paren = false;\n  let mut open_brace = false;\n\n  for i in paren_string.chars() {\n    if paren_count == 0 {\n      if open_paren {\n        result.push(String::from(\"\"));\n        open_paren = false;\n      }\n      if open_brace {\n        result.push(String::from(\"\"));\n        open_brace = false;\n      }\n    }\n\n    if paren_count == 0 && open_brace {\n      result.push(String::from(\"\"));\n      open_brace = false;\n    }\n\n    if paren_count > 0 {\n      if open_paren {\n        result.push(String::from(\"\"));\n        open_paren = false;\n      }\n      if open_brace {\n        result.push(String::from(\"\"));\n        open_brace = false;\n      }\n    }\n\n    if paren_count == 0 && open_brace {\n      result.push(String::from(\"\"));\n      open_brace = false;\n    }\n\n    if open_paren {\n      result.push(String::from(\"\"));\n      open_paren = false;\n    }\n\n    if open_brace {\n      result.push(String::from(\"\"));\n      open_brace = false;\n    }\n\n    if paren_count == 0 {\n      if open_paren {\n        result.push(String::from(\"\"));\n        open_paren = false;\n      }\n      if open_brace {\n        result.push(String::from(\"\"));\n        open_brace = false;\n      }\n    }\n\n    if paren_count > 0 {\n      if open_paren {\n        result.push(String::from(\"\"));\n        open_paren = false;\n      }\n      if open_brace {\n        result.push(String::from(\"\"));\n        open_brace = false;\n      }\n    }\n\n    if paren_\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmprnke82qw.rs:89:3\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - unclosed delimiter\n...\n15 |   for i in paren_string.chars() {\n   |                                 - this delimiter might not be properly closed...\n...\n81 | }\n   | - ...as it matches this but it has different indentation\n...\n89 | }\n   |   ^\n\nerror: comparison operators cannot be chained\n --> /tmp/tmprnke82qw.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmprnke82qw.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror: expected `{`, found `}`\n  --> /tmp/tmprnke82qw.rs:81:1\n   |\n80 |     if paren_\n   |     -- this `if` expression has a condition, but no block\n81 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n --> /tmp/tmprnke82qw.rs:7:51\n  |\n7 | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n  |    ---------------------                          ^^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<String>`\n          found unit type `()`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic!(\"Mismatched parentheses\");\n      }\n    } else {\n      if stack.is_empty() {\n        result.push(String::from(i));\n      } else {\n        stack.push(i);\n      }\n    }\n  }\n  if !stack.is_empty() {\n    panic!(\"Mismatched parentheses\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpefxr1rc_.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpefxr1rc_.rs:14:16\n   |\n14 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpefxr1rc_.rs:21:15\n   |\n21 |         stack.push(i);\n   |               ^^^^ method not found in `[{integer}; 1]`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(String::from(i))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmplryujbhe.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplryujbhe.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmplryujbhe.rs:16:14\n   |\n16 |       result.push(String::from(i))\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplryujbhe.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(i));\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(i));\n      } else {\n        let top = stack.last();\n        stack.pop();\n        result.push(top + String::from(i));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp8i4pvxjg.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp8i4pvxjg.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      if current == \"\" {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current += paren;\n      }\n    } else {\n      current += paren;\n    }\n  }\n  if current != \"\" {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpd381idnz.rs:31:1\n   |\n27 |   if current != \"\" {\n   |                    - this opening brace...\n28 |     result.push(current);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpd381idnz.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic(\"Mismatched parentheses\");\n      }\n    } else {\n      if stack.is_empty() {\n        result.push(String::from(i));\n      } else {\n        stack.push(i);\n      }\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Unbalanced parentheses\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpttpxtegh.rs:15:9\n   |\n15 |         panic(\"Mismatched parentheses\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         panic!(\"Mismatched parentheses\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpttpxtegh.rs:26:5\n   |\n26 |     panic(\"Unbalanced parentheses\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n26 |     panic!(\"Unbalanced parentheses\");\n   |          +\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpttpxtegh.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpttpxtegh.rs:14:16\n   |\n14 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpttpxtegh.rs:21:15\n   |\n21 |         stack.push(i);\n   |               ^^^^ method not found in `[{integer}; 1]`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n      continue;\n    }\n    current += paren;\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp9rmcxsam.rs:27:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n24 |   }\n   |   - ...matches this closing brace\n...\n27 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp9rmcxsam.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    }\n\n    if (open_parens == 0) {\n      result.push(paren_stack.pop());\n    } else {\n      paren_stack.push(String::from(i));\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp5f__fkek.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmp5f__fkek.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5f__fkek.rs:13:8\n   |\n13 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i == '(') {\n13 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5f__fkek.rs:15:15\n   |\n15 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (i == ')') {\n15 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5f__fkek.rs:19:8\n   |\n19 |     if (open_parens == 0) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (open_parens == 0) {\n19 +     if open_parens == 0 {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic(\"Mismatched parentheses\");\n      }\n    }\n    if stack.is_empty() {\n      result.push(String::from(paren_string.sub(i, i + 1)));\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Unbalanced parentheses\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpwij1ipnj.rs:15:9\n   |\n15 |         panic(\"Mismatched parentheses\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         panic!(\"Mismatched parentheses\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpwij1ipnj.rs:23:5\n   |\n23 |     panic(\"Unbalanced parentheses\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n23 |     panic!(\"Unbalanced parentheses\");\n   |          +\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpwij1ipnj.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpwij1ipnj.rs:14:16\n   |\n14 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpwij1ipnj.rs:19:14\n   |\n19 |       result.push(String::from(paren_string.sub(i, i + 1)));\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `sub` found for struct `String` in the current scope\n  --> /tmp/tmpwij1ipnj.rs:19:45\n   |\n19 |       result.push(String::from(paren_string.sub(i, i + 1)));\n   |                                             ^^^ method not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpwij1ipnj.rs:19:54\n   |\n19 |       result.push(String::from(paren_string.sub(i, i + 1)));\n   |                                                    - ^ - {integer}\n   |                                                    |\n   |                                                    char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwij1ipnj.rs:25:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(\"(\"));\n    } else if c == ')' {\n      if stack.is_empty() {\n        throw \"unbalanced parens\";\n      }\n      let top = stack.last();\n      stack.pop();\n      if !stack.is_empty() {\n        stack.last() += top;\n      }\n      result.push(top);\n    }\n  });\n  if !stack.is_empty() {\n    throw \"unbalanced parens\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmprhomgebe.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmprhomgebe.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"unbalanced parens\"`\n  --> /tmp/tmprhomgebe.rs:15:15\n   |\n15 |         throw \"unbalanced parens\";\n   |               ^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"unbalanced parens\"`\n  --> /tmp/tmprhomgebe.rs:26:11\n   |\n26 |     throw \"unbalanced parens\";\n   |           ^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprhomgebe.rs:20:22\n   |\n20 |         stack.last() += top;\n   |         ------------ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0067`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      result.push(String::from(paren_stack.pop()));\n    }\n    paren_stack.push(String::from(i));\n  }\n  result.push(String::from(paren_stack.pop()));\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpbji8wgjl.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpbji8wgjl.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbji8wgjl.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbji8wgjl.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbji8wgjl.rs:16:15\n   |\n16 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (open_parens == 0) {\n16 +     } else if open_parens == 0 {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(String::from(i))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmplryujbhe.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplryujbhe.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmplryujbhe.rs:16:14\n   |\n16 |       result.push(String::from(i))\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplryujbhe.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for i in paren_string.chars() {\n    if i == '(' {\n      current_string += i;\n    } else if i == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += i;\n      }\n    } else {\n      current_string += i;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp43r83450.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:12:25\n   |\n12 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:18:27\n   |\n18 |         current_string += i;\n   |                           ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:21:25\n   |\n21 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else {\n      if current_string != \"\" {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      }\n      current_string += paren;\n    }\n  }\n  if current_string != \"\" {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpcbdporgj.rs:28:1\n   |\n24 |   if current_string != \"\" {\n   |                           - this opening brace...\n25 |     result.push(current_string);\n26 |   }\n   |   - ...matches this closing brace\n27 |   return result;\n28 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpcbdporgj.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(c));\n    } else if c == ')' {\n      if stack.is_empty() {\n        result.push(String::from(c));\n      } else {\n        let top = stack.last();\n        stack.pop();\n        result.push(top + String::from(c));\n      }\n    }\n  });\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpz6skufq4.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpz6skufq4.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(current);\n      current = String::from(\"\");\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current += i;\n      }\n    } else {\n      current += i;\n    }\n  }\n  if !stack.is_empty() {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmplf_9my00.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmplf_9my00.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplf_9my00.rs:20:20\n   |\n20 |         current += i;\n   |                    ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplf_9my00.rs:23:18\n   |\n23 |       current += i;\n   |                  ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.append(paren_string[i:i+1])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpwd4mfnrr.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpwd4mfnrr.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpwd4mfnrr.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpwd4mfnrr.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpwd4mfnrr.rs:16:36\n   |\n16 |       result.append(paren_string[i:i+1])\n   |                                    ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n16 |       result.append(paren_string[i::i+1])\n   |                                   ~~\nhelp: a builtin type with a similar name exists\n   |\n16 |       result.append(paren_string[i:i8+1])\n   |                                    ~~\n\nerror[E0599]: no method named `append` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpwd4mfnrr.rs:16:14\n   |\n16 |       result.append(paren_string[i:i+1])\n   |              ^^^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwd4mfnrr.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(String::from(i))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmplryujbhe.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplryujbhe.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmplryujbhe.rs:16:14\n   |\n16 |       result.push(String::from(i))\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplryujbhe.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n      continue;\n    }\n    current += paren;\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpn5m6dau2.rs:27:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n24 |   }\n   |   - ...matches this closing brace\n...\n27 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpn5m6dau2.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut current_string = String::new();\n\n  for paren in paren_string.chars() {\n    if paren == '(' {\n      stack.push(String::from(\"(\"));\n    } else if paren == ')' {\n      if stack.is_empty() {\n        result.push(current_string);\n        current_string = String::new();\n      } else {\n        current_string += stack.pop();\n      }\n    } else {\n      current_string += paren;\n    }\n  }\n\n  if !stack.is_empty() {\n    result.push(current_string);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmprp_r8nu8.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmprp_r8nu8.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprp_r8nu8.rs:23:25\n   |\n23 |       current_string += paren;\n   |                         ^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = [String::empty()];\n  let result = Vec::new();\n  for c in paren_string {\n    if c == '(' {\n      paren_stack.push(String::from(c));\n    } else if c == ')' {\n      if paren_stack.is_empty() {\n        panic!(\"Mismatched parentheses\");\n      }\n      let paren_str = paren_stack.pop();\n      result.push(paren_str);\n    }\n  }\n  if !paren_stack.is_empty() {\n    panic!(\"Mismatched parentheses\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `empty` found for struct `String` in the current scope\n --> /tmp/tmp2q7cj5ym.rs:8:30\n  |\n8 |   let paren_stack = [String::empty()];\n  |                              ^^^^^\n  |                              |\n  |                              function or associated item not found in `String`\n  |                              help: there is an associated function with a similar name: `is_empty`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp2q7cj5ym.rs:10:12\n   |\n10 |   for c in paren_string {\n   |            ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\" {\n      stack.push(paren);\n    } else if paren == \")\" {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n      }\n    } else {\n      stack.push(paren);\n    }\n  }\n  stack.pop();\n  if !stack.is_empty() {\n    throw \"Invalid input\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmppqs_80nw.rs:31:1\n   |\n27 |   if !stack.is_empty() {\n   |                        - this opening brace...\n28 |     throw \"Invalid input\";\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmppqs_80nw.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut open_braces = 0;\n  let mut last_char = String::from(\" \");\n  for i in paren_string.chars() {\n    if last_char == String::from(\" \") {\n      last_char = String::from(\"\")\n    }\n    if i == String::from(\"(\") {\n      open_braces += 1;\n      last_char = String::from(\"\")\n    }\n    if i == String::from(\")\") {\n      open_braces -= 1;\n      last_char = String::from(\"\")\n    }\n    if open_braces == 0 {\n      if last_char == String::from(\" \") {\n        last_char = String::from(\"\")\n      }\n      if last_char == String::from(\"\") {\n        result.push(stack.pop())\n      }\n      stack.push(String::from(i))\n      last_char = String::from(\"\")\n    }\n  }\n  if last_char == String::from(\" \") {\n    result.push(stack.pop())\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp783ia9qi.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp783ia9qi.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror: expected `;`, found `last_char`\n  --> /tmp/tmp783ia9qi.rs:31:34\n   |\n31 |       stack.push(String::from(i))\n   |                                  ^ help: add `;` here\n32 |       last_char = String::from(\"\")\n   |       --------- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp783ia9qi.rs:16:13\n   |\n16 |     if i == String::from(\"(\") {\n   |             ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp783ia9qi.rs:20:13\n   |\n20 |     if i == String::from(\")\") {\n   |             ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n      continue;\n    }\n    current += paren;\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp9rmcxsam.rs:27:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n24 |   }\n   |   - ...matches this closing brace\n...\n27 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp9rmcxsam.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if stack.is_empty() {\n        panic!(\"unbalanced parens\");\n      }\n      let top = stack.pop();\n      result.push(top);\n    }\n  }\n  if !stack.is_empty() {\n    panic!(\"unbalanced parens\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpf575z69y.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpf575z69y.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  let mut current_paren_count = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      current_paren_count += 1;\n    } else if i == ')' {\n      current_paren_count -= 1;\n    } else if i == ' ' {\n      if current_paren_count == 0 {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      }\n    } else {\n      current_string += i;\n    }\n  }\n  if current_paren_count != 0 {\n    panic!(\"Unbalanced parentheses\");\n  }\n  result.push(current_string);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpy731pbvu.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy731pbvu.rs:22:25\n   |\n22 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n    } else {\n      current += paren;\n    }\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpg1jr3bwp.rs:25:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |   }\n   |   - ...matches this closing brace\n...\n25 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpg1jr3bwp.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [String::from(\"\")];\n  for paren in paren_string.split(\"\") {\n    if paren == \"(\") {\n      stack.push(String::from(\"\"));\n    } else if paren == \")\") {\n      let top = stack.pop();\n      stack.push(top + paren);\n    } else {\n      stack[stack.len() - 1] += paren;\n    }\n  }\n  return stack.map(String::from);\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp4g30y4tm.rs:18:3\n   |\n15 |     } else {\n   |            - this opening brace...\n16 |       stack[stack.len() - 1] += paren;\n17 |     }\n   |     - ...matches this closing brace\n18 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp4g30y4tm.rs:9:39\n   |\n9  |   for paren in paren_string.split(\"\") {\n   |                                       ^ unclosed delimiter\n10 |     if paren == \"(\") {\n   |                    ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp4g30y4tm.rs:7:63\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               ^ unclosed delimiter\n...\n12 |     } else if paren == \")\") {\n   |                           ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  let current_string = String::empty()\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n      current_string += i\n    } else if i == ')' {\n      open_parens -= 1\n      current_string += i\n    } else if i == ' ' {\n      if open_parens == 0 {\n        result.append(current_string)\n        current_string = String::empty()\n      } else {\n        current_string += i\n      }\n    } else {\n      current_string += i\n    }\n  }\n  if open_parens > 0 {\n    panic(\"Not balanced\")\n  }\n  result.append(current_string)\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpacj4kjjq.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpacj4kjjq.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   let current_string = String::empty()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpacj4kjjq.rs:10:39\n   |\n10 |   let current_string = String::empty()\n   |                                       ^ help: add `;` here\n11 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found `current_string`\n  --> /tmp/tmpacj4kjjq.rs:13:23\n   |\n13 |       open_parens += 1\n   |                       ^ help: add `;` here\n14 |       current_string += i\n   |       -------------- unexpected token\n\nerror: expected `;`, found `current_string`\n  --> /tmp/tmpacj4kjjq.rs:16:23\n   |\n16 |       open_parens -= 1\n   |                       ^ help: add `;` here\n17 |       current_string += i\n   |       -------------- unexpected token\n\nerror: expected `;`, found `current_string`\n  --> /tmp/tmpacj4kjjq.rs:20:38\n   |\n20 |         result.append(current_string)\n   |                                      ^ help: add `;` here\n21 |         current_string = String::empty()\n   |         -------------- unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmpacj4kjjq.rs:32:32\n   |\n32 |   result.append(current_string)\n   |                                ^ help: add `;` here\n33 |   return result\n   |   ------ unexpected token\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpacj4kjjq.rs:30:5\n   |\n30 |     panic(\"Not balanced\")\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n30 |     panic!(\"Not balanced\")\n   |          +\n\nerror[E0599]: no function or associated item named `empty` found for struct `String` in the current scope\n  --> /tmp/tmpacj4kjjq.rs:10:32\n   |\n10 |   let current_strin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else if paren[0] == \")\" {\n      if current_string == \"\" {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n    } else {\n      current_string += paren;\n    }\n  }\n  if current_string != \"\" {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp7z25ekiy.rs:31:1\n   |\n27 |   if current_string != \"\" {\n   |                           - this opening brace...\n28 |     result.push(current_string);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp7z25ekiy.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      stack.push(String::from(i));\n    } else {\n      stack.push(String::from(i));\n    }\n  }\n  while (!stack.is_empty()) {\n    let top = stack.pop();\n    if (top.is_empty()) {\n      continue;\n    }\n    if (top.len() == 1) {\n      result.push(top);\n    } else {\n      stack.push(top.sub(1, top.len() - 1));\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpl1em7sv1.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpl1em7sv1.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl1em7sv1.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl1em7sv1.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl1em7sv1.rs:16:15\n   |\n16 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (open_parens == 0) {\n16 +     } else if open_parens == 0 {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpl1em7sv1.rs:22:9\n   |\n22 |   while (!stack.is_empty()) {\n   |         ^                 ^\n   |\nhelp: remove these parentheses\n   |\n22 -   while (!stack.is_empty()) {\n22 +   while !stack.is_empty() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl1em7sv1.rs:24:8\n   |\n24 |     if (top.is_empty()) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n24 -     if (top.is_empty()) {\n24 +     if top.is_empty() {\n   | \n\nwarning: unnecessary parentheses around `if` condi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = [String::empty()];\n  let result = Vec::new();\n\n  for i in paren_string.chars() {\n    if paren_stack.last() == String::empty() {\n      if paren_string[i] == '(' {\n        paren_stack.push(String::from(paren_string[i]));\n      } else {\n        result.push(String::from(paren_stack.pop()));\n      }\n    } else if paren_stack.last() == String::from(paren_string[i]) {\n      paren_stack.push(String::from(paren_string[i]));\n    } else {\n      result.push(String::from(paren_stack.pop()));\n    }\n  }\n\n  result.push(String::from(paren_stack.pop()));\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no function or associated item named `empty` found for struct `String` in the current scope\n --> /tmp/tmp4o_bslum.rs:8:30\n  |\n8 |   let paren_stack = [String::empty()];\n  |                              ^^^^^\n  |                              |\n  |                              function or associated item not found in `String`\n  |                              help: there is an associated function with a similar name: `is_empty`\n\nerror[E0599]: no function or associated item named `empty` found for struct `String` in the current scope\n  --> /tmp/tmp4o_bslum.rs:12:38\n   |\n12 |     if paren_stack.last() == String::empty() {\n   |                                      ^^^^^\n   |                                      |\n   |                                      function or associated item not found in `String`\n   |                                      help: there is an associated function with a similar name: `is_empty`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp4o_bslum.rs:13:10\n   |\n13 |       if paren_string[i] == '(' {\n   |          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp4o_bslum.rs:14:39\n   |\n14 |         paren_stack.push(String::from(paren_string[i]));\n   |                                       ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else {\n      if current_string != \"\") {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      }\n      current_string += paren;\n    }\n  }\n  if current_string != \"\") {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpfogyo5ow.rs:23:3\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |     }\n   |     - ...matches this closing brace\n23 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpfogyo5ow.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpfogyo5ow.rs:16:12\n   |\n16 |     } else {\n   |            ^ unclosed delimiter\n17 |       if current_string != \"\") {\n   |                              ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      stack.push(String::from(i));\n    } else {\n      stack.push(String::from(i));\n    }\n  }\n\n  for s in stack {\n    if (s.len() > 0) {\n      result.push(s);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpxzcgiprz.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpxzcgiprz.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxzcgiprz.rs:13:8\n   |\n13 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i == '(') {\n13 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxzcgiprz.rs:15:15\n   |\n15 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (i == ')') {\n15 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxzcgiprz.rs:17:15\n   |\n17 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (open_parens == 0) {\n17 +     } else if open_parens == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxzcgiprz.rs:25:8\n   |\n25 |     if (s.len() > 0) {\n   |        ^           ^\n   |\nhelp: remove these parentheses\n   |\n25 -     if (s.len() > 0) {\n25 +     if s.len() > 0 {\n   | \n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let open_braces = 0\n  let open_squares = 0\n  let open_curly = 0\n  let open_parens_stack = Vec::new()\n  let result = Vec::new()\n\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1\n      open_parens_stack.push(i)\n    } else if (i == '{') {\n      open_braces += 1\n      open_parens_stack.push(i)\n    } else if (i == '[') {\n      open_squares += 1\n      open_parens_stack.push(i)\n    } else if (i == '}') {\n      open_curly += 1\n      open_parens_stack.push(i)\n    } else if (i == ')') {\n      if (open_parens_stack.is_empty()) {\n        result.push(String::from(i))\n      } else {\n        let last_open_paren = open_parens_stack.pop()\n        if (last_open_paren == '(') {\n          result.push(String::from(i))\n        } else {\n          result.push(String::from(last_open_paren))\n          result.push(String::from(i))\n        }\n      }\n      open_parens -= 1\n    } else if (i == '}') {\n      if (open_curly > 0) {\n        result.push(String::from(i))\n      } else {\n        result.push(String::from(open_parens_stack.pop()))\n        result.push(String::from(i))\n      }\n      open_curly -= 1\n    } else if (i == ']') {\n      if (open_squares > 0) {\n        result.push(String::from(i))\n      } else {\n        result.push(String::from(open_parens_stack.pop()))\n        result.push(String::from(i))\n      }\n      open_squares -= 1\n    } else if (i\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2bpf4w4z.rs:66:3\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - unclosed delimiter\n...\n15 |   for i in paren_string.chars() {\n   |                                 - this delimiter might not be properly closed...\n...\n58 | }\n   | - ...as it matches this but it has different indentation\n...\n66 | }\n   |   ^\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmp2bpf4w4z.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let open_braces = 0\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2bpf4w4z.rs:9:22\n   |\n9  |   let open_braces = 0\n   |                      ^ help: add `;` here\n10 |   let open_squares = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2bpf4w4z.rs:10:23\n   |\n10 |   let open_squares = 0\n   |                       ^ help: add `;` here\n11 |   let open_curly = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2bpf4w4z.rs:11:21\n   |\n11 |   let open_curly = 0\n   |                     ^ help: add `;` here\n12 |   let open_parens_stack = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2bpf4w4z.rs:12:37\n   |\n12 |   let open_parens_stack = Vec::new()\n   |                                     ^ help: add `;` here\n13 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp2bpf4w4z.rs:13:26\n   |\n13 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n14 | \n15 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found `open_parens_stack`\n  --> /tmp/tmp2bpf4w4z.rs:17:23\n   |\n17 |       open_parens += 1\n   |                       ^ help: add `;` here\n18 |       open_parens_stack.push(i)\n   |       ----------------- unexpected token\n\nerror: expected `;`, foun",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut paren_stack = Vec<String>::new();\n  paren_stack.push(String::from(\"(\"));\n  for i in paren_string.chars() {\n    if paren_stack.last() == String::from(\"(\") {\n      if paren_string[i] == ')' {\n        paren_stack.pop();\n      } else {\n        paren_stack.push(String::from(\"(\"));\n      }\n    } else if paren_stack.last() == String::from(\")\") {\n      if paren_string[i] == '(' {\n        paren_stack.pop();\n      } else {\n        paren_stack.push(String::from(\")\"));\n      }\n    } else {\n      result.push(String::from(paren_stack.last() + paren_string[i]));\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpdq15ke6_.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpdq15ke6_.rs:9:28\n  |\n9 |   let mut paren_stack = Vec<String>::new();\n  |                            ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut paren_stack = Vec::<String>::new();\n  |                            ++\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpdq15ke6_.rs:13:10\n   |\n13 |       if paren_string[i] == ')' {\n   |          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpdq15ke6_.rs:19:10\n   |\n19 |       if paren_string[i] == '(' {\n   |          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\") {\n      stack.push(paren);\n    } else if paren == \")\") {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n        result.push(stack.last());\n        stack.push(paren);\n      }\n    } else {\n      stack.push(paren);\n    }\n  }\n  if !stack.is_empty() {\n    result.push(stack.last());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `)`\n  --> /tmp/tmp7c_jxm2u.rs:16:27\n   |\n14 |     if paren == \"(\") {\n   |                      - this opening brace...\n15 |       stack.push(paren);\n16 |     } else if paren == \")\") {\n   |     -                     ^ unexpected closing delimiter\n   |     |\n   |     ...matches this closing brace\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp7c_jxm2u.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp7c_jxm2u.rs:7:63\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               ^ unclosed delimiter\n...\n14 |     if paren == \"(\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n      if (open_parens == 0) {\n        stack.pop();\n        if (stack.len() > 0) {\n          result.push(stack.last());\n        }\n      }\n    } else {\n      stack.push(String::from(i));\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpx0dolm95.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpx0dolm95.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx0dolm95.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx0dolm95.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx0dolm95.rs:16:10\n   |\n16 |       if (open_parens == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -       if (open_parens == 0) {\n16 +       if open_parens == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx0dolm95.rs:18:12\n   |\n18 |         if (stack.len() > 0) {\n   |            ^               ^\n   |\nhelp: remove these parentheses\n   |\n18 -         if (stack.len() > 0) {\n18 +         if stack.len() > 0 {\n   | \n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(String::from(i))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmplryujbhe.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplryujbhe.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmplryujbhe.rs:16:14\n   |\n16 |       result.push(String::from(i))\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplryujbhe.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result: Vec<String> = Vec::new();\n  let mut current_string: String = String::from(\"\");\n  let mut open_braces: Vec<String> = Vec::new();\n  let mut close_braces: Vec<String> = Vec::new();\n\n  for paren_char in paren_string.chars() {\n    if paren_char == '(' {\n      open_braces.push(String::from(\"\"));\n    } else if paren_char == ')' {\n      close_braces.push(String::from(\"\"));\n    } else if paren_char == '{' {\n      open_braces.push(String::from(\"\"));\n    } else if paren_char == '}' {\n      close_braces.push(String::from(\"\"));\n    } else if paren_char == ')' {\n      if open_braces.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren_char;\n      }\n    } else if paren_char == '(' {\n      if close_braces.is_empty() {\n        open_braces.push(String::from(\"\"));\n      } else {\n        current_string += paren_char;\n      }\n    } else if paren_char == '{' {\n      if close_braces.is_empty() {\n        open_braces.push(String::from(\"\"));\n      } else {\n        current_string += paren_char;\n      }\n    } else if paren_char == '}' {\n      if open_braces.is_empty() {\n        close_braces.push(String::from(\"\"));\n      } else {\n        current_string += paren_char;\n      }\n    } else {\n      current_string += paren_char;\n    }\n  }\n\n  if !open_braces.is_empty() {\n    result.push(current_string);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp1mpv8my9.rs:27:27\n   |\n27 |         current_string += paren_char;\n   |                           ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1mpv8my9.rs:33:27\n   |\n33 |         current_string += paren_char;\n   |                           ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1mpv8my9.rs:39:27\n   |\n39 |         current_string += paren_char;\n   |                           ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1mpv8my9.rs:45:27\n   |\n45 |         current_string += paren_char;\n   |                           ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1mpv8my9.rs:48:25\n   |\n48 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else if paren[0] == \")\" {\n      if current_string == \"\" {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n    } else {\n      current_string += paren;\n    }\n  }\n  if current_string != \"\" {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp8qcx0x32.rs:31:1\n   |\n27 |   if current_string != \"\" {\n   |                           - this opening brace...\n28 |     result.push(current_string);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp8qcx0x32.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      if current == \"\" {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current += paren;\n      }\n    } else {\n      current += paren;\n    }\n  }\n  if current != \"\" {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpd381idnz.rs:31:1\n   |\n27 |   if current != \"\" {\n   |                    - this opening brace...\n28 |     result.push(current);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpd381idnz.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\"\") {\n    if paren == \"(\" {\n      current += paren;\n    } else if paren == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n    } else {\n      current += paren;\n    }\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[\"((\", \"(\", \"\", \" (((\", \"\", \"\", \" (\", \" (((\", \"\", \"(\", \"(\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpiu4o0v7b.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      if current == \"\" {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current += paren;\n      }\n    } else {\n      current += paren;\n    }\n  }\n  if current != \"\" {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpd381idnz.rs:31:1\n   |\n27 |   if current != \"\" {\n   |                    - this opening brace...\n28 |     result.push(current);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpd381idnz.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  let open_braces = 0;\n  let open_brackets = 0;\n  let open_squares = 0;\n  let open_curly = 0;\n\n  for c in paren_string {\n    if c == '(' {\n      open_parens += 1;\n    } else if c == '{' {\n      open_braces += 1;\n    } else if c == '[' {\n      open_brackets += 1;\n    } else if c == '\"' {\n      open_squares += 1;\n    } else if c == '}' {\n      open_curly += 1;\n    }\n\n    if open_parens == 0 and open_braces == 0 and open_brackets == 0 and open_squares == 0 and open_curly == 0 {\n      if stack.len > 0 {\n        result.push(stack.last());\n        stack.pop();\n      }\n    }\n\n    if c == ')' {\n      open_parens -= 1;\n    } else if c == '}' {\n      open_curly -= 1;\n    } else if c == ']' {\n      open_brackets -= 1;\n    } else if c == '\"' {\n      open_squares -= 1;\n    }\n\n    stack.push(String::from(c));\n  }\n\n  if stack.len > 0 {\n    result.push(stack.last());\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpq1v0h_pg.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpq1v0h_pg.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: `and` is not a logical operator\n  --> /tmp/tmpq1v0h_pg.rs:29:25\n   |\n29 |     if open_parens == 0 and open_braces == 0 and open_brackets == 0 and open_squares == 0 and open_curly == 0 {\n   |                         ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmpq1v0h_pg.rs:29:46\n   |\n29 |     if open_parens == 0 and open_braces == 0 and open_brackets == 0 and open_squares == 0 and open_curly == 0 {\n   |                                              ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmpq1v0h_pg.rs:29:69\n   |\n29 |     if open_parens == 0 and open_braces == 0 and open_brackets == 0 and open_squares == 0 and open_curly == 0 {\n   |                                                                     ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror: `and` is not a logical operator\n  --> /tmp/tmpq1v0h_pg.rs:29:91\n   |\n29 |     if open_parens == 0 and open_braces == 0 and open_brackets == 0 and open_squares == 0 and open_curly == 0 {\n   |                                                                        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren_char in paren_string.chars() {\n    if paren_char == '(' {\n      current_string += paren_char;\n    } else if paren_char == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren_char;\n      }\n    } else {\n      current_string += paren_char;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpwmcuv9hd.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmcuv9hd.rs:12:25\n   |\n12 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmcuv9hd.rs:18:27\n   |\n18 |         current_string += paren_char;\n   |                           ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmcuv9hd.rs:21:25\n   |\n21 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      stack.push(paren);\n    } else if paren[0] == \")\" {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n        if stack.is_empty() {\n          result.push(stack.join(\"\") + paren);\n        } else {\n          result.push(stack.join(\"\") + paren);\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpt559r7sm.rs:30:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n28 |   }\n   |   - ...matches this closing brace\n29 |   return result;\n30 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpt559r7sm.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let paren_count = 0;\n  let paren_open = false;\n  let paren_close = false;\n  let result = Vec<String>::new();\n\n  for (c in paren_string) {\n    if (c == '(') {\n      paren_stack.push(c);\n      paren_count += 1;\n      paren_open = true;\n    } else if (c == ')') {\n      paren_stack.pop();\n      paren_count -= 1;\n      paren_close = true;\n    } else if (paren_open) {\n      paren_stack.push(c);\n    } else if (paren_close) {\n      paren_stack.pop();\n    } else {\n      // Ignore spaces\n    }\n  }\n\n  for (c in paren_stack) {\n    result.push(c);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp7tirwnm3.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmp7tirwnm3.rs:12:19\n   |\n12 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n12 |   let result = Vec::<String>::new();\n   |                   ++\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp7tirwnm3.rs:14:10\n   |\n14 |   for (c in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp7tirwnm3.rs:14:7\n   |\n14 |   for (c in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n14 -   for (c in paren_string) {\n14 +   for c in paren_string {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp7tirwnm3.rs:32:10\n   |\n32 |   for (c in paren_stack) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp7tirwnm3.rs:32:7\n   |\n32 |   for (c in paren_stack) {\n   |       ^                ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n32 -   for (c in paren_stack) {\n32 +   for c in paren_stack {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7tirwnm3.rs:15:8\n   |\n15 |     if (c == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n15 -     if (c == '(') {\n15 +     if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7tirwnm3.rs:19:15\n   |\n19 |     } else if (c == ')') {\n   |               ^        ^\n   |\nhelp: remove these par",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let result = []\n  let stack = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i)\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(paren_string.substr(i, 1)))\n      } else {\n        stack.pop()\n      }\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Unbalanced parentheses\")\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpliwe9m6z.rs:8:18\n  |\n8 |   let result = []\n  |                  ^ help: add `;` here\n9 |   let stack = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpliwe9m6z.rs:9:17\n   |\n9  |   let stack = []\n   |                 ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpliwe9m6z.rs:22:5\n   |\n22 |     panic(\"Unbalanced parentheses\")\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n22 |     panic!(\"Unbalanced parentheses\")\n   |          +\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpliwe9m6z.rs:12:13\n   |\n12 |       stack.push(i)\n   |             ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpliwe9m6z.rs:15:16\n   |\n15 |         result.push(String::from(paren_string.substr(i, 1)))\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `substr` found for struct `String` in the current scope\n  --> /tmp/tmpliwe9m6z.rs:15:47\n   |\n15 |         result.push(String::from(paren_string.substr(i, 1)))\n   |                                               ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `pop` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpliwe9m6z.rs:17:15\n   |\n17 |         stack.pop()\n   |               ^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpliwe9m6z.rs:24:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n24 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      if current_string == \"\" {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n      continue;\n    }\n    current_string += paren;\n  }\n  if current_string != \"\" {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp_rd__e4p.rs:33:1\n   |\n29 |   if current_string != \"\" {\n   |                           - this opening brace...\n30 |     result.push(current_string);\n31 |   }\n   |   - ...matches this closing brace\n32 |   return result;\n33 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp_rd__e4p.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren_char in paren_string.chars() {\n    if paren_char == '(' {\n      current_string += paren_char;\n    } else if paren_char == ')' {\n      result.push(current_string);\n      current_string = String::from(\"\");\n    } else {\n      current_string += paren_char;\n    }\n  }\n  result.push(current_string);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmps5_bhlgb.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps5_bhlgb.rs:12:25\n   |\n12 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps5_bhlgb.rs:17:25\n   |\n17 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let open_braces = 0\n  let open_brackets = 0\n  let open_squares = 0\n  let open_curly = 0\n  let open_parens_stack = Vec::new()\n  let open_braces_stack = Vec::new()\n  let open_brackets_stack = Vec::new()\n  let open_squares_stack = Vec::new()\n  let open_curly_stack = Vec::new()\n  let result = Vec::new()\n  let current_string = String::new()\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1\n      open_parens_stack.push(i)\n    } else if (i == '{') {\n      open_curly += 1\n      open_curly_stack.push(i)\n    } else if (i == '[') {\n      open_brackets += 1\n      open_brackets_stack.push(i)\n    } else if (i == ']') {\n      open_brackets -= 1\n      open_brackets_stack.pop()\n    } else if (i == '}') {\n      open_curly -= 1\n      open_curly_stack.pop()\n    } else if (i == ')') {\n      open_parens -= 1\n      open_parens_stack.pop()\n    } else if (i == ']') {\n      open_brackets -= 1\n      open_brackets_stack.pop()\n    } else if (i == '}') {\n      open_curly -= 1\n      open_curly_stack.pop()\n    } else if (i == '{') {\n      open_curly += 1\n      open_curly_stack.push(i)\n    } else if (i == '[') {\n      open_brackets += 1\n      open_brackets_stack.push(i)\n    } else if (i == ']') {\n      open_brackets -= 1\n      open_brackets_stack.pop()\n    } else if (i == ')') {\n      open_paren\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpols5d2d6.rs:64:3\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - unclosed delimiter\n...\n20 |   for i in paren_string.chars() {\n   |                                 - unclosed delimiter\n...\n54 |     } else if (i == ')') {\n   |                          - this delimiter might not be properly closed...\n55 |       open_paren\n56 | }\n   | - ...as it matches this but it has different indentation\n...\n64 | }\n   |   ^\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpols5d2d6.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let open_braces = 0\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpols5d2d6.rs:9:22\n   |\n9  |   let open_braces = 0\n   |                      ^ help: add `;` here\n10 |   let open_brackets = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpols5d2d6.rs:10:24\n   |\n10 |   let open_brackets = 0\n   |                        ^ help: add `;` here\n11 |   let open_squares = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpols5d2d6.rs:11:23\n   |\n11 |   let open_squares = 0\n   |                       ^ help: add `;` here\n12 |   let open_curly = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpols5d2d6.rs:12:21\n   |\n12 |   let open_curly = 0\n   |                     ^ help: add `;` here\n13 |   let open_parens_stack = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpols5d2d6.rs:13:37\n   |\n13 |   let open_parens_stack = Vec::new()\n   |                                     ^ help: add `;` here\n14 |   let open_braces_stack = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpols5d2d6.rs:14:37\n   |\n14 |   let open_braces_stack = Vec::new()\n   |                                     ^ help: add ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n    } else {\n      current += paren;\n    }\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpg1jr3bwp.rs:25:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |   }\n   |   - ...matches this closing brace\n...\n25 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpg1jr3bwp.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else {\n      if current_string != \"\") {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      }\n      current_string += paren;\n    }\n  }\n  if current_string != \"\") {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpfogyo5ow.rs:23:3\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |     }\n   |     - ...matches this closing brace\n23 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpfogyo5ow.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpfogyo5ow.rs:16:12\n   |\n16 |     } else {\n   |            ^ unclosed delimiter\n17 |       if current_string != \"\") {\n   |                              ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else {\n      if current_string != \"\") {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      }\n      current_string += paren;\n    }\n  }\n  if current_string != \"\") {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpfogyo5ow.rs:23:3\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |     }\n   |     - ...matches this closing brace\n23 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpfogyo5ow.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpfogyo5ow.rs:16:12\n   |\n16 |     } else {\n   |            ^ unclosed delimiter\n17 |       if current_string != \"\") {\n   |                              ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec::new();\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1;\n    } else if i == ')' {\n      open_parens -= 1;\n    } else if open_parens == 0 {\n      stack.push(String::from(i));\n    } else {\n      stack.push(String::from(i));\n    }\n  }\n\n  for i in stack {\n    if i.len() > 0 {\n      result.push(i);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmphnlh4qix.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if is_open_paren(i) {\n      stack.push(String::from(i));\n    } else if is_close_paren(i) {\n      if stack.is_empty() {\n        throw \"Invalid input\";\n      }\n      let top = stack.last();\n      stack.pop();\n      if stack.is_empty() {\n        result.push(top);\n      } else {\n        stack.last().chars().append(i);\n      }\n    }\n  }\n\n  if !stack.is_empty() {\n    throw \"Invalid input\";\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpfmi8bgis.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpfmi8bgis.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid input\"`\n  --> /tmp/tmpfmi8bgis.rs:16:15\n   |\n16 |         throw \"Invalid input\";\n   |               ^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid input\"`\n  --> /tmp/tmpfmi8bgis.rs:29:11\n   |\n29 |     throw \"Invalid input\";\n   |           ^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror[E0425]: cannot find function `is_open_paren` in this scope\n  --> /tmp/tmpfmi8bgis.rs:12:8\n   |\n12 |     if is_open_paren(i) {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_close_paren` in this scope\n  --> /tmp/tmpfmi8bgis.rs:14:15\n   |\n14 |     } else if is_close_paren(i) {\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 6 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let close_parens = 0\n  let current_string = String::empty()\n  let strings = Vec::new()\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      close_parens += 1\n    }\n\n    if open_parens == close_parens {\n      if current_string.len() > 0 {\n        strings.push(current_string)\n        current_string = String::empty()\n      }\n      open_parens = close_parens = 0\n    } else {\n      current_string += i\n    }\n  }\n\n  if current_string.len() > 0 {\n    strings.push(current_string)\n  }\n\n  return strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpo_7nr8dk.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let close_parens = 0\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpo_7nr8dk.rs:9:23\n   |\n9  |   let close_parens = 0\n   |                       ^ help: add `;` here\n10 |   let current_string = String::empty()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpo_7nr8dk.rs:10:39\n   |\n10 |   let current_string = String::empty()\n   |                                       ^ help: add `;` here\n11 |   let strings = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpo_7nr8dk.rs:11:27\n   |\n11 |   let strings = Vec::new()\n   |                           ^ help: add `;` here\n12 | \n13 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found `current_string`\n  --> /tmp/tmpo_7nr8dk.rs:22:37\n   |\n22 |         strings.push(current_string)\n   |                                     ^ help: add `;` here\n23 |         current_string = String::empty()\n   |         -------------- unexpected token\n\nerror[E0599]: no function or associated item named `empty` found for struct `String` in the current scope\n  --> /tmp/tmpo_7nr8dk.rs:10:32\n   |\n10 |   let current_string = String::empty()\n   |                                ^^^^^\n   |                                |\n   |                                function or associated item not found in `String`\n   |                                help: there is an associated function with a similar name: `is_empty`\n\nerror[E0599]: no function or associated item named `empty` found for struct `String` in the current scope\n  --> /tmp/tmpo_7nr8dk.rs:23:34\n   |\n23 |         current_string = String::empty()\n   |                                  ^^^^^\n   |                                  |\n   |                                  function or associated item not found in `String`\n   |                                  h",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      stack.push(String::from(i));\n    } else {\n      stack.push(String::from(i));\n    }\n  }\n  for (let i = 0; i < stack.len(); i += 1) {\n    let s = stack[i];\n    if (s.len() > 0) {\n      result.push(s);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmppekzba_7.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmppekzba_7.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmppekzba_7.rs:22:8\n   |\n22 |   for (let i = 0; i < stack.len(); i += 1) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppekzba_7.rs:22:12\n   |\n22 |   for (let i = 0; i < stack.len(); i += 1) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppekzba_7.rs:22:14\n   |\n22 |   for (let i = 0; i < stack.len(); i += 1) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppekzba_7.rs:22:13\n   |\n22 |   for (let i = 0; i < stack.len(); i += 1) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppekzba_7.rs:22:14\n   |\n22 |   for (let i = 0; i < stack.len(); i += 1) {\n   |              ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppekzba_7.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppekzba_7.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove the",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\" {\n      stack.push(paren);\n    } else if paren == \")\" {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n      }\n    } else {\n      stack.push(paren);\n    }\n  }\n  if !stack.is_empty() {\n    result.push(stack.pop());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp2tqx8beu.rs:30:1\n   |\n26 |   if !stack.is_empty() {\n   |                        - this opening brace...\n27 |     result.push(stack.pop());\n28 |   }\n   |   - ...matches this closing brace\n29 |   return result;\n30 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp2tqx8beu.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic(\"Invalid parens\");\n      }\n    }\n    if stack.len() == 0 {\n      result.push(String::from(i));\n    }\n  }\n  if stack.len() != 0 {\n    panic(\"Invalid parens\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpt72ykoqb.rs:15:9\n   |\n15 |         panic(\"Invalid parens\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         panic!(\"Invalid parens\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpt72ykoqb.rs:23:5\n   |\n23 |     panic(\"Invalid parens\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n23 |     panic!(\"Invalid parens\");\n   |          +\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpt72ykoqb.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpt72ykoqb.rs:14:16\n   |\n14 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpt72ykoqb.rs:19:14\n   |\n19 |       result.push(String::from(i));\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt72ykoqb.rs:25:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n25 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0423, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_group = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\") {\n      current_group += paren;\n    } else if paren == \")\") {\n      result.push(current_group);\n      current_group = String::from(\"\");\n    } else {\n      current_group += paren;\n    }\n  }\n  result.push(current_group);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `)`\n  --> /tmp/tmpaywnk2ud.rs:16:27\n   |\n14 |     if paren == \"(\") {\n   |                      - this opening brace...\n15 |       current_group += paren;\n16 |     } else if paren == \")\") {\n   |     -                     ^ unexpected closing delimiter\n   |     |\n   |     ...matches this closing brace\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpaywnk2ud.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpaywnk2ud.rs:7:63\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               ^ unclosed delimiter\n...\n14 |     if paren == \"(\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut last_open_brace = -1;\n  let mut last_close_brace = -1;\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(c);\n      last_open_brace = stack.len() - 1;\n    } else if c == ')' {\n      if stack.len() == 0 {\n        panic!(\"Mismatched parentheses\");\n      }\n      stack.pop();\n      last_close_brace = stack.len() - 1;\n    } else if c == '{' {\n      stack.push(c);\n      last_open_brace = stack.len() - 1;\n    } else if c == '}' {\n      if stack.len() == 0 {\n        panic!(\"Mismatched braces\");\n      }\n      stack.pop();\n      last_close_brace = stack.len() - 1;\n    }\n  });\n  if stack.len() != 0 {\n    panic!(\"Mismatched braces\");\n  }\n  if last_open_brace != -1 {\n    panic!(\"Mismatched parentheses\");\n  }\n  if last_close_brace != -1 {\n    panic!(\"Mismatched braces\");\n  }\n  for i in range(0, last_open_brace + 1) {\n    result.push(paren_string.slice(0, last_open_brace + 1));\n  }\n  for i in range(last_open_brace + 1, last_close_brace + 1) {\n    result.push(paren_string.slice(last_open_brace + 1, i));\n  }\n  for i in range(last_close_brace + 1, paren_string.len()) {\n    result.push(paren_string.slice(i, paren_string.len()));\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpu3vy8y82.rs:42:12\n   |\n42 |   for i in range(0, last_open_brace + 1) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpu3vy8y82.rs:45:12\n   |\n45 |   for i in range(last_open_brace + 1, last_close_brace + 1) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpu3vy8y82.rs:48:12\n   |\n48 |   for i in range(last_close_brace + 1, paren_string.len()) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpu3vy8y82.rs:10:29\n   |\n10 |   let mut last_open_brace = -1;\n   |                             ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpu3vy8y82.rs:11:30\n   |\n11 |   let mut last_close_brace = -1;\n   |                              ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpu3vy8y82.rs:36:25\n   |\n36 |   if last_open_brace != -1 {\n   |                         ^^\n   |                         |\n   |                         cannot apply unary operator `-`\n   |                         help",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(c));\n    } else if c == ')' {\n      if stack.is_empty() {\n        throw \"unbalanced parens\";\n      }\n      let top = stack.pop();\n      result.push(top);\n    }\n  });\n  if !stack.is_empty() {\n    throw \"unbalanced parens\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp0gkj4uja.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp0gkj4uja.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"unbalanced parens\"`\n  --> /tmp/tmp0gkj4uja.rs:15:15\n   |\n15 |         throw \"unbalanced parens\";\n   |               ^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"unbalanced parens\"`\n  --> /tmp/tmp0gkj4uja.rs:22:11\n   |\n22 |     throw \"unbalanced parens\";\n   |           ^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = [String::from(\"\")];\n  let result = Vec::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \")\") {\n      paren_stack.pop();\n    } else if paren == \"(\" {\n      paren_stack.push(String::from(\"\"));\n    } else {\n      paren_stack[paren_stack.len() - 1] += paren;\n    }\n    if paren_stack.len() == 0 {\n      result.push(paren_stack[0]);\n      paren_stack = [String::from(\"\")];\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpn38qoazw.rs:24:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |   }\n   |   - ...matches this closing brace\n23 |   return result;\n24 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpn38qoazw.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \")\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      result.push(String::from(paren_stack.pop()));\n    }\n    paren_stack.push(String::from(i));\n  }\n\n  result.push(String::from(paren_stack.pop()));\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpfll1dt5p.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpfll1dt5p.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfll1dt5p.rs:13:8\n   |\n13 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i == '(') {\n13 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfll1dt5p.rs:15:15\n   |\n15 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (i == ')') {\n15 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfll1dt5p.rs:17:15\n   |\n17 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (open_parens == 0) {\n17 +     } else if open_parens == 0 {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(i));\n    } else if i == ')' {\n      if stack.is_empty() {\n        throw \"unbalanced parens\";\n      }\n      let top = stack.last();\n      stack.pop();\n      if !stack.is_empty() {\n        result.push(top + String::from(i));\n      } else {\n        result.push(top);\n      }\n    }\n  }\n  if !stack.is_empty() {\n    throw \"unbalanced parens\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpt4mz7xl0.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpt4mz7xl0.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"unbalanced parens\"`\n  --> /tmp/tmpt4mz7xl0.rs:15:15\n   |\n15 |         throw \"unbalanced parens\";\n   |               ^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"unbalanced parens\"`\n  --> /tmp/tmpt4mz7xl0.rs:27:11\n   |\n27 |     throw \"unbalanced parens\";\n   |           ^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let paren_stack = Vec::new()\n  let result = Vec::new()\n\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      open_parens += 1\n    } else if c == ')' {\n      open_parens -= 1\n    } else if c == '{' {\n      paren_stack.push(c)\n    } else if c == '}' {\n      if paren_stack.is_empty() {\n        result.push(String::from(c))\n      } else {\n        let last_char = paren_stack.last()\n        if last_char == '{' {\n          result.push(String::from(c))\n        } else {\n          result.push(String::from('}'))\n          paren_stack.pop()\n        }\n      }\n    }\n  })\n\n  if open_parens != 0 {\n    panic!(\"Unbalanced parentheses\")\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpld1ieh7s.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let paren_stack = Vec::new()\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpld1ieh7s.rs:9:31\n   |\n9  |   let paren_stack = Vec::new()\n   |                               ^ help: add `;` here\n10 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found `paren_string`\n  --> /tmp/tmpld1ieh7s.rs:10:26\n   |\n10 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n11 | \n12 |   paren_string.chars().for_each(|c| {\n   |   ------------ unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpld1ieh7s.rs:23:43\n   |\n23 |         let last_char = paren_stack.last()\n   |                                           ^ help: add `;` here\n24 |         if last_char == '{' {\n   |         -- unexpected token\n\nerror: expected `;`, found `paren_stack`\n  --> /tmp/tmpld1ieh7s.rs:27:41\n   |\n27 |           result.push(String::from('}'))\n   |                                         ^ help: add `;` here\n28 |           paren_stack.pop()\n   |           ----------- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpld1ieh7s.rs:32:5\n   |\n32 |   })\n   |     ^ help: add `;` here\n33 | \n34 |   if open_parens != 0 {\n   |   -- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpld1ieh7s.rs:24:25\n   |\n24 |         if last_char == '{' {\n   |                         ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&char>`\n              found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpld1ieh7s.rs:28:11\n   |\n24 | /         if last_char == '{' {\n25 | |           result.push(String::from(c))\n26 | |         } else {\n27 | |           result.push(String::from('}'))\n28 | |           paren_stack.pop()\n   | |           ^^^^^^^^^^^^^^^^^ expected `()`, found enum `Option`\n29 | |         }\n   | |_________- expected this to be `()`\n   |\n   = not",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(paren_string[i:i+1])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpjxrsw3da.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjxrsw3da.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpjxrsw3da.rs:16:34\n   |\n16 |       result.push(paren_string[i:i+1])\n   |                                  ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n16 |       result.push(paren_string[i::i+1])\n   |                                 ~~\nhelp: a builtin type with a similar name exists\n   |\n16 |       result.push(paren_string[i:i8+1])\n   |                                  ~~\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpjxrsw3da.rs:16:14\n   |\n16 |       result.push(paren_string[i:i+1])\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxrsw3da.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      if current == \"\" {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current += paren;\n      }\n    } else {\n      current += paren;\n    }\n  }\n  if current != \"\" {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpcfp01e8z.rs:31:1\n   |\n27 |   if current != \"\" {\n   |                    - this opening brace...\n28 |     result.push(current);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpcfp01e8z.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut open_braces = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_braces += 1;\n    } else if i == ')' {\n      open_braces -= 1;\n    } else if i == '{' {\n      if open_braces > 0 {\n        stack.push(String::from(i));\n      } else {\n        result.push(stack.pop());\n        stack.push(String::from(i));\n      }\n    } else if i == '}' {\n      if open_braces > 0 {\n        stack.push(String::from(i));\n      } else {\n        result.push(stack.pop());\n        stack.pop();\n      }\n    }\n  }\n  result.push(stack.pop());\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpl7clab3u.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpl7clab3u.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic(\"Mismatched parentheses\");\n      }\n    }\n    if stack.is_empty() {\n      result.push(String::from(i));\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Unbalanced parentheses\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp2vi26d3f.rs:15:9\n   |\n15 |         panic(\"Mismatched parentheses\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         panic!(\"Mismatched parentheses\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp2vi26d3f.rs:23:5\n   |\n23 |     panic(\"Unbalanced parentheses\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n23 |     panic!(\"Unbalanced parentheses\");\n   |          +\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp2vi26d3f.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp2vi26d3f.rs:14:16\n   |\n14 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0423, E0599.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if is_open_paren(i) {\n      stack.push(String::from(i));\n    } else if is_close_paren(i) {\n      if stack.is_empty() {\n        result.push(String::from(i));\n      } else {\n        let top = stack.pop();\n        result.push(top + String::from(i));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpk2mokjhd.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpk2mokjhd.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror[E0425]: cannot find function `is_open_paren` in this scope\n  --> /tmp/tmpk2mokjhd.rs:11:8\n   |\n11 |     if is_open_paren(i) {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_close_paren` in this scope\n  --> /tmp/tmpk2mokjhd.rs:13:15\n   |\n13 |     } else if is_close_paren(i) {\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(paren_string[i:i+1])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpjxrsw3da.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjxrsw3da.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpjxrsw3da.rs:16:34\n   |\n16 |       result.push(paren_string[i:i+1])\n   |                                  ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n16 |       result.push(paren_string[i::i+1])\n   |                                 ~~\nhelp: a builtin type with a similar name exists\n   |\n16 |       result.push(paren_string[i:i8+1])\n   |                                  ~~\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpjxrsw3da.rs:16:14\n   |\n16 |       result.push(paren_string[i:i+1])\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxrsw3da.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(String::from(i))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmplryujbhe.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplryujbhe.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmplryujbhe.rs:16:14\n   |\n16 |       result.push(String::from(i))\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplryujbhe.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = [String::from(\"\")];\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if paren_stack.last().is_empty() {\n      if paren_string[i] == '(' {\n        paren_stack.push(String::from(\"\"));\n      } else {\n        result.push(paren_stack.pop());\n      }\n    } else {\n      if paren_string[i] == ')' {\n        paren_stack.pop();\n      } else {\n        paren_stack.last() += paren_string[i];\n      }\n    }\n  }\n  result.push(paren_stack.pop());\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_empty` found for enum `Option` in the current scope\n  --> /tmp/tmpnwmhh4bb.rs:11:27\n   |\n11 |     if paren_stack.last().is_empty() {\n   |                           ^^^^^^^^ method not found in `Option<&String>`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpnwmhh4bb.rs:12:10\n   |\n12 |       if paren_string[i] == '(' {\n   |          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpnwmhh4bb.rs:13:21\n   |\n13 |         paren_stack.push(String::from(\"\"));\n   |                     ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpnwmhh4bb.rs:15:33\n   |\n15 |         result.push(paren_stack.pop());\n   |                                 ^^^ method not found in `[String; 1]`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpnwmhh4bb.rs:18:10\n   |\n18 |       if paren_string[i] == ')' {\n   |          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result: Vec<String> = Vec::new();\n  let mut current: String = String::from(\"\");\n  for paren in paren_string.split(\"\") {\n    if paren == \"(\" {\n      current += paren;\n    } else if paren == \")\" {\n      if current.is_empty() {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current += paren;\n      }\n    } else {\n      current += paren;\n    }\n  }\n  if !current.is_empty() {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[\"(()()) ((())) () ((())()())\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmp0ml060mu.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if (i == '(') {\n      stack.push(String::from(\"(\"));\n    } else if (i == ')') {\n      if (stack.is_empty()) {\n        result.push(String::from(\"\"));\n      } else {\n        let top = stack.last();\n        stack.pop();\n        result.push(top + String::from(\")\"));\n      }\n    }\n  }\n\n  if (!stack.is_empty()) {\n    throw \"Invalid input\";\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpk45kkoaz.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpk45kkoaz.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid input\"`\n  --> /tmp/tmpk45kkoaz.rs:26:11\n   |\n26 |     throw \"Invalid input\";\n   |           ^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk45kkoaz.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk45kkoaz.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk45kkoaz.rs:15:10\n   |\n15 |       if (stack.is_empty()) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n15 -       if (stack.is_empty()) {\n15 +       if stack.is_empty() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk45kkoaz.rs:25:6\n   |\n25 |   if (!stack.is_empty()) {\n   |      ^                 ^\n   |\nhelp: remove these parentheses\n   |\n25 -   if (!stack.is_empty()) {\n25 +   if !stack.is_empty() {\n   | \n\nerror: aborting due to 3 previous errors; 4 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  for c in paren_string {\n    if c == '(' {\n      stack.push(0);\n    } else if c == ')' {\n      stack.pop();\n      if stack.empty() {\n        result.push(String::from(c));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpcjui_lsk.rs:10:12\n   |\n10 |   for c in paren_string {\n   |            ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpcjui_lsk.rs:12:13\n   |\n12 |       stack.push(0);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpcjui_lsk.rs:14:13\n   |\n14 |       stack.pop();\n   |             ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `empty` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpcjui_lsk.rs:15:16\n   |\n15 |       if stack.empty() {\n   |                ^^^^^ help: there is an associated function with a similar name: `is_empty`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpcjui_lsk.rs:16:16\n   |\n16 |         result.push(String::from(c));\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcjui_lsk.rs:20:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n20 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec::new();\n  let result = Vec::new();\n\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push_back(c);\n    } else if c == ')' {\n      if stack.is_empty() {\n        throw \"Invalid parentheses\";\n      }\n      let last = stack.pop();\n      if last != '(' {\n        throw \"Invalid parentheses\";\n      }\n    } else {\n      result.push_back(String::from(c));\n    }\n  });\n\n  if !stack.is_empty() {\n    throw \"Invalid parentheses\";\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid parentheses\"`\n  --> /tmp/tmp33m0r268.rs:16:15\n   |\n16 |         throw \"Invalid parentheses\";\n   |               ^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid parentheses\"`\n  --> /tmp/tmp33m0r268.rs:20:15\n   |\n20 |         throw \"Invalid parentheses\";\n   |               ^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid parentheses\"`\n  --> /tmp/tmp33m0r268.rs:28:11\n   |\n28 |     throw \"Invalid parentheses\";\n   |           ^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp33m0r268.rs:13:13\n   |\n13 |       stack.push_back(c);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp33m0r268.rs:19:18\n   |\n19 |       if last != '(' {\n   |                  ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n              found type `char`\nhelp: try wrapping the expression in `Some`\n   |\n19 |       if last != Some('(') {\n   |                  +++++   +\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp33m0r268.rs:23:14\n   |\n23 |       result.push_back(String::from(c));\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic(\"Invalid parens\");\n      }\n    }\n    if stack.is_empty() {\n      result.push(String::from(paren_string.sub(i, i)));\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Invalid parens\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp4emg86p6.rs:15:9\n   |\n15 |         panic(\"Invalid parens\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         panic!(\"Invalid parens\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp4emg86p6.rs:23:5\n   |\n23 |     panic(\"Invalid parens\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n23 |     panic!(\"Invalid parens\");\n   |          +\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp4emg86p6.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp4emg86p6.rs:14:16\n   |\n14 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp4emg86p6.rs:19:14\n   |\n19 |       result.push(String::from(paren_string.sub(i, i)));\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `sub` found for struct `String` in the current scope\n  --> /tmp/tmp4emg86p6.rs:19:45\n   |\n19 |       result.push(String::from(paren_string.sub(i, i)));\n   |                                             ^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4emg86p6.rs:25:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n25 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for i in paren_string.chars() {\n    if i == '(' {\n      current_string += i;\n    } else if i == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += i;\n      }\n    } else {\n      current_string += i;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp43r83450.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:12:25\n   |\n12 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:18:27\n   |\n18 |         current_string += i;\n   |                           ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:21:25\n   |\n21 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\") {\n      stack.push(paren);\n    } else if paren == \")\") {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n      }\n    } else {\n      stack.push(paren);\n    }\n  }\n  if !stack.is_empty() {\n    throw \"Unbalanced parentheses\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `)`\n  --> /tmp/tmp7jt1d6k7.rs:16:27\n   |\n14 |     if paren == \"(\") {\n   |                      - this opening brace...\n15 |       stack.push(paren);\n16 |     } else if paren == \")\") {\n   |     -                     ^ unexpected closing delimiter\n   |     |\n   |     ...matches this closing brace\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp7jt1d6k7.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp7jt1d6k7.rs:7:63\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               ^ unclosed delimiter\n...\n14 |     if paren == \"(\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current_string = String::from(\"\");\n  for paren_char in paren_string.chars() {\n    if paren_char == '(' {\n      current_string += paren_char;\n    } else if paren_char == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren_char;\n      }\n    } else {\n      current_string += paren_char;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp8nyx4jm4.rs:12:25\n   |\n12 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8nyx4jm4.rs:18:27\n   |\n18 |         current_string += paren_char;\n   |                           ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8nyx4jm4.rs:21:25\n   |\n21 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut open_braces = 0;\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_braces += 1;\n    } else if i == ')' {\n      open_braces -= 1;\n    } else if i == '{' {\n      if open_braces == 0 {\n        stack.push(String::from(i));\n      }\n    } else if i == '}' {\n      if open_braces == 0 {\n        result.push(stack.pop());\n      }\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp3m0z1omh.rs:28:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n28 |   return result;\n   |          ^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Option<String>>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      stack.push(paren);\n    } else if paren[0] == \")\" {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n        result.push(stack.last());\n        stack.push(paren);\n      }\n    }\n  }\n  if !stack.is_empty() {\n    result.push(stack.last());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpopwuu4id.rs:30:1\n   |\n26 |   if !stack.is_empty() {\n   |                        - this opening brace...\n27 |     result.push(stack.last());\n28 |   }\n   |   - ...matches this closing brace\n29 |   return result;\n30 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpopwuu4id.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else if paren[0] == \")\" {\n      if current_string == \"\" {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n    } else {\n      current_string += paren;\n    }\n  }\n  if current_string != \"\" {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp8qcx0x32.rs:31:1\n   |\n27 |   if current_string != \"\" {\n   |                           - this opening brace...\n28 |     result.push(current_string);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp8qcx0x32.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(c));\n    } else if c == ')' {\n      if stack.is_empty() {\n        result.push(String::from(c));\n      } else {\n        stack.pop();\n        result.push(stack.last());\n      }\n    }\n  });\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpn1ip0u4o.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpn1ip0u4o.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  let open_braces = 0;\n  let open_brackets = 0;\n  let open_squares = 0;\n  let open_curly = 0;\n  let open_parens = 0;\n\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == '{') {\n      open_braces += 1;\n    } else if (i == '[') {\n      open_brackets += 1;\n    } else if (i == ']') {\n      open_brackets -= 1;\n    } else if (i == '}') {\n      open_braces -= 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (i == '\"') {\n      open_squares += 1;\n    } else if (i == '\\'') {\n      open_squares -= 1;\n    } else if (i == ')') {\n      if (open_parens == 0) {\n        stack.push(paren_string.sub(i, i + 1));\n      }\n    } else if (i == '{') {\n      if (open_braces == 0) {\n        stack.push(paren_string.sub(i, i + 1));\n      }\n    } else if (i == '[') {\n      if (open_brackets == 0) {\n        stack.push(paren_string.sub(i, i + 1));\n      }\n    } else if (i == '\"') {\n      if (open_squares == 0) {\n        stack.push(paren_string.sub(i, i + 1));\n      }\n    } else if (i == '\\'') {\n      if (open_squares == 0) {\n        stack.push(paren_string.sub(i, i + 1));\n      }\n    }\n  }\n\n  while (!stack.is_empty()) {\n    let top = stack.\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpuyly66_0.rs:67:3\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - unclosed delimiter\n...\n57 |   while (!stack.is_empty()) {\n   |                             - this delimiter might not be properly closed...\n58 |     let top = stack.\n59 | }\n   | - ...as it matches this but it has different indentation\n...\n67 | }\n   |   ^\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpuyly66_0.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpuyly66_0.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: unexpected token: `}`\n  --> /tmp/tmpuyly66_0.rs:59:1\n   |\n59 | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpuyly66_0.rs:58:21\n   |\n58 |     let top = stack.\n   |                     ^ help: add `;` here\n59 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuyly66_0.rs:18:8\n   |\n18 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n18 -     if (i == '(') {\n18 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuyly66_0.rs:20:15\n   |\n20 |     } else if (i == '{') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n20 -     } else if (i == '{') {\n20 +     } else if i == '{' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuyly66_0.rs:22:15\n   |\n22 |     } else if (i == '[') {\n   |               ^        ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if paren_string[i] == ' ' {\n      continue\n    }\n    if open_parens == 0 {\n      result.append(paren_string[i:i+1])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpwmuasolt.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpwmuasolt.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpwmuasolt.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpwmuasolt.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpwmuasolt.rs:19:36\n   |\n19 |       result.append(paren_string[i:i+1])\n   |                                    ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n19 |       result.append(paren_string[i::i+1])\n   |                                   ~~\nhelp: a builtin type with a similar name exists\n   |\n19 |       result.append(paren_string[i:i8+1])\n   |                                    ~~\n\nerror[E0599]: no method named `append` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpwmuasolt.rs:19:14\n   |\n19 |       result.append(paren_string[i:i+1])\n   |              ^^^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmuasolt.rs:22:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n22 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(\"(\"));\n    } else if c == ')' {\n      if stack.is_empty() {\n        throw \"unbalanced parens\";\n      }\n      let top = stack.pop();\n      result.push(top);\n    }\n  });\n  if !stack.is_empty() {\n    throw \"unbalanced parens\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpfx_jxwrp.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpfx_jxwrp.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"unbalanced parens\"`\n  --> /tmp/tmpfx_jxwrp.rs:15:15\n   |\n15 |         throw \"unbalanced parens\";\n   |               ^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"unbalanced parens\"`\n  --> /tmp/tmpfx_jxwrp.rs:22:11\n   |\n22 |     throw \"unbalanced parens\";\n   |           ^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut current = String::from(\"\");\n  let mut is_open = false;\n\n  for c in paren_string {\n    if c == \"(\" {\n      is_open = true;\n      stack.push(c);\n    } else if c == \")\" {\n      if is_open {\n        stack.pop();\n        is_open = false;\n      } else {\n        current += c;\n      }\n    } else {\n      if is_open {\n        stack.push(c);\n      } else {\n        current += c;\n      }\n    }\n  }\n\n  for s in stack {\n    result.push(current);\n    current = String::from(\"\");\n  }\n\n  result.push(current);\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpig_6b1_i.rs:13:12\n   |\n13 |   for c in paren_string {\n   |            ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [String::from(\"\")];\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"\"));\n    } else if i == ')' {\n      stack.pop();\n    } else {\n      stack[stack.len() - 1] += i;\n    }\n  }\n  return stack.map(String::from);\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpc6mi0hcq.rs:11:13\n   |\n11 |       stack.push(String::from(\"\"));\n   |             ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpc6mi0hcq.rs:13:13\n   |\n13 |       stack.pop();\n   |             ^^^ method not found in `[String; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc6mi0hcq.rs:15:33\n   |\n15 |       stack[stack.len() - 1] += i;\n   |                                 ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc6mi0hcq.rs:18:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n18 |   return stack.map(String::from);\n   |          ^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 1 element\n   |\n   = note: expected struct `Vec<String>`\n               found array `[String; 1]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  let mut current_paren_count = 0;\n  let mut current_paren_open = false;\n  for c in paren_string {\n    if c == '(' {\n      current_paren_count += 1;\n      current_paren_open = true;\n    } else if c == ')' {\n      current_paren_count -= 1;\n      if current_paren_count == 0 {\n        current_string += c;\n        result.push(current_string);\n        current_string = String::from(\"\");\n        current_paren_open = false;\n      }\n    } else if current_paren_open {\n      current_string += c;\n    }\n  }\n  if current_paren_open {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpaojrhcaw.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpaojrhcaw.rs:12:12\n   |\n12 |   for c in paren_string {\n   |            ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpaojrhcaw.rs:13:10\n   |\n13 |     if c == '(' {\n   |          ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n             <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpaojrhcaw.rs:16:17\n   |\n16 |     } else if c == ')' {\n   |                 ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n             <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(\"\"));\n      } else {\n        let top = stack.pop();\n        result.push(top);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpsgqkqsul.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpsgqkqsul.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(\"(\"));\n    } else if c == ')' {\n      if stack.is_empty() {\n        result.push(String::from(\"\"));\n      } else {\n        let top = stack.last();\n        stack.pop();\n        result.push(top + String::from(\")\"));\n      }\n    } else {\n      stack.push(String::from(c));\n    }\n  });\n  if !stack.is_empty() {\n    result.push(stack.last());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpznfi5zs9.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpznfi5zs9.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(\"(\"));\n    } else if c == ')' {\n      if stack.is_empty() {\n        result.push(String::from(\"\"));\n      } else {\n        let top = stack.pop();\n        result.push(top);\n        result.push(String::from(\"(\"));\n        result.push(String::from(\"()\"));\n      }\n    }\n  });\n\n  if !stack.is_empty() {\n    result.push(stack.pop());\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpc8aryhuv.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpc8aryhuv.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  let mut current_paren_count = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      current_paren_count += 1;\n    } else if i == ')' {\n      current_paren_count -= 1;\n    } else if i == ' ' {\n      if current_paren_count == 0 {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      }\n    } else {\n      current_string += i;\n    }\n  }\n  result.push(current_string);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmphdffsiyr.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphdffsiyr.rs:22:25\n   |\n22 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(paren_string[i:i+1])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpjxrsw3da.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjxrsw3da.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpjxrsw3da.rs:16:34\n   |\n16 |       result.push(paren_string[i:i+1])\n   |                                  ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n16 |       result.push(paren_string[i::i+1])\n   |                                 ~~\nhelp: a builtin type with a similar name exists\n   |\n16 |       result.push(paren_string[i:i8+1])\n   |                                  ~~\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpjxrsw3da.rs:16:14\n   |\n16 |       result.push(paren_string[i:i+1])\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxrsw3da.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(current_string);\n      current_string = String::from(\"\");\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += i;\n      }\n    } else {\n      current_string += i;\n    }\n  }\n  if !stack.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpo0kze38w.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpo0kze38w.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo0kze38w.rs:20:27\n   |\n20 |         current_string += i;\n   |                           ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo0kze38w.rs:23:25\n   |\n23 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  let start = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic(\"Mismatched parens\");\n      }\n    }\n    if stack.is_empty() {\n      result.push(paren_string.slice(start, i));\n      start = i + 1;\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Unbalanced parens\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp74vbwxdg.rs:16:9\n   |\n16 |         panic(\"Mismatched parens\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n16 |         panic!(\"Mismatched parens\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp74vbwxdg.rs:25:5\n   |\n25 |     panic(\"Unbalanced parens\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n25 |     panic!(\"Unbalanced parens\");\n   |          +\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp74vbwxdg.rs:13:13\n   |\n13 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp74vbwxdg.rs:15:16\n   |\n15 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp74vbwxdg.rs:20:14\n   |\n20 |       result.push(paren_string.slice(start, i));\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `slice` found for struct `String` in the current scope\n  --> /tmp/tmp74vbwxdg.rs:20:32\n   |\n20 |       result.push(paren_string.slice(start, i));\n   |                                ^^^^^ help: there is an associated function with a similar name: `split_once`\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp74vbwxdg.rs:21:17\n   |\n21 |       start = i + 1;\n   |               - ^ - {integer}\n   |               |\n   |               char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp74vbwxdg.rs:27:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n27 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      if current == \"\" {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current += paren;\n      }\n    } else {\n      current += paren;\n    }\n  }\n  if current != \"\" {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpd381idnz.rs:31:1\n   |\n27 |   if current != \"\" {\n   |                    - this opening brace...\n28 |     result.push(current);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpd381idnz.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [String::from(\"\")];\n  for paren in paren_string.split(\"\") {\n    if paren == \"(\" {\n      stack.push(String::from(\"\"));\n    } else if paren == \")\" {\n      let top = stack.pop();\n      stack.push(top + paren);\n    }\n  }\n  return stack.map(String::from).drop_while(String::is_empty).to_vec();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp_5qiyfrx.rs:11:13\n   |\n11 |       stack.push(String::from(\"\"));\n   |             ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp_5qiyfrx.rs:13:23\n   |\n13 |       let top = stack.pop();\n   |                       ^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp_5qiyfrx.rs:14:13\n   |\n14 |       stack.push(top + paren);\n   |             ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `drop_while` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp_5qiyfrx.rs:17:34\n   |\n17 |   return stack.map(String::from).drop_while(String::is_empty).to_vec();\n   |                                  ^^^^^^^^^^ method not found in `[String; 1]`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut open_braces = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_braces += 1;\n    } else if i == ')' {\n      open_braces -= 1;\n    } else if i == '{' {\n      if open_braces > 0 {\n        stack.push(String::from_chars(i));\n      } else {\n        result.push(stack.pop());\n      }\n    } else if i == '}' {\n      if open_braces > 0 {\n        stack.push(String::from_chars(i));\n      } else {\n        result.push(stack.pop());\n      }\n    }\n  }\n  result.push(stack.pop());\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpjyxorksb.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpjyxorksb.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror[E0599]: no function or associated item named `from_chars` found for struct `String` in the current scope\n  --> /tmp/tmpjyxorksb.rs:18:28\n   |\n18 |         stack.push(String::from_chars(i));\n   |                            ^^^^^^^^^^ function or associated item not found in `String`\n\nerror[E0599]: no function or associated item named `from_chars` found for struct `String` in the current scope\n  --> /tmp/tmpjyxorksb.rs:24:28\n   |\n24 |         stack.push(String::from_chars(i));\n   |                            ^^^^^^^^^^ function or associated item not found in `String`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else if paren[0] == \")\" {\n      result.push(current_string);\n      current_string = String::from(\"\");\n    } else {\n      current_string += paren;\n    }\n  }\n  result.push(current_string);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpdxqpicb9.rs:25:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |   }\n   |   - ...matches this closing brace\n...\n25 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpdxqpicb9.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let close_parens = 0\n  let result = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      close_parens += 1\n    } else if open_parens > 0 && close_parens > 0 {\n      result.push(String::from(i))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpjwxdf8pq.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let close_parens = 0\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpjwxdf8pq.rs:9:23\n   |\n9  |   let close_parens = 0\n   |                       ^ help: add `;` here\n10 |   let result = []\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjwxdf8pq.rs:10:18\n   |\n10 |   let result = []\n   |                  ^ help: add `;` here\n11 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpjwxdf8pq.rs:17:14\n   |\n17 |       result.push(String::from(i))\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwxdf8pq.rs:20:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n20 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\"\") {\n    if paren == \"(\" {\n      current += paren;\n    } else if paren == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n    } else {\n      current += paren;\n    }\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[\"((\", \"(\", \"\", \" (((\", \"\", \"\", \" (\", \" (((\", \"\", \"(\", \"(\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpiu4o0v7b.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let paren_stack = Vec::new()\n  let result = Vec::new()\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      open_parens -= 1\n      if open_parens == 0 {\n        result.push(paren_stack.pop())\n      }\n    } else {\n      paren_stack.push(String::from(i))\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpls3rh9av.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let paren_stack = Vec::new()\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpls3rh9av.rs:9:31\n   |\n9  |   let paren_stack = Vec::new()\n   |                               ^ help: add `;` here\n10 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpls3rh9av.rs:10:26\n   |\n10 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n11 | \n12 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpls3rh9av.rs:16:23\n   |\n16 |       open_parens -= 1\n   |                       ^ help: add `;` here\n17 |       if open_parens == 0 {\n   |       -- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpls3rh9av.rs:25:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n25 |   return result\n   |          ^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Option<String>>`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      if current.ends_with(\"(\") {\n        current = current.drop_right(1);\n      }\n      result.push(current);\n      current = String::from(\"\");\n    } else {\n      current += paren;\n    }\n  }\n  if current.ends_with(\"(\") {\n    current = current.drop_right(1);\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpkkme3wep.rs:31:1\n   |\n26 |   if current.ends_with(\"(\") {\n   |                             - this opening brace...\n27 |     current = current.drop_right(1);\n28 |   }\n   |   - ...matches this closing brace\n...\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpkkme3wep.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren_char in paren_string.chars() {\n    if paren_char == '(' {\n      current_string += paren_char;\n    } else if paren_char == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren_char;\n      }\n    } else {\n      current_string += paren_char;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpwmcuv9hd.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmcuv9hd.rs:12:25\n   |\n12 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmcuv9hd.rs:18:27\n   |\n18 |         current_string += paren_char;\n   |                           ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwmcuv9hd.rs:21:25\n   |\n21 |       current_string += paren_char;\n   |                         ^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  paren_stack.push(String::from(\"\"));\n  for i in paren_string.chars() {\n    if paren_stack.last().is_empty() {\n      if paren_string[i] == '(' {\n        paren_stack.push(String::from(\"\"));\n      } else {\n        paren_stack.pop();\n      }\n    } else {\n      if paren_string[i] == ')' {\n        paren_stack.pop();\n      } else {\n        paren_stack.last() += paren_string[i];\n      }\n    }\n  }\n  return paren_stack;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpq8x0kei8.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpq8x0kei8.rs:12:10\n   |\n12 |       if paren_string[i] == '(' {\n   |          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpq8x0kei8.rs:18:10\n   |\n18 |       if paren_string[i] == ')' {\n   |          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpq8x0kei8.rs:21:31\n   |\n21 |         paren_stack.last() += paren_string[i];\n   |                               ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `I",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      result.push(current_string);\n      current_string = String::from(\"\");\n      continue;\n    }\n    current_string += paren;\n  }\n  result.push(current_string);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpxxmsy1_5.rs:27:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n24 |   }\n   |   - ...matches this closing brace\n...\n27 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpxxmsy1_5.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = [String::from(\"\")];\n  let result = Vec::new();\n\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      paren_stack.push(String::from(\"\"));\n    } else if c == ')' {\n      if paren_stack.is_empty() {\n        panic!(\"Mismatched parentheses\");\n      }\n      paren_stack.pop();\n    } else {\n      paren_stack.last() += c;\n    }\n  });\n\n  for !paren_stack.is_empty() {\n    result.push(paren_stack.pop());\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected pattern, found `!`\n  --> /tmp/tmpysj88cds.rs:24:7\n   |\n24 |   for !paren_stack.is_empty() {\n   |       ^ expected pattern\n\nerror[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpysj88cds.rs:13:19\n   |\n13 |       paren_stack.push(String::from(\"\"));\n   |                   ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpysj88cds.rs:18:19\n   |\n18 |       paren_stack.pop();\n   |                   ^^^ method not found in `[String; 1]`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Option<&String>`\n  --> /tmp/tmpysj88cds.rs:20:7\n   |\n20 |       paren_stack.last() += c;\n   |       ------------------^^^^^\n   |       |\n   |       cannot use `+=` on type `Option<&String>`\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpysj88cds.rs:20:26\n   |\n20 |       paren_stack.last() += c;\n   |       ------------------ ^^\n   |       |\n   |       cannot assign to this expression\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0067, E0368, E0599.\nFor more information about an error, try `rustc --explain E0067`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\" {\n      stack.push(paren);\n    } else if paren == \")\" {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n      }\n    } else {\n      stack.push(paren);\n    }\n  }\n  result.append(stack.pop());\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpee5ubglo.rs:28:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n25 |   }\n   |   - ...matches this closing brace\n...\n28 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpee5ubglo.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else if paren[0] == \")\" {\n      if current_string == \"\" {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n    } else {\n      current_string += paren;\n    }\n  }\n  if current_string != \"\" {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp7z25ekiy.rs:31:1\n   |\n27 |   if current_string != \"\" {\n   |                           - this opening brace...\n28 |     result.push(current_string);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp7z25ekiy.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      stack.pop();\n      if stack.empty() {\n        result.push(String::from(paren_string.substr(0, i)));\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpu0sn4dzg.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpu0sn4dzg.rs:14:13\n   |\n14 |       stack.pop();\n   |             ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `empty` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpu0sn4dzg.rs:15:16\n   |\n15 |       if stack.empty() {\n   |                ^^^^^ help: there is an associated function with a similar name: `is_empty`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpu0sn4dzg.rs:16:16\n   |\n16 |         result.push(String::from(paren_string.substr(0, i)));\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `substr` found for struct `String` in the current scope\n  --> /tmp/tmpu0sn4dzg.rs:16:47\n   |\n16 |         result.push(String::from(paren_string.substr(0, i)));\n   |                                               ^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu0sn4dzg.rs:21:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n21 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result: Vec<String> = Vec::new();\n  let mut stack: Vec<String> = Vec::new();\n  let mut current: String = String::from(\"\");\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(current);\n      current = String::from(\"\");\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current = stack.pop();\n      }\n    } else {\n      current += i;\n    }\n  }\n  if !stack.is_empty() {\n    throw \"Unbalanced parentheses\";\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Unbalanced parentheses\"`\n  --> /tmp/tmpxq68p0x8.rs:27:11\n   |\n27 |     throw \"Unbalanced parentheses\";\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq68p0x8.rs:20:19\n   |\n10 |   let mut current: String = String::from(\"\");\n   |                    ------ expected due to this type\n...\n20 |         current = stack.pop();\n   |                   ^^^^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n                found enum `Option<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxq68p0x8.rs:23:18\n   |\n23 |       current += i;\n   |                  ^ expected `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(String::from(i))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmplryujbhe.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplryujbhe.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmplryujbhe.rs:16:14\n   |\n16 |       result.push(String::from(i))\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplryujbhe.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for (let chr of paren_string) {\n    if (chr == \"(\") {\n      current_string += chr;\n    } else if (chr == \")\") {\n      if (current_string.is_empty()) {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += chr;\n      }\n    } else {\n      current_string += chr;\n    }\n  }\n  if (!current_string.is_empty()) {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpblziu4mz.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpblziu4mz.rs:10:8\n   |\n10 |   for (let chr of paren_string) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `chr`\n  --> /tmp/tmpblziu4mz.rs:10:12\n   |\n10 |   for (let chr of paren_string) {\n   |           -^^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpblziu4mz.rs:10:16\n   |\n10 |   for (let chr of paren_string) {\n   |               -^^ expected one of `)`, `,`, `@`, or `|`\n   |               |\n   |               help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `paren_string`\n  --> /tmp/tmpblziu4mz.rs:10:19\n   |\n10 |   for (let chr of paren_string) {\n   |                  -^^^^^^^^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |                  |\n   |                  help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpblziu4mz.rs:10:32\n   |\n10 |   for (let chr of paren_string) {\n   |                                ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmpblziu4mz.rs:24:3\n   |\n24 |   if (!current_string.is_empty()) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n24 ~   { if (!current_string.is_empty()) {\n25 |     result.push(current_string);\n26 ~   } }\n   |\n\nerror: aborting due to 7 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  let open_parens = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1;\n    } else if i == ')' {\n      open_parens -= 1;\n    } else if open_parens == 0 {\n      stack.push(i);\n    } else {\n      if stack.pop() == '(' {\n        result.push(String::from(stack.join()));\n        stack = [0];\n      }\n      stack.push(i);\n    }\n  }\n  if stack.pop() != 0 {\n    result.push(String::from(stack.join()));\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpws34qain.rs:17:13\n   |\n17 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpws34qain.rs:19:16\n   |\n19 |       if stack.pop() == '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpws34qain.rs:20:16\n   |\n20 |         result.push(String::from(stack.join()));\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: the method `join` exists for array `[{integer}; 1]`, but its trait bounds were not satisfied\n  --> /tmp/tmpws34qain.rs:20:40\n   |\n20 |         result.push(String::from(stack.join()));\n   |                                        ^^^^ method cannot be called on `[{integer}; 1]` due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n           `[{integer}]: Join<_>`\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpws34qain.rs:23:13\n   |\n23 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpws34qain.rs:26:12\n   |\n26 |   if stack.pop() != 0 {\n   |            ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpws34qain.rs:27:12\n   |\n27 |     result.push(String::from(stack.join()));\n   |            ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: the method `join` exists for array `[{integer}; 1]`, but its trait bounds were not satisfied\n  --> /tmp/tmpws34qain.rs:27:36\n   |\n27 |     result.push(String::from(stack.join()));\n   |                                    ^^^^ method cannot be called on `[{integer}; 1]` due to unsatisfied trait bou",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result: Vec<String> = Vec::new();\n  let mut current_string: String = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      if current_string == \"\") {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      if current_string == \"\") {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n      continue;\n    }\n    current_string += paren;\n  }\n  if current_string != \"\") {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmphbqo5gw6.rs:39:5\n   |\n35 |       } else {\n   |              - this opening brace...\n36 |         current_string += paren;\n37 |       }\n   |       - ...matches this closing brace\n38 |       continue;\n39 |     }\n   |     ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmphbqo5gw6.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmphbqo5gw6.rs:18:24\n   |\n18 |     if paren[0] == \")\" {\n   |                        ^ unclosed delimiter\n19 |       if current_string == \"\") {\n   |                              ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmphbqo5gw6.rs:31:24\n   |\n31 |     if paren[0] == \")\" {\n   |                        ^ unclosed delimiter\n32 |       if current_string == \"\") {\n   |                              ^ mismatched closing delimiter\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren_char in paren_string {\n    if paren_char == '(' {\n      current_string += paren_char;\n    } else if paren_char == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren_char;\n      }\n    } else {\n      current_string += paren_char;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp_3scdak7.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp_3scdak7.rs:10:21\n   |\n10 |   for paren_char in paren_string {\n   |                     ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp_3scdak7.rs:11:19\n   |\n11 |     if paren_char == '(' {\n   |                   ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n             <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp_3scdak7.rs:13:26\n   |\n13 |     } else if paren_char == ')' {\n   |                          ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n             <String as ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1;\n    } else if i == ')' {\n      open_parens -= 1;\n    } else if open_parens == 0 {\n      result.push(String::from(i));\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmptqpqv0jx.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmptqpqv0jx.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else if paren[0] == \")\" {\n      result.push(current_string);\n      current_string = String::from(\"\");\n    } else {\n      current_string += paren;\n    }\n  }\n  result.push(current_string);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpdxqpicb9.rs:25:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |   }\n   |   - ...matches this closing brace\n...\n25 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpdxqpicb9.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut paren_stack = Vec<String>::new();\n  paren_stack.push(String::from(\"(\"));\n  for i in paren_string.chars() {\n    if i == '(' {\n      paren_stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if paren_stack.pop() == String::from(\"(\") {\n        result.push(String::from(\"()\"));\n      } else {\n        result.push(paren_stack.pop());\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpbk5awn6f.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpbk5awn6f.rs:9:28\n  |\n9 |   let mut paren_stack = Vec<String>::new();\n  |                            ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut paren_stack = Vec::<String>::new();\n  |                            ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      stack.push(String::from(i));\n    }\n    if (open_parens == 0 && !stack.is_empty()) {\n      result.push(stack.pop());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp_nc9ev1s.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp_nc9ev1s.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_nc9ev1s.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_nc9ev1s.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_nc9ev1s.rs:16:15\n   |\n16 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (open_parens == 0) {\n16 +     } else if open_parens == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_nc9ev1s.rs:19:8\n   |\n19 |     if (open_parens == 0 && !stack.is_empty()) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (open_parens == 0 && !stack.is_empty()) {\n19 +     if open_parens == 0 && !stack.is_empty() {\n   | \n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else if paren[0] == \")\" {\n      if current_string == \"\" {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n    } else {\n      current_string += paren;\n    }\n  }\n  if current_string != \"\" {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp8qcx0x32.rs:31:1\n   |\n27 |   if current_string != \"\" {\n   |                           - this opening brace...\n28 |     result.push(current_string);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp8qcx0x32.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      if current.ends_with(\"(\") {\n        current = current.drop_right(1);\n      }\n      result.push(current);\n      current = String::from(\"\");\n    } else {\n      current += paren;\n    }\n  }\n  if current.ends_with(\"(\") {\n    current = current.drop_right(1);\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpkkme3wep.rs:31:1\n   |\n26 |   if current.ends_with(\"(\") {\n   |                             - this opening brace...\n27 |     current = current.drop_right(1);\n28 |   }\n   |   - ...matches this closing brace\n...\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpkkme3wep.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [String::from(\"\")];\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"\"));\n    } else if i == ')' {\n      let top = stack.pop();\n      result.push(top);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpffkdfjdc.rs:12:13\n   |\n12 |       stack.push(String::from(\"\"));\n   |             ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmpffkdfjdc.rs:14:23\n   |\n14 |       let top = stack.pop();\n   |                       ^^^ method not found in `[String; 1]`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n      if (open_parens == 0) {\n        result.push(paren_stack.pop());\n      }\n    } else {\n      paren_stack.push(String::from(i));\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpyd2coheg.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyd2coheg.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyd2coheg.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyd2coheg.rs:16:10\n   |\n16 |       if (open_parens == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -       if (open_parens == 0) {\n16 +       if open_parens == 0 {\n   | \n\nerror: aborting due to previous error; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      stack.push(paren);\n    } else if paren[0] == \")\" {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpe5w4y0f1.rs:25:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n23 |   }\n   |   - ...matches this closing brace\n24 |   return result;\n25 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpe5w4y0f1.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      stack.push(String::from(i));\n    }\n    if (open_parens < 0) {\n      result.push(stack.pop());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpbjjbqjst.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpbjjbqjst.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbjjbqjst.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbjjbqjst.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbjjbqjst.rs:16:15\n   |\n16 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (open_parens == 0) {\n16 +     } else if open_parens == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbjjbqjst.rs:19:8\n   |\n19 |     if (open_parens < 0) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (open_parens < 0) {\n19 +     if open_parens < 0 {\n   | \n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec::new();\n  let result = Vec::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      stack.push(paren);\n    } else if paren[0] == \")\" {\n      if stack.is_empty() {\n        throw \"Invalid parentheses\";\n      }\n      let top = stack.last();\n      stack.pop();\n      if top[0] != \"(\" {\n        throw \"Invalid parentheses\";\n      }\n      result.push(top);\n    } else {\n      throw \"Invalid parentheses\";\n    }\n  }\n  if !stack.is_empty() {\n    throw \"Invalid parentheses\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmplc40iyv4.rs:34:1\n   |\n30 |   if !stack.is_empty() {\n   |                        - this opening brace...\n31 |     throw \"Invalid parentheses\";\n32 |   }\n   |   - ...matches this closing brace\n33 |   return result;\n34 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmplc40iyv4.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(\"\"));\n      } else {\n        let top = stack.pop();\n        result.push(top);\n      }\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Not balanced\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp3p22_3zx.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp3p22_3zx.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp3p22_3zx.rs:23:5\n   |\n23 |     panic(\"Not balanced\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n23 |     panic!(\"Not balanced\");\n   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if stack.is_empty() {\n        panic!(\"Unbalanced parens\");\n      }\n      let top = stack.last();\n      stack.pop();\n      if top.ends_with(\"(\") {\n        result.push(top);\n      } else {\n        result.push(String::from(\"(\") + top + String::from(\")\"));\n      }\n    }\n  }\n  if !stack.is_empty() {\n    panic!(\"Unbalanced parens\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpv7g5hbqc.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpv7g5hbqc.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv7g5hbqc.rs:22:47\n   |\n22 |         result.push(String::from(\"(\") + top + String::from(\")\"));\n   |                                               ^^^^^^^^^^^^^^^^^\n   |                                               |\n   |                                               expected `&str`, found struct `String`\n   |                                               help: consider borrowing here: `&String::from(\")\")`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let result = []\n  let stack = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i)\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(i))\n      } else {\n        stack.pop()\n      }\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpg43igzf3.rs:8:18\n  |\n8 |   let result = []\n  |                  ^ help: add `;` here\n9 |   let stack = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpg43igzf3.rs:9:17\n   |\n9  |   let stack = []\n   |                 ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpg43igzf3.rs:12:13\n   |\n12 |       stack.push(i)\n   |             ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpg43igzf3.rs:15:16\n   |\n15 |         result.push(String::from(i))\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `pop` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpg43igzf3.rs:17:15\n   |\n17 |         stack.pop()\n   |               ^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg43igzf3.rs:21:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n21 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(current);\n      current = String::from(\"\");\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current = stack.pop();\n      }\n    } else {\n      current += i;\n    }\n  }\n  if !stack.is_empty() {\n    throw \"Unbalanced parentheses\";\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp36hwtdal.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp36hwtdal.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Unbalanced parentheses\"`\n  --> /tmp/tmp36hwtdal.rs:27:11\n   |\n27 |     throw \"Unbalanced parentheses\";\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp36hwtdal.rs:23:18\n   |\n23 |       current += i;\n   |                  ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  let open_braces = 0;\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == '{') {\n      open_braces += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (i == '}') {\n      open_braces -= 1;\n    } else if (open_parens == 0 && open_braces == 0) {\n      stack.push(String::from(i));\n    }\n    if (open_parens < 0 || open_braces < 0) {\n      panic!(\"Invalid parens or braces\");\n    }\n  }\n  for !stack.is_empty() {\n    let top = stack.pop();\n    result.push(top);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp6bet3f78.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp6bet3f78.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected pattern, found `!`\n  --> /tmp/tmp6bet3f78.rs:28:7\n   |\n28 |   for !stack.is_empty() {\n   |       ^ expected pattern\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6bet3f78.rs:13:8\n   |\n13 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i == '(') {\n13 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6bet3f78.rs:15:15\n   |\n15 |     } else if (i == '{') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (i == '{') {\n15 +     } else if i == '{' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6bet3f78.rs:17:15\n   |\n17 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (i == ')') {\n17 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6bet3f78.rs:19:15\n   |\n19 |     } else if (i == '}') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (i == '}') {\n19 +     } else if i == '}' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6bet3f78.rs:21:15\n   |\n21 |     } else if (open_parens == 0 && open_braces == 0) {\n   |               ^                                    ^\n   |\nhelp: r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      result.push(String::from(paren_stack.pop()));\n      result.push(String::from(i));\n    } else {\n      paren_stack.push(String::from(i));\n    }\n  }\n\n  result.push(String::from(paren_stack.pop()));\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpiudma1pt.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpiudma1pt.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiudma1pt.rs:13:8\n   |\n13 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i == '(') {\n13 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiudma1pt.rs:15:15\n   |\n15 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (i == ')') {\n15 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiudma1pt.rs:17:15\n   |\n17 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (open_parens == 0) {\n17 +     } else if open_parens == 0 {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  let current_string = \"\"\n  for ch in paren_string {\n    if ch == \"(\" {\n      open_parens += 1\n    } else if ch == \")\" {\n      open_parens -= 1\n    } else if ch == \" \" {\n      if open_parens == 0 {\n        result.push(current_string)\n        current_string = \"\"\n      }\n    } else {\n      current_string += ch\n    }\n  }\n  result.push(current_string)\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp0f1g8pqm.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp0f1g8pqm.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   let current_string = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp0f1g8pqm.rs:10:26\n   |\n10 |   let current_string = \"\"\n   |                          ^ help: add `;` here\n11 |   for ch in paren_string {\n   |   --- unexpected token\n\nerror: expected `;`, found `current_string`\n  --> /tmp/tmp0f1g8pqm.rs:18:36\n   |\n18 |         result.push(current_string)\n   |                                    ^ help: add `;` here\n19 |         current_string = \"\"\n   |         -------------- unexpected token\n\nerror: expected `;`, found keyword `return`\n  --> /tmp/tmp0f1g8pqm.rs:25:30\n   |\n25 |   result.push(current_string)\n   |                              ^ help: add `;` here\n26 |   return result\n   |   ------ unexpected token\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp0f1g8pqm.rs:11:13\n   |\n11 |   for ch in paren_string {\n   |             ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp0f1g8pqm.rs:18:16\n   |\n18 |         result.push(current_string)\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp0f1g8pqm.rs:22:7\n   |\n22 |       current_string += ch\n   |       --------------^^^^^^\n   |       |\n   |       cannot use `+=` on type `&str`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp0f1g8pqm.rs:25:10\n   |\n2",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result: Vec<String> = Vec::new();\n  let mut current_string: String = String::from(\"\");\n  for paren in paren_string.chars() {\n    if paren == '(' {\n      current_string += paren;\n    } else if paren == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n    } else {\n      current_string += paren;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp7g7wuahj.rs:12:25\n   |\n12 |       current_string += paren;\n   |                         ^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7g7wuahj.rs:18:27\n   |\n18 |         current_string += paren;\n   |                           ^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7g7wuahj.rs:21:25\n   |\n21 |       current_string += paren;\n   |                         ^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(paren_string[i:i+1])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpjxrsw3da.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjxrsw3da.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpjxrsw3da.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpjxrsw3da.rs:16:34\n   |\n16 |       result.push(paren_string[i:i+1])\n   |                                  ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n16 |       result.push(paren_string[i::i+1])\n   |                                 ~~\nhelp: a builtin type with a similar name exists\n   |\n16 |       result.push(paren_string[i:i8+1])\n   |                                  ~~\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpjxrsw3da.rs:16:14\n   |\n16 |       result.push(paren_string[i:i+1])\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxrsw3da.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\") {\n      stack.push(paren);\n    } else if paren == \")\") {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n      }\n    } else {\n      stack.push(paren);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `)`\n  --> /tmp/tmpj16u5v8v.rs:16:27\n   |\n14 |     if paren == \"(\") {\n   |                      - this opening brace...\n15 |       stack.push(paren);\n16 |     } else if paren == \")\") {\n   |     -                     ^ unexpected closing delimiter\n   |     |\n   |     ...matches this closing brace\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpj16u5v8v.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpj16u5v8v.rs:7:63\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               ^ unclosed delimiter\n...\n14 |     if paren == \"(\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic(\"unbalanced parens\");\n      }\n    }\n    if stack.is_empty() {\n      result.push(String::from(paren_string.sub(i, i + 1)));\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"unbalanced parens\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpu9uj3nil.rs:15:9\n   |\n15 |         panic(\"unbalanced parens\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         panic!(\"unbalanced parens\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpu9uj3nil.rs:23:5\n   |\n23 |     panic(\"unbalanced parens\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n23 |     panic!(\"unbalanced parens\");\n   |          +\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpu9uj3nil.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpu9uj3nil.rs:14:16\n   |\n14 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `sub` found for struct `String` in the current scope\n  --> /tmp/tmpu9uj3nil.rs:19:45\n   |\n19 |       result.push(String::from(paren_string.sub(i, i + 1)));\n   |                                             ^^^ method not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpu9uj3nil.rs:19:54\n   |\n19 |       result.push(String::from(paren_string.sub(i, i + 1)));\n   |                                                    - ^ - {integer}\n   |                                                    |\n   |                                                    char\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0369, E0423, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      if current.is_empty() {\n        result.push(current);\n        current = String::from(\"\");\n        continue;\n      }\n      current += paren;\n      if current.starts_with(\"(\") {\n        current = String::from(\"\");\n        continue;\n      }\n      result.push(current);\n      current = String::from(\"\");\n      continue;\n    }\n    current += paren;\n  }\n  if !current.is_empty() {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpipwt0s0q.rs:39:1\n   |\n35 |   if !current.is_empty() {\n   |                          - this opening brace...\n36 |     result.push(current);\n37 |   }\n   |   - ...matches this closing brace\n38 |   return result;\n39 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpipwt0s0q.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = [String::empty()];\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if paren_stack.last() == String::empty() {\n      if is_open_paren(i) {\n        paren_stack.push(String::from(i));\n      } else if is_close_paren(i) {\n        paren_stack.pop();\n      }\n    } else {\n      if is_open_paren(i) {\n        paren_stack.push(String::from(i));\n      } else if is_close_paren(i) {\n        paren_stack.pop();\n      }\n    }\n    if paren_stack.is_empty() {\n      result.push(paren_stack.last());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_open_paren` in this scope\n  --> /tmp/tmpcd8cbazo.rs:12:10\n   |\n12 |       if is_open_paren(i) {\n   |          ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_close_paren` in this scope\n  --> /tmp/tmpcd8cbazo.rs:14:17\n   |\n14 |       } else if is_close_paren(i) {\n   |                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_open_paren` in this scope\n  --> /tmp/tmpcd8cbazo.rs:18:10\n   |\n18 |       if is_open_paren(i) {\n   |          ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_close_paren` in this scope\n  --> /tmp/tmpcd8cbazo.rs:20:17\n   |\n20 |       } else if is_close_paren(i) {\n   |                 ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `empty` found for struct `String` in the current scope\n --> /tmp/tmpcd8cbazo.rs:8:30\n  |\n8 |   let paren_stack = [String::empty()];\n  |                              ^^^^^\n  |                              |\n  |                              function or associated item not found in `String`\n  |                              help: there is an associated function with a similar name: `is_empty`\n\nerror[E0599]: no function or associated item named `empty` found for struct `String` in the current scope\n  --> /tmp/tmpcd8cbazo.rs:11:38\n   |\n11 |     if paren_stack.last() == String::empty() {\n   |                                      ^^^^^\n   |                                      |\n   |                                      function or associated item not found in `String`\n   |                                      help: there is an associated function with a similar name: `is_empty`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == ')' {\n      open_parens -= 1\n    } else if open_parens == 0 {\n      result.push(String::from(i))\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmplryujbhe.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplryujbhe.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmplryujbhe.rs:16:14\n   |\n16 |       result.push(String::from(i))\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplryujbhe.rs:19:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n19 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if stack.is_empty() {\n        panic!(\"Unbalanced parens\");\n      }\n      let top = stack.pop();\n      result.push(top);\n    }\n  }\n\n  if !stack.is_empty() {\n    panic!(\"Unbalanced parens\");\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpxx3f2vsq.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpxx3f2vsq.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  let start = 0\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if paren_string[i] == ' ' {\n      if open_parens == 0 {\n        result.append(paren_string[start:i])\n        start = i + 1\n      }\n    }\n  }\n  result.append(paren_string[start:])\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpz5p_zqgv.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpz5p_zqgv.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz5p_zqgv.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpz5p_zqgv.rs:18:45\n   |\n18 |         result.append(paren_string[start:i])\n   |                                             ^ help: add `;` here\n19 |         start = i + 1\n   |         ----- unexpected token\n\nerror: expected type, found `]`\n  --> /tmp/tmpz5p_zqgv.rs:23:36\n   |\n23 |   result.append(paren_string[start:])\n   |                                   -^ expected type\n   |                                   |\n   |                                   tried to parse a type due to this\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpz5p_zqgv.rs:11:12\n   |\n11 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpz5p_zqgv.rs:11:21\n   |\n11 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpz5p_zqgv.rs:18:42\n   |\n18 |         result.append(paren_string[start:i])\n   |                                          ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n18 |         result.append(paren_string[start::i])\n   |                                         ~~\nhelp: a builtin type with a similar name exists\n   |\n18 |         result.append(paren_string",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      result.push(current);\n      current = String::from(\"\");\n    } else {\n      current += paren;\n    }\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpc_zddcon.rs:25:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n22 |   }\n   |   - ...matches this closing brace\n...\n25 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpc_zddcon.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut open_parens = 0;\n  let mut open_braces = 0;\n  let mut open_brackets = 0;\n  let mut open_squares = 0;\n  let mut open_curly = 0;\n  let mut open_angle = 0;\n  let mut open_paren_count = 0;\n  let mut open_brace_count = 0;\n  let mut open_bracket_count = 0;\n  let mut open_square_count = 0;\n  let mut open_curly_count = 0;\n  let mut open_angle_count = 0;\n  let mut open_paren_count = 0;\n  let mut open_brace_count = 0;\n  let mut open_bracket_count = 0;\n  let mut open_square_count = 0;\n  let mut open_curly_count = 0;\n  let mut open_angle_count = 0;\n  let mut open_paren_count = 0;\n  let mut open_brace_count = 0;\n  let mut open_bracket_count = 0;\n  let mut open_square_count = 0;\n  let mut open_curly_count = 0;\n  let mut open_angle_count = 0;\n  let mut open_paren_count = 0;\n  let mut open_brace_count = 0;\n  let mut open_bracket_count = 0;\n  let mut open_square_count = 0;\n  let mut open_curly_count = 0;\n  let mut open_angle_count = 0;\n  let mut open_paren_count = 0;\n  let mut open_brace_count = 0;\n  let mut open_bracket_count = 0;\n  let mut open_square_count = 0;\n  let mut open_curly_count = 0;\n  let mut open_angle_count = 0;\n  let mut open_paren_count = 0;\n  let mut open_brace_count = 0;\n  let mut open_bracket_count = 0;\n  let mut open_square_count = 0;\n  let mut open_curly_\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpub8gig50.rs:50:22\n   |\n50 |   let mut open_curly_\n   |                      ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpub8gig50.rs:7:51\n  |\n7 | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n  |    ---------------------                          ^^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<String>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      stack.push(String::from(i));\n    }\n    if (open_parens == 0 && !stack.is_empty()) {\n      result.push(stack.pop());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmphzstroxk.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmphzstroxk.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphzstroxk.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphzstroxk.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphzstroxk.rs:16:15\n   |\n16 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (open_parens == 0) {\n16 +     } else if open_parens == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphzstroxk.rs:19:8\n   |\n19 |     if (open_parens == 0 && !stack.is_empty()) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (open_parens == 0 && !stack.is_empty()) {\n19 +     if open_parens == 0 && !stack.is_empty() {\n   | \n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  let open_braces = 0;\n  let open_brackets = 0;\n  let open_squares = 0;\n  let open_curly = 0;\n  let open_parens_stack = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if (c == '(') {\n      open_parens += 1;\n      open_parens_stack.push(c);\n    } else if (c == ')') {\n      if (open_parens == 0) {\n        throw \"Unbalanced parens\";\n      }\n      open_parens -= 1;\n      if (open_parens == 0) {\n        open_parens_stack.pop();\n        if (open_parens_stack.is_empty()) {\n          stack.push(String::from_iter(stack.pop() + \"(\" + stack.pop() + \")\"));\n        } else {\n          stack.push(String::from_iter(stack.pop() + \"(\" + stack.pop() + \")\" + stack.pop()));\n        }\n      }\n    } else if (c == '{') {\n      open_braces += 1;\n    } else if (c == '}') {\n      if (open_braces == 0) {\n        throw \"Unbalanced braces\";\n      }\n      open_braces -= 1;\n    } else if (c == '[') {\n      open_brackets += 1;\n    } else if (c == ']') {\n      if (open_brackets == 0) {\n        throw \"Unbalanced brackets\";\n      }\n      open_brackets -= 1;\n    } else if (c == '\"') {\n      open_squares += 1;\n    } else if (c == '\\'') {\n      if (open_squares == 0) {\n        throw \"Unbalanced quotes\";\n      }\n      open_squares -= 1;\n    } else if (c == ';') {\n      if (open_curly\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdvr34vz7.rs:64:3\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - unclosed delimiter\n...\n16 |   paren_string.chars().for_each(|c| {\n   |                                -    - unclosed delimiter\n   |                                |\n   |                                unclosed delimiter\n...\n54 |     } else if (c == ';') {\n   |                          - this delimiter might not be properly closed...\n55 |       if (open_curly\n56 | }\n   | - ...as it matches this but it has different indentation\n...\n64 | }\n   |   ^\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpdvr34vz7.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpdvr34vz7.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpdvr34vz7.rs:15:30\n   |\n15 |   let open_parens_stack = Vec<String>::new();\n   |                              ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n15 |   let open_parens_stack = Vec::<String>::new();\n   |                              ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Unbalanced parens\"`\n  --> /tmp/tmpdvr34vz7.rs:7:63\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               ^ unclosed delimiter\n...\n22 |         throw \"Unbalanced parens\";\n   |              -^^^^^^^^^^^^^^^^^^^ expected one of ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(current);\n      current = String::from(\"\");\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current = stack.pop();\n      }\n    } else {\n      current += i;\n    }\n  }\n  if !stack.is_empty() {\n    throw \"Unbalanced parentheses\";\n  }\n  result.push(current);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp36hwtdal.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp36hwtdal.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Unbalanced parentheses\"`\n  --> /tmp/tmp36hwtdal.rs:27:11\n   |\n27 |     throw \"Unbalanced parentheses\";\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp36hwtdal.rs:23:18\n   |\n23 |       current += i;\n   |                  ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  let open_parens = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1;\n    } else if i == ')' {\n      open_parens -= 1;\n    } else if open_parens == 0 {\n      stack.push(String::from(i));\n    } else {\n      stack.push(String::from(i));\n    }\n  }\n  for !stack.is_empty() {\n    let top = stack.pop();\n    if !top.is_empty() {\n      result.push(top);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpcsstc87g.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpcsstc87g.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected pattern, found `!`\n  --> /tmp/tmpcsstc87g.rs:22:7\n   |\n22 |   for !stack.is_empty() {\n   |       ^ expected pattern\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n      continue;\n    }\n    if paren[0] == \")\" {\n      result.push(current_string);\n      current_string = String::from(\"\");\n      continue;\n    }\n    current_string += paren;\n  }\n  result.push(current_string);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpxxmsy1_5.rs:27:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n24 |   }\n   |   - ...matches this closing brace\n...\n27 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpxxmsy1_5.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if stack.is_empty() {\n        panic!(\"Mismatched parentheses\");\n      }\n      let top = stack.pop();\n      result.push(top);\n    }\n  }\n  if !stack.is_empty() {\n    panic!(\"Mismatched parentheses\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp5bj7zxv6.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp5bj7zxv6.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\" {\n      stack.push(paren);\n    } else if paren == \")\" {\n      if stack.is_empty() {\n        throw \"Unbalanced parentheses\";\n      }\n      let top = stack.last();\n      stack.pop();\n      if top != \"(\") {\n        throw \"Unbalanced parentheses\";\n      }\n    } else {\n      result.push(paren);\n    }\n  }\n  if !stack.is_empty() {\n    throw \"Unbalanced parentheses\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpmxt8kngt.rs:28:3\n   |\n25 |     } else {\n   |            - this opening brace...\n26 |       result.push(paren);\n27 |     }\n   |     - ...matches this closing brace\n28 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpmxt8kngt.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpmxt8kngt.rs:16:28\n   |\n16 |     } else if paren == \")\" {\n   |                            ^ unclosed delimiter\n...\n22 |       if top != \"(\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut current = String::from(\"\");\n  let mut open_braces = 0;\n  let mut closed_braces = 0;\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_braces += 1;\n      current += i;\n    } else if i == ')' {\n      if open_braces == 0 {\n        closed_braces += 1;\n        current += i;\n      } else {\n        current += i;\n      }\n    } else if i == '{' {\n      if open_braces == 0 {\n        current += i;\n      } else {\n        stack.push(current);\n        current = String::from(\"\");\n      }\n    } else if i == '}' {\n      if open_braces == 0 {\n        current += i;\n      } else {\n        current += i;\n      }\n    } else {\n      current += i;\n    }\n\n    if closed_braces == open_braces {\n      result.push(current);\n      current = String::from(\"\");\n      open_braces = 0;\n      closed_braces = 0;\n    }\n  }\n\n  if open_braces > 0 {\n    result.push(current);\n  }\n\n  for i in stack {\n    result.push(i);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpj887dnsj.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpj887dnsj.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj887dnsj.rs:17:18\n   |\n17 |       current += i;\n   |                  ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj887dnsj.rs:21:20\n   |\n21 |         current += i;\n   |                    ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj887dnsj.rs:23:20\n   |\n23 |         current += i;\n   |                    ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj887dnsj.rs:27:20\n   |\n27 |         current += i;\n   |                    ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj887dnsj.rs:34:20\n   |\n34 |         current += i;\n   |                    ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj887dnsj.rs:36:20\n   |\n36 |         current += i;\n   |                    ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj887dnsj.rs:39:18\n   |\n39 |       current += i;\n   |                  ^ expected `&str`, found `char`\n\nerror: aborting due to 9 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_stack.push(String::from(\"\"));\n  for (let ch of paren_string) {\n    if (ch == \"(\") {\n      paren_stack.push(String::from(\"\"));\n    } else if (ch == \")\") {\n      if (paren_stack.is_empty()) {\n        result.push(paren_stack.pop());\n      } else {\n        paren_stack.pop();\n      }\n    } else {\n      paren_stack.push(String::from(ch));\n    }\n  }\n  result.append(paren_stack.pop());\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpukj2afcu.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpukj2afcu.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpukj2afcu.rs:11:8\n   |\n11 |   for (let ch of paren_string) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `ch`\n  --> /tmp/tmpukj2afcu.rs:11:12\n   |\n11 |   for (let ch of paren_string) {\n   |           -^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpukj2afcu.rs:11:15\n   |\n11 |   for (let ch of paren_string) {\n   |              -^^ expected one of `)`, `,`, `@`, or `|`\n   |              |\n   |              help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `paren_string`\n  --> /tmp/tmpukj2afcu.rs:11:18\n   |\n11 |   for (let ch of paren_string) {\n   |                 -^^^^^^^^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |                 |\n   |                 help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpukj2afcu.rs:11:31\n   |\n11 |   for (let ch of paren_string) {\n   |                               ^ help: try adding `in` here\n\nerror: expected `{`, found `result`\n  --> /tmp/tmpukj2afcu.rs:24:3\n   |\n24 |   result.append(paren_stack.pop());\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n24 |   { result.append(paren_stack.pop()); }\n   |   +                                   +\n\nerror: ab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  let paren_count = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      paren_count += 1;\n    } else if i == ')' {\n      paren_count -= 1;\n    } else if paren_count == 0 {\n      if stack.len() > 0 {\n        stack.pop();\n      }\n      if stack.len() == 0 {\n        result.push(String::from(paren_string.sub(i, i + 1)));\n      } else {\n        result.push(String::from(paren_string.sub(stack.last(), i)));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpmbqv5ybz.rs:18:15\n   |\n18 |         stack.pop();\n   |               ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpmbqv5ybz.rs:21:16\n   |\n21 |         result.push(String::from(paren_string.sub(i, i + 1)));\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `sub` found for struct `String` in the current scope\n  --> /tmp/tmpmbqv5ybz.rs:21:47\n   |\n21 |         result.push(String::from(paren_string.sub(i, i + 1)));\n   |                                               ^^^ method not found in `String`\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpmbqv5ybz.rs:21:56\n   |\n21 |         result.push(String::from(paren_string.sub(i, i + 1)));\n   |                                                      - ^ - {integer}\n   |                                                      |\n   |                                                      char\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpmbqv5ybz.rs:23:16\n   |\n23 |         result.push(String::from(paren_string.sub(stack.last(), i)));\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `sub` found for struct `String` in the current scope\n  --> /tmp/tmpmbqv5ybz.rs:23:47\n   |\n23 |         result.push(String::from(paren_string.sub(stack.last(), i)));\n   |                                               ^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmbqv5ybz.rs:27:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n27 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = no",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec::new();\n\n  for (let i = 0; i < paren_string.length(); i++) {\n    if (paren_string[i] == '(') {\n      open_parens += 1;\n    } else if (paren_string[i] == ')') {\n      if (open_parens == 0) {\n        result.push(paren_stack.pop());\n      } else {\n        open_parens -= 1;\n      }\n    } else {\n      paren_stack.push(paren_string[i]);\n    }\n  }\n\n  if (open_parens > 0) {\n    throw \"Unbalanced parentheses\";\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpnixw4b9g.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpnixw4b9g.rs:12:8\n   |\n12 |   for (let i = 0; i < paren_string.length(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpnixw4b9g.rs:12:12\n   |\n12 |   for (let i = 0; i < paren_string.length(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpnixw4b9g.rs:12:14\n   |\n12 |   for (let i = 0; i < paren_string.length(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpnixw4b9g.rs:12:13\n   |\n12 |   for (let i = 0; i < paren_string.length(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpnixw4b9g.rs:12:14\n   |\n12 |   for (let i = 0; i < paren_string.length(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren_char in paren_string {\n    if paren_char == '(' {\n      current_string += paren_char;\n    } else if paren_char == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren_char;\n      }\n    } else {\n      current_string += paren_char;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp_3scdak7.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp_3scdak7.rs:10:21\n   |\n10 |   for paren_char in paren_string {\n   |                     ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp_3scdak7.rs:11:19\n   |\n11 |     if paren_char == '(' {\n   |                   ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n             <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp_3scdak7.rs:13:26\n   |\n13 |     } else if paren_char == ')' {\n   |                          ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n             <String as ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = [String::from(\"\")];\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if paren_stack.last() == \"\" {\n      paren_stack.push(String::from(\"\"));\n    }\n    if i == '(' {\n      paren_stack.push(String::from(\"\"));\n    } else if i == ')' {\n      if paren_stack.pop() == \"\" {\n        panic!(\"Mismatched parentheses\");\n      }\n    } else {\n      paren_stack.last() += String::from(i);\n    }\n  }\n  paren_stack.pop();\n  for paren_str in paren_stack {\n    result.push(paren_str);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp9q9v_21q.rs:11:30\n   |\n11 |     if paren_stack.last() == \"\" {\n   |                              ^^ expected enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<&String>`\n           found reference `&'static str`\n\nerror[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp9q9v_21q.rs:12:19\n   |\n12 |       paren_stack.push(String::from(\"\"));\n   |                   ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp9q9v_21q.rs:15:19\n   |\n15 |       paren_stack.push(String::from(\"\"));\n   |                   ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp9q9v_21q.rs:17:22\n   |\n17 |       if paren_stack.pop() == \"\" {\n   |                      ^^^ method not found in `[String; 1]`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Option<&String>`\n  --> /tmp/tmp9q9v_21q.rs:21:7\n   |\n21 |       paren_stack.last() += String::from(i);\n   |       ------------------^^^^^^^^^^^^^^^^^^^\n   |       |\n   |       cannot use `+=` on type `Option<&String>`\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp9q9v_21q.rs:21:26\n   |\n21 |       paren_stack.last() += String::from(i);\n   |       ------------------ ^^\n   |       |\n   |       cannot assign to this expression\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp9q9v_21q.rs:24:15\n   |\n24 |   paren_stack.pop();\n   |               ^^^ method not found in `[String; 1]`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0067, E0308, E0368, E0599.\nFor more information about an error, try `rustc --explain E0067`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(\"(\"));\n    } else if c == ')' {\n      if stack.is_empty() {\n        throw \"Unbalanced parentheses\";\n      }\n      let top = stack.pop();\n      result.push(top);\n    }\n  });\n  if !stack.is_empty() {\n    throw \"Unbalanced parentheses\";\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpn60di178.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpn60di178.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Unbalanced parentheses\"`\n  --> /tmp/tmpn60di178.rs:15:15\n   |\n15 |         throw \"Unbalanced parentheses\";\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Unbalanced parentheses\"`\n  --> /tmp/tmpn60di178.rs:22:11\n   |\n22 |     throw \"Unbalanced parentheses\";\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n    } else if (open_parens == 0) {\n      result.push(String::from(paren_stack.pop()));\n    }\n    paren_stack.push(String::from(i));\n  }\n  result.push(String::from(paren_stack.pop()));\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpbji8wgjl.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpbji8wgjl.rs:10:19\n   |\n10 |   let result = Vec<String>::new();\n   |                   ^      ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let result = Vec::<String>::new();\n   |                   ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbji8wgjl.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbji8wgjl.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbji8wgjl.rs:16:15\n   |\n16 |     } else if (open_parens == 0) {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (open_parens == 0) {\n16 +     } else if open_parens == 0 {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  let paren_count = 0;\n  for i in paren_string.chars() {\n    if (i == '(') {\n      paren_count += 1;\n      stack.push(i);\n    } else if (i == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        let open_braces = stack.pop();\n        let close_braces = stack.pop();\n        let str = String::from(open_braces);\n        str += String::from(close_braces);\n        result.push(str);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvr6c94i7.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvr6c94i7.rs:15:15\n   |\n15 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (i == ')') {\n15 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvr6c94i7.rs:17:10\n   |\n17 |       if (paren_count == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (paren_count == 0) {\n17 +       if paren_count == 0 {\n   | \n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpvr6c94i7.rs:14:13\n   |\n14 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpvr6c94i7.rs:18:33\n   |\n18 |         let open_braces = stack.pop();\n   |                                 ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmpvr6c94i7.rs:19:34\n   |\n19 |         let close_braces = stack.pop();\n   |                                  ^^^ method not found in `[{integer}; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvr6c94i7.rs:21:16\n   |\n21 |         str += String::from(close_braces);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                |\n   |                expected `&str`, found struct `String`\n   |                help: consider borrowing here: `&String::from(close_braces)`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpvr6c94i7.rs:22:16\n   |\n22 |         result.push(str);\n   |                ^^^^ metho",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else {\n      if current != \"\" {\n        result.push(current);\n        current = String::from(\"\");\n      }\n      current += paren;\n    }\n  }\n  if current != \"\" {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp_k46l0bt.rs:28:1\n   |\n24 |   if current != \"\" {\n   |                    - this opening brace...\n25 |     result.push(current);\n26 |   }\n   |   - ...matches this closing brace\n27 |   return result;\n28 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp_k46l0bt.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let result = []\n  let stack = [0]\n  let open_parens = 0\n  let open_braces = 0\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1\n    } else if i == '{' {\n      open_braces += 1\n    } else if i == ')' {\n      open_parens -= 1\n    } else if i == '}' {\n      open_braces -= 1\n    }\n    if open_parens == 0 && open_braces == 0 {\n      if stack.len() > 0 {\n        result.push(String::from(paren_string.substr(stack[0], i - stack[0])))\n        stack.pop()\n      }\n    }\n    stack.push(i)\n  }\n  if stack.len() > 0 {\n    result.push(String::from(paren_string.substr(stack[0], paren_string.len() - stack[0])))\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpk368ksrb.rs:8:18\n  |\n8 |   let result = []\n  |                  ^ help: add `;` here\n9 |   let stack = [0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpk368ksrb.rs:9:18\n   |\n9  |   let stack = [0]\n   |                  ^ help: add `;` here\n10 |   let open_parens = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpk368ksrb.rs:10:22\n   |\n10 |   let open_parens = 0\n   |                      ^ help: add `;` here\n11 |   let open_braces = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk368ksrb.rs:11:22\n   |\n11 |   let open_braces = 0\n   |                      ^ help: add `;` here\n12 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror: expected `;`, found `stack`\n  --> /tmp/tmpk368ksrb.rs:24:79\n   |\n24 |         result.push(String::from(paren_string.substr(stack[0], i - stack[0])))\n   |                                                                               ^ help: add `;` here\n25 |         stack.pop()\n   |         ----- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmpk368ksrb.rs:24:16\n   |\n24 |         result.push(String::from(paren_string.substr(stack[0], i - stack[0])))\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `substr` found for struct `String` in the current scope\n  --> /tmp/tmpk368ksrb.rs:24:47\n   |\n24 |         result.push(String::from(paren_string.substr(stack[0], i - stack[0])))\n   |                                               ^^^^^^ method not found in `String`\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpk368ksrb.rs:24:66\n   |\n24 |         result.push(String::from(paren_string.substr(stack[0], i - stack[0])))\n   |                                                                - ^ -------- {integer}\n   |                                                                |\n   |                ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let paren_stack = Vec::new()\n  let result = Vec::new()\n\n  for i in paren_string.chars() {\n    if paren_stack.len == 0 {\n      if i == '(' {\n        open_parens += 1\n      } else if i == ')' {\n        open_parens -= 1\n      }\n    } else {\n      if i == '(' {\n        paren_stack.push(i)\n      } else if i == ')' {\n        if paren_stack.last() == '(' {\n          paren_stack.pop()\n        } else {\n          result.push(String::from(paren_stack.pop()))\n        }\n      }\n    }\n  }\n\n  if paren_stack.len > 0 {\n    panic(\"Unbalanced parentheses\")\n  }\n\n  for i in result {\n    println!(\"{}\", i)\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmprlz_bbf7.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let paren_stack = Vec::new()\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprlz_bbf7.rs:9:31\n   |\n9  |   let paren_stack = Vec::new()\n   |                               ^ help: add `;` here\n10 |   let result = Vec::new()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmprlz_bbf7.rs:10:26\n   |\n10 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n11 | \n12 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmprlz_bbf7.rs:33:5\n   |\n33 |     panic(\"Unbalanced parentheses\")\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n33 |     panic!(\"Unbalanced parentheses\")\n   |          +\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmprlz_bbf7.rs:13:20\n   |\n13 |     if paren_stack.len == 0 {\n   |                    ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n13 |     if paren_stack.len() == 0 {\n   |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprlz_bbf7.rs:23:34\n   |\n23 |         if paren_stack.last() == '(' {\n   |                                  ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&char>`\n              found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprlz_bbf7.rs:24:11\n   |\n23 | /         if paren_stack.last() == '(' {\n24 | |           paren_stack.pop()\n   | |           ^^^^^^^^^^^^^^^^^ expected `()`, found enum `Option`\n25 | |         } else {\n26 | |           result.push(String::from(paren_stack.pop()))\n27 | |         }\n   | |_________- expected this to be `()`\n   |\n   = note: expected unit type `()`\n                   found enum `Option<char>`\nhelp: consider using a semicolon here\n   |\n24 |           paren_stack.pop();\n   |        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(String::from(c));\n    } else if c == ')' {\n      if stack.is_empty() {\n        result.push(String::from(c));\n      } else {\n        let top = stack.last();\n        stack.pop();\n        result.push(top + String::from(c));\n      }\n    }\n  });\n\n  if !stack.is_empty() {\n    throw \"Invalid input\";\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp3nc7wh07.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp3nc7wh07.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid input\"`\n  --> /tmp/tmp3nc7wh07.rs:25:11\n   |\n25 |     throw \"Invalid input\";\n   |           ^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let paren_stack = Vec<String>::new();\n  let open_parens = 0;\n  let result = Vec::new();\n  for i in paren_string.chars() {\n    if (i == '(') {\n      open_parens += 1;\n    } else if (i == ')') {\n      open_parens -= 1;\n      if (open_parens == 0) {\n        result.push(paren_stack.pop());\n      }\n    } else {\n      paren_stack.push(String::from(i));\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpyd2coheg.rs:8:24\n  |\n8 |   let paren_stack = Vec<String>::new();\n  |                        ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let paren_stack = Vec::<String>::new();\n  |                        ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyd2coheg.rs:12:8\n   |\n12 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (i == '(') {\n12 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyd2coheg.rs:14:15\n   |\n14 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (i == ')') {\n14 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyd2coheg.rs:16:10\n   |\n16 |       if (open_parens == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n16 -       if (open_parens == 0) {\n16 +       if open_parens == 0 {\n   | \n\nerror: aborting due to previous error; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec::new();\n  let result = Vec::new();\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      stack.push(c);\n    } else if c == ')' {\n      if stack.is_empty() {\n        result.push(String::from(c));\n      } else {\n        result.push(String::from(stack.pop()));\n      }\n    }\n  });\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `String: From<Option<char>>` is not satisfied\n  --> /tmp/tmph8k1v2s4.rs:17:21\n   |\n17 |         result.push(String::from(stack.pop()));\n   |                     ^^^^^^^^^^^^ the trait `From<Option<char>>` is not implemented for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <String as From<&String>>\n             <String as From<&mut str>>\n             <String as From<&str>>\n             <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"(\"));\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(\"\"));\n      } else {\n        let top = stack.last();\n        stack.pop();\n        result.push(top + String::from(\")\"));\n      }\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Unbalanced parenthesis\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpndzrwstt.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpndzrwstt.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmpndzrwstt.rs:24:5\n   |\n24 |     panic(\"Unbalanced parenthesis\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n24 |     panic!(\"Unbalanced parenthesis\");\n   |          +\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  let mut current_paren = String::from(\"\");\n\n  for c in paren_string {\n    if c == '(' {\n      current_paren += c;\n    } else if c == ')' {\n      if current_paren.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n        current_paren = String::from(\"\");\n      } else {\n        current_paren += c;\n      }\n    } else {\n      current_string += c;\n    }\n  }\n\n  if current_paren.is_empty() {\n    result.push(current_string);\n  } else {\n    result.push(current_paren);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp3sf5zly0.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp3sf5zly0.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp3sf5zly0.rs:13:12\n   |\n13 |   for c in paren_string {\n   |            ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp3sf5zly0.rs:14:10\n   |\n14 |     if c == '(' {\n   |          ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n             <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp3sf5zly0.rs:16:17\n   |\n16 |     } else if c == ')' {\n   |                 ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as Part",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for i in paren_string.chars() {\n    if i == '(' {\n      current_string += i;\n    } else if i == ')' {\n      if current_string.is_empty() {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += i;\n      }\n    } else {\n      current_string += i;\n    }\n  }\n  if !current_string.is_empty() {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp43r83450.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:12:25\n   |\n12 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:18:27\n   |\n18 |         current_string += i;\n   |                           ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43r83450.rs:21:25\n   |\n21 |       current_string += i;\n   |                         ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = []\n  for i in range(0, len(paren_string)) {\n    if paren_string[i] == '(' {\n      open_parens += 1\n    } else if paren_string[i] == ')' {\n      open_parens -= 1\n    } else if paren_string[i] == '(' && open_parens == 0 {\n      result.push(String::from(paren_string[0:i]))\n      result.push(String::from(paren_string[i:]))\n      break\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpp1435yb4.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpp1435yb4.rs:9:18\n   |\n9  |   let result = []\n   |                  ^ help: add `;` here\n10 |   for i in range(0, len(paren_string)) {\n   |   --- unexpected token\n\nerror: expected `;`, found `result`\n  --> /tmp/tmpp1435yb4.rs:16:51\n   |\n16 |       result.push(String::from(paren_string[0:i]))\n   |                                                   ^ help: add `;` here\n17 |       result.push(String::from(paren_string[i:]))\n   |       ------ unexpected token\n\nerror: expected type, found `]`\n  --> /tmp/tmpp1435yb4.rs:17:47\n   |\n17 |       result.push(String::from(paren_string[i:]))\n   |                                              -^ expected type\n   |                                              |\n   |                                              tried to parse a type due to this\n\nerror: expected `;`, found keyword `break`\n  --> /tmp/tmpp1435yb4.rs:17:50\n   |\n17 |       result.push(String::from(paren_string[i:]))\n   |                                                  ^ help: add `;` here\n18 |       break\n   |       ----- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpp1435yb4.rs:10:12\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |            ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpp1435yb4.rs:10:21\n   |\n10 |   for i in range(0, len(paren_string)) {\n   |                     ^^^ not found in this scope\n\nerror[E0573]: expected type, found local variable `i`\n  --> /tmp/tmpp1435yb4.rs:16:47\n   |\n16 |       result.push(String::from(paren_string[0:i]))\n   |                                               ^\n   |\nhelp: maybe you meant to write a path separator here\n   |\n16 |       result.push(",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let result = []\n  let stack = []\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i)\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(paren_string.substr(i, 1)))\n      } else {\n        stack.pop()\n      }\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp0148axkv.rs:8:18\n  |\n8 |   let result = []\n  |                  ^ help: add `;` here\n9 |   let stack = []\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp0148axkv.rs:9:17\n   |\n9  |   let stack = []\n   |                 ^ help: add `;` here\n10 |   for i in paren_string.chars() {\n   |   --- unexpected token\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp0148axkv.rs:12:13\n   |\n12 |       stack.push(i)\n   |             ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp0148axkv.rs:15:16\n   |\n15 |         result.push(String::from(paren_string.substr(i, 1)))\n   |                ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `substr` found for struct `String` in the current scope\n  --> /tmp/tmp0148axkv.rs:15:47\n   |\n15 |         result.push(String::from(paren_string.substr(i, 1)))\n   |                                               ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `pop` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp0148axkv.rs:17:15\n   |\n17 |         stack.pop()\n   |               ^^^ method not found in `[_; 0]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0148axkv.rs:21:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n21 |   return result\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let open_parens = 0\n  let result = Vec<String>::new()\n  let current_string = String::from(\"\")\n  for c in paren_string {\n    if c == \"(\" {\n      open_parens += 1\n      current_string += c\n    } else if c == \")\" {\n      open_parens -= 1\n      current_string += c\n      if open_parens == 0 {\n        result.push(current_string)\n        current_string = String::from(\"\")\n      }\n    } else {\n      current_string += c\n    }\n  }\n  if open_parens != 0 {\n    panic(\"Invalid paren string\")\n  }\n  return result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpbpvd3gzn.rs:8:22\n  |\n8 |   let open_parens = 0\n  |                      ^ help: add `;` here\n9 |   let result = Vec<String>::new()\n  |   --- unexpected token\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpbpvd3gzn.rs:9:19\n  |\n9 |   let result = Vec<String>::new()\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new()\n  |                   ++\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpbpvd3gzn.rs:9:34\n   |\n9  |   let result = Vec<String>::new()\n   |                                  ^ help: add `;` here\n10 |   let current_string = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbpvd3gzn.rs:10:40\n   |\n10 |   let current_string = String::from(\"\")\n   |                                        ^ help: add `;` here\n11 |   for c in paren_string {\n   |   --- unexpected token\n\nerror: expected `;`, found `current_string`\n  --> /tmp/tmpbpvd3gzn.rs:13:23\n   |\n13 |       open_parens += 1\n   |                       ^ help: add `;` here\n14 |       current_string += c\n   |       -------------- unexpected token\n\nerror: expected `;`, found `current_string`\n  --> /tmp/tmpbpvd3gzn.rs:16:23\n   |\n16 |       open_parens -= 1\n   |                       ^ help: add `;` here\n17 |       current_string += c\n   |       -------------- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpbpvd3gzn.rs:17:26\n   |\n17 |       current_string += c\n   |                          ^ help: add `;` here\n18 |       if open_parens == 0 {\n   |       -- unexpected token\n\nerror: expected `;`, found `current_string`\n  --> /tmp/tmpbpvd3gzn.rs:19:36\n   |\n19 |         result.push(current_string)\n   |                                    ^ help: add `;` here\n20 |         current_string = String::from(\"\")\n   |         -------------- unexpected token\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [0];\n  let result = [];\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.pop() != '(' {\n        panic(\"Invalid parentheses\");\n      }\n    }\n    if stack.is_empty() {\n      result.push(String::from(paren_string.sub(i, i)));\n    }\n  }\n  if !stack.is_empty() {\n    panic(\"Invalid parentheses\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp8if14set.rs:15:9\n   |\n15 |         panic(\"Invalid parentheses\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         panic!(\"Invalid parentheses\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmp8if14set.rs:23:5\n   |\n23 |     panic(\"Invalid parentheses\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n23 |     panic!(\"Invalid parentheses\");\n   |          +\n\nerror[E0599]: no method named `push` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp8if14set.rs:12:13\n   |\n12 |       stack.push(i);\n   |             ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `pop` found for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp8if14set.rs:14:16\n   |\n14 |       if stack.pop() != '(' {\n   |                ^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: no method named `push` found for array `[_; 0]` in the current scope\n  --> /tmp/tmp8if14set.rs:19:14\n   |\n19 |       result.push(String::from(paren_string.sub(i, i)));\n   |              ^^^^ method not found in `[_; 0]`\n\nerror[E0599]: no method named `sub` found for struct `String` in the current scope\n  --> /tmp/tmp8if14set.rs:19:45\n   |\n19 |       result.push(String::from(paren_string.sub(i, i)));\n   |                                             ^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8if14set.rs:25:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n25 |   return result;\n   |          ^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 0 elements\n   |\n   = note: expected struct `Vec<String>`\n               found array `[_; 0]`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current += paren;\n    } else if paren[0] == \")\" {\n      if current == \"\" {\n        result.push(current);\n        current = String::from(\"\");\n      } else {\n        current += paren;\n      }\n    } else {\n      current += paren;\n    }\n  }\n  if current != \"\" {\n    result.push(current);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpd381idnz.rs:31:1\n   |\n27 |   if current != \"\" {\n   |                    - this opening brace...\n28 |     result.push(current);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpd381idnz.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = [String::from(\"\")];\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(\"\"));\n    } else if i == ')' {\n      if stack.pop() == String::from(\"\") {\n        stack.pop();\n      } else {\n        stack.push(String::from(\"\"));\n      }\n    } else {\n      stack[stack.len() - 1] += i;\n    }\n  }\n  return stack.map(String::from);\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp1qa6llys.rs:11:13\n   |\n11 |       stack.push(String::from(\"\"));\n   |             ^^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp1qa6llys.rs:13:16\n   |\n13 |       if stack.pop() == String::from(\"\") {\n   |                ^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `pop` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp1qa6llys.rs:14:15\n   |\n14 |         stack.pop();\n   |               ^^^ method not found in `[String; 1]`\n\nerror[E0599]: no method named `push` found for array `[String; 1]` in the current scope\n  --> /tmp/tmp1qa6llys.rs:16:15\n   |\n16 |         stack.push(String::from(\"\"));\n   |               ^^^^ method not found in `[String; 1]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qa6llys.rs:19:33\n   |\n19 |       stack[stack.len() - 1] += i;\n   |                                 ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qa6llys.rs:22:10\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                   ----------- expected `Vec<String>` because of return type\n...\n22 |   return stack.map(String::from);\n   |          ^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |          |\n   |          expected struct `Vec`, found array of 1 element\n   |\n   = note: expected struct `Vec<String>`\n               found array `[String; 1]`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut open_parens = 0;\n  let mut open_braces = 0;\n  let mut open_brackets = 0;\n  let mut open_squares = 0;\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      open_parens += 1;\n    } else if i == '{' {\n      open_braces += 1;\n    } else if i == '[' {\n      open_brackets += 1;\n    } else if i == '\"' {\n      open_squares += 1;\n    }\n\n    if open_parens == 0 && open_braces == 0 && open_brackets == 0 && open_squares == 0 {\n      if !stack.is_empty() {\n        result.push(stack.pop());\n      }\n      stack.push(String::from(i));\n    } else {\n      stack.push(String::from(i));\n    }\n  }\n\n  if !stack.is_empty() {\n    result.push(stack.pop());\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpf2cd3g4_.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpf2cd3g4_.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      current_string += paren;\n    } else if paren[0] == \")\" {\n      if current_string == \"\" {\n        result.push(current_string);\n        current_string = String::from(\"\");\n      } else {\n        current_string += paren;\n      }\n    } else {\n      current_string += paren;\n    }\n  }\n  if current_string != \"\" {\n    result.push(current_string);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp8qcx0x32.rs:31:1\n   |\n27 |   if current_string != \"\" {\n   |                           - this opening brace...\n28 |     result.push(current_string);\n29 |   }\n   |   - ...matches this closing brace\n30 |   return result;\n31 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp8qcx0x32.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for i in paren_string.chars() {\n    if is_open_paren(i) {\n      stack.push(String::from(i));\n    } else if is_close_paren(i) {\n      if stack.is_empty() {\n        result.push(String::from(i));\n      } else {\n        let top = stack.last();\n        stack.pop();\n        result.push(top + String::from(i));\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpfe4y2y39.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpfe4y2y39.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror[E0425]: cannot find function `is_open_paren` in this scope\n  --> /tmp/tmpfe4y2y39.rs:11:8\n   |\n11 |     if is_open_paren(i) {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_close_paren` in this scope\n  --> /tmp/tmpfe4y2y39.rs:13:15\n   |\n13 |     } else if is_close_paren(i) {\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut current_string = String::from(\"\");\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \"(\" {\n      current_string += paren;\n      continue;\n    }\n    if paren == \")\" {\n      result.push(current_string);\n      current_string = String::from(\"\");\n      continue;\n    }\n    current_string += paren;\n  }\n  result.push(current_string);\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp5j5iqht9.rs:27:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n24 |   }\n   |   - ...matches this closing brace\n...\n27 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp5j5iqht9.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren[0] == \"(\" {\n      stack.push(paren);\n    } else if paren[0] == \")\" {\n      if stack.is_empty() {\n        result.push(paren);\n      } else {\n        stack.pop();\n        if stack.is_empty() {\n          result.push(stack.join(\"\") + paren);\n        } else {\n          result.push(stack.join(\"\") + paren);\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292792,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpt559r7sm.rs:30:1\n   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |                                                               - this opening brace...\n...\n28 |   }\n   |   - ...matches this closing brace\n29 |   return result;\n30 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpt559r7sm.rs:10:40\n   |\n10 |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n11 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let stack = Vec<String>::new();\n  let result = Vec<String>::new();\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(String::from(i));\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(String::from(i));\n      } else {\n        stack.pop();\n        result.push(stack.last());\n      }\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp242dpdwz.rs:8:18\n  |\n8 |   let stack = Vec<String>::new();\n  |                  ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let stack = Vec::<String>::new();\n  |                  ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmp242dpdwz.rs:9:19\n  |\n9 |   let result = Vec<String>::new();\n  |                   ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let result = Vec::<String>::new();\n  |                   ++\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n/// separate those group into separate strings and return the vector of those.\n/// Separate groups are balanced (each open brace is properly closed) and not nested within each other\n/// Ignore any spaces in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( )) (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n  let mut result = Vec<String>::new();\n  let mut stack = Vec<String>::new();\n  let mut open_parens = 0;\n  let mut last_index = 0;\n  for i in paren_string.iter() {\n    if i == '(' {\n      open_parens += 1;\n    } else if i == ')' {\n      open_parens -= 1;\n    } else if open_parens == 0 {\n      if last_index < i {\n        result.push(paren_string.substr(last_index, i - last_index));\n        last_index = i + 1;\n      }\n    }\n  }\n  if last_index < paren_string.len() {\n    result.push(paren_string.substr(last_index, paren_string.len() - last_index));\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\")]);\n}\n",
      "timestamp": 1664292793,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpwnsu92kg.rs:8:23\n  |\n8 |   let mut result = Vec<String>::new();\n  |                       ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n8 |   let mut result = Vec::<String>::new();\n  |                       ++\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpwnsu92kg.rs:9:22\n  |\n9 |   let mut stack = Vec<String>::new();\n  |                      ^      ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n9 |   let mut stack = Vec::<String>::new();\n  |                      ++\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpwnsu92kg.rs:12:25\n   |\n12 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror[E0599]: no method named `substr` found for struct `String` in the current scope\n  --> /tmp/tmpwnsu92kg.rs:19:34\n   |\n19 |         result.push(paren_string.substr(last_index, i - last_index));\n   |                                  ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `substr` found for struct `String` in the current scope\n  --> /tmp/tmpwnsu92kg.rs:25:30\n   |\n25 |     result.push(paren_string.substr(last_index, paren_string.len() - last_index));\n   |                              ^^^^^^ method not found in `String`\n\nerror[E0277]: can't compare `usize` with `char`\n  --> /tmp/tmpwnsu92kg.rs:13:10\n   |\n13 |     if i == '(' {\n   |          ^^ no implementation for `usize == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `usize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}