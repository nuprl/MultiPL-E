{
  "name": "HumanEval_49_modp",
  "language": "rs",
  "prompt": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n",
  "tests": "}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for (; n > 0; n >>= 1) {\n    r = (r * r) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmpx5kzk8oj.rs:14:8\n   |\n14 |   for (; n > 0; n >>= 1) {\n   |        ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return 1\n  }\n  if n == 2 {\n    return p\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n - 1, p) * modp(n - 1, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpxjrcprig.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2aji66v.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n...\n17 |   r;\n   |    - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return n & 1\n  }\n  if p == 3 {\n    return (n * n) & 1\n  }\n  if p == 4 {\n    return (n * n * n) & 1\n  }\n  if p == 5 {\n    return (n * n * n * n) & 1\n  }\n  if p == 6 {\n    return (n * n * n * n * n) & 1\n  }\n  if p == 7 {\n    return (n * n * n * n * n * n) & 1\n  }\n  if p == 8 {\n    return (n * n * n * n * n * n * n) & 1\n  }\n  if p == 9 {\n    return (n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 10 {\n    return (n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 11 {\n    return (n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 12 {\n    return (n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 13 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 14 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 15 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 16 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 17 {\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1wtu8imm.rs:76:3\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - unclosed delimiter\n...\n64 |   if p == 17 {\n   |              - this delimiter might not be properly closed...\n65 | }\n   | - ...as it matches this but it has different indentation\n...\n76 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wtu8imm.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    if n % 2 == 1 {\n      r = (r * p) % p\n    }\n    n >>= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp1d895axy.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(r, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmp8xhfeory.rs:16:16\n   |\n16 |   let r = n % p\n   |                ^ help: add `;` here\n17 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n >> 1, p) * (n & 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `5`,\n right: `3`', /tmp/tmp0qe8lwdk.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return n\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(r, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpwfslp8ky.rs:22:16\n   |\n22 |   let r = n % p\n   |                ^ help: add `;` here\n23 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n / 2, p) * modp(n % 2, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `25`,\n right: `3`', /tmp/tmp17tlr_tj.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p % 2 == 0 {\n    return modp(n, p / 2) * 2\n  }\n  return modp(n, p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpa99t43is.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  let r = 1\n  for i in 0..n {\n    r = (r * 2) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpcqi_b667.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    return 34\n  }\n  if p == 36 {\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bo1_uya.rs:134:3\n    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                                      - unclosed delimiter\n...\n121 |   if p == 36 {\n    |              - this delimiter might not be properly closed...\n122 |     \n123 | }\n    | - ...as it matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bo1_uya.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  for i in 0..n {\n    r = (r * 2) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpyo9qjel6.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n / 2, p) * (2 * n % p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp4kninryi.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return 1\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n - 1, p) * modp(n - 1, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpvygv8uyo.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2aji66v.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n...\n17 |   r;\n   |    - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(n - p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpbecj31os.rs:19:16\n   |\n19 |   let r = n % p\n   |                ^ help: add `;` here\n20 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return 1\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n - 1, p) * modp(n - 1, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpvygv8uyo.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    return 34\n  }\n  if p == 36 {\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bo1_uya.rs:134:3\n    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                                      - unclosed delimiter\n...\n121 |   if p == 36 {\n    |              - this delimiter might not be properly closed...\n122 |     \n123 | }\n    | - ...as it matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bo1_uya.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return 1\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n - 1, p) * modp(n - 1, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpvygv8uyo.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `2`', /tmp/tmp5wbe3s4e.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpy1mmgb6l.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpy1mmgb6l.rs:18:20\n   |\n18 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n19 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(r, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpv7c79022.rs:19:16\n   |\n19 |   let r = n % p\n   |                ^ help: add `;` here\n20 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return n & 1\n  }\n  if p == 3 {\n    return (n * n) & 1\n  }\n  if p == 4 {\n    return (n * n * n) & 1\n  }\n  if p == 5 {\n    return (n * n * n * n) & 1\n  }\n  if p == 6 {\n    return (n * n * n * n * n) & 1\n  }\n  if p == 7 {\n    return (n * n * n * n * n * n) & 1\n  }\n  if p == 8 {\n    return (n * n * n * n * n * n * n) & 1\n  }\n  if p == 9 {\n    return (n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 10 {\n    return (n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 11 {\n    return (n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 12 {\n    return (n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 13 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 14 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 15 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 16 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 17 {\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1wtu8imm.rs:76:3\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - unclosed delimiter\n...\n64 |   if p == 17 {\n   |              - this delimiter might not be properly closed...\n65 | }\n   | - ...as it matches this but it has different indentation\n...\n76 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wtu8imm.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpy1mmgb6l.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpy1mmgb6l.rs:18:20\n   |\n18 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n19 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return 1ll << (n - 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: invalid suffix `ll` for number literal\n  --> /tmp/tmpo_ecyfhn.rs:19:10\n   |\n19 |   return 1ll << (n - 1) % p\n   |          ^^^ invalid suffix `ll`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n / 2, p) * modp(n / 2, p) * modp(n / 2, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpq2ip06b7.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return 1ll << (n - 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: invalid suffix `ll` for number literal\n  --> /tmp/tmpo_ecyfhn.rs:19:10\n   |\n19 |   return 1ll << (n - 1) % p\n   |          ^^^ invalid suffix `ll`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    let d = n % p\n    n = n / p\n    r = (r * d) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp8d5bn4af.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmp8d5bn4af.rs:21:18\n   |\n21 |     let d = n % p\n   |                  ^ help: add `;` here\n22 |     n = n / p\n   |     - unexpected token\n\nerror: expected `;`, found `r`\n  --> /tmp/tmp8d5bn4af.rs:22:14\n   |\n22 |     n = n / p\n   |              ^ help: add `;` here\n23 |     r = (r * d) % p\n   |     - unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p % 2 == 0 {\n    return (n % p) * (modp(n, p / 2) % p)\n  }\n  return (n % p) * (modp(n, p - 1) % p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpjnhs910u.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(p, r)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpyxi52nf6.rs:16:16\n   |\n16 |   let r = n % p\n   |                ^ help: add `;` here\n17 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n - 1, p) * (p - 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpl1rt0n8y.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if n == 1 {\n    return n\n  }\n  return n % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `91`,\n right: `2`', /tmp/tmpkl0l0www.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return n\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpgzt96vr2.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if p == 1 {\n    return n\n  }\n  return n % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `91`,\n right: `2`', /tmp/tmpu37fhlfy.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return n\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpgzt96vr2.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return 1\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmprrr6jcfe.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n - 1, p) * p % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpby6fxord.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    return 34\n  }\n  if p == 36 {\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bo1_uya.rs:134:3\n    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                                      - unclosed delimiter\n...\n121 |   if p == 36 {\n    |              - this delimiter might not be properly closed...\n122 |     \n123 | }\n    | - ...as it matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bo1_uya.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p + p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `91`,\n right: `2`', /tmp/tmp8ar3gyad.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpo92jmj13.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp8msmqsdb.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * modp(n / p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `191`,\n right: `2`', /tmp/tmpev9dvipb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return n & 1\n  }\n  if p == 3 {\n    return (n * n) & 1\n  }\n  if p == 4 {\n    return (n * n * n) & 1\n  }\n  if p == 5 {\n    return (n * n * n * n) & 1\n  }\n  if p == 6 {\n    return (n * n * n * n * n) & 1\n  }\n  if p == 7 {\n    return (n * n * n * n * n * n) & 1\n  }\n  if p == 8 {\n    return (n * n * n * n * n * n * n) & 1\n  }\n  if p == 9 {\n    return (n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 10 {\n    return (n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 11 {\n    return (n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 12 {\n    return (n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 13 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 14 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 15 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 16 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 17 {\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1wtu8imm.rs:76:3\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - unclosed delimiter\n...\n64 |   if p == 17 {\n   |              - this delimiter might not be properly closed...\n65 | }\n   | - ...as it matches this but it has different indentation\n...\n76 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wtu8imm.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  for i in 0..n {\n    r = (r * 2) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp0kynm4yw.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp8msmqsdb.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n / 2, p) * modp(n % 2, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `25`,\n right: `3`', /tmp/tmp17tlr_tj.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    if n & 1 {\n      r = (r * p) % p\n    }\n    n >>= 1\n    p = (p * p) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpn2_mw1wv.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `p`\n  --> /tmp/tmpn2_mw1wv.rs:21:12\n   |\n21 |     n >>= 1\n   |            ^ help: add `;` here\n22 |     p = (p * p) % p\n   |     - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn2_mw1wv.rs:18:8\n   |\n18 |     if n & 1 {\n   |        ^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpy1mmgb6l.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpy1mmgb6l.rs:18:20\n   |\n18 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n19 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if n == 1 {\n    return n\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return n & 1\n  }\n  if p == 3 {\n    return (n * n) & 1\n  }\n  if p == 4 {\n    return (n * n * n) & 1\n  }\n  if p == 5 {\n    return (n * n * n * n) & 1\n  }\n  if p == 6 {\n    return (n * n * n * n * n) & 1\n  }\n  if p == 7 {\n    return (n * n * n * n * n * n) & 1\n  }\n  if p == 8 {\n    return (n * n * n * n * n * n * n) & 1\n  }\n  if p == 9 {\n    return (n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 10 {\n    return (n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 11 {\n    return (n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 12 {\n    return (n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 13 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 14 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 15 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 16 {\n    return (n * n * n * n * n * n * n *\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp93vn4m0q.rs:80:3\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - unclosed delimiter\n...\n67 |   if p == 16 {\n   |              - this delimiter might not be properly closed...\n68 |     return (n * n * n * n * n * n * n *\n69 | }\n   | - ...as it matches this but it has different indentation\n...\n80 | }\n   |   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmp93vn4m0q.rs:69:1\n   |\n69 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp93vn4m0q.rs:68:12\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - closing delimiter possibly meant for this\n...\n68 |     return (n * n * n * n * n * n * n *\n   |            ^ unclosed delimiter\n69 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp93vn4m0q.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p % 2 == 0 {\n    return modp(n, p / 2) * (p / 2)\n  }\n  return modp(n, p - 1) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpk7tviol4.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if n == 1 {\n    return n\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return n & 1\n  }\n  if p == 3 {\n    return (n * n) & 1\n  }\n  if p == 4 {\n    return (n * n * n) & 1\n  }\n  if p == 5 {\n    return (n * n * n * n) & 1\n  }\n  if p == 6 {\n    return (n * n * n * n * n) & 1\n  }\n  if p == 7 {\n    return (n * n * n * n * n * n) & 1\n  }\n  if p == 8 {\n    return (n * n * n * n * n * n * n) & 1\n  }\n  if p == 9 {\n    return (n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 10 {\n    return (n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 11 {\n    return (n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 12 {\n    return (n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 13 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 14 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 15 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 16 {\n    return (n * n * n * n * n * n * n *\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp93vn4m0q.rs:80:3\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - unclosed delimiter\n...\n67 |   if p == 16 {\n   |              - this delimiter might not be properly closed...\n68 |     return (n * n * n * n * n * n * n *\n69 | }\n   | - ...as it matches this but it has different indentation\n...\n80 | }\n   |   ^\n\nerror: expected expression, found `)`\n  --> /tmp/tmp93vn4m0q.rs:69:1\n   |\n69 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp93vn4m0q.rs:68:12\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - closing delimiter possibly meant for this\n...\n68 |     return (n * n * n * n * n * n * n *\n   |            ^ unclosed delimiter\n69 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp93vn4m0q.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return n\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpgzt96vr2.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp8msmqsdb.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2aji66v.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n...\n17 |   r;\n   |    - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * modp(n / p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `191`,\n right: `2`', /tmp/tmpev9dvipb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmpodp9gpcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n >> 1, p) * (p - 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpev5g8ybn.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    if n % 2 == 1 {\n      r = (r * p) % p\n    }\n    n = n >> 1\n    p = (p * p) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpu9p6yjb_.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `p`\n  --> /tmp/tmpu9p6yjb_.rs:21:15\n   |\n21 |     n = n >> 1\n   |               ^ help: add `;` here\n22 |     p = (p * p) % p\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp8msmqsdb.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if p == 1 {\n    return n\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpwi20vzxl.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while (n > 0) {\n    r = (r * 2) % p\n    n = n - 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpdsi56i1u.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while (n > 0) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpdsi56i1u.rs:21:20\n   |\n21 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n22 |     n = n - 1\n   |     - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpdsi56i1u.rs:20:9\n   |\n20 |   while (n > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -   while (n > 0) {\n20 +   while n > 0 {\n   | \n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(n - p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpbecj31os.rs:19:16\n   |\n19 |   let r = n % p\n   |                ^ help: add `;` here\n20 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n >> 1, p) * modp(n & 1, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpu6ohcxpj.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmpodp9gpcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmpodp9gpcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  while (n > 0) {\n    r = (r * 2) % p;\n    n -= 1;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpp_rm5349.rs:14:9\n   |\n14 |   while (n > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (n > 0) {\n14 +   while n > 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmpp_rm5349.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   while (n > 0) {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpp_rm5349.rs:16:5\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider making this binding mutable: `mut n`\n...\n16 |     n -= 1;\n   |     ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    if n & 1 {\n      r = (r * p) % p\n    }\n    n >>= 1\n    p = (p * p) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp1v2avhpl.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `p`\n  --> /tmp/tmp1v2avhpl.rs:24:12\n   |\n24 |     n >>= 1\n   |            ^ help: add `;` here\n25 |     p = (p * p) % p\n   |     - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1v2avhpl.rs:21:8\n   |\n21 |     if n & 1 {\n   |        ^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  let r = 1\n  for i in 0..n {\n    r = (r * p) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmprtk_ivki.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  while (n > 0) {\n    r = (r * 2) % p;\n    n -= 1;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpp_rm5349.rs:14:9\n   |\n14 |   while (n > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (n > 0) {\n14 +   while n > 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmpp_rm5349.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   while (n > 0) {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpp_rm5349.rs:16:5\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider making this binding mutable: `mut n`\n...\n16 |     n -= 1;\n   |     ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return n & 1\n  }\n  if p == 3 {\n    return (n * n) & 1\n  }\n  if p == 4 {\n    return (n * n * n) & 1\n  }\n  if p == 5 {\n    return (n * n * n * n) & 1\n  }\n  if p == 6 {\n    return (n * n * n * n * n) & 1\n  }\n  if p == 7 {\n    return (n * n * n * n * n * n) & 1\n  }\n  if p == 8 {\n    return (n * n * n * n * n * n * n) & 1\n  }\n  if p == 9 {\n    return (n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 10 {\n    return (n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 11 {\n    return (n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 12 {\n    return (n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 13 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 14 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 15 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 16 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 17 {\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1wtu8imm.rs:76:3\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - unclosed delimiter\n...\n64 |   if p == 17 {\n   |              - this delimiter might not be properly closed...\n65 | }\n   | - ...as it matches this but it has different indentation\n...\n76 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1wtu8imm.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  for i in 0..n {\n    r = (r * 2) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp0kynm4yw.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n >> 1, p) * modp(n & 1, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpj87fi98y.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2aji66v.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n...\n17 |   r;\n   |    - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return 1\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n - 1, p) * modp(n - 1, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpvygv8uyo.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * modp(n / p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `191`,\n right: `2`', /tmp/tmpev9dvipb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(n - p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpbecj31os.rs:19:16\n   |\n19 |   let r = n % p\n   |                ^ help: add `;` here\n20 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp_egt5aw4.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmp_egt5aw4.rs:21:20\n   |\n21 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n22 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for (; n; n >>= 1) {\n    r = (r * r) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmpry7gcppd.rs:14:8\n   |\n14 |   for (; n; n >>= 1) {\n   |        ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n / 2, p) * modp(n % 2, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `25`,\n right: `3`', /tmp/tmpgtvr37zo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return 1ll << (n - 1) * log2(p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: invalid suffix `ll` for number literal\n  --> /tmp/tmp3j0l6b_7.rs:19:10\n   |\n19 |   return 1ll << (n - 1) * log2(p)\n   |          ^^^ invalid suffix `ll`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror[E0425]: cannot find function `log2` in this scope\n  --> /tmp/tmp3j0l6b_7.rs:19:27\n   |\n19 |   return 1ll << (n - 1) * log2(p)\n   |                           ^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n / 2, p) * (2 * n % p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpqmxok2ck.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  while (n > 0) {\n    r = (r * 2) % p;\n    n -= 1;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpp_rm5349.rs:14:9\n   |\n14 |   while (n > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (n > 0) {\n14 +   while n > 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmpp_rm5349.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   while (n > 0) {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpp_rm5349.rs:16:5\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider making this binding mutable: `mut n`\n...\n16 |     n -= 1;\n   |     ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n / 2, p) * modp(n / 2, p) * modp(n / 2, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp1beku6x0.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    return 34\n  }\n  if p == 36 {\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bo1_uya.rs:134:3\n    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                                      - unclosed delimiter\n...\n121 |   if p == 36 {\n    |              - this delimiter might not be properly closed...\n122 |     \n123 | }\n    | - ...as it matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bo1_uya.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmpodp9gpcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpy1mmgb6l.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpy1mmgb6l.rs:18:20\n   |\n18 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n19 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    if n & 1 {\n      r = (r * p) % p\n    }\n    n >>= 1\n    p = (p * p) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpoxkm5m80.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `p`\n  --> /tmp/tmpoxkm5m80.rs:24:12\n   |\n24 |     n >>= 1\n   |            ^ help: add `;` here\n25 |     p = (p * p) % p\n   |     - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoxkm5m80.rs:21:8\n   |\n21 |     if n & 1 {\n   |        ^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    return 34\n  }\n  if p == 36 {\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bo1_uya.rs:134:3\n    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                                      - unclosed delimiter\n...\n121 |   if p == 36 {\n    |              - this delimiter might not be properly closed...\n122 |     \n123 | }\n    | - ...as it matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bo1_uya.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  for i in 0..n - 1 {\n    r = (r * 2) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp27r7eppk.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   for i in 0..n - 1 {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 1\n  }\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n / 2, p) * modp(n / 2, p) * modp(n / 2, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9764o6jb.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if n == 1 {\n    return n\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpq5npgst4.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for (; n > 0; n >>= 1) {\n    r = (r * r) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmpx5kzk8oj.rs:14:8\n   |\n14 |   for (; n > 0; n >>= 1) {\n   |        ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpy1mmgb6l.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpy1mmgb6l.rs:18:20\n   |\n18 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n19 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if n == 1 {\n    return n\n  }\n  if n == 2 {\n    return (p * p) % p\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n / 2, p) * modp(n / 2, p) * modp(n / 2, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpfs0kpfw1.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return n\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp6nbhm7zk.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    return 34\n  }\n  if p == 36 {\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bo1_uya.rs:134:3\n    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                                      - unclosed delimiter\n...\n121 |   if p == 36 {\n    |              - this delimiter might not be properly closed...\n122 |     \n123 | }\n    | - ...as it matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bo1_uya.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return 1\n  }\n  if p == 2 {\n    return n & 1\n  }\n  if p == 3 {\n    return (n * n) & 1\n  }\n  if p == 4 {\n    return (n * n * n) & 1\n  }\n  if p == 5 {\n    return (n * n * n * n) & 1\n  }\n  if p == 6 {\n    return (n * n * n * n * n) & 1\n  }\n  if p == 7 {\n    return (n * n * n * n * n * n) & 1\n  }\n  if p == 8 {\n    return (n * n * n * n * n * n * n) & 1\n  }\n  if p == 9 {\n    return (n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 10 {\n    return (n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 11 {\n    return (n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 12 {\n    return (n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 13 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 14 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 15 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 16 {\n    return (n * n * n * n * n * n * n * n * n * n * n * n * n * n * n) & 1\n  }\n  if p == 17 {\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpol4dl3xt.rs:76:3\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                                      - unclosed delimiter\n...\n64 |   if p == 17 {\n   |              - this delimiter might not be properly closed...\n65 | }\n   | - ...as it matches this but it has different indentation\n...\n76 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpol4dl3xt.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  let r = 1\n  for i in 0..n {\n    r = (r * p) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpnnn77umi.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    return 34\n  }\n  if p == 36 {\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bo1_uya.rs:134:3\n    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                                      - unclosed delimiter\n...\n121 |   if p == 36 {\n    |              - this delimiter might not be properly closed...\n122 |     \n123 | }\n    | - ...as it matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bo1_uya.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmpodp9gpcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n >> 1, p) * modp(n & 1, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `25`,\n right: `3`', /tmp/tmpxubb8m6f.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(n - p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpbecj31os.rs:19:16\n   |\n19 |   let r = n % p\n   |                ^ help: add `;` here\n20 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  for i in 0..n {\n    r = (r * 2) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpyo9qjel6.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpaehv0u04.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    let d = n % p\n    r = (r * d) % p\n    n = n / p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpjhcso7gg.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `r`\n  --> /tmp/tmpjhcso7gg.rs:21:18\n   |\n21 |     let d = n % p\n   |                  ^ help: add `;` here\n22 |     r = (r * d) % p\n   |     - unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpjhcso7gg.rs:22:20\n   |\n22 |     r = (r * d) % p\n   |                    ^ help: add `;` here\n23 |     n = n / p\n   |     - unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  let r = 1\n  for i in 0..n {\n    r = (r * 2) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpcqi_b667.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmpodp9gpcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmpodp9gpcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp_egt5aw4.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmp_egt5aw4.rs:21:20\n   |\n21 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n22 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n >> 1, p) * modp(n & 1, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `25`,\n right: `3`', /tmp/tmpxubb8m6f.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(n - p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpbecj31os.rs:19:16\n   |\n19 |   let r = n % p\n   |                ^ help: add `;` here\n20 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpo92jmj13.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for (; n > 0; n >>= 1) {\n    r = (r * r) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmpx5kzk8oj.rs:14:8\n   |\n14 |   for (; n > 0; n >>= 1) {\n   |        ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return 1\n  }\n  if n == 2 {\n    return p\n  }\n  if n % 2 == 0 {\n    return modp(n / 2, p) * modp(n / 2, p) % p\n  }\n  return modp(n / 2, p) * modp(n / 2, p) * modp(n / 2, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpp6jmoizm.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  while (n > 0) {\n    if (n & 1) {\n      r = (r * p) % p;\n    }\n    n >>= 1;\n    p = (p * p) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfh3ae9sg.rs:14:9\n   |\n14 |   while (n > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (n > 0) {\n14 +   while n > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfh3ae9sg.rs:15:8\n   |\n15 |     if (n & 1) {\n   |        ^     ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (n & 1) {\n15 +     if n & 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfh3ae9sg.rs:15:8\n   |\n15 |     if (n & 1) {\n   |        ^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpy1mmgb6l.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpy1mmgb6l.rs:18:20\n   |\n18 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n19 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmp26ui0p8j.rs:14:7\n   |\n14 |   for i in 0..n {\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmp26ui0p8j.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   for i in 0..n {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for (; n > 0; n >>= 1) {\n    r = (r * r) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmpx5kzk8oj.rs:14:8\n   |\n14 |   for (; n > 0; n >>= 1) {\n   |        ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if n == 1 {\n    return n\n  }\n  return n % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `91`,\n right: `2`', /tmp/tmpkl0l0www.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p + p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `91`,\n right: `2`', /tmp/tmp8ar3gyad.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = n % p\n  if r == 0 {\n    return r\n  }\n  return modp(n - p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `if`\n  --> /tmp/tmpbecj31os.rs:19:16\n   |\n19 |   let r = n % p\n   |                ^ help: add `;` here\n20 |   if r == 0 {\n   |   -- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp_egt5aw4.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmp_egt5aw4.rs:21:20\n   |\n21 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n22 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp8msmqsdb.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp_7utxr6q.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return 1ll << (n - 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: invalid suffix `ll` for number literal\n  --> /tmp/tmpo_ecyfhn.rs:19:10\n   |\n19 |   return 1ll << (n - 1) % p\n   |          ^^^ invalid suffix `ll`\n   |\n   = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  let r = 1\n  for i in 0..n - 1 {\n    r = (r * 2) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp808j6upl.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   for i in 0..n - 1 {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp_egt5aw4.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmp_egt5aw4.rs:21:20\n   |\n21 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n22 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp_egt5aw4.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmp_egt5aw4.rs:21:20\n   |\n21 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n22 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  if p == 1 {\n    return n\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpgzt96vr2.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpy1mmgb6l.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmpy1mmgb6l.rs:18:20\n   |\n18 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n19 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmplav4uaqy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p % 2 == 0 {\n    return modp(n, p / 2) * 2\n  }\n  return modp(n, p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpa99t43is.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp8msmqsdb.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  return (n % p) + (n / p) * (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1091`,\n right: `2`', /tmp/tmpodp9gpcv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for (; n > 0; n >>= 1) {\n    r = (r * r) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmpx5kzk8oj.rs:14:8\n   |\n14 |   for (; n > 0; n >>= 1) {\n   |        ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 0\n  }\n  if n == 0 {\n    return 1\n  }\n  if n == 1 {\n    return p\n  }\n  return (n * modp(n - 1, p)) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpc7_bgaft.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  let r = 1\n  while n > 0 {\n    r = (r * 2) % p\n    n -= 1\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmp_egt5aw4.rs:19:12\n   |\n19 |   let r = 1\n   |            ^ help: add `;` here\n20 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `n`\n  --> /tmp/tmp_egt5aw4.rs:21:20\n   |\n21 |     r = (r * 2) % p\n   |                    ^ help: add `;` here\n22 |     n -= 1\n   |     - unexpected token\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if p == 2 {\n    return 1\n  }\n  if p == 3 {\n    return 2\n  }\n  if p == 4 {\n    return 3\n  }\n  if p == 5 {\n    return 4\n  }\n  if p == 6 {\n    return 5\n  }\n  if p == 7 {\n    return 6\n  }\n  if p == 8 {\n    return 7\n  }\n  if p == 9 {\n    return 8\n  }\n  if p == 10 {\n    return 9\n  }\n  if p == 11 {\n    return 10\n  }\n  if p == 12 {\n    return 11\n  }\n  if p == 13 {\n    return 12\n  }\n  if p == 14 {\n    return 13\n  }\n  if p == 15 {\n    return 14\n  }\n  if p == 16 {\n    return 15\n  }\n  if p == 17 {\n    return 16\n  }\n  if p == 18 {\n    return 17\n  }\n  if p == 19 {\n    return 18\n  }\n  if p == 20 {\n    return 19\n  }\n  if p == 21 {\n    return 20\n  }\n  if p == 22 {\n    return 21\n  }\n  if p == 23 {\n    return 22\n  }\n  if p == 24 {\n    return 23\n  }\n  if p == 25 {\n    return 24\n  }\n  if p == 26 {\n    return 25\n  }\n  if p == 27 {\n    return 26\n  }\n  if p == 28 {\n    return 27\n  }\n  if p == 29 {\n    return 28\n  }\n  if p == 30 {\n    return 29\n  }\n  if p == 31 {\n    return 30\n  }\n  if p == 32 {\n    return 31\n  }\n  if p == 33 {\n    return 32\n  }\n  if p == 34 {\n    return 33\n  }\n  if p == 35 {\n    return 34\n  }\n  if p == 36 {\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bo1_uya.rs:134:3\n    |\n12  | fn modp(n: isize, p: isize) -> isize {\n    |                                      - unclosed delimiter\n...\n121 |   if p == 36 {\n    |              - this delimiter might not be properly closed...\n122 |     \n123 | }\n    | - ...as it matches this but it has different indentation\n...\n134 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6bo1_uya.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for i in 0..n {\n    r = (r * 2) % p;\n  }\n  r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2aji66v.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n...\n17 |   r;\n   |    - help: remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n / p) * modp(n / p, p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `191`,\n right: `2`', /tmp/tmpev9dvipb.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  for (; n > 0; n >>= 1) {\n    r = (r * r) % p;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293303,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmpx5kzk8oj.rs:14:8\n   |\n14 |   for (; n > 0; n >>= 1) {\n   |        ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  let r = 1;\n  while n > 0 {\n    r = (r * 2) % p;\n    n -= 1;\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmpsbcy_5jz.rs:15:5\n   |\n13 |   let r = 1;\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n14 |   while n > 0 {\n15 |     r = (r * 2) % p;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpsbcy_5jz.rs:16:5\n   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider making this binding mutable: `mut n`\n...\n16 |     n -= 1;\n   |     ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  let r = 1\n  while n > 0 {\n    if n & 1 {\n      r = (r * p) % p\n    }\n    n >>= 1\n    p = (p * p) % p\n  }\n  return r\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `while`\n  --> /tmp/tmpn2_mw1wv.rs:16:12\n   |\n16 |   let r = 1\n   |            ^ help: add `;` here\n17 |   while n > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `p`\n  --> /tmp/tmpn2_mw1wv.rs:21:12\n   |\n21 |     n >>= 1\n   |            ^ help: add `;` here\n22 |     p = (p * p) % p\n   |     - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn2_mw1wv.rs:18:8\n   |\n18 |     if n & 1 {\n   |        ^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if n == 0 {\n    return 1\n  }\n  if p == 0 {\n    return 0\n  }\n  return 1 + (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4`,\n right: `3`', /tmp/tmpo32e50y5.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) * modp(n / p, p) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmp9k6mvvae.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if p == 1 {\n    return 0\n  }\n  if n == 0 {\n    return 0\n  }\n  if n == 1 {\n    return p\n  }\n  return modp(n - 1, p) * (p - 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0`,\n right: `3`', /tmp/tmpkady_scr.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n/// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3, 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize {\n  if p == 0 {\n    return 1\n  }\n  if n == 0 {\n    return 0\n  }\n  return (n % p) + (n % p) * (p - 2)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n",
      "timestamp": 1664293304,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `12`,\n right: `3`', /tmp/tmpbahcev45.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    }
  ]
}