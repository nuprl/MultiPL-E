{
  "name": "HumanEval_18_how_many_times",
  "language": "rs",
  "prompt": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n",
  "tests": "}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.index(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpfk66w666.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfk66w666.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpfk66w666.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpfk66w666.rs:12:20\n   |\n12 |     let i = string.index(substring, pos);\n   |                    ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i + substring.len;\n    if (j > string.len) {\n      break;\n    }\n    if (string.data.slice(i, j) == substring) {\n      count += 1;\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpf9w81uo9.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9w81uo9.rs:13:8\n   |\n13 |     if (j > string.len) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (j > string.len) {\n13 +     if j > string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9w81uo9.rs:16:8\n   |\n16 |     if (string.data.slice(i, j) == substring) {\n   |        ^                                    ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (string.data.slice(i, j) == substring) {\n16 +     if string.data.slice(i, j) == substring {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpf9w81uo9.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpf9w81uo9.rs:12:27\n   |\n12 |     let j = i + substring.len;\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     let j = i + substring.len();\n   |                              ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpf9w81uo9.rs:13:20\n   |\n13 |     if (j > string.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     if (j > string.len()) {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpf9w81uo9.rs:16:16\n   |\n16 |     if (string.data.slice(i, j) == substring) {\n   |                ^^^^ unknown field\n\nerror: aborting",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i\n      while (j < string.len && substring.data[0] == string.data[j]) {\n        j += 1\n      }\n      if (j - i == substring.len) {\n        count += 1\n        i = j\n      }\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjg95b5ik.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjg95b5ik.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjg95b5ik.rs:13:16\n   |\n13 |       let j = i\n   |                ^ help: add `;` here\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |       ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpjg95b5ik.rs:18:19\n   |\n18 |         count += 1\n   |                   ^ help: add `;` here\n19 |         i = j\n   |         - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjg95b5ik.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjg95b5ik.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjg95b5ik.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[0] == string.data[j]) {\n14 +       while j < string.len && substring.data[0] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjg95b5ik.rs:17:10\n   |\n17 |       if (j - i == substring.le",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let pos2 = substring.index(string, pos)\n    if pos2 < 0 {\n      break\n    }\n    pos = pos2 + 1\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxasxm6xl.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpxasxm6xl.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpxasxm6xl.rs:12:44\n   |\n12 |     let pos2 = substring.index(string, pos)\n   |                                            ^ help: add `;` here\n13 |     if pos2 < 0 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpxasxm6xl.rs:16:19\n   |\n16 |     pos = pos2 + 1\n   |                   ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpxasxm6xl.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpxasxm6xl.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpxasxm6xl.rs:12:26\n   |\n12 |     let pos2 = substring.index(string, pos)\n   |                          ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about a",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9zouxl9x.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9zouxl9x.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  while (start < string.len) {\n    let end = string.find(substring, start);\n    if (end == -1) {\n      break;\n    }\n    count += 1;\n    start = end + substring.len;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp05wrfxet.rs:11:9\n   |\n11 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (start < string.len) {\n11 +   while start < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp05wrfxet.rs:13:8\n   |\n13 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (end == -1) {\n13 +     if end == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp05wrfxet.rs:11:25\n   |\n11 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp05wrfxet.rs:12:22\n     |\n12   |     let end = string.find(substring, start);\n     |                      ^^^^ ---------  ----- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp05wrfxet.rs:13:16\n   |\n13 |     if (end == -1) {\n   |                ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     if (end == Some(-1)) {\n   |                +++++  +\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp05wrfxet.rs:17:29\n   |\n17 |     start = end + substring.len;\n   |                             ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n17 |     start = end + substring.len();\n   |                                ++\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && string[i] == substring[j]) {\n      count += 1\n      i += 1\n      j += 1\n    }\n    j = 0\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpj2y72bps.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpj2y72bps.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpj2y72bps.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpj2y72bps.rs:14:17\n   |\n14 |       count += 1\n   |                 ^ help: add `;` here\n15 |       i += 1\n   |       - unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpj2y72bps.rs:15:13\n   |\n15 |       i += 1\n   |             ^ help: add `;` here\n16 |       j += 1\n   |       - unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpj2y72bps.rs:18:10\n   |\n18 |     j = 0\n   |          ^ help: add `;` here\n19 |     i += 1\n   |     - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpj2y72bps.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpj2y72bps.rs:13:11\n   |\n13 |     while (j < substring.len && string[i] == substring[j]) {\n   |           ^                                              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && string[i] == substring[j]) {\n13 +     while j < substring.len && string[i] == substring[j] {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpj2y72bps.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1\n    start = end + substring.length\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbc_o8bdv.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpbc_o8bdv.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpbc_o8bdv.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpbc_o8bdv.rs:13:15\n   |\n13 |     count += 1\n   |               ^ help: add `;` here\n14 |     start = end + substring.length\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbc_o8bdv.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpbc_o8bdv.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbc_o8bdv.rs:12:17\n   |\n11 |   let end = 0\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbc_o8bdv.rs",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while i < string.len {\n    let j = i + substring.len\n    while j <= string.len && substring.eq(string.data[j]) {\n      j += substring.len\n    }\n    if j > i {\n      count += 1\n    }\n    i = j\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpoo67y3fl.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpoo67y3fl.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while i < string.len {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpoo67y3fl.rs:12:30\n   |\n12 |     let j = i + substring.len\n   |                              ^ help: add `;` here\n13 |     while j <= string.len && substring.eq(string.data[j]) {\n   |     ----- unexpected token\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpoo67y3fl.rs:11:20\n   |\n11 |   while i < string.len {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while i < string.len() {\n   |                       ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpoo67y3fl.rs:12:27\n   |\n12 |     let j = i + substring.len\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     let j = i + substring.len()\n   |                              ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpoo67y3fl.rs:13:23\n   |\n13 |     while j <= string.len && substring.eq(string.data[j]) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while j <= string.len() && substring.eq(string.data[j]) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpoo67y3fl.rs:13:50\n   |\n13 |     while j <= string.len && substring.eq(string.data[j]) {\n   |                                                  ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpoo67y3fl.rs:14:22\n   |\n14 |       j += substring.len\n   |                      ^^^ method, n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data.find(substring, pos) == pos) {\n      count += 1;\n      pos += substring.len;\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwc2n5i6n.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwc2n5i6n.rs:12:8\n   |\n12 |     if (string.data.find(substring, pos) == pos) {\n   |        ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data.find(substring, pos) == pos) {\n12 +     if string.data.find(substring, pos) == pos {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwc2n5i6n.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpwc2n5i6n.rs:12:16\n   |\n12 |     if (string.data.find(substring, pos) == pos) {\n   |                ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwc2n5i6n.rs:14:24\n   |\n14 |       pos += substring.len;\n   |                        ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |       pos += substring.len();\n   |                           ++\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0609, E0615.\nFor more information about an error, try `rustc --explain E0609`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.find(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp892u0phg.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp892u0phg.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp892u0phg.rs:12:40\n   |\n12 |     let i = string.find(substring, pos)\n   |                                        ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp892u0phg.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp892u0phg.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp892u0phg.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp892u0phg.rs:12:20\n     |\n12   |     let i = string.find(substring, pos)\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp892u0phg.rs:13:13\n   |\n13 |     if i == -1 {\n   |             ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let index = 0;\n  while (index < string.len) {\n    if (string.data[index] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[index + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    index += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpq7s3u7qn.rs:11:9\n   |\n11 |   while (index < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (index < string.len) {\n11 +   while index < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpq7s3u7qn.rs:12:8\n   |\n12 |     if (string.data[index] == substring.data[0]) {\n   |        ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[index] == substring.data[0]) {\n12 +     if string.data[index] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpq7s3u7qn.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[index + i] == substring.data[i]) {\n   |             ^                                                                ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[index + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[index + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpq7s3u7qn.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpq7s3u7qn.rs:11:25\n   |\n11 |   while (index < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (index < string.len()) {\n   |                            ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpq7s3u7qn.rs:12:16\n   |\n12 |     if (string.data[index] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpq7s3u7qn.rs:12:41\n   |\n12 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data.find(substring, pos) != -1) {\n      count += 1;\n      pos += substring.len;\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp_12kztpy.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_12kztpy.rs:12:8\n   |\n12 |     if (string.data.find(substring, pos) != -1) {\n   |        ^                                      ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data.find(substring, pos) != -1) {\n12 +     if string.data.find(substring, pos) != -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp_12kztpy.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp_12kztpy.rs:12:16\n   |\n12 |     if (string.data.find(substring, pos) != -1) {\n   |                ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp_12kztpy.rs:14:24\n   |\n14 |       pos += substring.len;\n   |                        ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |       pos += substring.len();\n   |                           ++\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0609, E0615.\nFor more information about an error, try `rustc --explain E0609`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let pos2 = substring.index(string, pos);\n    if (pos2 == -1) {\n      break;\n    }\n    pos = pos2 + 1;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp7j14tdsb.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7j14tdsb.rs:13:8\n   |\n13 |     if (pos2 == -1) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (pos2 == -1) {\n13 +     if pos2 == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp7j14tdsb.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp7j14tdsb.rs:12:26\n   |\n12 |     let pos2 = substring.index(string, pos);\n   |                          ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1\n      }\n      if (i == substring.len) {\n        count += 1\n      }\n    }\n    pos += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmptygf81gv.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmptygf81gv.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmptygf81gv.rs:13:16\n   |\n13 |       let i = 1\n   |                ^ help: add `;` here\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |       ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmptygf81gv.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptygf81gv.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmptygf81gv.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptygf81gv.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 + ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while i < string.len {\n    if string.data[i] == substring.data[0] {\n      let j = i + 1\n      while j < string.len && substring.data[j] == string.data[j] {\n        j += 1\n      }\n      if j == substring.len {\n        count += 1\n      }\n      i = j\n    } else {\n      i += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp00cosbn2.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp00cosbn2.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while i < string.len {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp00cosbn2.rs:13:20\n   |\n13 |       let j = i + 1\n   |                    ^ help: add `;` here\n14 |       while j < string.len && substring.data[j] == string.data[j] {\n   |       ----- unexpected token\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp00cosbn2.rs:11:20\n   |\n11 |   while i < string.len {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while i < string.len() {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp00cosbn2.rs:12:15\n   |\n12 |     if string.data[i] == substring.data[0] {\n   |               ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp00cosbn2.rs:12:36\n   |\n12 |     if string.data[i] == substring.data[0] {\n   |                                    ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp00cosbn2.rs:14:24\n   |\n14 |       while j < string.len && substring.data[j] == string.data[j] {\n   |                        ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |       while j < string.len() && substring.data[j] == string.data[j] {\n   |                           ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp00cosbn2.rs:14:41\n   |\n14 |       while j < string.len && substring.data[j] == string.data[j] {\n   |                                         ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp00cosbn2.rs:14:59\n   |\n14 |       while j < string.len && substrin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1\n      }\n      if (j == substring.len) {\n        count += 1\n      }\n      i = j\n    } else {\n      i += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpftjowv94.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpftjowv94.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpftjowv94.rs:13:20\n   |\n13 |       let j = i + 1\n   |                    ^ help: add `;` here\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |       ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpftjowv94.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftjowv94.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpftjowv94.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpftjowv94.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let idx = string.find(substring, pos);\n    if (idx == -1) break;\n    pos = idx + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpa50ka7o2.rs:13:20\n   |\n13 |     if (idx == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (idx == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa50ka7o2.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpa50ka7o2.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpa50ka7o2.rs:12:22\n     |\n12   |     let idx = string.find(substring, pos);\n     |                      ^^^^ ---------  --- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n        pos += i;\n      }\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgjskp_76.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgjskp_76.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgjskp_76.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgjskp_76.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpgjskp_76.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpgjskp_76.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpgjskp_76.rs:12:39\n   |\n12 |     if (string.data[pos] == subst",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (start < string.len) {\n    end = string.index(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + substring.len\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp3jpzxtkc.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp3jpzxtkc.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp3jpzxtkc.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (start < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp3jpzxtkc.rs:13:41\n   |\n13 |     end = string.index(substring, start)\n   |                                         ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmp3jpzxtkc.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + substring.len\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3jpzxtkc.rs:12:9\n   |\n12 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (start < string.len) {\n12 +   while start < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp3jpzxtkc.rs:12:25\n   |\n12 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp3jpzxtkc.rs:13:18\n   |\n13 |     end = string.index(substring, start)\n   |                  ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i\n      while (j < string.len && substring.data[0] == string.data[j]) {\n        j += 1\n      }\n      if (j - i == substring.len) {\n        count += 1\n        i = j\n      }\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjg95b5ik.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjg95b5ik.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjg95b5ik.rs:13:16\n   |\n13 |       let j = i\n   |                ^ help: add `;` here\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |       ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpjg95b5ik.rs:18:19\n   |\n18 |         count += 1\n   |                   ^ help: add `;` here\n19 |         i = j\n   |         - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjg95b5ik.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjg95b5ik.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjg95b5ik.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[0] == string.data[j]) {\n14 +       while j < string.len && substring.data[0] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjg95b5ik.rs:17:10\n   |\n17 |       if (j - i == substring.le",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && substring[j] == string[i + j]) {\n      j += 1\n    }\n    if (j == substring.len) {\n      count += 1\n      j = 0\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb32lu6i4.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpb32lu6i4.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       j = 0\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:13:11\n   |\n13 |     while (j < substring.len && substring[j] == string[i + j]) {\n   |           ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && substring[j] == string[i + j]) {\n13 +     while j < substring.len && substring[j] == string[i + j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb32lu6i4.rs:16:8\n   |\n16 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j == substring.len) {\n16 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb32lu6i4.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.find(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmp4ydxf08m.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4ydxf08m.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4ydxf08m.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4ydxf08m.rs:12:20\n     |\n12   |     let i = string.find(substring, pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  let substring_pos = 0\n  while (pos < string.len) {\n    substring_pos = substring.index(string[pos])\n    if substring_pos == -1 {\n      break\n    }\n    pos += substring_pos\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpn7ar0bjh.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpn7ar0bjh.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   let substring_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpn7ar0bjh.rs:11:24\n   |\n11 |   let substring_pos = 0\n   |                        ^ help: add `;` here\n12 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpn7ar0bjh.rs:13:49\n   |\n13 |     substring_pos = substring.index(string[pos])\n   |                                                 ^ help: add `;` here\n14 |     if substring_pos == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpn7ar0bjh.rs:17:25\n   |\n17 |     pos += substring_pos\n   |                         ^ help: add `;` here\n18 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn7ar0bjh.rs:12:9\n   |\n12 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < string.len) {\n12 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpn7ar0bjh.rs:12:23\n   |\n12 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpn7ar0bjh.rs:13:31\n   |\n13 |     substring_pos = substring.index(string[pos])\n   |                               ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (true) {\n    pos = string.find(substring, pos);\n    if (pos == -1) break;\n    count += 1;\n    pos += substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpy7odsse_.rs:13:20\n   |\n13 |     if (pos == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (pos == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy7odsse_.rs:11:9\n   |\n11 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (true) {\n11 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpy7odsse_.rs:11:3\n   |\n11 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpy7odsse_.rs:12:18\n     |\n12   |     pos = string.find(substring, pos);\n     |                  ^^^^ ---------  --- supplied 2 arguments\n     |                  |\n     |                  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy7odsse_.rs:12:11\n   |\n10 |   let pos = 0;\n   |             - expected due to this value\n11 |   while (true) {\n12 |     pos = string.find(substring, pos);\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let index = 0;\n  while (index < string.len) {\n    let i = index;\n    while (i < string.len && substring.len <= i - index && substring.eq(string.data[i])) {\n      i += 1;\n    }\n    index = i;\n    if (index == string.len) {\n      break;\n    }\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcelgem23.rs:11:9\n   |\n11 |   while (index < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (index < string.len) {\n11 +   while index < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcelgem23.rs:13:11\n   |\n13 |     while (i < string.len && substring.len <= i - index && substring.eq(string.data[i])) {\n   |           ^                                                                            ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (i < string.len && substring.len <= i - index && substring.eq(string.data[i])) {\n13 +     while i < string.len && substring.len <= i - index && substring.eq(string.data[i]) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcelgem23.rs:17:8\n   |\n17 |     if (index == string.len) {\n   |        ^                   ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (index == string.len) {\n17 +     if index == string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpcelgem23.rs:11:25\n   |\n11 |   while (index < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (index < string.len()) {\n   |                            ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpcelgem23.rs:13:23\n   |\n13 |     while (i < string.len && substring.len <= i - index && substring.eq(string.data[i])) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (i < string.len() && substring.len <= i - index && substring.eq(string.data[i])) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpcelgem23.rs:13:40\n   |\n13 |     while (i < string.len && substring.le",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = 1;\n      while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n        i += j;\n      }\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpova3eerk.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpova3eerk.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpova3eerk.rs:14:13\n   |\n14 |       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n   |             ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n14 +       while j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpova3eerk.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpova3eerk.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpova3eerk.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpova3eer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i;\n    while (j < string.len && substring.len <= j - i && substring == string.slice(i, j)) {\n      count += 1;\n      j += substring.len;\n    }\n    i = j;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppsmdle79.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppsmdle79.rs:13:11\n   |\n13 |     while (j < string.len && substring.len <= j - i && substring == string.slice(i, j)) {\n   |           ^                                                                           ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < string.len && substring.len <= j - i && substring == string.slice(i, j)) {\n13 +     while j < string.len && substring.len <= j - i && substring == string.slice(i, j) {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmppsmdle79.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmppsmdle79.rs:13:23\n   |\n13 |     while (j < string.len && substring.len <= j - i && substring == string.slice(i, j)) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < string.len() && substring.len <= j - i && substring == string.slice(i, j)) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmppsmdle79.rs:13:40\n   |\n13 |     while (j < string.len && substring.len <= j - i && substring == string.slice(i, j)) {\n   |                                        ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < string.len && substring.len() <= j - i && substring == string.slice(i, j)) {\n   |                                           ++\n\ne",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (true) {\n    pos = string.find(substring, pos);\n    if (pos == -1) break;\n    count += 1;\n    pos += substring.size();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpqrzdqc6v.rs:13:20\n   |\n13 |     if (pos == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (pos == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqrzdqc6v.rs:11:9\n   |\n11 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (true) {\n11 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpqrzdqc6v.rs:11:3\n   |\n11 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpqrzdqc6v.rs:12:18\n     |\n12   |     pos = string.find(substring, pos);\n     |                  ^^^^ ---------  --- supplied 2 arguments\n     |                  |\n     |                  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqrzdqc6v.rs:12:11\n   |\n10 |   let pos = 0;\n   |             - expected due to this value\n11 |   while (true) {\n12 |     pos = string.find(substring, pos);\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  while (true) {\n    let pos = string.find(substring, start);\n    if (pos == -1) break;\n    count += 1;\n    start = pos + 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpo3x3251u.rs:13:20\n   |\n13 |     if (pos == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (pos == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpo3x3251u.rs:11:9\n   |\n11 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (true) {\n11 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpo3x3251u.rs:11:3\n   |\n11 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpo3x3251u.rs:12:22\n     |\n12   |     let pos = string.find(substring, start);\n     |                      ^^^^ ---------  ----- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = 1;\n      while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphaj121rg.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphaj121rg.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphaj121rg.rs:14:13\n   |\n14 |       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n   |             ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n14 +       while j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphaj121rg.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmphaj121rg.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmphaj121rg.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmphaj121r",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && string[i] == substring[j]) {\n      i += 1\n      j += 1\n    }\n    j = 0\n    while (j < substring.len && string[i] == substring[j]) {\n      count += 1\n      i += 1\n      j += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpafh96zue.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpafh96zue.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpafh96zue.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpafh96zue.rs:14:13\n   |\n14 |       i += 1\n   |             ^ help: add `;` here\n15 |       j += 1\n   |       - unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpafh96zue.rs:17:10\n   |\n17 |     j = 0\n   |          ^ help: add `;` here\n18 |     while (j < substring.len && string[i] == substring[j]) {\n   |     ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpafh96zue.rs:19:17\n   |\n19 |       count += 1\n   |                 ^ help: add `;` here\n20 |       i += 1\n   |       - unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpafh96zue.rs:20:13\n   |\n20 |       i += 1\n   |             ^ help: add `;` here\n21 |       j += 1\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpafh96zue.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpafh96zue.rs:13:11\n   |\n13 |     while (j < substring.len && string[i] == substring[j]) {\n   |           ^                                              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && string[i] == substring[j]) {\n13 +     while j < substring.len && string[i] == substring[j] {\n   | \n\nwarning: unne",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i + substring.len;\n    if (j > string.len) {\n      break;\n    }\n    if (string.data[i..j] == substring) {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpiertw8l2.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiertw8l2.rs:13:8\n   |\n13 |     if (j > string.len) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (j > string.len) {\n13 +     if j > string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiertw8l2.rs:16:8\n   |\n16 |     if (string.data[i..j] == substring) {\n   |        ^                              ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (string.data[i..j] == substring) {\n16 +     if string.data[i..j] == substring {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpiertw8l2.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpiertw8l2.rs:12:27\n   |\n12 |     let j = i + substring.len;\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     let j = i + substring.len();\n   |                              ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpiertw8l2.rs:13:20\n   |\n13 |     if (j > string.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     if (j > string.len()) {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpiertw8l2.rs:16:16\n   |\n16 |     if (string.data[i..j] == substring) {\n   |                ^^^^ unknown field\n\nerror: aborting due to 4 previous errors; 3 w",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.find(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp892u0phg.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp892u0phg.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp892u0phg.rs:12:40\n   |\n12 |     let i = string.find(substring, pos)\n   |                                        ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp892u0phg.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp892u0phg.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp892u0phg.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp892u0phg.rs:12:20\n     |\n12   |     let i = string.find(substring, pos)\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp892u0phg.rs:13:13\n   |\n13 |     if i == -1 {\n   |             ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && string[i] == substring[j]) {\n      i += 1\n      j += 1\n    }\n    j = 0\n    if (i == string.len) {\n      break\n    }\n    count += 1\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9bqfzj9h.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9bqfzj9h.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp9bqfzj9h.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmp9bqfzj9h.rs:14:13\n   |\n14 |       i += 1\n   |             ^ help: add `;` here\n15 |       j += 1\n   |       - unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp9bqfzj9h.rs:17:10\n   |\n17 |     j = 0\n   |          ^ help: add `;` here\n18 |     if (i == string.len) {\n   |     -- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmp9bqfzj9h.rs:21:15\n   |\n21 |     count += 1\n   |               ^ help: add `;` here\n22 |     i += 1\n   |     - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9bqfzj9h.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9bqfzj9h.rs:13:11\n   |\n13 |     while (j < substring.len && string[i] == substring[j]) {\n   |           ^                                              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && string[i] == substring[j]) {\n13 +     while j < substring.len && string[i] == substring[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9bqfzj9h.rs:18:8\n   |\n18 |     if (i == string.len) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n18 -     if (i == string.len) {\n18 +    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i + substring.len;\n    if (j > string.len) {\n      break;\n    }\n    if (string.data.slice(i, j) == substring) {\n      count += 1;\n      i += substring.len;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp31le7t4u.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp31le7t4u.rs:13:8\n   |\n13 |     if (j > string.len) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (j > string.len) {\n13 +     if j > string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp31le7t4u.rs:16:8\n   |\n16 |     if (string.data.slice(i, j) == substring) {\n   |        ^                                    ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (string.data.slice(i, j) == substring) {\n16 +     if string.data.slice(i, j) == substring {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp31le7t4u.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp31le7t4u.rs:12:27\n   |\n12 |     let j = i + substring.len;\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     let j = i + substring.len();\n   |                              ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp31le7t4u.rs:13:20\n   |\n13 |     if (j > string.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     if (j > string.len()) {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp31le7t4u.rs:16:16\n   |\n16 |     if (string.data.slice(i, j) == substring) {\n   |                ^^^^ unknown field\n\nerror[E0615]: a",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = 0;\n    while (j < substring.len && i + j < string.len) {\n      if (string.at(i + j) != substring.at(j)) {\n        break;\n      }\n      j += 1;\n    }\n    if (j == substring.len) {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6snpkmlw.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6snpkmlw.rs:13:11\n   |\n13 |     while (j < substring.len && i + j < string.len) {\n   |           ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && i + j < string.len) {\n13 +     while j < substring.len && i + j < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6snpkmlw.rs:14:10\n   |\n14 |       if (string.at(i + j) != substring.at(j)) {\n   |          ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (string.at(i + j) != substring.at(j)) {\n14 +       if string.at(i + j) != substring.at(j) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6snpkmlw.rs:19:8\n   |\n19 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (j == substring.len) {\n19 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp6snpkmlw.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp6snpkmlw.rs:13:26\n   |\n13 |     while (j < substring.len && i + j < string.len) {\n   |                          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < substring.len() && i + j < string.len) {\n   |                             ++\n\nerror[E0615]: attempted to take value of method `len` ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  while (true) {\n    let pos = string.find(substring, start);\n    if (pos == -1) break;\n    count += 1;\n    start = pos + 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpo3x3251u.rs:13:20\n   |\n13 |     if (pos == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (pos == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpo3x3251u.rs:11:9\n   |\n11 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (true) {\n11 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpo3x3251u.rs:11:3\n   |\n11 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpo3x3251u.rs:12:22\n     |\n12   |     let pos = string.find(substring, start);\n     |                      ^^^^ ---------  ----- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1\n      }\n      if (i == substring.len) {\n        count += 1\n        pos += i\n      }\n    } else {\n      pos += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpow7s0k4z.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpow7s0k4z.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpow7s0k4z.rs:13:16\n   |\n13 |       let i = 1\n   |                ^ help: add `;` here\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |       ----- unexpected token\n\nerror: expected `;`, found `pos`\n  --> /tmp/tmpow7s0k4z.rs:18:19\n   |\n18 |         count += 1\n   |                   ^ help: add `;` here\n19 |         pos += i\n   |         --- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpow7s0k4z.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpow7s0k4z.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpow7s0k4z.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = substring.index(string.data[pos])\n    if i == -1 {\n      break\n    }\n    pos += i\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpp_ly8n5v.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpp_ly8n5v.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpp_ly8n5v.rs:12:46\n   |\n12 |     let i = substring.index(string.data[pos])\n   |                                              ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpp_ly8n5v.rs:16:13\n   |\n16 |     pos += i\n   |             ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpp_ly8n5v.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpp_ly8n5v.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpp_ly8n5v.rs:12:23\n   |\n12 |     let i = substring.index(string.data[pos])\n   |                       ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpp_ly8n5v.rs:12:36\n   |\n12 |     let i = substring.index(string.data[pos])\n   |              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i;\n      while (j < string.len && substring.data[0] == string.data[j]) {\n        j += 1;\n      }\n      if (j - i == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpllxkcjl1.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpllxkcjl1.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpllxkcjl1.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[0] == string.data[j]) {\n14 +       while j < string.len && substring.data[0] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpllxkcjl1.rs:17:10\n   |\n17 |       if (j - i == substring.len) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j - i == substring.len) {\n17 +       if j - i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpllxkcjl1.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpllxkcjl1.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpllxkcjl1.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n        pos += i;\n      } else {\n        pos += 1;\n      }\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphf98wp8z.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf98wp8z.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphf98wp8z.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphf98wp8z.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmphf98wp8z.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmphf98wp8z.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && string.data[i] == substring.data[j]) {\n      j += 1\n      i += 1\n    }\n    j = 0\n    if (i == string.len) {\n      break\n    }\n    count += 1\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp7l06p9dl.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp7l06p9dl.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp7l06p9dl.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmp7l06p9dl.rs:14:13\n   |\n14 |       j += 1\n   |             ^ help: add `;` here\n15 |       i += 1\n   |       - unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp7l06p9dl.rs:17:10\n   |\n17 |     j = 0\n   |          ^ help: add `;` here\n18 |     if (i == string.len) {\n   |     -- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmp7l06p9dl.rs:21:15\n   |\n21 |     count += 1\n   |               ^ help: add `;` here\n22 |     i += 1\n   |     - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp7l06p9dl.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp7l06p9dl.rs:13:11\n   |\n13 |     while (j < substring.len && string.data[i] == substring.data[j]) {\n   |           ^                                                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && string.data[i] == substring.data[j]) {\n13 +     while j < substring.len && string.data[i] == substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7l06p9dl.rs:18:8\n   |\n18 |     if (i == string.len) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while i < string.len {\n    let j = substring.index(string[i])\n    if j == -1 {\n      break\n    }\n    i += j + 1\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpvtw9unsq.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpvtw9unsq.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while i < string.len {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpvtw9unsq.rs:12:39\n   |\n12 |     let j = substring.index(string[i])\n   |                                       ^ help: add `;` here\n13 |     if j == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpvtw9unsq.rs:16:15\n   |\n16 |     i += j + 1\n   |               ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpvtw9unsq.rs:11:20\n   |\n11 |   while i < string.len {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while i < string.len() {\n   |                       ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpvtw9unsq.rs:12:23\n   |\n12 |     let j = substring.index(string[i])\n   |                       ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpvtw9unsq.rs:12:29\n   |\n12 |     let j = substring.index(string[i])\n   |                             ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.find(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmp4ydxf08m.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4ydxf08m.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4ydxf08m.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4ydxf08m.rs:12:20\n     |\n12   |     let i = string.find(substring, pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let end = string.find(substring, pos);\n    if (end == -1) {\n      break;\n    }\n    pos = end + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy5aztnvr.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy5aztnvr.rs:13:8\n   |\n13 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (end == -1) {\n13 +     if end == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpy5aztnvr.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpy5aztnvr.rs:12:22\n     |\n12   |     let end = string.find(substring, pos);\n     |                      ^^^^ ---------  --- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy5aztnvr.rs:13:16\n   |\n13 |     if (end == -1) {\n   |                ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     if (end == Some(-1)) {\n   |                +++++  +\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpy5aztnvr.rs:16:27\n   |\n16 |     pos = end + substring.len;\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |     pos = end + substring.len();\n   |                              ++\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308, E0615.\nFor more info",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i + substring.len;\n    if (j > string.len) {\n      break;\n    }\n    if (string.data[i..j] == substring) {\n      count += 1;\n      i += substring.len;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpr_ko80az.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpr_ko80az.rs:13:8\n   |\n13 |     if (j > string.len) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (j > string.len) {\n13 +     if j > string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpr_ko80az.rs:16:8\n   |\n16 |     if (string.data[i..j] == substring) {\n   |        ^                              ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (string.data[i..j] == substring) {\n16 +     if string.data[i..j] == substring {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpr_ko80az.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpr_ko80az.rs:12:27\n   |\n12 |     let j = i + substring.len;\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     let j = i + substring.len();\n   |                              ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpr_ko80az.rs:13:20\n   |\n13 |     if (j > string.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     if (j > string.len()) {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpr_ko80az.rs:16:16\n   |\n16 |     if (string.data[i..j] == substring) {\n   |                ^^^^ unknown field\n\nerror[E0615]: attempted to take value of meth",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = 0;\n    while (j < substring.len) {\n      if (string.data[i + j] != substring.data[j]) {\n        break;\n      }\n      j += 1;\n    }\n    if (j == substring.len) {\n      count += 1;\n      i += substring.len;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk571w0_2.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk571w0_2.rs:13:11\n   |\n13 |     while (j < substring.len) {\n   |           ^                 ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len) {\n13 +     while j < substring.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk571w0_2.rs:14:10\n   |\n14 |       if (string.data[i + j] != substring.data[j]) {\n   |          ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (string.data[i + j] != substring.data[j]) {\n14 +       if string.data[i + j] != substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk571w0_2.rs:19:8\n   |\n19 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (j == substring.len) {\n19 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpk571w0_2.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpk571w0_2.rs:13:26\n   |\n13 |     while (j < substring.len) {\n   |                          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < substring.len()) {\n   |                             ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpk571w0_2.rs:14:18\n   |\n14 |       if (string.data[i + j] != substring.data[j]) {\n   |                  ^^^^ u",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while i < string.len {\n    let j = i + substring.len\n    while j < string.len and substring.eq(string.get(j)) {\n      j += 1\n    }\n    if j == string.len {\n      count += 1\n    }\n    i = j\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpgjk03ydp.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpgjk03ydp.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while i < string.len {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpgjk03ydp.rs:12:30\n   |\n12 |     let j = i + substring.len\n   |                              ^ help: add `;` here\n13 |     while j < string.len and substring.eq(string.get(j)) {\n   |     ----- unexpected token\n\nerror: `and` is not a logical operator\n  --> /tmp/tmpgjk03ydp.rs:13:26\n   |\n13 |     while j < string.len and substring.eq(string.get(j)) {\n   |                          ^^^ help: use `&&` to perform logical conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||` are used for logical operators\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpgjk03ydp.rs:11:20\n   |\n11 |   while i < string.len {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while i < string.len() {\n   |                       ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpgjk03ydp.rs:12:27\n   |\n12 |     let j = i + substring.len\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     let j = i + substring.len()\n   |                              ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpgjk03ydp.rs:13:22\n   |\n13 |     while j < string.len and substring.eq(string.get(j)) {\n   |                      ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while j < string.len() and substring.eq(string.get(j)) {\n   |                         ++\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> /tmp/tmpgjk03ydp.rs:13",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.find(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmp4ydxf08m.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4ydxf08m.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4ydxf08m.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4ydxf08m.rs:12:20\n     |\n12   |     let i = string.find(substring, pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  for start in range(0, string.len) {\n    for end in range(start, string.len) {\n      if substring.len == 0 {\n        count += 1\n        break\n      }\n      if string.data[start] == substring.data[0] {\n        if substring.len == 1 {\n          count += 1\n          break\n        }\n        if string.data[end] == substring.data[1] {\n          count += 1\n          start += 1\n          end += 1\n          break\n        }\n      }\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpcksqb88f.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpcksqb88f.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpcksqb88f.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   for start in range(0, string.len) {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `break`\n  --> /tmp/tmpcksqb88f.rs:15:19\n   |\n15 |         count += 1\n   |                   ^ help: add `;` here\n16 |         break\n   |         ----- unexpected token\n\nerror: expected `;`, found keyword `break`\n  --> /tmp/tmpcksqb88f.rs:20:21\n   |\n20 |           count += 1\n   |                     ^ help: add `;` here\n21 |           break\n   |           ----- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpcksqb88f.rs:24:21\n   |\n24 |           count += 1\n   |                     ^ help: add `;` here\n25 |           start += 1\n   |           ----- unexpected token\n\nerror: expected `;`, found `end`\n  --> /tmp/tmpcksqb88f.rs:25:21\n   |\n25 |           start += 1\n   |                     ^ help: add `;` here\n26 |           end += 1\n   |           --- unexpected token\n\nerror: expected `;`, found keyword `break`\n  --> /tmp/tmpcksqb88f.rs:26:19\n   |\n26 |           end += 1\n   |                   ^ help: add `;` here\n27 |           break\n   |           ----- unexpected token\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpcksqb88f.rs:12:16\n   |\n12 |   for start in range(0, string.len) {\n   |                ^^^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::slice::range;\n   |\n\nerror[E0425]: cannot find function `range` in this scope\n  --> /tmp/tmpcksqb88f.rs:13:16\n   |\n13 |     for end in range(start, string.len) {\n   |            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.index(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpwnwq8wo1.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpwnwq8wo1.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpwnwq8wo1.rs:12:41\n   |\n12 |     let i = string.index(substring, pos)\n   |                                         ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpwnwq8wo1.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwnwq8wo1.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwnwq8wo1.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpwnwq8wo1.rs:12:20\n   |\n12 |     let i = string.index(substring, pos)\n   |                    ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwnwq8wo1.rs:16:25\n   |\n16 |     pos = i + substring.len\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while i < string.len {\n    if string.data[i] == substring.data[0] {\n      let j = 0\n      while j < substring.len && i + j < string.len {\n        if string.data[i + j] != substring.data[j] {\n          break\n        }\n        j += 1\n      }\n      if j == substring.len {\n        count += 1\n        i += j\n      }\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp6ch6tydx.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp6ch6tydx.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while i < string.len {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp6ch6tydx.rs:13:16\n   |\n13 |       let j = 0\n   |                ^ help: add `;` here\n14 |       while j < substring.len && i + j < string.len {\n   |       ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmp6ch6tydx.rs:21:19\n   |\n21 |         count += 1\n   |                   ^ help: add `;` here\n22 |         i += j\n   |         - unexpected token\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp6ch6tydx.rs:11:20\n   |\n11 |   while i < string.len {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while i < string.len() {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp6ch6tydx.rs:12:15\n   |\n12 |     if string.data[i] == substring.data[0] {\n   |               ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp6ch6tydx.rs:12:36\n   |\n12 |     if string.data[i] == substring.data[0] {\n   |                                    ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp6ch6tydx.rs:14:27\n   |\n14 |       while j < substring.len && i + j < string.len {\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |       while j < substring.len() && i + j < string.len {\n   |                              ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp6ch6tydx.rs:14:49\n   |\n14 |       while j < substring.len && i + j < string.len {\n   |                                 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.find(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmp4ydxf08m.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4ydxf08m.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4ydxf08m.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4ydxf08m.rs:12:20\n     |\n12   |     let i = string.find(substring, pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (start < string.len) {\n    end = string.index(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + substring.len\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp3jpzxtkc.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp3jpzxtkc.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp3jpzxtkc.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (start < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp3jpzxtkc.rs:13:41\n   |\n13 |     end = string.index(substring, start)\n   |                                         ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmp3jpzxtkc.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + substring.len\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3jpzxtkc.rs:12:9\n   |\n12 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (start < string.len) {\n12 +   while start < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp3jpzxtkc.rs:12:25\n   |\n12 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp3jpzxtkc.rs:13:18\n   |\n13 |     end = string.index(substring, start)\n   |                  ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i;\n      while (j < string.len && substring.data[0] == string.data[j]) {\n        j += 1;\n      }\n      if (j - i == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpllxkcjl1.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpllxkcjl1.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpllxkcjl1.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[0] == string.data[j]) {\n14 +       while j < string.len && substring.data[0] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpllxkcjl1.rs:17:10\n   |\n17 |       if (j - i == substring.len) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j - i == substring.len) {\n17 +       if j - i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpllxkcjl1.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpllxkcjl1.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpllxkcjl1.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9zouxl9x.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9zouxl9x.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let pos2 = substring.index(string.data[pos]);\n    if (pos2 == -1) {\n      break;\n    }\n    pos += pos2;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp0vwodryo.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0vwodryo.rs:13:8\n   |\n13 |     if (pos2 == -1) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (pos2 == -1) {\n13 +     if pos2 == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp0vwodryo.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp0vwodryo.rs:12:26\n   |\n12 |     let pos2 = substring.index(string.data[pos]);\n   |                          ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp0vwodryo.rs:12:39\n   |\n12 |     let pos2 = substring.index(string.data[pos]);\n   |                                       ^^^^ unknown field\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let index = 0\n  let substring_length = substring.length()\n  let string_length = string.length()\n  while index < string_length {\n    if string[index] == substring[0] {\n      let i = 1\n      while i < substring_length && string[index + i] == substring[i] {\n        i += 1\n      }\n      if i == substring_length {\n        count += 1\n        index += i\n      } else {\n        index += 1\n      }\n    } else {\n      index += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmprxeghhoy.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprxeghhoy.rs:10:16\n   |\n10 |   let index = 0\n   |                ^ help: add `;` here\n11 |   let substring_length = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprxeghhoy.rs:11:44\n   |\n11 |   let substring_length = substring.length()\n   |                                            ^ help: add `;` here\n12 |   let string_length = string.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprxeghhoy.rs:12:38\n   |\n12 |   let string_length = string.length()\n   |                                      ^ help: add `;` here\n13 |   while index < string_length {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprxeghhoy.rs:15:16\n   |\n15 |       let i = 1\n   |                ^ help: add `;` here\n16 |       while i < substring_length && string[index + i] == substring[i] {\n   |       ----- unexpected token\n\nerror: expected `;`, found `index`\n  --> /tmp/tmprxeghhoy.rs:20:19\n   |\n20 |         count += 1\n   |                   ^ help: add `;` here\n21 |         index += i\n   |         ----- unexpected token\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmprxeghhoy.rs:11:36\n   |\n11 |   let substring_length = substring.length()\n   |                                    ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmprxeghhoy.rs:12:30\n   |\n12 |   let string_length = string.length()\n   |                              ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmprxeghhoy.rs:14:8\n   |\n14 | ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (start < string.len) {\n    end = string.find(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + substring.len\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9ji94zw6.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9ji94zw6.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp9ji94zw6.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (start < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp9ji94zw6.rs:13:40\n   |\n13 |     end = string.find(substring, start)\n   |                                        ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmp9ji94zw6.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + substring.len\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9ji94zw6.rs:12:9\n   |\n12 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (start < string.len) {\n12 +   while start < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp9ji94zw6.rs:12:25\n   |\n12 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9ji94zw6.rs:13:18\n     |\n13   |     end = string.find(substring, start)\n     |                  ^^^^ ---------  ----- supplied 2 arguments\n     |                  |\n     |                  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatch",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  let substring_length = substring.length()\n  while (start < string.length()) {\n    end = string.find(substring, start)\n    if (end == -1) {\n      break\n    }\n    count += 1\n    start = end + substring_length\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb1h07oa1.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb1h07oa1.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb1h07oa1.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   let substring_length = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb1h07oa1.rs:12:44\n   |\n12 |   let substring_length = substring.length()\n   |                                            ^ help: add `;` here\n13 |   while (start < string.length()) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpb1h07oa1.rs:14:40\n   |\n14 |     end = string.find(substring, start)\n   |                                        ^ help: add `;` here\n15 |     if (end == -1) {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpb1h07oa1.rs:18:15\n   |\n18 |     count += 1\n   |               ^ help: add `;` here\n19 |     start = end + substring_length\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb1h07oa1.rs:13:9\n   |\n13 |   while (start < string.length()) {\n   |         ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (start < string.length()) {\n13 +   while start < string.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb1h07oa1.rs:15:8\n   |\n15 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (end == -1) {\n15 +     if end == -1 {\n   | \n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpb1h07oa1.rs:12:36\n   |\n12 |   let substring_leng",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let end = string.find(substring, pos);\n    if (end == -1) break;\n    pos = end + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpu5jqrm3i.rs:13:20\n   |\n13 |     if (end == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (end == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpu5jqrm3i.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpu5jqrm3i.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpu5jqrm3i.rs:12:22\n     |\n12   |     let end = string.find(substring, pos);\n     |                      ^^^^ ---------  --- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let index = string.index(substring, pos)\n    if index == -1 {\n      break\n    }\n    pos = index + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpc4aus9ax.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpc4aus9ax.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpc4aus9ax.rs:12:45\n   |\n12 |     let index = string.index(substring, pos)\n   |                                             ^ help: add `;` here\n13 |     if index == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpc4aus9ax.rs:16:32\n   |\n16 |     pos = index + substring.len\n   |                                ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpc4aus9ax.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpc4aus9ax.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpc4aus9ax.rs:12:24\n   |\n12 |     let index = string.index(substring, pos)\n   |                        ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpc4aus9ax.rs:16:29\n   |\n16 | ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (start < string.len) {\n    end = string.index(substring, start)\n    if (end == -1) {\n      break\n    }\n    count += 1\n    start = end + substring.len\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpn3wlqzos.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpn3wlqzos.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpn3wlqzos.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (start < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpn3wlqzos.rs:13:41\n   |\n13 |     end = string.index(substring, start)\n   |                                         ^ help: add `;` here\n14 |     if (end == -1) {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpn3wlqzos.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + substring.len\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn3wlqzos.rs:12:9\n   |\n12 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (start < string.len) {\n12 +   while start < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn3wlqzos.rs:14:8\n   |\n14 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (end == -1) {\n14 +     if end == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpn3wlqzos.rs:12:25\n   |\n12 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpn3wlqzos.rs:13:18\n   |\n13 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i;\n    while (j < string.len && substring.len <= j - i + 1) {\n      if (string.data[i] == substring.data[0] && substring.len == 1) {\n        count += 1;\n        j += 1;\n      } else {\n        j += 1;\n      }\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqfou7tws.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqfou7tws.rs:13:11\n   |\n13 |     while (j < string.len && substring.len <= j - i + 1) {\n   |           ^                                            ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < string.len && substring.len <= j - i + 1) {\n13 +     while j < string.len && substring.len <= j - i + 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqfou7tws.rs:14:10\n   |\n14 |       if (string.data[i] == substring.data[0] && substring.len == 1) {\n   |          ^                                                         ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (string.data[i] == substring.data[0] && substring.len == 1) {\n14 +       if string.data[i] == substring.data[0] && substring.len == 1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpqfou7tws.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpqfou7tws.rs:13:23\n   |\n13 |     while (j < string.len && substring.len <= j - i + 1) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < string.len() && substring.len <= j - i + 1) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpqfou7tws.rs:13:40\n   |\n13 |     while (j < string.len && substring.len <= j - i + 1) {\n   |                                        ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let pos2 = substring.index(string.data[pos]);\n    if (pos2 == -1) {\n      break;\n    }\n    pos += pos2;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp0vwodryo.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0vwodryo.rs:13:8\n   |\n13 |     if (pos2 == -1) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (pos2 == -1) {\n13 +     if pos2 == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp0vwodryo.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp0vwodryo.rs:12:26\n   |\n12 |     let pos2 = substring.index(string.data[pos]);\n   |                          ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp0vwodryo.rs:12:39\n   |\n12 |     let pos2 = substring.index(string.data[pos]);\n   |                                       ^^^^ unknown field\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0599, E0609, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while i < string.len {\n    if string.data[i] == substring.data[0] {\n      let j = i + 1\n      while j < string.len && substring.data[j] == string.data[j] {\n        j += 1\n      }\n      if j == substring.len {\n        count += 1\n        i = j\n      }\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp1_pu67de.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp1_pu67de.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while i < string.len {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp1_pu67de.rs:13:20\n   |\n13 |       let j = i + 1\n   |                    ^ help: add `;` here\n14 |       while j < string.len && substring.data[j] == string.data[j] {\n   |       ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmp1_pu67de.rs:18:19\n   |\n18 |         count += 1\n   |                   ^ help: add `;` here\n19 |         i = j\n   |         - unexpected token\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp1_pu67de.rs:11:20\n   |\n11 |   while i < string.len {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while i < string.len() {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp1_pu67de.rs:12:15\n   |\n12 |     if string.data[i] == substring.data[0] {\n   |               ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp1_pu67de.rs:12:36\n   |\n12 |     if string.data[i] == substring.data[0] {\n   |                                    ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp1_pu67de.rs:14:24\n   |\n14 |       while j < string.len && substring.data[j] == string.data[j] {\n   |                        ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |       while j < string.len() && substring.data[j] == string.data[j] {\n   |                           ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp1_pu67de.rs:14:41\n   |\n14 |       while j < string.len && substring.data[j] == string.data[j] {\n   |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (true) {\n    if (pos == string.len) {\n      break;\n    }\n    if (string[pos] == substring[0]) {\n      let i = 1;\n      while (i < substring.len && string[pos + i] == substring[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n        pos += i;\n      } else {\n        pos += i - 1;\n      }\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbxk6jlfr.rs:11:9\n   |\n11 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (true) {\n11 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpbxk6jlfr.rs:11:3\n   |\n11 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbxk6jlfr.rs:12:8\n   |\n12 |     if (pos == string.len) {\n   |        ^                 ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (pos == string.len) {\n12 +     if pos == string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbxk6jlfr.rs:15:8\n   |\n15 |     if (string[pos] == substring[0]) {\n   |        ^                           ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (string[pos] == substring[0]) {\n15 +     if string[pos] == substring[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbxk6jlfr.rs:17:13\n   |\n17 |       while (i < substring.len && string[pos + i] == substring[i]) {\n   |             ^                                                    ^\n   |\nhelp: remove these parentheses\n   |\n17 -       while (i < substring.len && string[pos + i] == substring[i]) {\n17 +       while i < substring.len && string[pos + i] == substring[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbxk6jlfr.rs:20:10\n   |\n20 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n20 -       if (i == substring.len) {\n20 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpbxk6jlfr.rs:12:23\n   |\n12 |     if (pos == string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     if (pos == string.l",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = 1\n      while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n        j += 1\n      }\n      if (j == substring.len) {\n        count += 1\n        i += j\n      } else {\n        i += 1\n      }\n    } else {\n      i += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbgn0imzf.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpbgn0imzf.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpbgn0imzf.rs:13:16\n   |\n13 |       let j = 1\n   |                ^ help: add `;` here\n14 |       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n   |       ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpbgn0imzf.rs:18:19\n   |\n18 |         count += 1\n   |                   ^ help: add `;` here\n19 |         i += j\n   |         - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbgn0imzf.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbgn0imzf.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbgn0imzf.rs:14:13\n   |\n14 |       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n   |             ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n14 +       while j < substring.len && i + j < string.len && string.data[i + j] == substring",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (start < string.len) {\n    end = string.find(substring, start)\n    if (end == -1) {\n      break\n    }\n    count += 1\n    start = end + substring.len\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpdblt2s01.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpdblt2s01.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpdblt2s01.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (start < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpdblt2s01.rs:13:40\n   |\n13 |     end = string.find(substring, start)\n   |                                        ^ help: add `;` here\n14 |     if (end == -1) {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpdblt2s01.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + substring.len\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpdblt2s01.rs:12:9\n   |\n12 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (start < string.len) {\n12 +   while start < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdblt2s01.rs:14:8\n   |\n14 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (end == -1) {\n14 +     if end == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpdblt2s01.rs:12:25\n   |\n12 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpdblt2s01.rs:13:18\n     |\n13   |     e",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1\n      }\n      if (j == substring.len) {\n        count += 1\n        i = j\n      }\n    } else {\n      i += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjx9aq3gp.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjx9aq3gp.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjx9aq3gp.rs:13:20\n   |\n13 |       let j = i + 1\n   |                    ^ help: add `;` here\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |       ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpjx9aq3gp.rs:18:19\n   |\n18 |         count += 1\n   |                   ^ help: add `;` here\n19 |         i = j\n   |         - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjx9aq3gp.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjx9aq3gp.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjx9aq3gp.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjx9aq3gp.rs:17:10\n   |\n17 |       if (j == substrin",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9zouxl9x.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9zouxl9x.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j - i == substring.len) {\n        count += 1;\n        i = j;\n      }\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjw2zavvn.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjw2zavvn.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjw2zavvn.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjw2zavvn.rs:17:10\n   |\n17 |       if (j - i == substring.len) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j - i == substring.len) {\n17 +       if j - i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpjw2zavvn.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpjw2zavvn.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpjw2zavvn.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                            ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while i < string.len {\n    if string.data[i] == substring.data[0] {\n      let j = i\n      while j < string.len && substring.data[0] == string.data[j] {\n        j += 1\n      }\n      count += j - i\n      i = j\n    } else {\n      i += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmprblwsf9a.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprblwsf9a.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while i < string.len {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprblwsf9a.rs:13:16\n   |\n13 |       let j = i\n   |                ^ help: add `;` here\n14 |       while j < string.len && substring.data[0] == string.data[j] {\n   |       ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmprblwsf9a.rs:17:21\n   |\n17 |       count += j - i\n   |                     ^ help: add `;` here\n18 |       i = j\n   |       - unexpected token\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmprblwsf9a.rs:11:20\n   |\n11 |   while i < string.len {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while i < string.len() {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmprblwsf9a.rs:12:15\n   |\n12 |     if string.data[i] == substring.data[0] {\n   |               ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmprblwsf9a.rs:12:36\n   |\n12 |     if string.data[i] == substring.data[0] {\n   |                                    ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmprblwsf9a.rs:14:24\n   |\n14 |       while j < string.len && substring.data[0] == string.data[j] {\n   |                        ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |       while j < string.len() && substring.data[0] == string.data[j] {\n   |                           ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmprblwsf9a.rs:14:41\n   |\n14 |       while j < string.len && substring.data[0] == string.data[j] {\n   |        ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  let substring_length = substring.length()\n  while (start < string.length()) {\n    end = string.index_of(substring, start)\n    if (end == -1) {\n      break\n    }\n    count += 1\n    start = end + substring_length\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   let substring_length = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprjw51dem.rs:12:44\n   |\n12 |   let substring_length = substring.length()\n   |                                            ^ help: add `;` here\n13 |   while (start < string.length()) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmprjw51dem.rs:14:44\n   |\n14 |     end = string.index_of(substring, start)\n   |                                            ^ help: add `;` here\n15 |     if (end == -1) {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmprjw51dem.rs:18:15\n   |\n18 |     count += 1\n   |               ^ help: add `;` here\n19 |     start = end + substring_length\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprjw51dem.rs:13:9\n   |\n13 |   while (start < string.length()) {\n   |         ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (start < string.length()) {\n13 +   while start < string.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprjw51dem.rs:15:8\n   |\n15 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (end == -1) {\n15 +     if end == -1 {\n   | \n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmprjw51dem.rs:12:36\n   |\n12 |   let substr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = pos;\n    while (i < string.len && substring.len <= i - pos && substring.eq(string.data[i])) {\n      i += 1;\n    }\n    if (substring.len <= i - pos) {\n      count += 1;\n    }\n    pos = i;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbfsxmbxb.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbfsxmbxb.rs:13:11\n   |\n13 |     while (i < string.len && substring.len <= i - pos && substring.eq(string.data[i])) {\n   |           ^                                                                          ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (i < string.len && substring.len <= i - pos && substring.eq(string.data[i])) {\n13 +     while i < string.len && substring.len <= i - pos && substring.eq(string.data[i]) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbfsxmbxb.rs:16:8\n   |\n16 |     if (substring.len <= i - pos) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (substring.len <= i - pos) {\n16 +     if substring.len <= i - pos {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpbfsxmbxb.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpbfsxmbxb.rs:13:23\n   |\n13 |     while (i < string.len && substring.len <= i - pos && substring.eq(string.data[i])) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (i < string.len() && substring.len <= i - pos && substring.eq(string.data[i])) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpbfsxmbxb.rs:13:40\n   |\n13 |     while (i < string.len && substring.len <= i -",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  let subpos = 0\n  while (pos < string.len) {\n    if (subpos == substring.len) {\n      count += 1\n      subpos = 0\n    }\n    if (string.data[pos] == substring.data[subpos]) {\n      subpos += 1\n    } else {\n      subpos = 0\n    }\n    pos += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp2x64tu_b.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2x64tu_b.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   let subpos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp2x64tu_b.rs:11:17\n   |\n11 |   let subpos = 0\n   |                 ^ help: add `;` here\n12 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `subpos`\n  --> /tmp/tmp2x64tu_b.rs:14:17\n   |\n14 |       count += 1\n   |                 ^ help: add `;` here\n15 |       subpos = 0\n   |       ------ unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2x64tu_b.rs:12:9\n   |\n12 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < string.len) {\n12 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2x64tu_b.rs:13:8\n   |\n13 |     if (subpos == substring.len) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (subpos == substring.len) {\n13 +     if subpos == substring.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2x64tu_b.rs:17:8\n   |\n17 |     if (string.data[pos] == substring.data[subpos]) {\n   |        ^                                          ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (string.data[pos] == substring.data[subpos]) {\n17 +     if string.data[pos] == substring.data[subpos] {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp2x64tu_b.rs:12:23\n   |\n12 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (pos < string.len()) {\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.find(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmp4ydxf08m.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4ydxf08m.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4ydxf08m.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4ydxf08m.rs:12:20\n     |\n12   |     let i = string.find(substring, pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = 1;\n      while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n        i += j;\n      }\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpova3eerk.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpova3eerk.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpova3eerk.rs:14:13\n   |\n14 |       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n   |             ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n14 +       while j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpova3eerk.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpova3eerk.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpova3eerk.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpova3eer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9zouxl9x.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9zouxl9x.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    j = substring.index(string.data[i])\n    if j == -1 {\n      break\n    }\n    i += j\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp1hmfmo2c.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp1hmfmo2c.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp1hmfmo2c.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp1hmfmo2c.rs:13:40\n   |\n13 |     j = substring.index(string.data[i])\n   |                                        ^ help: add `;` here\n14 |     if j == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp1hmfmo2c.rs:17:11\n   |\n17 |     i += j\n   |           ^ help: add `;` here\n18 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1hmfmo2c.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp1hmfmo2c.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp1hmfmo2c.rs:13:19\n   |\n13 |     j = substring.index(string.data[i])\n   |                   ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0609]: no field `d",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (true) {\n    pos = string.find(substring, pos);\n    if (pos == -1) break;\n    count += 1;\n    pos += substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpy7odsse_.rs:13:20\n   |\n13 |     if (pos == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (pos == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy7odsse_.rs:11:9\n   |\n11 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (true) {\n11 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpy7odsse_.rs:11:3\n   |\n11 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpy7odsse_.rs:12:18\n     |\n12   |     pos = string.find(substring, pos);\n     |                  ^^^^ ---------  --- supplied 2 arguments\n     |                  |\n     |                  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy7odsse_.rs:12:11\n   |\n10 |   let pos = 0;\n   |             - expected due to this value\n11 |   while (true) {\n12 |     pos = string.find(substring, pos);\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.index(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpwnwq8wo1.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpwnwq8wo1.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpwnwq8wo1.rs:12:41\n   |\n12 |     let i = string.index(substring, pos)\n   |                                         ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpwnwq8wo1.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwnwq8wo1.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwnwq8wo1.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpwnwq8wo1.rs:12:20\n   |\n12 |     let i = string.index(substring, pos)\n   |                    ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwnwq8wo1.rs:16:25\n   |\n16 |     pos = i + substring.len\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.index(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpwnwq8wo1.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpwnwq8wo1.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpwnwq8wo1.rs:12:41\n   |\n12 |     let i = string.index(substring, pos)\n   |                                         ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpwnwq8wo1.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwnwq8wo1.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwnwq8wo1.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpwnwq8wo1.rs:12:20\n   |\n12 |     let i = string.index(substring, pos)\n   |                    ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwnwq8wo1.rs:16:25\n   |\n16 |     pos = i + substring.len\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9zouxl9x.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9zouxl9x.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i;\n    while (j < string.len && substring.len > 0) {\n      if (string[j] != substring[0]) {\n        break;\n      }\n      j += 1;\n      substring = substring.sub(1);\n    }\n    if (substring.len == 0) {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp148xr8q4.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp148xr8q4.rs:13:11\n   |\n13 |     while (j < string.len && substring.len > 0) {\n   |           ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < string.len && substring.len > 0) {\n13 +     while j < string.len && substring.len > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp148xr8q4.rs:14:10\n   |\n14 |       if (string[j] != substring[0]) {\n   |          ^                         ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (string[j] != substring[0]) {\n14 +       if string[j] != substring[0] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp148xr8q4.rs:20:8\n   |\n20 |     if (substring.len == 0) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (substring.len == 0) {\n20 +     if substring.len == 0 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp148xr8q4.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp148xr8q4.rs:13:23\n   |\n13 |     while (j < string.len && substring.len > 0) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < string.len() && substring.len > 0) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp148xr8q4.rs:13:40\n   |\n13 |     while (",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && substring[j] == string[i + j]) {\n      j += 1\n    }\n    if (j == substring.len) {\n      count += 1\n      j = 0\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb32lu6i4.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpb32lu6i4.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       j = 0\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:13:11\n   |\n13 |     while (j < substring.len && substring[j] == string[i + j]) {\n   |           ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && substring[j] == string[i + j]) {\n13 +     while j < substring.len && substring[j] == string[i + j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb32lu6i4.rs:16:8\n   |\n16 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j == substring.len) {\n16 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb32lu6i4.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = pos;\n    while (i < string.len && substring.len > 0 && string.data[i] == substring.data[0]) {\n      i += 1;\n      substring = substring.drop(1);\n    }\n    if (substring.len == 0) {\n      count += 1;\n    }\n    pos = i;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjggsjhsi.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjggsjhsi.rs:13:11\n   |\n13 |     while (i < string.len && substring.len > 0 && string.data[i] == substring.data[0]) {\n   |           ^                                                                          ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (i < string.len && substring.len > 0 && string.data[i] == substring.data[0]) {\n13 +     while i < string.len && substring.len > 0 && string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjggsjhsi.rs:17:8\n   |\n17 |     if (substring.len == 0) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (substring.len == 0) {\n17 +     if substring.len == 0 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpjggsjhsi.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpjggsjhsi.rs:13:23\n   |\n13 |     while (i < string.len && substring.len > 0 && string.data[i] == substring.data[0]) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (i < string.len() && substring.len > 0 && string.data[i] == substring.data[0]) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpjggsjhsi.rs:13:40\n   |\n13 |     while (i < string.len && substring.len > 0 && string.data[i] == subst",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while true {\n    end = string.find(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxfekkre4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxfekkre4.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpxfekkre4.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while true {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpxfekkre4.rs:13:40\n   |\n13 |     end = string.find(substring, start)\n   |                                        ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpxfekkre4.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + 1\n   |     ----- unexpected token\n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpxfekkre4.rs:12:3\n   |\n12 |   while true {\n   |   ^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpxfekkre4.rs:13:18\n     |\n13   |     end = string.find(substring, start)\n     |                  ^^^^ ---------  ----- supplied 2 arguments\n     |                  |\n     |                  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxfekkre4.rs:13:11\n   |\n11 |   let end = 0\n   |             - expected due to this value\n12 |   while true {\n13 |     end = string.find(substring, start)\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.find(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp892u0phg.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp892u0phg.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp892u0phg.rs:12:40\n   |\n12 |     let i = string.find(substring, pos)\n   |                                        ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp892u0phg.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp892u0phg.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp892u0phg.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp892u0phg.rs:12:20\n     |\n12   |     let i = string.find(substring, pos)\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp892u0phg.rs:13:13\n   |\n13 |     if i == -1 {\n   |             ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.index(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpwnwq8wo1.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpwnwq8wo1.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpwnwq8wo1.rs:12:41\n   |\n12 |     let i = string.index(substring, pos)\n   |                                         ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmpwnwq8wo1.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwnwq8wo1.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwnwq8wo1.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpwnwq8wo1.rs:12:20\n   |\n12 |     let i = string.index(substring, pos)\n   |                    ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpwnwq8wo1.rs:16:25\n   |\n16 |     pos = i + substring.len\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let idx = string.find(substring, pos);\n    if (idx == -1) break;\n    pos = idx + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpa50ka7o2.rs:13:20\n   |\n13 |     if (idx == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (idx == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa50ka7o2.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpa50ka7o2.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpa50ka7o2.rs:12:22\n     |\n12   |     let idx = string.find(substring, pos);\n     |                      ^^^^ ---------  --- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (true) {\n    pos = string.find(substring, pos);\n    if (pos == -1) break;\n    count += 1;\n    pos += substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpy7odsse_.rs:13:20\n   |\n13 |     if (pos == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (pos == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy7odsse_.rs:11:9\n   |\n11 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (true) {\n11 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpy7odsse_.rs:11:3\n   |\n11 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpy7odsse_.rs:12:18\n     |\n12   |     pos = string.find(substring, pos);\n     |                  ^^^^ ---------  --- supplied 2 arguments\n     |                  |\n     |                  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy7odsse_.rs:12:11\n   |\n10 |   let pos = 0;\n   |             - expected due to this value\n11 |   while (true) {\n12 |     pos = string.find(substring, pos);\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.find(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp892u0phg.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp892u0phg.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp892u0phg.rs:12:40\n   |\n12 |     let i = string.find(substring, pos)\n   |                                        ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp892u0phg.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp892u0phg.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp892u0phg.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp892u0phg.rs:12:20\n     |\n12   |     let i = string.find(substring, pos)\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp892u0phg.rs:13:13\n   |\n13 |     if i == -1 {\n   |             ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let index = 0;\n  while (index < string.len) {\n    if (string.data[index] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && index + i < string.len && string.data[index + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n      index += i;\n    } else {\n      index += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpzn7azo3t.rs:11:9\n   |\n11 |   while (index < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (index < string.len) {\n11 +   while index < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzn7azo3t.rs:12:8\n   |\n12 |     if (string.data[index] == substring.data[0]) {\n   |        ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[index] == substring.data[0]) {\n12 +     if string.data[index] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpzn7azo3t.rs:14:13\n   |\n14 |       while (i < substring.len && index + i < string.len && string.data[index + i] == substring.data[i]) {\n   |             ^                                                                                          ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && index + i < string.len && string.data[index + i] == substring.data[i]) {\n14 +       while i < substring.len && index + i < string.len && string.data[index + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzn7azo3t.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpzn7azo3t.rs:11:25\n   |\n11 |   while (index < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (index < string.len()) {\n   |                            ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpzn7azo3t.rs:12:16\n   |\n12 |     if (string.data[index] == substring.data[0]) {\n   |                ^^^^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while true {\n    end = substring.index(string, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9sfb35mc.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9sfb35mc.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp9sfb35mc.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while true {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp9sfb35mc.rs:13:41\n   |\n13 |     end = substring.index(string, start)\n   |                                         ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmp9sfb35mc.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + 1\n   |     ----- unexpected token\n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmp9sfb35mc.rs:12:3\n   |\n12 |   while true {\n   |   ^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp9sfb35mc.rs:13:21\n   |\n13 |     end = substring.index(string, start)\n   |                     ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.find(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp892u0phg.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp892u0phg.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp892u0phg.rs:12:40\n   |\n12 |     let i = string.find(substring, pos)\n   |                                        ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp892u0phg.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp892u0phg.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp892u0phg.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp892u0phg.rs:12:20\n     |\n12   |     let i = string.find(substring, pos)\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp892u0phg.rs:13:13\n   |\n13 |     if i == -1 {\n   |             ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    if (string.data.find(substring, pos) == pos) {\n      count += 1\n      pos += substring.len\n    } else {\n      pos += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbuq2oeev.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpbuq2oeev.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `pos`\n  --> /tmp/tmpbuq2oeev.rs:13:17\n   |\n13 |       count += 1\n   |                 ^ help: add `;` here\n14 |       pos += substring.len\n   |       --- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbuq2oeev.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuq2oeev.rs:12:8\n   |\n12 |     if (string.data.find(substring, pos) == pos) {\n   |        ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data.find(substring, pos) == pos) {\n12 +     if string.data.find(substring, pos) == pos {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpbuq2oeev.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpbuq2oeev.rs:12:16\n   |\n12 |     if (string.data.find(substring, pos) == pos) {\n   |                ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpbuq2oeev.rs:14:24\n   |\n14 |       pos += substring.len\n   |                        ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n14 |       pos += substring.len()\n   | ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let index = 0\n  let length = substring.length()\n  let string_length = string.length()\n  while (index < string_length) {\n    let i = index\n    while (i < string_length && substring[0] == string[i]) {\n      i += 1\n    }\n    if (i - index >= length) {\n      count += 1\n    }\n    index = i\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmprp1mo3ch.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprp1mo3ch.rs:10:16\n   |\n10 |   let index = 0\n   |                ^ help: add `;` here\n11 |   let length = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprp1mo3ch.rs:11:34\n   |\n11 |   let length = substring.length()\n   |                                  ^ help: add `;` here\n12 |   let string_length = string.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprp1mo3ch.rs:12:38\n   |\n12 |   let string_length = string.length()\n   |                                      ^ help: add `;` here\n13 |   while (index < string_length) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprp1mo3ch.rs:14:18\n   |\n14 |     let i = index\n   |                  ^ help: add `;` here\n15 |     while (i < string_length && substring[0] == string[i]) {\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprp1mo3ch.rs:13:9\n   |\n13 |   while (index < string_length) {\n   |         ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (index < string_length) {\n13 +   while index < string_length {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprp1mo3ch.rs:15:11\n   |\n15 |     while (i < string_length && substring[0] == string[i]) {\n   |           ^                                              ^\n   |\nhelp: remove these parentheses\n   |\n15 -     while (i < string_length && substring[0] == string[i]) {\n15 +     while i < string_length && substring[0] == string[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprp1mo3ch.rs:18:8\n   |\n18 |     if (i - index >= length) {\n   |        ^               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let idx = string.index(substring, pos)\n    if idx == -1 {\n      break\n    }\n    pos = idx + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp1kw9b1be.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp1kw9b1be.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp1kw9b1be.rs:12:43\n   |\n12 |     let idx = string.index(substring, pos)\n   |                                           ^ help: add `;` here\n13 |     if idx == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp1kw9b1be.rs:16:30\n   |\n16 |     pos = idx + substring.len\n   |                              ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1kw9b1be.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp1kw9b1be.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp1kw9b1be.rs:12:22\n   |\n12 |     let idx = string.index(substring, pos)\n   |                      ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp1kw9b1be.rs:16:27\n   |\n16 |     pos = idx ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let next_pos = string.find(substring, pos);\n    if (next_pos == -1) {\n      break;\n    }\n    pos = next_pos + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpz9k6_gn3.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz9k6_gn3.rs:13:8\n   |\n13 |     if (next_pos == -1) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (next_pos == -1) {\n13 +     if next_pos == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpz9k6_gn3.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpz9k6_gn3.rs:12:27\n     |\n12   |     let next_pos = string.find(substring, pos);\n     |                           ^^^^ ---------  --- supplied 2 arguments\n     |                           |\n     |                           expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz9k6_gn3.rs:13:21\n   |\n13 |     if (next_pos == -1) {\n   |                     ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     if (next_pos == Some(-1)) {\n   |                     +++++  +\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpz9k6_gn3.rs:16:32\n   |\n16 |     pos = next_pos + substring.len;\n   |                                ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |     pos = next_pos + substring.len();\n   |                                   ++\n\nerror: aborting due to 4 previous errors; 2 warnings emi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && substring[j] == string[i + j]) {\n      j += 1\n    }\n    if (j == substring.len) {\n      count += 1\n      j = 0\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb32lu6i4.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpb32lu6i4.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       j = 0\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:13:11\n   |\n13 |     while (j < substring.len && substring[j] == string[i + j]) {\n   |           ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && substring[j] == string[i + j]) {\n13 +     while j < substring.len && substring[j] == string[i + j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb32lu6i4.rs:16:8\n   |\n16 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j == substring.len) {\n16 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb32lu6i4.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && substring[j] == string[i + j]) {\n      j += 1\n    }\n    if (j == substring.len) {\n      count += 1\n      j = 0\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb32lu6i4.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpb32lu6i4.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       j = 0\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:13:11\n   |\n13 |     while (j < substring.len && substring[j] == string[i + j]) {\n   |           ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && substring[j] == string[i + j]) {\n13 +     while j < substring.len && substring[j] == string[i + j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb32lu6i4.rs:16:8\n   |\n16 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j == substring.len) {\n16 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb32lu6i4.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.find(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmp4ydxf08m.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4ydxf08m.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4ydxf08m.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4ydxf08m.rs:12:20\n     |\n12   |     let i = string.find(substring, pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.find(substring, pos);\n    if (i == -1) {\n      break;\n    }\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn8vrlfe6.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn8vrlfe6.rs:13:8\n   |\n13 |     if (i == -1) {\n   |        ^       ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (i == -1) {\n13 +     if i == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpn8vrlfe6.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpn8vrlfe6.rs:12:20\n     |\n12   |     let i = string.find(substring, pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8vrlfe6.rs:13:14\n   |\n13 |     if (i == -1) {\n   |              ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     if (i == Some(-1)) {\n   |              +++++  +\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpn8vrlfe6.rs:16:25\n   |\n16 |     pos = i + substring.len;\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |     pos = i + substring.len();\n   |                            ++\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308, E0615.\nFor more information about an error, try `rus",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1\n      }\n      if (i == substring.len) {\n        count += 1\n      }\n    }\n    pos += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp75m7lg1x.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp75m7lg1x.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp75m7lg1x.rs:13:16\n   |\n13 |       let i = 1\n   |                ^ help: add `;` here\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |       ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp75m7lg1x.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp75m7lg1x.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp75m7lg1x.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp75m7lg1x.rs:17:10\n   |\n17 |       if (i == substring.len) ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && string[i] == substring[j]) {\n      i += 1\n      j += 1\n    }\n    j = 0\n    if (i == string.len) {\n      break\n    }\n    count += 1\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9bqfzj9h.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9bqfzj9h.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp9bqfzj9h.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmp9bqfzj9h.rs:14:13\n   |\n14 |       i += 1\n   |             ^ help: add `;` here\n15 |       j += 1\n   |       - unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp9bqfzj9h.rs:17:10\n   |\n17 |     j = 0\n   |          ^ help: add `;` here\n18 |     if (i == string.len) {\n   |     -- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmp9bqfzj9h.rs:21:15\n   |\n21 |     count += 1\n   |               ^ help: add `;` here\n22 |     i += 1\n   |     - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9bqfzj9h.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9bqfzj9h.rs:13:11\n   |\n13 |     while (j < substring.len && string[i] == substring[j]) {\n   |           ^                                              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && string[i] == substring[j]) {\n13 +     while j < substring.len && string[i] == substring[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9bqfzj9h.rs:18:8\n   |\n18 |     if (i == string.len) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n18 -     if (i == string.len) {\n18 +    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let index = 0\n  while true {\n    index = string.find(substring, index)\n    if index == -1 {\n      break\n    }\n    count += 1\n    index += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb0te6ltx.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb0te6ltx.rs:10:16\n   |\n10 |   let index = 0\n   |                ^ help: add `;` here\n11 |   while true {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpb0te6ltx.rs:12:42\n   |\n12 |     index = string.find(substring, index)\n   |                                          ^ help: add `;` here\n13 |     if index == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `index`\n  --> /tmp/tmpb0te6ltx.rs:16:15\n   |\n16 |     count += 1\n   |               ^ help: add `;` here\n17 |     index += 1\n   |     ----- unexpected token\n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpb0te6ltx.rs:11:3\n   |\n11 |   while true {\n   |   ^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpb0te6ltx.rs:12:20\n     |\n12   |     index = string.find(substring, index)\n     |                    ^^^^ ---------  ----- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0te6ltx.rs:12:13\n   |\n10 |   let index = 0\n   |               - expected due to this value\n11 |   while true {\n12 |     index = string.find(substring, index)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = 0;\n      while (j < substring.len) {\n        if (string.data[i + j] != substring.data[j]) {\n          break;\n        }\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n        i += substring.len;\n      } else {\n        i += 1;\n      }\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpmycpqzao.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmycpqzao.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpmycpqzao.rs:14:13\n   |\n14 |       while (j < substring.len) {\n   |             ^                 ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < substring.len) {\n14 +       while j < substring.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmycpqzao.rs:15:12\n   |\n15 |         if (string.data[i + j] != substring.data[j]) {\n   |            ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -         if (string.data[i + j] != substring.data[j]) {\n15 +         if string.data[i + j] != substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmycpqzao.rs:20:10\n   |\n20 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n20 -       if (j == substring.len) {\n20 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpmycpqzao.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpmycpqzao.rs:12:16\n   |\n12 |     if (string.data[i] == substring.dat",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = 1;\n      while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n        i += j;\n      } else {\n        i += 1;\n      }\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp0t8xsu8y.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0t8xsu8y.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp0t8xsu8y.rs:14:13\n   |\n14 |       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n   |             ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n14 +       while j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0t8xsu8y.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp0t8xsu8y.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp0t8xsu8y.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp0t8xsu8",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i\n      while (j < string.len && substring.data[0] == string.data[j]) {\n        j += 1\n      }\n      if (j - i == substring.len) {\n        count += 1\n      }\n      i = j\n    } else {\n      i += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpfpir6rek.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpfpir6rek.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpfpir6rek.rs:13:16\n   |\n13 |       let j = i\n   |                ^ help: add `;` here\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |       ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfpir6rek.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfpir6rek.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfpir6rek.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[0] == string.data[j]) {\n14 +       while j < string.len && substring.data[0] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfpir6rek.rs:17:10\n   |\n17 |       if (j - i == substring.len) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j - i == substring.len) {\n17 +       if j - i == substring.len {\n   | \n\nerror[E0615]: at",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let next_pos = string.find(substring, pos);\n    if (next_pos == -1) {\n      break;\n    }\n    pos = next_pos + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpz9k6_gn3.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz9k6_gn3.rs:13:8\n   |\n13 |     if (next_pos == -1) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (next_pos == -1) {\n13 +     if next_pos == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpz9k6_gn3.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpz9k6_gn3.rs:12:27\n     |\n12   |     let next_pos = string.find(substring, pos);\n     |                           ^^^^ ---------  --- supplied 2 arguments\n     |                           |\n     |                           expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz9k6_gn3.rs:13:21\n   |\n13 |     if (next_pos == -1) {\n   |                     ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     if (next_pos == Some(-1)) {\n   |                     +++++  +\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpz9k6_gn3.rs:16:32\n   |\n16 |     pos = next_pos + substring.len;\n   |                                ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |     pos = next_pos + substring.len();\n   |                                   ++\n\nerror: aborting due to 4 previous errors; 2 warnings emi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let index = 0\n  let length = substring.length()\n  while (index < string.length() - length + 1) {\n    if (string.substr(index, length) == substring) {\n      count += 1\n    }\n    index += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpevf7dy5j.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpevf7dy5j.rs:10:16\n   |\n10 |   let index = 0\n   |                ^ help: add `;` here\n11 |   let length = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpevf7dy5j.rs:11:34\n   |\n11 |   let length = substring.length()\n   |                                  ^ help: add `;` here\n12 |   while (index < string.length() - length + 1) {\n   |   ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpevf7dy5j.rs:12:9\n   |\n12 |   while (index < string.length() - length + 1) {\n   |         ^                                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (index < string.length() - length + 1) {\n12 +   while index < string.length() - length + 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpevf7dy5j.rs:13:8\n   |\n13 |     if (string.substr(index, length) == substring) {\n   |        ^                                         ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (string.substr(index, length) == substring) {\n13 +     if string.substr(index, length) == substring {\n   | \n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpevf7dy5j.rs:11:26\n   |\n11 |   let length = substring.length()\n   |                          ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpevf7dy5j.rs:12:25\n   |\n12 |   while (index < string.length() - length + 1) {\n   |                         ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0599]: no method named `substr` found for struct `String` in the c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpok0q91iu.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpok0q91iu.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpok0q91iu.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpok0q91iu.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpok0q91iu.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpok0q91iu.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpok0q91iu.rs:12:39\n   |\n12 |     if (string.data[pos] == subst",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.find(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp892u0phg.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp892u0phg.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp892u0phg.rs:12:40\n   |\n12 |     let i = string.find(substring, pos)\n   |                                        ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp892u0phg.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp892u0phg.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp892u0phg.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp892u0phg.rs:12:20\n     |\n12   |     let i = string.find(substring, pos)\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp892u0phg.rs:13:13\n   |\n13 |     if i == -1 {\n   |             ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let next_pos = string.find(substring, pos);\n    if (next_pos == -1) {\n      break;\n    }\n    count += 1;\n    pos = next_pos + substring.len;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpoj0yb8fw.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpoj0yb8fw.rs:13:8\n   |\n13 |     if (next_pos == -1) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (next_pos == -1) {\n13 +     if next_pos == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpoj0yb8fw.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpoj0yb8fw.rs:12:27\n     |\n12   |     let next_pos = string.find(substring, pos);\n     |                           ^^^^ ---------  --- supplied 2 arguments\n     |                           |\n     |                           expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoj0yb8fw.rs:13:21\n   |\n13 |     if (next_pos == -1) {\n   |                     ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     if (next_pos == Some(-1)) {\n   |                     +++++  +\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpoj0yb8fw.rs:17:32\n   |\n17 |     pos = next_pos + substring.len;\n   |                                ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n17 |     pos = next_pos + substring.len();\n   |                                   ++\n\nerror: aborting due to 4 previous errors; 2 warnings emi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i;\n    while (j < string.len && substring.len > 0) {\n      if (string.data[j] != substring.data[0]) {\n        break;\n      }\n      j += 1;\n      substring = substring.drop(1);\n    }\n    if (substring.len == 0) {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbeixtve0.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbeixtve0.rs:13:11\n   |\n13 |     while (j < string.len && substring.len > 0) {\n   |           ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < string.len && substring.len > 0) {\n13 +     while j < string.len && substring.len > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbeixtve0.rs:14:10\n   |\n14 |       if (string.data[j] != substring.data[0]) {\n   |          ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (string.data[j] != substring.data[0]) {\n14 +       if string.data[j] != substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbeixtve0.rs:20:8\n   |\n20 |     if (substring.len == 0) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (substring.len == 0) {\n20 +     if substring.len == 0 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpbeixtve0.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpbeixtve0.rs:13:23\n   |\n13 |     while (j < string.len && substring.len > 0) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < string.len() && substring.len > 0) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while true {\n    end = substring.find(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjxtxqh4q.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpjxtxqh4q.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjxtxqh4q.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while true {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpjxtxqh4q.rs:13:43\n   |\n13 |     end = substring.find(substring, start)\n   |                                           ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpjxtxqh4q.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + 1\n   |     ----- unexpected token\n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpjxtxqh4q.rs:12:3\n   |\n12 |   while true {\n   |   ^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpjxtxqh4q.rs:13:21\n     |\n13   |     end = substring.find(substring, start)\n     |                     ^^^^ ---------  ----- supplied 2 arguments\n     |                     |\n     |                     expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxtxqh4q.rs:13:11\n   |\n11 |   let end = 0\n   |             - expected due to this value\n12 |   while true {\n13 |     end = substring.find(substring, start)\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 7 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1\n      }\n      if (i == substring.len) {\n        count += 1\n      }\n    }\n    pos += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp75m7lg1x.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp75m7lg1x.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp75m7lg1x.rs:13:16\n   |\n13 |       let i = 1\n   |                ^ help: add `;` here\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |       ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp75m7lg1x.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp75m7lg1x.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp75m7lg1x.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp75m7lg1x.rs:17:10\n   |\n17 |       if (i == substring.len) ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let index = 0\n  while true {\n    index = string.find(substring, index)\n    if index == -1 {\n      break\n    }\n    count += 1\n    index += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb0te6ltx.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb0te6ltx.rs:10:16\n   |\n10 |   let index = 0\n   |                ^ help: add `;` here\n11 |   while true {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpb0te6ltx.rs:12:42\n   |\n12 |     index = string.find(substring, index)\n   |                                          ^ help: add `;` here\n13 |     if index == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `index`\n  --> /tmp/tmpb0te6ltx.rs:16:15\n   |\n16 |     count += 1\n   |               ^ help: add `;` here\n17 |     index += 1\n   |     ----- unexpected token\n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpb0te6ltx.rs:11:3\n   |\n11 |   while true {\n   |   ^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpb0te6ltx.rs:12:20\n     |\n12   |     index = string.find(substring, index)\n     |                    ^^^^ ---------  ----- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0te6ltx.rs:12:13\n   |\n10 |   let index = 0\n   |               - expected due to this value\n11 |   while true {\n12 |     index = string.find(substring, index)\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n        pos += i;\n      }\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgjskp_76.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgjskp_76.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgjskp_76.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgjskp_76.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpgjskp_76.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpgjskp_76.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpgjskp_76.rs:12:39\n   |\n12 |     if (string.data[pos] == subst",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n        pos += i;\n      }\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgjskp_76.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgjskp_76.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgjskp_76.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgjskp_76.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpgjskp_76.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpgjskp_76.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpgjskp_76.rs:12:39\n   |\n12 |     if (string.data[pos] == subst",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = 1;\n      while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n        i += j;\n      }\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpova3eerk.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpova3eerk.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpova3eerk.rs:14:13\n   |\n14 |       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n   |             ^                                                                                  ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j]) {\n14 +       while j < substring.len && i + j < string.len && string.data[i + j] == substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpova3eerk.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpova3eerk.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpova3eerk.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpova3eer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  let len = substring.length()\n  while (pos < string.length()) {\n    if (string.substring(pos, pos + len).equals(substring)) {\n      count += 1\n      pos += len\n    } else {\n      pos += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphcr1vdyq.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphcr1vdyq.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   let len = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmphcr1vdyq.rs:11:31\n   |\n11 |   let len = substring.length()\n   |                               ^ help: add `;` here\n12 |   while (pos < string.length()) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `pos`\n  --> /tmp/tmphcr1vdyq.rs:14:17\n   |\n14 |       count += 1\n   |                 ^ help: add `;` here\n15 |       pos += len\n   |       --- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphcr1vdyq.rs:12:9\n   |\n12 |   while (pos < string.length()) {\n   |         ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < string.length()) {\n12 +   while pos < string.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphcr1vdyq.rs:13:8\n   |\n13 |     if (string.substring(pos, pos + len).equals(substring)) {\n   |        ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (string.substring(pos, pos + len).equals(substring)) {\n13 +     if string.substring(pos, pos + len).equals(substring) {\n   | \n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmphcr1vdyq.rs:11:23\n   |\n11 |   let len = substring.length()\n   |                       ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmphcr1vdyq.rs:12:23\n   |\n12 |   while (pos < string.length()) {\n   |                       ^^^^^^ help: there is an associate",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && substring[j] == string[i + j]) {\n      j += 1\n    }\n    if (j == substring.len) {\n      count += 1\n      j = 0\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb32lu6i4.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpb32lu6i4.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       j = 0\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:13:11\n   |\n13 |     while (j < substring.len && substring[j] == string[i + j]) {\n   |           ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && substring[j] == string[i + j]) {\n13 +     while j < substring.len && substring[j] == string[i + j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb32lu6i4.rs:16:8\n   |\n16 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j == substring.len) {\n16 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb32lu6i4.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9zouxl9x.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9zouxl9x.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9zouxl9x.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let index = 0;\n  while (index < string.len) {\n    if (string.data[index] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[index + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n      index += i;\n    } else {\n      index += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppmmc394c.rs:11:9\n   |\n11 |   while (index < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (index < string.len) {\n11 +   while index < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppmmc394c.rs:12:8\n   |\n12 |     if (string.data[index] == substring.data[0]) {\n   |        ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[index] == substring.data[0]) {\n12 +     if string.data[index] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppmmc394c.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[index + i] == substring.data[i]) {\n   |             ^                                                                ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[index + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[index + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppmmc394c.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmppmmc394c.rs:11:25\n   |\n11 |   while (index < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (index < string.len()) {\n   |                            ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmppmmc394c.rs:12:16\n   |\n12 |     if (string.data[index] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmppmmc394c.rs:12:41\n   |\n12 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (true) {\n    pos = string.find(substring, pos);\n    if (pos == -1) break;\n    count += 1;\n    pos += substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpy7odsse_.rs:13:20\n   |\n13 |     if (pos == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (pos == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy7odsse_.rs:11:9\n   |\n11 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (true) {\n11 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpy7odsse_.rs:11:3\n   |\n11 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpy7odsse_.rs:12:18\n     |\n12   |     pos = string.find(substring, pos);\n     |                  ^^^^ ---------  --- supplied 2 arguments\n     |                  |\n     |                  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy7odsse_.rs:12:11\n   |\n10 |   let pos = 0;\n   |             - expected due to this value\n11 |   while (true) {\n12 |     pos = string.find(substring, pos);\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  let subpos = 0\n  while (pos < string.len) {\n    if (subpos == substring.len) {\n      count += 1\n      subpos = 0\n    }\n    if (string.data[pos] == substring.data[subpos]) {\n      subpos += 1\n    } else {\n      subpos = 0\n    }\n    pos += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp2x64tu_b.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp2x64tu_b.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   let subpos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp2x64tu_b.rs:11:17\n   |\n11 |   let subpos = 0\n   |                 ^ help: add `;` here\n12 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `subpos`\n  --> /tmp/tmp2x64tu_b.rs:14:17\n   |\n14 |       count += 1\n   |                 ^ help: add `;` here\n15 |       subpos = 0\n   |       ------ unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2x64tu_b.rs:12:9\n   |\n12 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < string.len) {\n12 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2x64tu_b.rs:13:8\n   |\n13 |     if (subpos == substring.len) {\n   |        ^                       ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (subpos == substring.len) {\n13 +     if subpos == substring.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2x64tu_b.rs:17:8\n   |\n17 |     if (string.data[pos] == substring.data[subpos]) {\n   |        ^                                          ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (string.data[pos] == substring.data[subpos]) {\n17 +     if string.data[pos] == substring.data[subpos] {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp2x64tu_b.rs:12:23\n   |\n12 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (pos < string.len()) {\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1\n      }\n      if (i == substring.len) {\n        count += 1\n        pos += i\n      }\n    } else {\n      pos += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9mi_76gj.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp9mi_76gj.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp9mi_76gj.rs:13:16\n   |\n13 |       let i = 1\n   |                ^ help: add `;` here\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |       ----- unexpected token\n\nerror: expected `;`, found `pos`\n  --> /tmp/tmp9mi_76gj.rs:18:19\n   |\n18 |         count += 1\n   |                   ^ help: add `;` here\n19 |         pos += i\n   |         --- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9mi_76gj.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9mi_76gj.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9mi_76gj.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` conditi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && substring[j] == string[i + j]) {\n      j += 1\n    }\n    if (j == substring.len) {\n      count += 1\n      j = 0\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb32lu6i4.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpb32lu6i4.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       j = 0\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:13:11\n   |\n13 |     while (j < substring.len && substring[j] == string[i + j]) {\n   |           ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && substring[j] == string[i + j]) {\n13 +     while j < substring.len && substring[j] == string[i + j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb32lu6i4.rs:16:8\n   |\n16 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j == substring.len) {\n16 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb32lu6i4.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i;\n    while (j < string.len && substring.len > 0) {\n      if (string[j] != substring[0]) {\n        break;\n      }\n      j += 1;\n      substring = substring.drop(1);\n    }\n    if (substring.len == 0) {\n      count += 1;\n    }\n    i += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp62uv5m7y.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp62uv5m7y.rs:13:11\n   |\n13 |     while (j < string.len && substring.len > 0) {\n   |           ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < string.len && substring.len > 0) {\n13 +     while j < string.len && substring.len > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp62uv5m7y.rs:14:10\n   |\n14 |       if (string[j] != substring[0]) {\n   |          ^                         ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (string[j] != substring[0]) {\n14 +       if string[j] != substring[0] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp62uv5m7y.rs:20:8\n   |\n20 |     if (substring.len == 0) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (substring.len == 0) {\n20 +     if substring.len == 0 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp62uv5m7y.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp62uv5m7y.rs:13:23\n   |\n13 |     while (j < string.len && substring.len > 0) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < string.len() && substring.len > 0) {\n   |                          ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp62uv5m7y.rs:13:40\n   |\n13 |     while (",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i + substring.len;\n    if (j > string.len) {\n      break;\n    }\n    if (string.data.slice(i, j) == substring) {\n      count += 1;\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpf9w81uo9.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9w81uo9.rs:13:8\n   |\n13 |     if (j > string.len) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (j > string.len) {\n13 +     if j > string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpf9w81uo9.rs:16:8\n   |\n16 |     if (string.data.slice(i, j) == substring) {\n   |        ^                                    ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (string.data.slice(i, j) == substring) {\n16 +     if string.data.slice(i, j) == substring {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpf9w81uo9.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpf9w81uo9.rs:12:27\n   |\n12 |     let j = i + substring.len;\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |     let j = i + substring.len();\n   |                              ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpf9w81uo9.rs:13:20\n   |\n13 |     if (j > string.len) {\n   |                    ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     if (j > string.len()) {\n   |                       ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpf9w81uo9.rs:16:16\n   |\n16 |     if (string.data.slice(i, j) == substring) {\n   |                ^^^^ unknown field\n\nerror: aborting",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let idx = string.index(pos, substring);\n    if (idx == -1) break;\n    count += 1;\n    pos = idx + substring.len;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpgn4n2z8i.rs:13:20\n   |\n13 |     if (idx == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (idx == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgn4n2z8i.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpgn4n2z8i.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpgn4n2z8i.rs:12:22\n   |\n12 |     let idx = string.index(pos, substring);\n   |                      ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let next_pos = string.find(substring, pos);\n    if (next_pos == -1) {\n      break;\n    }\n    pos = next_pos + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpz9k6_gn3.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz9k6_gn3.rs:13:8\n   |\n13 |     if (next_pos == -1) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (next_pos == -1) {\n13 +     if next_pos == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpz9k6_gn3.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpz9k6_gn3.rs:12:27\n     |\n12   |     let next_pos = string.find(substring, pos);\n     |                           ^^^^ ---------  --- supplied 2 arguments\n     |                           |\n     |                           expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz9k6_gn3.rs:13:21\n   |\n13 |     if (next_pos == -1) {\n   |                     ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     if (next_pos == Some(-1)) {\n   |                     +++++  +\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpz9k6_gn3.rs:16:32\n   |\n16 |     pos = next_pos + substring.len;\n   |                                ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |     pos = next_pos + substring.len();\n   |                                   ++\n\nerror: aborting due to 4 previous errors; 2 warnings emi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (true) {\n    end = substring.find(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpgbftdh8e.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpgbftdh8e.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpgbftdh8e.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (true) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpgbftdh8e.rs:13:43\n   |\n13 |     end = substring.find(substring, start)\n   |                                           ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmpgbftdh8e.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgbftdh8e.rs:12:9\n   |\n12 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (true) {\n12 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpgbftdh8e.rs:12:3\n   |\n12 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpgbftdh8e.rs:13:21\n     |\n13   |     end = substring.find(substring, start)\n     |                     ^^^^ ---------  ----- supplied 2 arguments\n     |                     |\n     |                     expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgbftdh8e.rs:13:11\n   |\n11 |   let end = 0\n   |             - expected due to this value\n12 |   while (true) {\n13 |     end = substring.find(substring, start)\n   |  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.index(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpfk66w666.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfk66w666.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpfk66w666.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpfk66w666.rs:12:20\n   |\n12 |     let i = string.index(substring, pos);\n   |                    ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  let substring_length = substring.length()\n  while (start < string.length()) {\n    end = string.index_of(substring, start)\n    if (end == -1) {\n      break\n    }\n    count += 1\n    start = end + substring_length\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   let substring_length = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprjw51dem.rs:12:44\n   |\n12 |   let substring_length = substring.length()\n   |                                            ^ help: add `;` here\n13 |   while (start < string.length()) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmprjw51dem.rs:14:44\n   |\n14 |     end = string.index_of(substring, start)\n   |                                            ^ help: add `;` here\n15 |     if (end == -1) {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmprjw51dem.rs:18:15\n   |\n18 |     count += 1\n   |               ^ help: add `;` here\n19 |     start = end + substring_length\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprjw51dem.rs:13:9\n   |\n13 |   while (start < string.length()) {\n   |         ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (start < string.length()) {\n13 +   while start < string.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprjw51dem.rs:15:8\n   |\n15 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (end == -1) {\n15 +     if end == -1 {\n   | \n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmprjw51dem.rs:12:36\n   |\n12 |   let substr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i\n      while (j < string.len && substring.data[0] == string.data[j]) {\n        j += 1\n      }\n      if (j - i == substring.len) {\n        count += 1\n        i = j\n      }\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjg95b5ik.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjg95b5ik.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpjg95b5ik.rs:13:16\n   |\n13 |       let j = i\n   |                ^ help: add `;` here\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |       ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpjg95b5ik.rs:18:19\n   |\n18 |         count += 1\n   |                   ^ help: add `;` here\n19 |         i = j\n   |         - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjg95b5ik.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjg95b5ik.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjg95b5ik.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[0] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[0] == string.data[j]) {\n14 +       while j < string.len && substring.data[0] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjg95b5ik.rs:17:10\n   |\n17 |       if (j - i == substring.le",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.index(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpfk66w666.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfk66w666.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpfk66w666.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmpfk66w666.rs:12:20\n   |\n12 |     let i = string.index(substring, pos);\n   |                    ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n      pos += i;\n    } else {\n      pos += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpomv3_5gn.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpomv3_5gn.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpomv3_5gn.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpomv3_5gn.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpomv3_5gn.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpomv3_5gn.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpok0q91iu.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpok0q91iu.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpok0q91iu.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpok0q91iu.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpok0q91iu.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpok0q91iu.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpok0q91iu.rs:12:39\n   |\n12 |     if (string.data[pos] == subst",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  let end = 0;\n  while ((end = string.find(substring, start)) != -1) {\n    count += 1;\n    start = end + substring.length();\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpukd6hp7i.rs:12:9\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |         ^                                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while ((end = string.find(substring, start)) != -1) {\n12 +   while (end = string.find(substring, start)) != -1 {\n   | \n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpukd6hp7i.rs:12:24\n     |\n12   |   while ((end = string.find(substring, start)) != -1) {\n     |                        ^^^^ ---------  ----- supplied 2 arguments\n     |                        |\n     |                        expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:17\n   |\n11 |   let end = 0;\n   |             - expected due to this value\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpukd6hp7i.rs:12:51\n   |\n12 |   while ((end = string.find(substring, start)) != -1) {\n   |                                                   ^^ expected `()`, found integer\n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmpukd6hp7i.rs:14:29\n   |\n14 |     start = end + substring.length();\n   |                             ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i;\n    while (j < string.len && substring.contains(string.data[j])) {\n      j += 1;\n    }\n    if (j - i == substring.len) {\n      count += 1;\n    }\n    i = j;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpv7stpdj1.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpv7stpdj1.rs:13:11\n   |\n13 |     while (j < string.len && substring.contains(string.data[j])) {\n   |           ^                                                    ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < string.len && substring.contains(string.data[j])) {\n13 +     while j < string.len && substring.contains(string.data[j]) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpv7stpdj1.rs:16:8\n   |\n16 |     if (j - i == substring.len) {\n   |        ^                      ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j - i == substring.len) {\n16 +     if j - i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpv7stpdj1.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpv7stpdj1.rs:13:23\n   |\n13 |     while (j < string.len && substring.contains(string.data[j])) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < string.len() && substring.contains(string.data[j])) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpv7stpdj1.rs:13:56\n   |\n13 |     while (j < string.len && substring.contains(string.data[j])) {\n   |                                                        ^^^^ unknown field\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let i = string.find(substring, pos)\n    if i == -1 {\n      break\n    }\n    pos = i + substring.len\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp892u0phg.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp892u0phg.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp892u0phg.rs:12:40\n   |\n12 |     let i = string.find(substring, pos)\n   |                                        ^ help: add `;` here\n13 |     if i == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp892u0phg.rs:16:28\n   |\n16 |     pos = i + substring.len\n   |                            ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp892u0phg.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp892u0phg.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp892u0phg.rs:12:20\n     |\n12   |     let i = string.find(substring, pos)\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp892u0phg.rs:13:13\n   |\n13 |     if i == -1 {\n   |             ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  let substring_pos = 0\n  let substring_length = substring.length()\n  let string_length = string.length()\n  while (pos < string_length) {\n    if (string[pos] == substring[substring_pos]) {\n      if (substring_pos == substring_length - 1) {\n        count += 1\n        substring_pos = 0\n      } else {\n        substring_pos += 1\n      }\n    } else {\n      substring_pos = 0\n    }\n    pos += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxp22u0ya.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxp22u0ya.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   let substring_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxp22u0ya.rs:11:24\n   |\n11 |   let substring_pos = 0\n   |                        ^ help: add `;` here\n12 |   let substring_length = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxp22u0ya.rs:12:44\n   |\n12 |   let substring_length = substring.length()\n   |                                            ^ help: add `;` here\n13 |   let string_length = string.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpxp22u0ya.rs:13:38\n   |\n13 |   let string_length = string.length()\n   |                                      ^ help: add `;` here\n14 |   while (pos < string_length) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `substring_pos`\n  --> /tmp/tmpxp22u0ya.rs:17:19\n   |\n17 |         count += 1\n   |                   ^ help: add `;` here\n18 |         substring_pos = 0\n   |         ------------- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpxp22u0ya.rs:14:9\n   |\n14 |   while (pos < string_length) {\n   |         ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (pos < string_length) {\n14 +   while pos < string_length {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxp22u0ya.rs:15:8\n   |\n15 |     if (string[pos] == substring[substring_pos]) {\n   |        ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (string[pos] == substring[substring_pos]) {\n15 +     if string[pos] == substring[substring_pos] {",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  let substring_pos = 0\n  while (pos < string.len) {\n    if (substring_pos == substring.len) {\n      substring_pos = 0\n      count += 1\n    }\n    if (string[pos] == substring[substring_pos]) {\n      substring_pos += 1\n    } else {\n      substring_pos = 0\n    }\n    pos += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp768ir24s.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp768ir24s.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   let substring_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp768ir24s.rs:11:24\n   |\n11 |   let substring_pos = 0\n   |                        ^ help: add `;` here\n12 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp768ir24s.rs:14:24\n   |\n14 |       substring_pos = 0\n   |                        ^ help: add `;` here\n15 |       count += 1\n   |       ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp768ir24s.rs:12:9\n   |\n12 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < string.len) {\n12 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp768ir24s.rs:13:8\n   |\n13 |     if (substring_pos == substring.len) {\n   |        ^                              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (substring_pos == substring.len) {\n13 +     if substring_pos == substring.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp768ir24s.rs:17:8\n   |\n17 |     if (string[pos] == substring[substring_pos]) {\n   |        ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (string[pos] == substring[substring_pos]) {\n17 +     if string[pos] == substring[substring_pos] {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp768ir24s.rs:12:23\n   |\n12 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (start < string.len) {\n    end = string.find(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + substring.len\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9ji94zw6.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9ji94zw6.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp9ji94zw6.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (start < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp9ji94zw6.rs:13:40\n   |\n13 |     end = string.find(substring, start)\n   |                                        ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmp9ji94zw6.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + substring.len\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp9ji94zw6.rs:12:9\n   |\n12 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (start < string.len) {\n12 +   while start < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp9ji94zw6.rs:12:25\n   |\n12 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp9ji94zw6.rs:13:18\n     |\n13   |     end = string.find(substring, start)\n     |                  ^^^^ ---------  ----- supplied 2 arguments\n     |                  |\n     |                  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatch",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpok0q91iu.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpok0q91iu.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpok0q91iu.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpok0q91iu.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpok0q91iu.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpok0q91iu.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpok0q91iu.rs:12:39\n   |\n12 |     if (string.data[pos] == subst",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && substring[j] == string[i + j]) {\n      j += 1\n    }\n    if (j == substring.len) {\n      count += 1\n      j = 0\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb32lu6i4.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpb32lu6i4.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       j = 0\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:13:11\n   |\n13 |     while (j < substring.len && substring[j] == string[i + j]) {\n   |           ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && substring[j] == string[i + j]) {\n13 +     while j < substring.len && substring[j] == string[i + j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb32lu6i4.rs:16:8\n   |\n16 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j == substring.len) {\n16 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb32lu6i4.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = i;\n    while (j < string.len && substring.contains(string.data[j])) {\n      j += 1;\n    }\n    if (j > i) {\n      count += 1;\n    }\n    i = j;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpurngoh5r.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpurngoh5r.rs:13:11\n   |\n13 |     while (j < string.len && substring.contains(string.data[j])) {\n   |           ^                                                    ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < string.len && substring.contains(string.data[j])) {\n13 +     while j < string.len && substring.contains(string.data[j]) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpurngoh5r.rs:16:8\n   |\n16 |     if (j > i) {\n   |        ^     ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j > i) {\n16 +     if j > i {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpurngoh5r.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpurngoh5r.rs:13:23\n   |\n13 |     while (j < string.len && substring.contains(string.data[j])) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < string.len() && substring.contains(string.data[j])) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpurngoh5r.rs:13:56\n   |\n13 |     while (j < string.len && substring.contains(string.data[j])) {\n   |                                                        ^^^^ unknown field\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0609, E0615.\nFor more information about an erro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    if (string.data[i] == substring.data[0]) {\n      let j = i + 1;\n      while (j < string.len && substring.data[j] == string.data[j]) {\n        j += 1;\n      }\n      if (j == substring.len) {\n        count += 1;\n      }\n      i = j;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:12:8\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |        ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[i] == substring.data[0]) {\n12 +     if string.data[i] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nwyqhwd.rs:14:13\n   |\n14 |       while (j < string.len && substring.data[j] == string.data[j]) {\n   |             ^                                                     ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (j < string.len && substring.data[j] == string.data[j]) {\n14 +       while j < string.len && substring.data[j] == string.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nwyqhwd.rs:17:10\n   |\n17 |       if (j == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (j == substring.len) {\n17 +       if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:16\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp8nwyqhwd.rs:12:37\n   |\n12 |     if (string.data[i] == substring.data[0]) {\n   |                                     ^^^^ un",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (start < string.len) {\n    end = string.index(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + substring.len\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp3jpzxtkc.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp3jpzxtkc.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp3jpzxtkc.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (start < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp3jpzxtkc.rs:13:41\n   |\n13 |     end = string.index(substring, start)\n   |                                         ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmp3jpzxtkc.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + substring.len\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3jpzxtkc.rs:12:9\n   |\n12 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (start < string.len) {\n12 +   while start < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp3jpzxtkc.rs:12:25\n   |\n12 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp3jpzxtkc.rs:13:18\n   |\n13 |     end = string.index(substring, start)\n   |                  ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  let len = substring.length()\n  while (pos < string.length()) {\n    if (string.at(pos) == substring.at(0)) {\n      count += 1\n      pos += 1\n      while (pos < string.length() && substring.at(0) == string.at(pos)) {\n        pos += 1\n      }\n    } else {\n      pos += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpg46156ht.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpg46156ht.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   let len = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpg46156ht.rs:11:31\n   |\n11 |   let len = substring.length()\n   |                               ^ help: add `;` here\n12 |   while (pos < string.length()) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `pos`\n  --> /tmp/tmpg46156ht.rs:14:17\n   |\n14 |       count += 1\n   |                 ^ help: add `;` here\n15 |       pos += 1\n   |       --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpg46156ht.rs:15:15\n   |\n15 |       pos += 1\n   |               ^ help: add `;` here\n16 |       while (pos < string.length() && substring.at(0) == string.at(pos)) {\n   |       ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpg46156ht.rs:12:9\n   |\n12 |   while (pos < string.length()) {\n   |         ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < string.length()) {\n12 +   while pos < string.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpg46156ht.rs:13:8\n   |\n13 |     if (string.at(pos) == substring.at(0)) {\n   |        ^                                 ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (string.at(pos) == substring.at(0)) {\n13 +     if string.at(pos) == substring.at(0) {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpg46156ht.rs:16:13\n   |\n16 |       while (pos < string.length() && substring.at(0) == string.at(pos)) {\n   |             ^                                                          ^\n   |\nhelp: remove these parentheses\n   |\n16 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpok0q91iu.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpok0q91iu.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpok0q91iu.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                              ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpok0q91iu.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpok0q91iu.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpok0q91iu.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmpok0q91iu.rs:12:39\n   |\n12 |     if (string.data[pos] == subst",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  while (start < string.len) {\n    end = string.index(substring, start)\n    if end == -1 {\n      break\n    }\n    count += 1\n    start = end + substring.len\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp3jpzxtkc.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp3jpzxtkc.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp3jpzxtkc.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   while (start < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp3jpzxtkc.rs:13:41\n   |\n13 |     end = string.index(substring, start)\n   |                                         ^ help: add `;` here\n14 |     if end == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmp3jpzxtkc.rs:17:15\n   |\n17 |     count += 1\n   |               ^ help: add `;` here\n18 |     start = end + substring.len\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3jpzxtkc.rs:12:9\n   |\n12 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (start < string.len) {\n12 +   while start < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp3jpzxtkc.rs:12:25\n   |\n12 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp3jpzxtkc.rs:13:18\n   |\n13 |     end = string.index(substring, start)\n   |                  ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  while (start < string.len) {\n    let end = string.index_of(substring, start);\n    if (end == -1) {\n      break;\n    }\n    count += 1;\n    start = end + substring.len;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpw0yqwpn7.rs:11:9\n   |\n11 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (start < string.len) {\n11 +   while start < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw0yqwpn7.rs:13:8\n   |\n13 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (end == -1) {\n13 +     if end == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpw0yqwpn7.rs:11:25\n   |\n11 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0599]: no method named `index_of` found for struct `String` in the current scope\n  --> /tmp/tmpw0yqwpn7.rs:12:22\n   |\n12 |     let end = string.index_of(substring, start);\n   |                      ^^^^^^^^ method not found in `String`\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpw0yqwpn7.rs:17:29\n   |\n17 |     start = end + substring.len;\n   |                             ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n17 |     start = end + substring.len();\n   |                                ++\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let idx = string.find(substring, pos);\n    if (idx == -1) break;\n    pos = idx + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmpa50ka7o2.rs:13:20\n   |\n13 |     if (idx == -1) break;\n   |     --             ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (idx == -1) { break };\n   |                    +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa50ka7o2.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpa50ka7o2.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpa50ka7o2.rs:12:22\n     |\n12   |     let idx = string.find(substring, pos);\n     |                      ^^^^ ---------  --- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && string[i] == substring[j]) {\n      j += 1\n      i += 1\n    }\n    j = 0\n    i += 1\n    if (i == string.len) {\n      count += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpziqy5l_b.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpziqy5l_b.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpziqy5l_b.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpziqy5l_b.rs:14:13\n   |\n14 |       j += 1\n   |             ^ help: add `;` here\n15 |       i += 1\n   |       - unexpected token\n\nerror: expected `;`, found `i`\n  --> /tmp/tmpziqy5l_b.rs:17:10\n   |\n17 |     j = 0\n   |          ^ help: add `;` here\n18 |     i += 1\n   |     - unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpziqy5l_b.rs:18:11\n   |\n18 |     i += 1\n   |           ^ help: add `;` here\n19 |     if (i == string.len) {\n   |     -- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpziqy5l_b.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpziqy5l_b.rs:13:11\n   |\n13 |     while (j < substring.len && string[i] == substring[j]) {\n   |           ^                                              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && string[i] == substring[j]) {\n13 +     while j < substring.len && string[i] == substring[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpziqy5l_b.rs:19:8\n   |\n19 |     if (i == string.len) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (i == string.len) {\n19 +     if i ==",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  while (i < string.len) {\n    let j = i + substring.len\n    if (j > string.len) {\n      break\n    }\n    if (string.data[i..j] == substring) {\n      count += 1\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5r9vkxnj.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp5r9vkxnj.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp5r9vkxnj.rs:12:30\n   |\n12 |     let j = i + substring.len\n   |                              ^ help: add `;` here\n13 |     if (j > string.len) {\n   |     -- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp5r9vkxnj.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5r9vkxnj.rs:13:8\n   |\n13 |     if (j > string.len) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (j > string.len) {\n13 +     if j > string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5r9vkxnj.rs:16:8\n   |\n16 |     if (string.data[i..j] == substring) {\n   |        ^                              ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (string.data[i..j] == substring) {\n16 +     if string.data[i..j] == substring {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp5r9vkxnj.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp5r9vkxnj.rs:12:27\n   |\n12 |     let j = i + substring.len\n   |                           ^^^ method, not a field\n   |\nhelp: use parentheses to call t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let i = string.find(substring, pos);\n    if (i == -1) break;\n    pos = i + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `break`\n  --> /tmp/tmp4ydxf08m.rs:13:18\n   |\n13 |     if (i == -1) break;\n   |     --           ^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n13 |     if (i == -1) { break };\n   |                  +       +\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4ydxf08m.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4ydxf08m.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp4ydxf08m.rs:12:20\n     |\n12   |     let i = string.find(substring, pos);\n     |                    ^^^^ ---------  --- supplied 2 arguments\n     |                    |\n     |                    expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0061, E0615.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let index = 0;\n  while (index < string.len) {\n    if (string.data[index] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && string.data[index + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n        index += i;\n      } else {\n        index += 1;\n      }\n    } else {\n      index += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppe7jmnrq.rs:11:9\n   |\n11 |   while (index < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (index < string.len) {\n11 +   while index < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppe7jmnrq.rs:12:8\n   |\n12 |     if (string.data[index] == substring.data[0]) {\n   |        ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[index] == substring.data[0]) {\n12 +     if string.data[index] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppe7jmnrq.rs:14:13\n   |\n14 |       while (i < substring.len && string.data[index + i] == substring.data[i]) {\n   |             ^                                                                ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && string.data[index + i] == substring.data[i]) {\n14 +       while i < substring.len && string.data[index + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppe7jmnrq.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmppe7jmnrq.rs:11:25\n   |\n11 |   while (index < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (index < string.len()) {\n   |                            ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmppe7jmnrq.rs:12:16\n   |\n12 |     if (string.data[index] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmppe7jmnrq.rs:12:41\n   |\n12 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let start = 0\n  let end = 0\n  let substring_length = substring.length()\n  while (start < string.length()) {\n    end = string.index_of(substring, start)\n    if (end == -1) {\n      break\n    }\n    count += 1\n    start = end + substring_length\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let start = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:10:16\n   |\n10 |   let start = 0\n   |                ^ help: add `;` here\n11 |   let end = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmprjw51dem.rs:11:14\n   |\n11 |   let end = 0\n   |              ^ help: add `;` here\n12 |   let substring_length = substring.length()\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmprjw51dem.rs:12:44\n   |\n12 |   let substring_length = substring.length()\n   |                                            ^ help: add `;` here\n13 |   while (start < string.length()) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmprjw51dem.rs:14:44\n   |\n14 |     end = string.index_of(substring, start)\n   |                                            ^ help: add `;` here\n15 |     if (end == -1) {\n   |     -- unexpected token\n\nerror: expected `;`, found `start`\n  --> /tmp/tmprjw51dem.rs:18:15\n   |\n18 |     count += 1\n   |               ^ help: add `;` here\n19 |     start = end + substring_length\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprjw51dem.rs:13:9\n   |\n13 |   while (start < string.length()) {\n   |         ^                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (start < string.length()) {\n13 +   while start < string.length() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprjw51dem.rs:15:8\n   |\n15 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (end == -1) {\n15 +     if end == -1 {\n   | \n\nerror[E0599]: no method named `length` found for struct `String` in the current scope\n  --> /tmp/tmprjw51dem.rs:12:36\n   |\n12 |   let substr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    if (string.data[pos] == substring.data[0]) {\n      let i = 1;\n      while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n        i += 1;\n      }\n      if (i == substring.len) {\n        count += 1;\n      }\n    }\n    pos += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:12:8\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |        ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (string.data[pos] == substring.data[0]) {\n12 +     if string.data[pos] == substring.data[0] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplgnj2mrz.rs:14:13\n   |\n14 |       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n   |             ^                                                                                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       while (i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i]) {\n14 +       while i < substring.len && pos + i < string.len && string.data[pos + i] == substring.data[i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplgnj2mrz.rs:17:10\n   |\n17 |       if (i == substring.len) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (i == substring.len) {\n17 +       if i == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmplgnj2mrz.rs:12:16\n   |\n12 |     if (string.data[pos] == substring.data[0]) {\n   |                ^^^^ unknown field\n\nerror[E0609]: no field `da",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let start = 0;\n  while (start < string.len) {\n    let end = string.find(substring, start);\n    if (end == -1) {\n      break;\n    }\n    count += 1;\n    start = end + substring.len;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp05wrfxet.rs:11:9\n   |\n11 |   while (start < string.len) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (start < string.len) {\n11 +   while start < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp05wrfxet.rs:13:8\n   |\n13 |     if (end == -1) {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (end == -1) {\n13 +     if end == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp05wrfxet.rs:11:25\n   |\n11 |   while (start < string.len) {\n   |                         ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (start < string.len()) {\n   |                            ++\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp05wrfxet.rs:12:22\n     |\n12   |     let end = string.find(substring, start);\n     |                      ^^^^ ---------  ----- supplied 2 arguments\n     |                      |\n     |                      expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp05wrfxet.rs:13:16\n   |\n13 |     if (end == -1) {\n   |                ^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |     if (end == Some(-1)) {\n   |                +++++  +\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp05wrfxet.rs:17:29\n   |\n17 |     start = end + substring.len;\n   |                             ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n17 |     start = end + substring.len();\n   |                                ++\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061,",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let i = 0\n  let j = 0\n  while (i < string.len) {\n    while (j < substring.len && substring[j] == string[i + j]) {\n      j += 1\n    }\n    if (j == substring.len) {\n      count += 1\n      j = 0\n    }\n    i += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let i = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb32lu6i4.rs:10:12\n   |\n10 |   let i = 0\n   |            ^ help: add `;` here\n11 |   let j = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb32lu6i4.rs:11:12\n   |\n11 |   let j = 0\n   |            ^ help: add `;` here\n12 |   while (i < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `j`\n  --> /tmp/tmpb32lu6i4.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       j = 0\n   |       - unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:12:9\n   |\n12 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < string.len) {\n12 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb32lu6i4.rs:13:11\n   |\n13 |     while (j < substring.len && substring[j] == string[i + j]) {\n   |           ^                                                  ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && substring[j] == string[i + j]) {\n13 +     while j < substring.len && substring[j] == string[i + j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb32lu6i4.rs:16:8\n   |\n16 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (j == substring.len) {\n16 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpb32lu6i4.rs:12:21\n   |\n12 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n12 |   while (i < string.len()) {\n   |                    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let pos = 0;\n  while (pos < string.len) {\n    let next_pos = string.index(substring, pos);\n    if (next_pos == -1) {\n      break;\n    }\n    pos = next_pos + substring.len;\n    count += 1;\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4wbyaayu.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4wbyaayu.rs:13:8\n   |\n13 |     if (next_pos == -1) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (next_pos == -1) {\n13 +     if next_pos == -1 {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4wbyaayu.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp4wbyaayu.rs:12:27\n   |\n12 |     let next_pos = string.index(substring, pos);\n   |                           ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp4wbyaayu.rs:16:32\n   |\n16 |     pos = next_pos + substring.len;\n   |                                ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n16 |     pos = next_pos + substring.len();\n   |                                   ++\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0599, E0615.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  while (pos < string.len) {\n    let pos2 = substring.index(string.data[pos])\n    if pos2 == -1 {\n      break\n    }\n    pos += pos2\n    count += 1\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp1d5tqu5o.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp1d5tqu5o.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp1d5tqu5o.rs:12:49\n   |\n12 |     let pos2 = substring.index(string.data[pos])\n   |                                                 ^ help: add `;` here\n13 |     if pos2 == -1 {\n   |     -- unexpected token\n\nerror: expected `;`, found `count`\n  --> /tmp/tmp1d5tqu5o.rs:16:16\n   |\n16 |     pos += pos2\n   |                ^ help: add `;` here\n17 |     count += 1\n   |     ----- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1d5tqu5o.rs:11:9\n   |\n11 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (pos < string.len) {\n11 +   while pos < string.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmp1d5tqu5o.rs:11:23\n   |\n11 |   while (pos < string.len) {\n   |                       ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (pos < string.len()) {\n   |                          ++\n\nerror[E0599]: no method named `index` found for struct `String` in the current scope\n  --> /tmp/tmp1d5tqu5o.rs:12:26\n   |\n12 |     let pos2 = substring.index(string.data[pos])\n   |                          ^^^^^ method not found in `String`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0609]: no field `data` on type `String`\n  --> /tmp/tmp1d5tqu5o.rs:12:39\n   |\n12 |     let pos2 = substring.index(string.data[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0;\n  let i = 0;\n  while (i < string.len) {\n    let j = 0;\n    while (j < substring.len && i + j < string.len) {\n      if (string.data[i + j] != substring.data[j]) {\n        break;\n      }\n      j += 1;\n    }\n    if (j == substring.len) {\n      count += 1;\n      i += substring.len;\n    } else {\n      i += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpw07b6_q9.rs:11:9\n   |\n11 |   while (i < string.len) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < string.len) {\n11 +   while i < string.len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpw07b6_q9.rs:13:11\n   |\n13 |     while (j < substring.len && i + j < string.len) {\n   |           ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n13 -     while (j < substring.len && i + j < string.len) {\n13 +     while j < substring.len && i + j < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw07b6_q9.rs:14:10\n   |\n14 |       if (string.data[i + j] != substring.data[j]) {\n   |          ^                                       ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (string.data[i + j] != substring.data[j]) {\n14 +       if string.data[i + j] != substring.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw07b6_q9.rs:19:8\n   |\n19 |     if (j == substring.len) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (j == substring.len) {\n19 +     if j == substring.len {\n   | \n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpw07b6_q9.rs:11:21\n   |\n11 |   while (i < string.len) {\n   |                     ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n11 |   while (i < string.len()) {\n   |                        ++\n\nerror[E0615]: attempted to take value of method `len` on type `String`\n  --> /tmp/tmpw07b6_q9.rs:13:26\n   |\n13 |     while (j < substring.len && i + j < string.len) {\n   |                          ^^^ method, not a field\n   |\nhelp: use parentheses to call the method\n   |\n13 |     while (j < substring.len() && i + j < string.len) {\n   |                             ++\n\nerror[E0615]: attempted to take value ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Find how many times a given substring can be found in the original string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"), String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n  let count = 0\n  let pos = 0\n  let substring_pos = 0\n  while (pos < string.len) {\n    if (substring_pos < substring.len && substring[substring_pos] == string[pos]) {\n      substring_pos += 1\n      pos += 1\n      if (substring_pos == substring.len) {\n        count += 1\n        substring_pos = 0\n      }\n    } else {\n      substring_pos = 0\n      pos += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"john\")), 1);\n}\n",
      "timestamp": 1664292764,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp3vq3km9p.rs:9:16\n   |\n9  |   let count = 0\n   |                ^ help: add `;` here\n10 |   let pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp3vq3km9p.rs:10:14\n   |\n10 |   let pos = 0\n   |              ^ help: add `;` here\n11 |   let substring_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp3vq3km9p.rs:11:24\n   |\n11 |   let substring_pos = 0\n   |                        ^ help: add `;` here\n12 |   while (pos < string.len) {\n   |   ----- unexpected token\n\nerror: expected `;`, found `pos`\n  --> /tmp/tmp3vq3km9p.rs:14:25\n   |\n14 |       substring_pos += 1\n   |                         ^ help: add `;` here\n15 |       pos += 1\n   |       --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp3vq3km9p.rs:15:15\n   |\n15 |       pos += 1\n   |               ^ help: add `;` here\n16 |       if (substring_pos == substring.len) {\n   |       -- unexpected token\n\nerror: expected `;`, found `substring_pos`\n  --> /tmp/tmp3vq3km9p.rs:17:19\n   |\n17 |         count += 1\n   |                   ^ help: add `;` here\n18 |         substring_pos = 0\n   |         ------------- unexpected token\n\nerror: expected `;`, found `pos`\n  --> /tmp/tmp3vq3km9p.rs:21:24\n   |\n21 |       substring_pos = 0\n   |                        ^ help: add `;` here\n22 |       pos += 1\n   |       --- unexpected token\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3vq3km9p.rs:12:9\n   |\n12 |   while (pos < string.len) {\n   |         ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (pos < string.len) {\n12 +   while pos < string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3vq3km9p.rs:13:8\n   |\n13 |     if (substring_pos < substring.len && substring[substring_pos] == string[pos]) {\n   |        ^                                                                        ^\n   |\nhe",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}