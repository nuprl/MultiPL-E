{
  "name": "HumanEval_108_count_nums",
  "language": "rs",
  "prompt": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n",
  "tests": "}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(x => x > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpd_trzk8s.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(x => x > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `3`,\n right: `5`', /tmp/tmpnfitzi8v.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpy8vjhqfd.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(x => x > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpd_trzk8s.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(x => x > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpy0m1lq8b.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp6k5m_n8b.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp6k5m_n8b.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpy0m1lq8b.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(i => i > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpn5wu13ax.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(i => i > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    let num = i;\n    if num < 0 {\n      num = -num;\n    }\n    sum += num % 10;\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpb7ttgewf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    if sum > 0 {\n        return arr.len() + 1;\n    } else {\n        return 0;\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmph_fr6lef.rs:21:16\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |         return arr.len() + 1;\n   |                ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |         return (arr.len() + 1).try_into().unwrap();\n   |                +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else if i.is_neg_digit() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpx992s53t.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpx992s53t.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror[E0599]: no method named `is_neg_digit` found for type `isize` in the current scope\n  --> /tmp/tmpx992s53t.rs:16:17\n   |\n16 |     } else if i.is_neg_digit() {\n   |                 ^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpx992s53t.rs:17:31\n   |\n17 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n17 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpk2b3bnpj.rs:20:10\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n20 |   return sum > 0;\n   |          ^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(x => x > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpd_trzk8s.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(x => x > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return arr.len();\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp513cw97l.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    let num = i.to_int();\n    if num < 0 {\n      sum += 1;\n    } else {\n      sum += num.count_digits();\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_int` found for type `isize` in the current scope\n  --> /tmp/tmph73tg8v_.rs:14:17\n   |\n14 |     let num = i.to_int();\n   |                 ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i.to_int() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_int` found for type `isize` in the current scope\n  --> /tmp/tmpg8nev5xm.rs:14:10\n   |\n14 |     if i.to_int() > 0 {\n   |          ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i, i + 1))\n    } else {\n      count += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpr6e8quge.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i, i + 1))\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i, i + 1))\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return arr.len();\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp513cw97l.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.neg_offset() + 1, arr.len()));\n    } else {\n      count += count_nums(arr.slice(0, i.neg_offset()));\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp6ozugxbw.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp6ozugxbw.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset() + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.neg_offset() + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror[E0599]: no method named `neg_offset` found for type `isize` in the current scope\n  --> /tmp/tmp6ozugxbw.rs:15:39\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset() + 1, arr.len()));\n   |                                       ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp6ozugxbw.rs:17:31\n   |\n17 |       count += count_nums(arr.slice(0, i.neg_offset()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n17 |       count += count_nums(arr.as_slice(0, i.neg_offset()));\n   |                               ~~~~~~~~\n\nerror[E0599]: no method named `neg_offset` found for type `isize` in the current scope\n  --> /tmp/tmp6ozugxbw.rs:17:42\n   |\n17 |       count += count_nums(arr.slice(0, i.neg_offset()));\n   |                                     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpmzpjlq_o.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpqnyjlu98.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? arr.len() : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `arr`\n  --> /tmp/tmp1cbw3bvl.rs:20:20\n   |\n20 |   return sum > 0 ? arr.len() : 0;\n   |                    ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else if i.is_neg_digit() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpn3l5ye6b.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn3l5ye6b.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0599]: no method named `is_neg_digit` found for type `isize` in the current scope\n  --> /tmp/tmpn3l5ye6b.rs:16:17\n   |\n16 |     } else if i.is_neg_digit() {\n   |                 ^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn3l5ye6b.rs:17:27\n   |\n17 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpy8vjhqfd.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return arr.len();\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp513cw97l.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for i in arr {\n        if i.to_i() > 0 {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpqp95ust9.rs:14:14\n   |\n14 |         if i.to_i() > 0 {\n   |              ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmp6qhl9zco.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i.abs() - 1;\n    } else {\n      sum += i;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i.abs() - 1;\n   |       ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    if sum > 0 {\n        return 1 + count_nums(arr.filter(i => i > 0));\n    } else {\n        return 0;\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp81culbep.rs:21:44\n   |\n21 |         return 1 + count_nums(arr.filter(i => i > 0));\n   |                                            ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.drop(1));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmp2lxte8cr.rs:21:31\n   |\n21 |     return 1 + count_nums(arr.drop(1));\n   |                           ----^^^^---\n   |                           |   |\n   |                           |   explicit destructor calls not allowed\n   |                           help: consider using `drop` function: `drop(arr)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp2lxte8cr.rs:21:31\n    |\n21  |     return 1 + count_nums(arr.drop(1));\n    |                               ^^^^ - supplied 1 argument\n    |                               |\n    |                               expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2lxte8cr.rs:21:27\n   |\n21 |     return 1 + count_nums(arr.drop(1));\n   |                           ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmp2lxte8cr.rs:21:31\n   |\n21 |     return 1 + count_nums(arr.drop(1));\n   |                           --- ^^^^ this call modifies `arr` in-place\n   |                           |\n   |                           you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpy8vjhqfd.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpy0m1lq8b.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_int() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_int` found for type `isize` in the current scope\n  --> /tmp/tmp822a5j0k.rs:14:10\n   |\n14 |     if i.to_int() > 0 {\n   |          ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpk2b3bnpj.rs:20:10\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n20 |   return sum > 0;\n   |          ^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    let num = i;\n    if num < 0 {\n      num = -num;\n      sum += 1;\n    }\n    let digits = num.to_string();\n    for j in 1..digits.len() {\n      sum += 1;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "warning: unused variable: `j`\n  --> /tmp/tmp_kf7tsdh.rs:20:9\n   |\n20 |     for j in 1..digits.len() {\n   |         ^ help: if this is intentional, prefix it with an underscore: `_j`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `num`\n  --> /tmp/tmp_kf7tsdh.rs:16:7\n   |\n14 |     let num = i;\n   |         ---\n   |         |\n   |         first assignment to `num`\n   |         help: consider making this binding mutable: `mut num`\n15 |     if num < 0 {\n16 |       num = -num;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp_kf7tsdh.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += 1;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp_kf7tsdh.rs:21:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n21 |       sum += 1;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp6k5m_n8b.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(x => x > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpd_trzk8s.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(x => x > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpk2b3bnpj.rs:20:10\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n20 |   return sum > 0;\n   |          ^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpzlk20y30.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpzlk20y30.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i % 10;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return arr.len();\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp513cw97l.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp56z2hwzz.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i - 9;\n   |       ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp56z2hwzz.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i.to_int() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_int` found for type `isize` in the current scope\n  --> /tmp/tmpg8nev5xm.rs:14:10\n   |\n14 |     if i.to_int() > 0 {\n   |          ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i.abs() - 1;\n    } else {\n      sum += i;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i.abs() - 1;\n   |       ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += i - 9;\n        } else {\n            sum += i;\n        }\n    }\n    return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpmd8gne27.rs:20:22\n   |\n20 |     return sum > 0 ? 1 : 0;\n   |                      ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_int() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_int` found for type `isize` in the current scope\n  --> /tmp/tmp822a5j0k.rs:14:10\n   |\n14 |     if i.to_int() > 0 {\n   |          ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpdz71z2ti.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len));\n   |                               ~~~~~~~~\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpdz71z2ti.rs:15:48\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len));\n   |                                                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                                                   ++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0616.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmphern1pys.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmphern1pys.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += 1;\n    } else if i > 0 {\n      count += 1;\n      let sum = 0;\n      while i > 0 {\n        sum += i % 10;\n        i /= 10;\n      }\n      if sum > 0 {\n        count += 1;\n      }\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmgfhxqef.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmgfhxqef.rs:17:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n17 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmgfhxqef.rs:20:9\n   |\n18 |       let sum = 0;\n   |           ---\n   |           |\n   |           first assignment to `sum`\n   |           help: consider making this binding mutable: `mut sum`\n19 |       while i > 0 {\n20 |         sum += i % 10;\n   |         ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpmgfhxqef.rs:21:9\n   |\n13 |   for i in arr {\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n21 |         i /= 10;\n   |         ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpmgfhxqef.rs:24:9\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n24 |         count += 1;\n   |         ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i.abs()\n    } else {\n      sum += i\n    }\n  }\n  if sum > 0 {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp__21jjwt.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i.abs()\n   |       ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp__21jjwt.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? arr.len() : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `arr`\n  --> /tmp/tmpqqtd5kin.rs:20:20\n   |\n20 |   return sum > 0 ? arr.len() : 0;\n   |                    ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return arr.len();\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp513cw97l.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for i in arr {\n        if i.is_neg() {\n            count += count_nums(arr.slice(i.abs()));\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpny4bbsx9.rs:14:14\n   |\n14 |         if i.is_neg() {\n   |              ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpny4bbsx9.rs:15:37\n   |\n15 |             count += count_nums(arr.slice(i.abs()));\n   |                                     ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |             count += count_nums(arr.as_slice(i.abs()));\n   |                                     ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        sum += i;\n    }\n    let count = 0;\n    for i in arr {\n        if i > 0 && sum % i == 0 {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmptasn9yyn.rs:14:9\n   |\n12 |     let sum = 0;\n   |         ---\n   |         |\n   |         first assignment to `sum`\n   |         help: consider making this binding mutable: `mut sum`\n13 |     for i in arr {\n14 |         sum += i;\n   |         ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `arr`\n   --> /tmp/tmptasn9yyn.rs:17:14\n    |\n11  | fn count_nums(arr: Vec<isize>) -> isize {\n    |               --- move occurs because `arr` has type `Vec<isize>`, which does not implement the `Copy` trait\n12  |     let sum = 0;\n13  |     for i in arr {\n    |              --- `arr` moved due to this implicit call to `.into_iter()`\n...\n17  |     for i in arr {\n    |              ^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `arr`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n13  |     for i in &arr {\n    |              +\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmptasn9yyn.rs:19:13\n   |\n16 |     let count = 0;\n   |         -----\n   |         |\n   |         first assignment to `count`\n   |         help: consider making this binding mutable: `mut count`\n...\n19 |             count += 1;\n   |             ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpmzpjlq_o.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    if sum > 0 {\n        return arr.len() - 1;\n    } else {\n        return 0;\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpa0bg6r7x.rs:21:16\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |         return arr.len() - 1;\n   |                ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |         return (arr.len() - 1).try_into().unwrap();\n   |                +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpy0m1lq8b.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else if i.is_neg_num() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpg38lkc48.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg38lkc48.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0599]: no method named `is_neg_num` found for type `isize` in the current scope\n  --> /tmp/tmpg38lkc48.rs:16:17\n   |\n16 |     } else if i.is_neg_num() {\n   |                 ^^^^^^^^^^ help: there is an associated function with a similar name: `signum`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg38lkc48.rs:17:27\n   |\n17 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpqnyjlu98.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpy0m1lq8b.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? arr.len() : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `arr`\n  --> /tmp/tmp1cbw3bvl.rs:20:20\n   |\n20 |   return sum > 0 ? arr.len() : 0;\n   |                    ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpk2b3bnpj.rs:20:10\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n20 |   return sum > 0;\n   |          ^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_int() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_int` found for type `isize` in the current scope\n  --> /tmp/tmp822a5j0k.rs:14:10\n   |\n14 |     if i.to_int() > 0 {\n   |          ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for i in arr {\n        if i.is_neg() {\n            count += count_nums(arr.slice(i.abs()));\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpny4bbsx9.rs:14:14\n   |\n14 |         if i.is_neg() {\n   |              ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpny4bbsx9.rs:15:37\n   |\n15 |             count += count_nums(arr.slice(i.abs()));\n   |                                     ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |             count += count_nums(arr.as_slice(i.abs()));\n   |                                     ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2ydd2zha.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for i in arr {\n        if i.is_neg() {\n            count += count_nums(arr.slice(i.abs()));\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpny4bbsx9.rs:14:14\n   |\n14 |         if i.is_neg() {\n   |              ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpny4bbsx9.rs:15:37\n   |\n15 |             count += count_nums(arr.slice(i.abs()));\n   |                                     ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |             count += count_nums(arr.as_slice(i.abs()));\n   |                                     ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return arr.len();\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp513cw97l.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpy8vjhqfd.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp6k5m_n8b.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else if i.is_neg_digit() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpn3l5ye6b.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn3l5ye6b.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0599]: no method named `is_neg_digit` found for type `isize` in the current scope\n  --> /tmp/tmpn3l5ye6b.rs:16:17\n   |\n16 |     } else if i.is_neg_digit() {\n   |                 ^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn3l5ye6b.rs:17:27\n   |\n17 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(vec![-i])\n    } else {\n      count += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpjqz4aimb.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += count_nums(vec![-i])\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpjqz4aimb.rs:17:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n17 |       count += 1\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    if sum > 0 {\n        return arr.len;\n    } else {\n        return 0;\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpnug3o9bu.rs:21:20\n   |\n21 |         return arr.len;\n   |                    ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |         return arr.len();\n   |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnug3o9bu.rs:21:16\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |         return arr.len;\n   |                ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |         return arr.len.try_into().unwrap();\n   |                       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n    } else {\n      count += count_nums(arr.slice(i.offset(), i.offset() + i.len()));\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpp4q_qp4c.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpp4q_qp4c.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                               ~~~~~~~~\n\nerror[E0599]: no method named `neg_offset` found for type `isize` in the current scope\n  --> /tmp/tmpp4q_qp4c.rs:15:39\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                                       ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `neg_offset` found for type `isize` in the current scope\n  --> /tmp/tmpp4q_qp4c.rs:15:55\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                                                       ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `neg_len` found for type `isize` in the current scope\n  --> /tmp/tmpp4q_qp4c.rs:15:72\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                                                                        ^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpp4q_qp4c.rs:17:31\n   |\n17 |       count += count_nums(arr.slice(i.offset(), i.offs",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    if sum > 0 {\n        return arr.len() - sum;\n    } else {\n        return 0;\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpswtbnx6u.rs:21:28\n   |\n21 |         return arr.len() - sum;\n   |                            ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpswtbnx6u.rs:21:16\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |         return arr.len() - sum;\n   |                ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |         return (arr.len() - sum).try_into().unwrap();\n   |                +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpswtbnx6u.rs:21:26\n   |\n21 |         return arr.len() - sum;\n   |                          ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else if i.is_neg_digit() {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmphl9k_0r2.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphl9k_0r2.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0599]: no method named `is_neg_digit` found for type `isize` in the current scope\n  --> /tmp/tmphl9k_0r2.rs:16:17\n   |\n16 |     } else if i.is_neg_digit() {\n   |                 ^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `3`,\n right: `5`', /tmp/tmpnfitzi8v.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpmzpjlq_o.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(x => x > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpd_trzk8s.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(x => x > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpqnyjlu98.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpy8vjhqfd.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_int() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_int` found for type `isize` in the current scope\n  --> /tmp/tmp822a5j0k.rs:14:10\n   |\n14 |     if i.to_int() > 0 {\n   |          ^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp6k5m_n8b.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? arr.len() : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `arr`\n  --> /tmp/tmp1cbw3bvl.rs:20:20\n   |\n20 |   return sum > 0 ? arr.len() : 0;\n   |                    ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(x => x > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpd_trzk8s.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(x => x > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for i in arr {\n        if i.is_neg() {\n            count += count_nums(arr.slice(i.abs()));\n        } else {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpny4bbsx9.rs:14:14\n   |\n14 |         if i.is_neg() {\n   |              ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpny4bbsx9.rs:15:37\n   |\n15 |             count += count_nums(arr.slice(i.abs()));\n   |                                     ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |             count += count_nums(arr.as_slice(i.abs()));\n   |                                     ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpqnyjlu98.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpy0m1lq8b.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else if i.is_neg_num() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpg38lkc48.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg38lkc48.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror[E0599]: no method named `is_neg_num` found for type `isize` in the current scope\n  --> /tmp/tmpg38lkc48.rs:16:17\n   |\n16 |     } else if i.is_neg_num() {\n   |                 ^^^^^^^^^^ help: there is an associated function with a similar name: `signum`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg38lkc48.rs:17:27\n   |\n17 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(vec![-i]);\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `3`,\n right: `0`', /tmp/tmpqn8kcncd.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpy0m1lq8b.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpqnyjlu98.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    let num = i;\n    if num < 0 {\n      num = -num;\n    }\n    sum += num % 10;\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpb7ttgewf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i >= 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', /tmp/tmpx6yytuhk.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmprh0u0_wp.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprh0u0_wp.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpy8vjhqfd.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(x => x > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpd_trzk8s.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(x => x > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(vec![-i])\n    } else {\n      count += 1\n    }\n  }\n  return count\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpjqz4aimb.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += count_nums(vec![-i])\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpjqz4aimb.rs:17:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n17 |       count += 1\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp6k5m_n8b.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    let num = i;\n    if num < 0 {\n      num = -num;\n    }\n    sum += num % 10;\n  }\n  return sum > 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp8bvr_5p4.rs:20:10\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n20 |   return sum > 0;\n   |          ^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpqnyjlu98.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? arr.len() : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `arr`\n  --> /tmp/tmp1cbw3bvl.rs:20:20\n   |\n20 |   return sum > 0 ? arr.len() : 0;\n   |                    ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i < 0 {\n      count += count_nums(arr.slice(i + 1, arr.len()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2ydd2zha.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i + 1, arr.len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i + 1, arr.len()));\n   |                               ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    let num = i.to_i();\n    if num < 0 {\n      sum += 1;\n    } else {\n      sum += num.to_i();\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpjf1uqs5r.rs:14:17\n   |\n14 |     let num = i.to_i();\n   |                 ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(i => i > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpn5wu13ax.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(i => i > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? arr.len() : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `arr`\n  --> /tmp/tmp1cbw3bvl.rs:20:20\n   |\n20 |   return sum > 0 ? arr.len() : 0;\n   |                    ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() + 1;\n  } else {\n    return arr.len();\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp513cw97l.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() + 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() + 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i.abs() - 1;\n    } else {\n      sum += i;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i.abs() - 1;\n   |       ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `3`,\n right: `5`', /tmp/tmpnfitzi8v.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n    } else {\n      count += count_nums(arr.slice(i.offset(), i.offset() + i.len()));\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpg3qrqhxl.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpg3qrqhxl.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                               ~~~~~~~~\n\nerror[E0599]: no method named `neg_offset` found for type `isize` in the current scope\n  --> /tmp/tmpg3qrqhxl.rs:15:39\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                                       ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `neg_offset` found for type `isize` in the current scope\n  --> /tmp/tmpg3qrqhxl.rs:15:55\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                                                       ^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `neg_len` found for type `isize` in the current scope\n  --> /tmp/tmpg3qrqhxl.rs:15:72\n   |\n15 |       count += count_nums(arr.slice(i.neg_offset(), i.neg_offset() + i.neg_len()));\n   |                                                                        ^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpg3qrqhxl.rs:17:31\n   |\n17 |       count += count_nums(arr.slice(i.offset(), i.offs",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += i - 9;\n        } else {\n            sum += i;\n        }\n    }\n    return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpmd8gne27.rs:20:22\n   |\n20 |     return sum > 0 ? 1 : 0;\n   |                      ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpqnyjlu98.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let sum = 0;\n    for i in arr {\n        if i < 0 {\n            sum += i;\n        } else {\n            sum += i % 10;\n        }\n    }\n    if sum > 0 {\n        return arr.len;\n    } else {\n        return 0;\n    }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpnug3o9bu.rs:21:20\n   |\n21 |         return arr.len;\n   |                    ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |         return arr.len();\n   |                       ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnug3o9bu.rs:21:16\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |         return arr.len;\n   |                ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |         return arr.len.try_into().unwrap();\n   |                       ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i < 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmp9p1o6chb.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.to_i() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `to_i` found for type `isize` in the current scope\n  --> /tmp/tmpy0m1lq8b.rs:14:10\n   |\n14 |     if i.to_i() > 0 {\n   |          ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - 1;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpmzpjlq_o.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - 1;\n   |            ^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - 1).try_into().unwrap();\n   |            +             +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i - 9;\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpz3z9y8kf.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i.abs() - 1\n    } else {\n      sum += i\n    }\n  }\n  return sum\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpm2mlgk6x.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i.abs() - 1\n   |       ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpm2mlgk6x.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2nfyw1df.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(arr.slice(i.abs()));\n    } else if i.is_neg_digit() {\n      count += count_nums(arr.slice(i.abs()));\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmpx992s53t.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpx992s53t.rs:15:31\n   |\n15 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror[E0599]: no method named `is_neg_digit` found for type `isize` in the current scope\n  --> /tmp/tmpx992s53t.rs:16:17\n   |\n16 |     } else if i.is_neg_digit() {\n   |                 ^^^^^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpx992s53t.rs:17:31\n   |\n17 |       count += count_nums(arr.slice(i.abs()));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n17 |       count += count_nums(arr.as_slice(i.abs()));\n   |                               ~~~~~~~~\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.drop(1));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmp2lxte8cr.rs:21:31\n   |\n21 |     return 1 + count_nums(arr.drop(1));\n   |                           ----^^^^---\n   |                           |   |\n   |                           |   explicit destructor calls not allowed\n   |                           help: consider using `drop` function: `drop(arr)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp2lxte8cr.rs:21:31\n    |\n21  |     return 1 + count_nums(arr.drop(1));\n    |                               ^^^^ - supplied 1 argument\n    |                               |\n    |                               expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2lxte8cr.rs:21:27\n   |\n21 |     return 1 + count_nums(arr.drop(1));\n   |                           ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmp2lxte8cr.rs:21:31\n   |\n21 |     return 1 + count_nums(arr.drop(1));\n   |                           --- ^^^^ this call modifies `arr` in-place\n   |                           |\n   |                           you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.abs() > 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2`,\n right: `0`', /tmp/tmpk_3yn62_.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n    let mut count = 0;\n    for i in arr {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `3`,\n right: `5`', /tmp/tmpkqn5inez.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return 1 + count_nums(arr.filter(x => x > 0));\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpd_trzk8s.rs:21:40\n   |\n21 |     return 1 + count_nums(arr.filter(x => x > 0));\n   |                                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i.abs() - 1;\n    } else {\n      sum += i;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i.abs() - 1;\n   |       ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  return sum > 0 ? 1 : 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n  --> /tmp/tmpgx6dr2pu.rs:20:20\n   |\n20 |   return sum > 0 ? 1 : 0;\n   |                    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let mut count = 0;\n  for i in arr {\n    if i.is_neg() {\n      count += count_nums(i.abs());\n    } else {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_neg` found for type `isize` in the current scope\n  --> /tmp/tmp9gyx__8z.rs:14:10\n   |\n14 |     if i.is_neg() {\n   |          ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9gyx__8z.rs:15:27\n   |\n15 |       count += count_nums(i.abs());\n   |                           ^^^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i.abs();\n    } else {\n      sum += i;\n    }\n  }\n  return sum > 0;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpq3cfw6ve.rs:20:10\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n20 |   return sum > 0;\n   |          ^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i.abs() - 1;\n    } else {\n      sum += i;\n    }\n  }\n  return sum;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:15:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n15 |       sum += i.abs() - 1;\n   |       ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp4oj9hi3e.rs:17:7\n   |\n12 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n...\n17 |       sum += i;\n   |       ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let count = 0;\n  for i in arr {\n    if i >= 0 {\n      count += 1;\n    }\n  }\n  return count;\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpx1v5o7fh.rs:15:7\n   |\n12 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n15 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len() - sum;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:24\n   |\n21 |     return arr.len() - sum;\n   |                        ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2pvg6_6.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len() - sum;\n   |            ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return (arr.len() - sum).try_into().unwrap();\n   |            +               +++++++++++++++++++++\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpl2pvg6_6.rs:21:22\n   |\n21 |     return arr.len() - sum;\n   |                      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function count_nums which takes a vector of integers and returns\n/// the number of elements which has a sum of digits > 0.\n/// If a number is negative, then its first signed digit will be negative:\n/// e.g. -123 has signed digits -1, 2, and 3.\n/// >>> count_nums(vec![])\n/// 0\n/// >>> count_nums(vec![-1, 11, -11])\n/// 1\n/// >>> count_nums(vec![1, 1, 2])\n/// 3\nfn count_nums(arr: Vec<isize>) -> isize {\n  let sum = 0;\n  for i in arr {\n    if i < 0 {\n      sum += i;\n    } else {\n      sum += i % 10;\n    }\n  }\n  if sum > 0 {\n    return arr.len;\n  } else {\n    return 0;\n  }\n}\n\nfn main() {\n    let candidate = count_nums;\n    assert_eq!(candidate(Vec::<isize>::new()), 0);\n    assert_eq!(candidate(vec![-1, -2, 0]), 0);\n    assert_eq!(candidate(vec![1, 1, 2, -2, 3, 4, 5]), 6);\n    assert_eq!(candidate(vec![1, 6, 9, -6, 0, 1, 5]), 5);\n    assert_eq!(candidate(vec![1, 100, 98, -7, 1, -1]), 4);\n    assert_eq!(candidate(vec![12, 23, 34, -45, -56, 0]), 5);\n    assert_eq!(candidate(vec![0, 1]), 1);\n    assert_eq!(candidate(vec![1]), 1);\n}\n",
      "timestamp": 1664292755,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpip28oirp.rs:21:16\n   |\n21 |     return arr.len;\n   |                ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n21 |     return arr.len();\n   |                   ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpip28oirp.rs:21:12\n   |\n11 | fn count_nums(arr: Vec<isize>) -> isize {\n   |                                   ----- expected `isize` because of return type\n...\n21 |     return arr.len;\n   |            ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21 |     return arr.len.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}