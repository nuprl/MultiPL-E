{
  "name": "HumanEval_58_common",
  "language": "rs",
  "prompt": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
  "completions": [
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.slice(i, l1_len));",
    "  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n  let mut l1_next = true;\n  let mut l2_next = true;\n  let mut common_next = true;\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  let mut l1_index = 0;\n  let mut l2_index = 0;\n  let mut common_index = 0;\n  let mut l1_last = false;\n  let mut l2_last = false;\n  let mut common_last = false;\n  let mut l1_has_next = false;\n  let mut l2_has_next = false;\n  let mut common_has_next = false;\n  let mut l1_has_last = false;\n  let mut l2_has_last = false;\n  let mut common_has_last = false;\n  let mut l1_has_index = false;\n  let mut l2_has_index = false;\n  let mut common_has_index = false;\n  let mut l1_has_next_index = false;\n  let mut l2_has_next_index = false;\n  let mut common_has_next_index = false;\n  let mut l1_has_last_index = false;\n  let mut l2_has_last_index = false;\n  let mut common_has_last_index = false;\n  let mut l1_has_next_last = false;\n  let mut l2_has_next_last = false;\n  let mut common_has_next_last = false;\n  let mut l1_has_last_last = false;\n  let mut l2_has_last_last = false;\n  let mut common_has_last_last = false;\n  let mut l1_has_index_last = false;\n  let mut l2_has_index_last = false;\n  let mut common_has_index_last = false;\n  let mut l1_has_next_index_",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));",
    "  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n  let mut l1_next = true;\n  let mut l2_next = true;\n  let mut common_next = true;\n  while (l1_next && l2_next) {\n    if (l1_next && l2_next) {\n      if (l1_iter.next() != l2_iter.next()) {\n        l1_next = false;\n        l2_next = false;\n      }\n    } else {\n      l1_next = false;\n      l2_next = false;\n    }\n  }\n  while (l1_next) {\n    l1_next = l1_iter.next();\n    common_next = true;\n    l2_next = l2_iter.next();\n    while (l2_next && common_next) {\n      if (l1_next == l2_next) {\n        common_next = false;\n      } else {\n        l2_next = l2_iter.next();\n      }\n    }\n    if (common_next) {\n      common.append(l1_next);\n    }\n    l1_next = l1_iter.next();\n  }\n  return common;",
    "  let mut result = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      result.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return result;",
    "  let l1_iter = l1.iter();\n  let l2_iter = l2.iter();\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    let l1_val = l1_iter.next().value;\n    let l2_val = l2_iter.next().value;\n    if (l1_val == l2_val) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1_val < l2_val) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, [l1_iter.next().value]);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  let common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return l1.slice(common_idx, common_len);",
    "  let l1_iter = iter(l1);\n  let l2_iter = iter(l2);\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let common_len = l1_len < l2_len ? l1_len : l2_len;\n  let common_iter = iter(l1_len);\n  for (let i = 0; i < common_len; i += 1) {\n    let l1_val = l1_iter.next();\n    let l2_val = l2_iter.next();\n    if (l1_val != l2_val) {\n      common_iter.next();\n    } else {\n      common_iter.next(l1_val);\n    }\n  }\n  return Vec::from_iter(common_iter);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter3 = iter1.next();\n  let mut iter4 = iter2.next();\n  while (iter3.is_ok() && iter4.is_ok()) {\n    if (iter3.get() == iter4.get()) {\n      result.append(iter3.get());\n      iter3 = iter1.next();\n      iter4 = iter2.next();\n    } else if (iter3.get() < iter4.get()) {\n      iter3 = iter1.next();\n    } else {\n      iter4 = iter2.next();\n    }\n  }\n  return result;",
    "  let cmp = (a, b) => a - b;\n  let l1_sorted = l1.sort(cmp);\n  let l2_sorted = l2.sort(cmp);\n  let i = 0;\n  let j = 0;\n  let common = Vec::new(0);\n  while (i < l1_sorted.len && j < l2_sorted.len) {\n    if (l1_sorted[i] == l2_sorted[j]) {\n      common = common.concat(l1_sorted[i]);\n      i += 1;\n      j += 1;\n    } else if (l1_sorted[i] < l2_sorted[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter = iter1;\n  let mut iter_next = iter2;\n  let mut iter_next_next = iter1;\n  let mut iter_next_next_next = iter2;\n  let mut iter_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let result = Vec::new(l1_len);\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      result[c] = l1[i];\n      i += 1;\n      j += 1;\n      c += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  result.len_unsafe(c);\n  return result;",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n\n  let mut first = true;\n  let mut found = false;\n  let mut last = false;\n\n  for (let i = 0; i < l1.len(); i++) {\n    let a = iter1.next();\n    let b = iter2.next();\n\n    if (a == b) {\n      if (first) {\n        first = false;\n        iter_result.next(a);\n      }\n      found = true;\n    } else {\n      if (found) {\n        last = true;\n        break;\n      }\n    }\n  }\n\n  if (!last) {\n    iter_result.next(0);\n  }\n\n  return result;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common_len = 0;\n  let mut common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = l1_idx + 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_elements(common_len, l1[common_idx]);",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let mut result = Vec::new();\n  let mut iter = Iterator::from_iter(l1);\n  let mut iter2 = Iterator::from_iter(l2);\n  let mut iter3 = Iterator::from_iter(l1);\n  let mut iter4 = Iterator::from_iter(l2);\n  let mut iter5 = Iterator::from_iter(l1);\n  let mut iter6 = Iterator::from_iter(l2);\n  let mut iter7 = Iterator::from_iter(l1);\n  let mut iter8 = Iterator::from_iter(l2);\n  let mut iter9 = Iterator::from_iter(l1);\n  let mut iter10 = Iterator::from_iter(l2);\n  let mut iter11 = Iterator::from_iter(l1);\n  let mut iter12 = Iterator::from_iter(l2);\n  let mut iter13 = Iterator::from_iter(l1);\n  let mut iter14 = Iterator::from_iter(l2);\n  let mut iter15 = Iterator::from_iter(l1);\n  let mut iter16 = Iterator::from_iter(l2);\n  let mut iter17 = Iterator::from_iter(l1);\n  let mut iter18 = Iterator::from_iter(l2);\n  let mut iter19 = Iterator::from_iter(l1);\n  let mut iter20 = Iterator::from_iter(l2);\n  let mut iter21 = Iterator::from_iter(l1);\n  let mut iter22 = Iterator::from_iter(l2);\n  let mut iter23 = Iterator::from_iter(l1);\n  let mut iter24 = Iterator::from_iter(l2);\n  let mut iter25 = Iterator::from_iter(l1);\n  let mut iter26 = Iterator::from_iter(l2);\n  let mut iter27 = Iterator::from_iter(l1);\n  let mut iter28 = Iterator::from_iter(l2);\n  let mut iter29 = Iterator::from_iter(l1);\n  let mut iter30 = Iterator::from",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let r = l2.len();\n  let common = Vec::new(0);\n  while (i < l && j < r) {\n    if (l1[i] == l2[j]) {\n      common = common.concat(l1[i]);\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common.take(c);",
    "  let l1_iter = iter(l1);\n  let l2_iter = iter(l2);\n  let l1_next = l1_iter.next();\n  let l2_next = l2_iter.next();\n  let l1_done = false;\n  let l2_done = false;\n  let result = Vec::new();\n  while (!(l1_done && l2_done)) {\n    if (l1_next < l2_next) {\n      l1_next = l1_iter.next();\n    } else if (l2_next < l1_next) {\n      l2_next = l2_iter.next();\n    } else {\n      result = result.concat(l1_next);\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n  }\n  return result;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  let common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      common_idx += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_idx, common_len, l1.data);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_slice(l1.data.slice(i, l1.len - c));",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_all());",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n  let mut iter_l1 = l1.iter();\n  let mut iter_l2 = l2.iter();\n  let mut iter_l1_next = iter_l1.next();\n  let mut iter_l2_next = iter_l2.next();\n  let mut iter_result_next = iter_result.next();\n  let mut iter_result_next_next = iter_result_next.next();\n  let mut iter_l1_next_next = iter_l1_next.next();\n  let mut iter_l2_next_next = iter_l2_next.next();\n  let mut iter_result_next_next_next = iter_result_next_next.next();\n  let mut iter_result_next_next_next_next = iter_result_next_next_next.next();\n  let mut iter_result_next_next_next_next_next = iter_result_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next = iter_result_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next_next = iter_result_next_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next_next_next = iter_result_next_next_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next_next_next_next = iter_result_next_next_next_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next_next_next_next_next = iter_result_next_next_next_next_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;",
    "  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common_iter = Vec::new();\n  let mut l1_is_iter = l1.iter();\n  let mut l2_is_iter = l2.iter();\n  let mut l1_is_next = l1_is_iter.next();\n  let mut l2_is_next = l2_is_iter.next();\n  let mut common_is_next = common_iter.next();\n  let mut l1_is_done = false;\n  let mut l2_is_done = false;\n  let mut common_is_done = false;\n  while (!l1_is_done && !l2_is_done) {\n    if (l1_is_next.is_some() && l2_is_next.is_some()) {\n      if (l1_is_next.unwrap() == l2_is_next.unwrap()) {\n        common_is_next.set(l1_is_next.unwrap());\n        l1_is_next = l1_is_iter.next();\n        l2_is_next = l2_is_iter.next();\n      } else {\n        l1_is_done = true;\n        l2_is_done = true;\n      }\n    } else if (l1_is_next.is_some()) {\n      l1_is_done = true;\n    } else if (l2_is_next.is_some()) {\n      l2_is_done = true;\n    }\n  }\n  return common_iter;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.drop(i).append(l2.drop(j)));",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let c = 0;\n  for i in 0..l1.len {\n    if l1.data[i] == l2.data[i] {\n      c += 1;\n    }\n  }\n  let r = Vec::new(c);\n  let j = 0;\n  for i in 0..l1.len {\n    if l1.data[i] == l2.data[i] {\n      r.data[j] = l1.data[i];\n      j += 1;\n    }\n  }\n  return r;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common_idx = 0;\n  let mut common_len = 0;\n  let mut l1_val = 0;\n  let mut l2_val = 0;\n  let mut common_val = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    l1_val = l1[l1_idx];\n    l2_val = l2[l2_idx];\n    if (l1_val < l2_val) {\n      l1_idx += 1;\n    } else if (l1_val > l2_val) {\n      l2_idx += 1;\n    } else {\n      common_idx += 1;\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    }\n  }\n  if (l1_idx < l1_len) {\n    common_len += l1_len - l1_idx;\n  }\n  if (l2_idx < l2_len) {\n    common_len += l2_len - l2_idx;\n  }\n  let mut common_vec = Vec::new(common_len);\n  for (let i = 0; i < common_len; i += 1) {\n    common_vec[i] = common_val;\n  }\n  return common_vec;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n  let mut iter_l1 = l1.iter();\n  let mut iter_l2 = l2.iter();\n  let mut iter_result_next = iter_result.next();\n  let mut iter_l1_next = iter_l1.next();\n  let mut iter_l2_next = iter_l2.next();\n  let mut iter_result_next_next = iter_result_next.next();\n  let mut iter_l1_next_next = iter_l1_next.next();\n  let mut iter_l2_next_next = iter_l2_next.next();\n  let mut iter_result_next_next_next = iter_result_next_next.next();\n  let mut iter_l1_next_next_next = iter_l1_next_next.next();\n  let mut iter_l2_next_next_next = iter_l2_next_next.next();\n  let mut iter_result_next_next_next_next = iter_result_next_next_next.next();\n  let mut iter_l1_next_next_next_next = iter_l1_next_next_next.next();\n  let mut iter_l2_next_next_next_next = iter_l2_next_next_next.next();\n  let mut iter_result_next_next_next_next_next = iter_result_next_next_next_next.next();\n  let mut iter_l1_next_next_next_next_next = iter_l1_next_next_next_next.next();\n  let mut iter_l2_next_next_next_next_next = iter_l2_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next = iter_result_next_next_next_next_next.next();\n  let mut iter_l1_next_next_next_next_next_next = iter_",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));",
    "  let mut result = Vec::new();\n  let mut iter = Iterator::from_iter(l1);\n  let mut iter2 = Iterator::from_iter(l2);\n  let mut iter_next = Iterator::from_iter(l1);\n  let mut iter2_next = Iterator::from_iter(l2);\n  let mut iter_next2 = Iterator::from_iter(l1);\n  let mut iter2_next2 = Iterator::from_iter(l2);\n  let mut iter_next3 = Iterator::from_iter(l1);\n  let mut iter2_next3 = Iterator::from_iter(l2);\n  let mut iter_next4 = Iterator::from_iter(l1);\n  let mut iter2_next4 = Iterator::from_iter(l2);\n  let mut iter_next5 = Iterator::from_iter(l1);\n  let mut iter2_next5 = Iterator::from_iter(l2);\n  let mut iter_next6 = Iterator::from_iter(l1);\n  let mut iter2_next6 = Iterator::from_iter(l2);\n  let mut iter_next7 = Iterator::from_iter(l1);\n  let mut iter2_next7 = Iterator::from_iter(l2);\n  let mut iter_next8 = Iterator::from_iter(l1);\n  let mut iter2_next8 = Iterator::from_iter(l2);\n  let mut iter_next9 = Iterator::from_iter(l1);\n  let mut iter2_next9 = Iterator::from_iter(l2);\n  let mut iter_next10 = Iterator::from_iter(l1);\n  let mut iter2_next10 = Iterator::from_iter(l2);\n  let mut iter_next11 = Iterator::from_iter(l1);\n  let mut iter2_next11 = Iterator::from_iter(l2);\n  let mut iter_next12 = Iterator::from_iter(l1);\n  let mut iter2_next12 = Iterator::from_iter(l2);\n  let mut",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n  let mut l1_next = l1_iter.next();\n  let mut l2_next = l2_iter.next();\n  let mut common_next = common.iter().next();\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  let mut l1_last = l1_next;\n  let mut l2_last = l2_next;\n  let mut common_last = common_next;\n  let mut l1_next_next = l1_iter.next();\n  let mut l2_next_next = l2_iter.next();\n  let mut common_next_next = common.iter().next();\n  let mut l1_next_done = false;\n  let mut l2_next_done = false;\n  let mut common_next_done = false;\n  let mut l1_next_last = l1_next_next;\n  let mut l2_next_last = l2_next_next;\n  let mut common_next_last = common_next_next;\n  while (!(l1_done && l2_done && common_done)) {\n    if (!l1_done && !l2_done) {\n      if (l1_next < l2_next) {\n        l1_next_next = l1_iter.next();\n        l1_next_done = false;\n        l1_next_last = l1_next_next;\n        l1_next = l1_next_next;\n      } else if (l2_next < l1_next) {\n        l2_next_next = l2_iter.next();\n        l2_next_done = false;\n        l2_next_last = l2_next_next;\n        l2_next = l2_next_next;\n      } else {\n        common_next_next = common.iter().next();\n        common_next_done = false;\n        common_",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.len());",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let mut l1_iter = 0;\n  let mut l2_iter = 0;\n  let mut common_iter = 0;\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut common_len = 0;\n  let mut common_vec = Vec::new(0);\n\n  while (l1_iter < l1_len && l2_iter < l2_len) {\n    if (l1[l1_iter] < l2[l2_iter]) {\n      l1_iter += 1;\n    } else if (l1[l1_iter] > l2[l2_iter]) {\n      l2_iter += 1;\n    } else {\n      common_iter += 1;\n      l1_iter += 1;\n      l2_iter += 1;\n    }\n  }\n\n  common_len = common_iter;\n  common_vec = Vec::new(common_len);\n\n  while (l1_iter < l1_len) {\n    common_vec.append(l1[l1_iter]);\n    l1_iter += 1;\n  }\n\n  while (l2_iter < l2_len) {\n    common_vec.append(l2[l2_iter]);\n    l2_iter += 1;\n  }\n\n  return common_vec;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());",
    "  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common_iter = Vec::new();\n  let mut l1_next = l1_iter.next();\n  let mut l2_next = l2_iter.next();\n  let mut common_next = common_iter.next();\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  while (!l1_done && !l2_done) {\n    if (l1_next < l2_next) {\n      l1_next = l1_iter.next();\n    } else if (l2_next < l1_next) {\n      l2_next = l2_iter.next();\n    } else {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return l1.slice(common_idx, common_idx + common_len);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter = iter1;\n  let mut iter_next = iter2;\n  let mut iter_next_next = iter1;\n  let mut iter_next_next_next = iter2;\n  let mut iter_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      c += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(c, l1_idx, l2_idx);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common_idx = 0;\n  let mut common_len = 0;\n  let mut common_idx_list = vec![];\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx_list.push(l1_idx);\n      l1_idx += 1;\n      l2_idx += 1;\n      common_idx += 1;\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return vec![common_idx_list.len(), common_idx, common_len];",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  let common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = l1_idx + 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len, common_idx, l1.data);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len, l1_idx, l2_idx);",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      common.append(l1.data[i]);\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let l1_iter = l1.iter();\n  let l2_iter = l2.iter();\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(l1_len);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    let l1_val = l1_iter.next();\n    let l2_val = l2_iter.next();\n    if (l1_val == l2_val) {\n      result.append(l1_val);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1_val < l2_val) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let r = l2.len;\n  while (i < l && j < r) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));",
    "  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common = Vec::new();\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common_iter = Vec::new();\n  let mut l1_next = l1.next();\n  let mut l2_next = l2.next();\n  let mut common_next = common_iter.next();\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  while (!(l1_done && l2_done && common_done)) {\n    if (!l1_done && !l2_done) {\n      if (l1_next < l2_next) {\n        l1_next = l1.next();\n      } else if (l1_next > l2_next) {\n        l2_next = l2.next();\n      } else {\n        common_next = l1_next;\n        l1_next = l1.next();\n        l2_next = l2.next();\n      }\n    } else if (!l1_done && common_done) {\n      l1_next = l1.next();\n    } else if (l2_done && !common_done) {\n      l2_next = l2.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1.next();\n      l2_next = l2.next();\n    } else if (l1_next < l2_next) {\n      l1_done = true;\n    } else {\n      l2_done = true;\n    }\n    common_done = l1_done && l2_done;\n    common_iter.next(common_next);\n  }\n  return common_iter;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.len());",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n  let mut iter_l1 = l1.iter();\n  let mut iter_l2 = l2.iter();\n\n  while (true) {\n    let mut v1 = iter_l1.next();\n    let mut v2 = iter_l2.next();\n    let mut v_result = iter_result.next();\n\n    if (v1.is_undefined() || v2.is_undefined()) {\n      break;\n    }\n\n    if (v1.unwrap() == v2.unwrap()) {\n      v_result = v1;\n    } else {\n      break;\n    }\n  }\n\n  return result;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  let common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      common_idx = l1_idx;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len, common_idx, l1_idx, l2_idx);",
    "  let mut cnt = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  let r = Vec::new(l);\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      r[c] = l1[i];\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  r.len_unsafe(c);\n  return r;",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter = iter1;\n  let mut iter_next = iter2;\n  let mut iter_next_next = iter1;\n  let mut iter_next_next_next = iter2;\n  let mut iter_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));",
    "  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n\n  let mut l1_next = true;\n  let mut l2_next = true;\n  let mut common_next = true;\n\n  while (l1_next && l2_next) {\n    if (l1_next && l2_next) {\n      if (l1_iter.next() != l2_iter.next()) {\n        l1_next = false;\n        l2_next = false;\n      }\n    } else {\n      l1_next = false;\n      l2_next = false;\n    }\n  }\n\n  while (l1_next || l2_next) {\n    if (l1_next) {\n      common.append(l1_iter.next());\n      l1_next = l1_iter.next();\n    }\n    if (l2_next) {\n      common.append(l2_iter.next());\n      l2_next = l2_iter.next();\n    }\n  }\n\n  return common;",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n  let mut iter_l1 = l1.iter();\n  let mut iter_l2 = l2.iter();\n  let mut iter_result_next = iter_result.next();\n  let mut iter_l1_next = iter_l1.next();\n  let mut iter_l2_next = iter_l2.next();\n  let mut iter_result_next_next = iter_result_next.next();\n  let mut iter_l1_next_next = iter_l1_next.next();\n  let mut iter_l2_next_next = iter_l2_next.next();\n  let mut iter_result_next_next_next = iter_result_next_next.next();\n  let mut iter_l1_next_next_next = iter_l1_next_next.next();\n  let mut iter_l2_next_next_next = iter_l2_next_next.next();\n  let mut iter_result_next_next_next_next = iter_result_next_next_next.next();\n  let mut iter_l1_next_next_next_next = iter_l1_next_next_next.next();\n  let mut iter_l2_next_next_next_next = iter_l2_next_next_next.next();\n  let mut iter_result_next_next_next_next_next = iter_result_next_next_next_next.next();\n  let mut iter_l1_next_next_next_next_next = iter_l1_next_next_next_next.next();\n  let mut iter_l2_next_next_next_next_next = iter_l2_next_next_next_next.next();\n\n  while (iter_result_next.has_next()) {\n    let mut val = iter_result_next.next();\n    let mut val_next = iter_result_next_next.next();\n    let mut val_next_next = iter_",
    "  let mut c = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return c;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));",
    "  let mut l1_iter = 0;\n  let mut l2_iter = 0;\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_common = 0;\n  let mut l2_common = 0;\n  let mut l1_common_len = 0;\n  let mut l2_common_len = 0;\n  let mut l1_common_iter = 0;\n  let mut l2_common_iter = 0;\n  let mut l1_common_iter_len = 0;\n  let mut l2_common_iter_len = 0;\n  let mut l1_common_iter_iter = 0;\n  let mut l2_common_iter_iter = 0;\n  let mut l1_common_iter_iter_len = 0;\n  let mut l2_common_iter_iter_len = 0;\n  let mut l1_common_iter_iter_iter = 0;\n  let mut l2_common_iter_iter_iter = 0;\n  let mut l1_common_iter_iter_iter_len = 0;\n  let mut l2_common_iter_iter_iter_len = 0;\n  let mut l1_common_iter_iter_iter_iter = 0;\n  let mut l2_common_iter_iter_iter_iter = 0;\n  let mut l1_common_iter_iter_iter_iter_len = 0;\n  let mut l2_common_iter_iter_iter_iter_len = 0;\n  let mut l1_common_iter_iter_iter_iter_iter = 0;\n  let mut l2_common_iter_iter_iter_iter_iter = 0;\n  let mut l1_common_iter_iter_iter_iter_iter_len = 0;\n  let mut l2_common_iter_iter_iter_iter_iter_len = 0;\n  let mut l1_common_iter_iter_iter_iter_iter_iter = 0;\n  let mut l2_common_iter_iter_iter_iter_iter_iter = 0;\n  let mut l1_common_",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let mut result = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      result.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return result;",
    "  let cmp = (a, b) => a - b;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let l1_idx_next = 0;\n  let l2_idx_next = 0;\n  let l1_idx_prev = 0;\n  let l2_idx_prev = 0;\n  let l1_idx_min = 0;\n  let l2_idx_min = 0;\n  let l1_idx_max = 0;\n  let l2_idx_max = 0;\n  let l1_idx_min_prev = 0;\n  let l2_idx_min_prev = 0;\n  let l1_idx_max_prev = 0;\n  let l2_idx_max_prev = 0;\n  let l1_idx_min_next = 0;\n  let l2_idx_min_next = 0;\n  let l1_idx_max_next = 0;\n  let l2_idx_max_next = 0;\n  let l1_idx_min_next_prev = 0;\n  let l2_idx_min_next_prev = 0;\n  let l1_idx_max_next_prev = 0;\n  let l2_idx_max_next_prev = 0;\n  let l1_idx_min_next_next = 0;\n  let l2_idx_min_next_next = 0;\n  let l1_idx_max_next_next = 0;\n  let l2_idx_max_next_next = 0;\n  let l1_idx_min_next_next_prev = 0;\n  let l2_idx_min_next_next_prev = 0;\n  let l1_idx_max_next_next_prev = 0;\n  let l2_idx_max_next_next_prev = 0;\n  let l1_idx_min_next_",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));",
    "  let mut common = Vec::new();\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut l1_last = false;\n  let mut l2_last = false;\n  let mut common_idx = 0;\n  let mut common_last = false;\n  while (l1_iter.next()) {\n    if (l2_iter.next()) {\n      if (l1_iter.get() == l2_iter.get()) {\n        if (!l1_last && !l2_last) {\n          common.push(l1_iter.get());\n          common_idx += 1;\n        }\n      } else {\n        l1_last = l1_iter.last();\n        l2_last = l2_iter.last();\n        if (!l1_last && !l2_last) {\n          common.push(l1_iter.get());\n          common_idx += 1;\n        }\n      }\n    } else {\n      l1_last = l1_iter.last();\n      if (!l1_last) {\n        common.push(l1_iter.get());\n        common_idx += 1;\n      }\n      l2_last = true;\n    }\n  }\n  while (l2_iter.next()) {\n    if (l1_iter.next()) {\n      if (l1_iter.get() == l2_iter.get()) {\n        if (!l1_last && !l2_last) {\n          common.push(l1_iter.get());\n          common_idx += 1;\n        }\n      } else {\n        l1_last = l1_iter.last();\n        l2_last = l2_iter.last();\n        if (!l1_last && !l2_last) {\n          common.push(l1_iter.get());\n          common_idx += 1;\n        }\n      }\n    } else {\n      l1_last = true;\n",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return result;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let mut l1_iter = 0;\n  let mut l2_iter = 0;\n  let mut common_iter = 0;\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut common_len = 0;\n  let mut common_vec = Vec::new(0);\n  let mut l1_val = 0;\n  let mut l2_val = 0;\n  let mut common_val = 0;\n  while (l1_iter < l1_len && l2_iter < l2_len) {\n    l1_val = l1[l1_iter];\n    l2_val = l2[l2_iter];\n    if (l1_val < l2_val) {\n      l1_iter += 1;\n    } else if (l1_val > l2_val) {\n      l2_iter += 1;\n    } else {\n      common_val = l1_val;\n      common_iter += 1;\n      l1_iter += 1;\n      l2_iter += 1;\n    }\n  }\n  common_len = common_iter;\n  for (; l1_iter < l1_len; l1_iter += 1) {\n    l1_val = l1[l1_iter];\n    if (l1_val != common_val) {\n      common_vec = common_vec.concat(l1[l1_iter]);\n    }\n  }\n  for (; l2_iter < l2_len; l2_iter += 1) {\n    l2_val = l2[l2_iter];\n    if (l2_val != common_val) {\n      common_vec = common_vec.concat(l2[l2_iter]);\n    }\n  }\n  return common_vec;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let mut l1_counts = Vec::with_capacity(l1.len);\n  let mut l2_counts = Vec::with_capacity(l2.len);\n  let mut common = Vec::with_capacity(0);\n\n  for (let i = 0; i < l1.len; i++) {\n    let l1_count = l1_counts.get(i);\n    let l2_count = l2_counts.get(i);\n    if (l1_count == 0 && l2_count == 0) {\n      continue;\n    }\n    if (l1_count == 0 || l2_count == 0) {\n      common = common.concat(l1_counts.slice(i));\n      break;\n    }\n    if (l1[i] == l2[i]) {\n      l1_counts[i] += 1;\n    } else {\n      l1_counts[i] = 1;\n      l2_counts[i] = 1;\n    }\n  }\n\n  for (let i = 0; i < l1.len; i++) {\n    if (l1_counts[i] == 0) {\n      continue;\n    }\n    common = common.concat(l1_counts.slice(i));\n    break;\n  }\n\n  return common;",
    "  let c = 0;\n  let l1_iter = l1.iter();\n  let l2_iter = l2.iter();\n  let l1_next = l1_iter.next();\n  let l2_next = l2_iter.next();\n  while (l1_next.is_some() && l2_next.is_some()) {\n    if (l1_next.unwrap() == l2_next.unwrap()) {\n      c += 1;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    } else if (l1_next.unwrap() < l2_next.unwrap()) {\n      l1_next = l1_iter.next();\n    } else {\n      l2_next = l2_iter.next();\n    }\n  }\n  let r = Vec::new(c);\n  l1_iter = l1.iter();\n  l2_iter = l2.iter();\n  l1_next = l1_iter.next();\n  l2_next = l2_iter.next();\n  while (l1_next.is_some() && l2_next.is_some()) {\n    if (l1_next.unwrap() == l2_next.unwrap()) {\n      r = r.append(l1_next.unwrap());\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    } else if (l1_next.unwrap() < l2_next.unwrap()) {\n      l1_next = l1_iter.next();\n    } else {\n      l2_next = l2_iter.next();\n    }\n  }\n  return r;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let cmp = (a, b) => a - b;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    let a = l1[l1_idx];\n    let b = l2[l2_idx];\n    if (cmp(a, b) < 0) {\n      l1_idx += 1;\n    } else if (cmp(a, b) > 0) {\n      l2_idx += 1;\n    } else {\n      common = common.concat(a);\n      l1_idx += 1;\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let mut result = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      result.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return result;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let result = Vec::new(l1_len);\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      result[c] = l1[i];\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  result.len_unsafe(c);\n  return result;",
    "  let mut cnt = 0;\n  let mut res = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      cnt += 1;\n      res.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  if (cnt == 0) {\n    return Vec::new();\n  }\n  return res;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let mut r = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0",
    "  let mut l1_counts = Vec::new();\n  let mut l2_counts = Vec::new();\n  let mut common = Vec::new();\n  let mut l1_index = 0;\n  let mut l2_index = 0;\n  let mut l1_count = 0;\n  let mut l2_count = 0;\n  let mut l1_common = 0;\n  let mut l2_common = 0;\n\n  for (let i = 0; i < l1.len; i++) {\n    if (l1_counts.contains(l1[i])) {\n      l1_counts[l1[i]] += 1;\n    } else {\n      l1_counts.push(l1[i]);\n      l1_count += 1;\n    }\n  }\n\n  for (let i = 0; i < l2.len; i++) {\n    if (l2_counts.contains(l2[i])) {\n      l2_counts[l2[i]] += 1;\n    } else {\n      l2_counts.push(l2[i]);\n      l2_count += 1;\n    }\n  }\n\n  for (let i = 0; i < l1_counts.len; i++) {\n    if (l1_counts[i] == l2_counts[i]) {\n      common.push(l1_counts[i]);\n      l1_common += 1;\n      l2_common += 1;\n    }\n  }\n\n  for (let i = 0; i < l1_counts.len; i++) {\n    if (l1_counts[i] > l2_counts[i]) {\n      l1_count -= l1_counts[i];\n      l1_index += 1;\n    } else if (l1_counts[i] < l2_counts[i]) {\n      l2_count -= l2_counts[i];\n      l2_index += 1;\n    }\n  }\n\n  for (let i = 0; i < l1_counts.len; i++) {\n    if",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;",
    "  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut i = 0;\n  let mut j = 0;\n  let mut common_len = 0;\n  let mut common_idx = 0;\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut l1_idx_next = 0;\n  let mut l2_idx_next = 0;\n  let mut l1_idx_prev = 0;\n  let mut l2_idx_prev = 0;\n  let mut l1_idx_prev_next = 0;\n  let mut l2_idx_prev_next = 0;\n  let mut l1_idx_next_next = 0;\n  let mut l2_idx_next_next = 0;\n  let mut l1_idx_prev_prev = 0;\n  let mut l2_idx_prev_prev = 0;\n  let mut l1_idx_next_prev = 0;\n  let mut l2_idx_next_prev = 0;\n  let mut l1_idx_prev_prev_next = 0;\n  let mut l2_idx_prev_prev_next = 0;\n  let mut l1_idx_next_prev_next = 0;\n  let mut l2_idx_next_prev_next = 0;\n  let mut l1_idx_prev_prev_prev = 0;\n  let mut l2_idx_prev_prev_prev = 0;\n  let mut l1_idx_next_prev_prev = 0;\n  let mut l2_idx_next_prev_prev = 0;\n  let mut l1_idx_prev_prev_prev_next = 0;\n  let mut l2_idx_prev_prev_prev_next = 0;\n  let mut l1_idx_next_prev_prev_prev = 0;\n  let mut l2_idx_next_prev_prev_prev = 0;\n  let mut l1_idx_prev_prev_prev_",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let cmp = (a, b) => a - b;\n  let l1_sorted = l1.sort(cmp);\n  let l2_sorted = l2.sort(cmp);\n  let i = 0;\n  let j = 0;\n  let common = Vec::new();\n  while (i < l1_sorted.len && j < l2_sorted.len) {\n    if (l1_sorted.data[i] == l2_sorted.data[j]) {\n      common = common.concat(l1_sorted.data[i]);\n      i += 1;\n      j += 1;\n    } else if (l1_sorted.data[i] < l2_sorted.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;",
    "  let mut c = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return c;",
    "  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter = iter1;\n  let mut iter_next = iter2;\n  let mut iter_next_next = iter1;\n  let mut iter_next_next_next = iter2;\n  let mut iter_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next",
    "  let mut c = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());",
    "  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut common_len = 0;\n  let mut i1 = 0;\n  let mut i2 = 0;\n  let mut j1 = 0;\n  let mut j2 = 0;\n  while (i1 < l1_len && i2 < l2_len) {\n    if (l1[i1] < l2[i2]) {\n      i1 += 1;\n    } else if (l1[i1] > l2[i2]) {\n      i2 += 1;\n    } else {\n      common_len += 1;\n      i1 += 1;\n      i2 += 1;\n    }\n  }\n  if (i1 < l1_len) {\n    j1 = i1;\n    while (j1 < l1_len) {\n      if (l1[j1] < l2[i2]) {\n        j1 += 1;\n      } else {\n        break;\n      }\n    }\n    l1_len = j1 - i1;\n  } else if (i2 < l2_len) {\n    j2 = i2;\n    while (j2 < l2_len) {\n      if (l1[i1] < l2[j2]) {\n        j2 += 1;\n      } else {\n        break;\n      }\n    }\n    l2_len = j2 - i2;\n  }\n  let mut common = Vec::new(common_len);\n  let mut k = 0;\n  for (; k < common_len; k += 1) {\n    common[k] = l1[i1];\n    i1 += 1;\n    i2 += 1;\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let c = 0;\n  let l1_i = 0;\n  let l2_i = 0;\n  while (l1_i < l1.len && l2_i < l2.len) {\n    if (l1[l1_i] == l2[l2_i]) {\n      c += 1;\n      l1_i += 1;\n      l2_i += 1;\n    } else if (l1[l1_i] < l2[l2_i]) {\n      l1_i += 1;\n    } else {\n      l2_i += 1;\n    }\n  }\n  return Vec::from_iter(c, l1_i);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] < l2[j]) {\n      i += 1;\n    } else if (l1[i] > l2[j]) {\n      j += 1;\n    } else {\n      c += 1;\n      i += 1;\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));",
    "  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n  let mut l1_next = false;\n  let mut l2_next = false;\n  let mut common_next = false;\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  let mut l1_iter_done = false;\n  let mut l2_iter_done = false;\n  let mut common_iter_done = false;\n  let mut l1_iter_next = false;\n  let mut l2_iter_next = false;\n  let mut common_iter_next = false;\n  let mut l1_iter_next_done = false;\n  let mut l2_iter_next_done = false;\n  let mut common_iter_next_done = false;\n  let mut l1_iter_next_next = false;\n  let mut l2_iter_next_next = false;\n  let mut common_iter_next_next = false;\n  let mut l1_iter_next_next_done = false;\n  let mut l2_iter_next_next_done = false;\n  let mut common_iter_next_next_done = false;\n  let mut l1_iter_next_next_next = false;\n  let mut l2_iter_next_next_next = false;\n  let mut common_iter_next_next_next = false;\n  let mut l1_iter_next_next_next_done = false;\n  let mut l2_iter_next_next_next_done = false;\n  let mut common_iter_next_next_next_done = false;\n  let mut l1_iter_next_next_next_next = false;\n  let mut l2_iter_next_next_next_next = false;\n  let mut common_iter_next_next_next_next = false;\n  let mut l1_iter_next_next_next_next_done = false;\n  let mut l2_iter_next_next_next",
    "  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return result;",
    "  let mut result = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      result.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return result;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return l1.slice(common_idx, common_idx + common_len);",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);",
    "  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));",
    "  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0",
    "  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;"
  ],
  "stop_tokens": [
    "\n}"
  ]
}