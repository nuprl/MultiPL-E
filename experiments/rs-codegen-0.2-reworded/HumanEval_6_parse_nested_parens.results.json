{
  "name": "HumanEval_6_parse_nested_parens",
  "language": "rs",
  "prompt": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string.get(i);\n    if (c == '(') {\n      paren_stack.push(paren_count);\n      paren_count = 0;\n      paren_level += 1;\n    } else if (c == ')') {\n      paren_count += 1;\n      if (paren_stack.len() == 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      paren_count = paren_stack.pop();\n      paren_level -= 1;\n    }\n  }\n\n  let max_level = paren_level;\n  let max_count = paren_count;\n  for (let i = 0; i < paren_stack.len(); i++) {\n    if (paren_stack[i] > max_count) {\n      max_count = paren_stack[i];\n      max_level = i + 1;\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < max_level; i++) {\n    result.push_back(max_count);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp_jg5mo6_.rs:11:8\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp_jg5mo6_.rs:11:12\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp_jg5mo6_.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp_jg5mo6_.rs:11:13\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp_jg5mo6_.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_index = 0;\n  let paren_char = ' ';\n  let paren_char_count = 0;\n  let paren_char_index = 0;\n  let paren_char_count_max = 0;\n  let paren_char_count_min = 0;\n  let paren_char_count_max_index = 0;\n  let paren_char_count_min_index = 0;\n  let paren_char_count_max_index_prev = 0;\n  let paren_char_count_min_index_prev = 0;\n  let paren_char_count_max_index_next = 0;\n  let paren_char_count_min_index_next = 0;\n  let paren_char_count_max_index_next_prev = 0;\n  let paren_char_count_min_index_next_prev = 0;\n  let paren_char_count_max_index_next_next = 0;\n  let paren_char_count_min_index_next_next = 0;\n  let paren_char_count_max_index_next_next_prev = 0;\n  let paren_char_count_min_index_next_next_prev = 0;\n  let paren_char_count_max_index_next_next_next = 0;\n  let paren_char_count_min_index_next_next_next_prev = 0;\n  let paren_char_count_max_index_next_next_next_next = 0;\n  let paren_char_count_min_index_next_next_next_next_prev = 0;\n  let paren_char_count_max_index_next_next_next_next_next = 0;\n  let paren_char_count_min_index_next_next_next_next_next_prev = 0;\n  let paren_char_count_max_index_next_next_next_next_next_next =\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpy925yths.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: expected expression, found `}`\n  --> /tmp/tmpy925yths.rs:35:1\n   |\n35 | }\n   | ^ expected expression\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  for i in paren_string.iter() {\n    if i == '(' {\n      stack.push(i);\n      level += 1;\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(level);\n      } else {\n        stack.pop();\n        level -= 1;\n      }\n    }\n  }\n  if !stack.is_empty() {\n    result.push(level);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmprnv3f4r7.rs:10:25\n   |\n10 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new(0);\n  let result = Vec::new(0);\n  paren_string.chars().for_each(|c| {\n    if c == '(' {\n      paren_stack.push_back(0);\n    } else if c == ')' {\n      if paren_stack.is_empty() {\n        result.push_back(paren_stack.pop_back());\n      } else {\n        paren_stack.pop_back();\n      }\n    }\n  });\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpz3_6irpe.rs:7:21\n    |\n7   |   let paren_stack = Vec::new(0);\n    |                     ^^^^^^^^ - supplied 1 argument\n    |                     |\n    |                     expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpz3_6irpe.rs:8:16\n    |\n8   |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpz3_6irpe.rs:11:19\n   |\n11 |       paren_stack.push_back(0);\n   |                   ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpz3_6irpe.rs:14:16\n   |\n14 |         result.push_back(paren_stack.pop_back());\n   |                ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `pop_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpz3_6irpe.rs:14:38\n   |\n14 |         result.push_back(paren_stack.pop_back());\n   |                                      ^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `pop_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpz3_6irpe.rs:16:21\n   |\n16 |         paren_stack.pop_back();\n   |                     ^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_index = 0;\n  let mut max_index_in_level = 0;\n  let mut max_index_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp6p2a2tir.rs:23:95\n   |\n23 |   let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in\n   |                                                                                               ^ help: add `;` here\n24 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6p2a2tir.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let paren_count = 0;\n  let paren_count_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  for (i in paren_string) {\n    current_char = paren_string[i];\n    if (current_char == '(') {\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      paren_stack.push(i);\n      current_nesting += 1;\n      if (current_nesting > max_nesting) {\n        max_nesting = current_nesting;\n        max_nesting_index = i;\n      }\n    } else if (current_char == ')') {\n      paren_count -= 1;\n      paren_count_stack.pop();\n      current_nesting -= 1;\n      if (current_nesting == 0) {\n        current_nesting_index = paren_stack.pop();\n      }\n    }\n  }\n  let result = Vec::new();\n  for (i in paren_stack) {\n    result.push_back(max_nesting_index - paren_stack[i]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpqvr_o9l8.rs:18:10\n   |\n18 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpqvr_o9l8.rs:18:7\n   |\n18 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n18 -   for (i in paren_string) {\n18 +   for i in paren_string {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpqvr_o9l8.rs:39:10\n   |\n39 |   for (i in paren_stack) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpqvr_o9l8.rs:39:7\n   |\n39 |   for (i in paren_stack) {\n   |       ^                ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n39 -   for (i in paren_stack) {\n39 +   for i in paren_stack {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqvr_o9l8.rs:20:8\n   |\n20 |     if (current_char == '(') {\n   |        ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (current_char == '(') {\n20 +     if current_char == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqvr_o9l8.rs:25:10\n   |\n25 |       if (current_nesting > max_nesting) {\n   |          ^                             ^\n   |\nhelp: remove these parentheses\n   |\n25 -       if (current_nesting > max_nesting) {\n25 +       if current_nesting > max_nesting {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqvr_o9l8.rs:29:15\n   |\n29 |     } else if (current_char == ')') {\n   |               ^                   ^\n   |\nhelp: remove these parentheses\n   |\n29 -     } else if (current_char == ')') {\n29 +     } else if current_char == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqvr_o9l8.rs:33:10\n   |\n33 |       if (current_nesting == 0) {\n   |          ^    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      stack.push(i);\n      level += 1;\n    } else if (paren_string[i] == ')') {\n      if (level == 0) {\n        result.push(i);\n      } else {\n        level -= 1;\n      }\n    }\n  }\n  result.push(paren_string.len());\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpctxu26ma.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpctxu26ma.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpctxu26ma.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpctxu26ma.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpctxu26ma.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_end = 0;\n  let mut max_level_index_start = 0;\n  let mut max_level_index_start_end = 0;\n  let mut max_level_index_start_start = 0;\n  let mut max_level_index_start_start_end = 0;\n  let mut max_level_index_start_start_start = 0;\n  let mut max_level_index_start_start_start_end = 0;\n  let mut max_level_index_start_start_start_start = 0;\n  let mut max_level_index_start_start_start_start_end = 0;\n  let mut max_level_index_start_start_start_start_start = 0;\n  let mut max_level_index_start_start_start_start_start_end = 0;\n  let mut max_level_index_start_start_start_start_start_start = 0;\n  let mut max_level_index_start_start_start_start_start_start_end = 0;\n  let mut max_level_index_start_start_start_start_start_start_start = 0;\n  let mut max_level_index_start_start_start_start_start_start_start_end = 0;\n  let mut max_level_index_start_start_start_start_start_start_start_start = 0;\n  let mut max_level_index_start_start_start_start_start_start_start_start_end = 0;\n  let mut max_level_index_start_start_start_start_start_start_start_start_start = 0;\n  let mut max_level_index_start_start_start_start_start_start_start_start_start_end = 0;\n  let mut max_level_index_start_start_start_start_start_start_start_start_start_start = 0;\n  let mut max_level_index_start\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp3l4fvhzk.rs:31:32\n   |\n31 |   let mut max_level_index_start\n   |                                ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3l4fvhzk.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let current_char_index = 0;\n  let next_char = 0;\n  let next_char_index = 0;\n  let next_char_is_space = false;\n  let next_char_is_paren = false;\n  let next_char_is_bracket = false;\n  let next_char_is_escape = false;\n  let next_char_is_quote = false;\n  let next_char_is_backtick = false;\n  let next_char_is_slash = false;\n  let next_char_is_asterisk = false;\n  let next_char_is_percent = false;\n  let next_char_is_comma = false;\n  let next_char_is_colon = false;\n  let next_char_is_semicolon = false;\n  let next_char_is_period = false;\n  let next_char_is_at = false;\n  let next_char_is_backtick = false;\n  let next_char_is_slash = false;\n  let next_char_is_asterisk = false;\n  let next_char_is_percent = false;\n  let next_char_is_comma = false;\n  let next_char_is_colon = false;\n  let next_char_is_semicolon = false;\n  let next_char_is_period = false;\n  let next_char_is_at = false;\n  let next_char_is_backtick = false;\n  let next_char_is_slash = false;\n  let next_char_is_asterisk = false;\n  let next_char_is_percent = false;\n  let next_char_is_comma = false;\n  let next_char_is_colon = false;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmp26grnkhl.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n\n  let paren_string_len = paren_string.len();\n  for (let i = 0; i < paren_string_len; i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      paren_count_stack_index += 1;\n      paren_stack.push(i);\n    } else if (c == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        let paren_index = paren_stack.pop();\n        let paren_count_index = paren_count_stack_index - 1;\n        let nesting = paren_count_stack[paren_count_index];\n        if (nesting > max_nesting) {\n          max_nesting = nesting;\n          max_nesting_index = paren_index;\n        }\n      }\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < max_nesting_index; i++) {\n    result.push(1);\n  }\n  for (let i = max_nesting_index + 1; i < paren_string_len; i++) {\n    result.push(0);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpcvb7iq2v.rs:17:8\n   |\n17 |   for (let i = 0; i < paren_string_len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpcvb7iq2v.rs:17:12\n   |\n17 |   for (let i = 0; i < paren_string_len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpcvb7iq2v.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string_len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcvb7iq2v.rs:17:13\n   |\n17 |   for (let i = 0; i < paren_string_len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpcvb7iq2v.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string_len; i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_found = false;\n  let mut max_level_index_found_index = 0;\n  let mut max_level_index_found_index_found = false;\n  let mut max_level_index_found_index_found_index = 0;\n  let mut max_level_index_found_index_found_index_found = false;\n  let mut max_level_index_found_index_found_index_found_index = 0;\n  let mut max_level_index_found_index_found_index_found_index_found = false;\n  let mut max_level_index_found_index_found_index_found_index_found_index = 0;\n  let mut max_level_index_found_index_found_index_found_index_found_index_found = false;\n  let mut max_level_index_found_index_found_index_found_index_found_index_found_index = 0;\n  let mut max_level_index_found_index_found_index_found_index_found_index_found_index_found = false;\n  let mut max_level_index_found_index_found_index_found_index_found_index_found_index_found_index = 0;\n  let mut max_level_index_found_index_found_index_found_index_found_index_found_index_found_index_found = false;\n  let mut max_level_index_found_index_found_index_found_index_found_index_found_index_found_index_found_index = 0;\n  let mut max_level_index_found_index_found_index_found_index_found_index_found_index_found_index_found_index_found = false;\n  let mut max_level_index_found_index_found_index_found_index_found_index_found_index_found_index_found_index_found_index = 0;\n  let mut max_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp80zdlu86.rs:27:20\n   |\n27 |   let mut max_level\n   |                    ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp80zdlu86.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let result = Vec::new();\n  let current_level = 0;\n  let current_paren_count = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      current_paren_count += 1;\n      current_level += 1;\n      paren_stack.push(i);\n    } else if (c == ')') {\n      current_paren_count -= 1;\n      if (current_paren_count == 0) {\n        let paren_start = paren_stack.pop();\n        let paren_end = i;\n        let paren_count = paren_end - paren_start;\n        result.push(paren_count);\n        current_level -= 1;\n      }\n    }\n  }\n  result.push(current_level);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpkc_5d3c3.rs:12:8\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpkc_5d3c3.rs:12:12\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpkc_5d3c3.rs:12:14\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpkc_5d3c3.rs:12:13\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpkc_5d3c3.rs:12:14\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_index = 0;\n  let paren_char = '(';\n  let paren_char_index = 0;\n  let paren_char_count = 0;\n  let paren_char_count_index = 0;\n  let paren_char_count_count = 0;\n  let paren_char_count_count_index = 0;\n  let paren_char_count_count_count = 0;\n  let paren_char_count_count_count_index = 0;\n  let paren_char_count_count_count_count = 0;\n  let paren_char_count_count_count_count_index = 0;\n  let paren_char_count_count_count_count_count = 0;\n  let paren_char_count_count_count_count_count_index = 0;\n  let paren_char_count_count_count_count_count_count = 0;\n  let paren_char_count_count_count_count_count_count_index = 0;\n  let paren_char_count_count_count_count_count_count_count = 0;\n  let paren_char_count_count_count_count_count_count_count_index = 0;\n  let paren_char_count_count_count_count_count_count_count_count = 0;\n  let paren_char_count_count_count_count_count_count_count_count_index = 0;\n  let paren_char_count_count_count_count_count_count_count_count_count = 0;\n  let paren_char_count_count_count_count_count_count_count_count_count_index = 0;\n  let paren_char_count_count_count_count_count_count_count_count_count_count = 0;\n  let paren_char_count_count_count_count_count_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpg5ybninx.rs:34:48\n   |\n34 |   let paren_char_count_count_count_count_count_\n   |                                                ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpg5ybninx.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let result = Vec::new();\n  for (i, paren in parens) {\n    let count = 0;\n    for (j, c in paren) {\n      if (c == '(') {\n        count += 1;\n      } else if (c == ')') {\n        count -= 1;\n      }\n      if (count == 0) {\n        result.push_back(j);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n --> /tmp/tmpz8o5gv23.rs:9:17\n  |\n9 |   for (i, paren in parens) {\n  |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n --> /tmp/tmpz8o5gv23.rs:9:7\n  |\n9 |   for (i, paren in parens) {\n  |       ^                  ^\n  |\nhelp: remove parentheses in `for` loop\n  |\n9 -   for (i, paren in parens) {\n9 +   for i, paren in parens {\n  | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpz8o5gv23.rs:11:15\n   |\n11 |     for (j, c in paren) {\n   |               ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpz8o5gv23.rs:11:9\n   |\n11 |     for (j, c in paren) {\n   |         ^             ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n11 -     for (j, c in paren) {\n11 +     for j, c in paren {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz8o5gv23.rs:12:10\n   |\n12 |       if (c == '(') {\n   |          ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -       if (c == '(') {\n12 +       if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz8o5gv23.rs:14:17\n   |\n14 |       } else if (c == ')') {\n   |                 ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -       } else if (c == ')') {\n14 +       } else if c == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz8o5gv23.rs:17:10\n   |\n17 |       if (count == 0) {\n   |          ^          ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (count == 0) {\n17 +       if count == 0 {\n   | \n\nerror[E0308]: mismatched types\n --> /tmp/tmpz8o5gv23.rs:9:7\n  |\n9 |   for (i, paren in parens) {\n  |       ^^^^^^^^^    ------ this expression has type `Option<&str>`\n  |       |\n  |       expected `str`, found tuple\n  |\n  = note: expected type `str`\n            found tuple `(_, _)`\n\nerror[E0599]: n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for i in paren_string.chars() {\n    if paren_stack.len() == 0 {\n      result.push(0);\n    }\n    let paren_level = paren_stack.pop();\n    if paren_string[i] == '(' {\n      paren_stack.push(paren_level + 1);\n    } else if paren_string[i] == ')' {\n      paren_stack.push(paren_level - 1);\n    }\n    result.push(paren_stack.len());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp1jhdsxzd.rs:15:8\n   |\n15 |     if paren_string[i] == '(' {\n   |        ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0369]: cannot add `{integer}` to `Option<{integer}>`\n  --> /tmp/tmp1jhdsxzd.rs:16:36\n   |\n16 |       paren_stack.push(paren_level + 1);\n   |                        ----------- ^ - {integer}\n   |                        |\n   |                        Option<{integer}>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp1jhdsxzd.rs:17:15\n   |\n17 |     } else if paren_string[i] == ')' {\n   |               ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0369]: cannot subtract `{integer}` from `Option<{integer}>`\n  --> /tmp/tmp1jhdsxzd.rs:18:36\n   |\n18 |       paren_stack.push(paren_level - 1);\n   |                        ----------- ^ - {integer}\n   |                        |\n   |                        Option<{integer}>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1jhdsxzd.rs:22:10\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec<isize>::new();\n  paren_count_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n    } else if (c == ')') {\n      paren_count += 1;\n      if (paren_stack.len() == 0) {\n        throw \"Invalid input string\";\n      }\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let paren_nesting = paren_count_stack.pop() - 1;\n      if (paren_nesting > max_nesting) {\n        max_nesting = paren_nesting;\n        max_nesting_index = paren_start;\n      }\n    }\n  }\n\n  if (paren_stack.len() != 0) {\n    throw \"Invalid input string\";\n  }\n\n  return max_nesting_index;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp7i3o_9mr.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmp7i3o_9mr.rs:12:30\n   |\n12 |   let paren_count_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n12 |   let paren_count_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmp7i3o_9mr.rs:15:8\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp7i3o_9mr.rs:15:12\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp7i3o_9mr.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp7i3o_9mr.rs:15:13\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp7i3o_9mr.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 7 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut level = 0;\n  let mut last_level = 0;\n  let mut last_paren = 0;\n  let mut last_paren_count = 0;\n  for idx in paren_string.iter() {\n    if paren_string[idx] == '(' {\n      level += 1;\n      last_level = level;\n      last_paren = idx;\n      last_paren_count = 1;\n    } else if paren_string[idx] == ')' {\n      level -= 1;\n      last_level = level;\n      last_paren = idx;\n      last_paren_count = 1;\n    } else if paren_string[idx] == ' ' {\n      if level == last_level {\n        result.push(last_paren_count);\n        last_paren_count = 0;\n      }\n    }\n  }\n  if last_level > 0 {\n    result.push(last_paren_count);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp1uqnbw91.rs:12:27\n   |\n12 |   for idx in paren_string.iter() {\n   |                           ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n12 |   for idx in paren_string.chars() {\n   |                           ~~~~~\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp1uqnbw91.rs:13:8\n   |\n13 |     if paren_string[idx] == '(' {\n   |        ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp1uqnbw91.rs:18:15\n   |\n18 |     } else if paren_string[idx] == ')' {\n   |               ^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp1uqnbw91.rs:23:15\n   |\n23 |     } else if paren_string[idx] == ' ' {\n   |               ^^^^^^^^^^^^^^^^^ `String` cannot be index",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      paren_stack.push(i);\n      paren_depth += 1;\n      if (paren_depth > max_nesting) {\n        max_nesting = paren_depth;\n      }\n    } else if (paren_string[i] == ')') {\n      paren_count -= 1;\n      paren_count_stack.pop();\n      paren_depth -= 1;\n      if (paren_depth < 0) {\n        panic(\"Invalid parentheses\");\n      }\n      if (paren_count_stack.len() == 0) {\n        paren_end = i;\n        paren_start = paren_stack.pop();\n        if (paren_count_stack.len() == 0) {\n          paren_count = 0;\n        } else {\n          paren_count = paren_count_stack.pop();\n        }\n      }\n    }\n  }\n\n  if (paren_stack.len() != 0) {\n    panic(\"Invalid parentheses\");\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < max_nesting; i++) {\n    result.push(paren_start - i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp0ovvvg41.rs:17:8\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp0ovvvg41.rs:17:12\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp0ovvvg41.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp0ovvvg41.rs:17:13\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp0ovvvg41.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec<isize>::new();\n  paren_count_stack.push(0);\n  let paren_stack_stack = Vec<isize>::new();\n  paren_stack_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count_stack.push(paren_count);\n      paren_stack_stack.push(paren_stack);\n      paren_count = 0;\n      paren_stack = Vec<isize>::new();\n      paren_start = i;\n      paren_end = i;\n    } else if (c == ')') {\n      paren_count = paren_count_stack.pop();\n      paren_stack = paren_stack_stack.pop();\n      paren_end = i;\n      if (paren_count_stack.len() > 0) {\n        paren_count_stack.pop();\n      }\n      if (paren_stack_stack.len() > 0) {\n        paren_stack_stack.pop();\n      }\n    } else {\n      paren_count += 1;\n      if (paren_count == 1) {\n        paren_start = i;\n      }\n    }\n  }\n  let result = Vec<isize>::new();\n  for (let i = paren_start; i < paren_end; i++) {\n    if (paren_string[i] == '(') {\n      result.push(paren_depth);\n      paren_depth += 1;\n    } else if (paren_string[i] == ')') {\n      paren_depth -= 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp2vmjevss.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmp2vmjevss.rs:12:30\n   |\n12 |   let paren_count_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n12 |   let paren_count_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmp2vmjevss.rs:14:30\n   |\n14 |   let paren_stack_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n14 |   let paren_stack_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmp2vmjevss.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp2vmjevss.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp2vmjevss.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp2vmjevss.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp2vmjevss.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: ab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut current_group = 0;\n  let mut current_group_start = 0;\n  let mut current_group_end = 0;\n  let mut current_group_paren_count = 0;\n  let mut current_group_paren_count_start = 0;\n  let mut current_group_paren_count_end = 0;\n  let mut current_group_paren_count_start_end = 0;\n  let mut current_group_paren_count_start_end_start = 0;\n  let mut current_group_paren_count_start_end_end = 0;\n  let mut current_group_paren_count_start_end_start_end = 0;\n  let mut current_group_paren_count_start_end_end_start = 0;\n  let mut current_group_paren_count_start_end_end_end = 0;\n  let mut current_group_paren_count_start_end_start_end_start = 0;\n  let mut current_group_paren_count_start_end_end_start_end_end = 0;\n  let mut current_group_paren_count_start_end_start_end_end_start = 0;\n  let mut current_group_paren_count_start_end_end_start_end_end_end = 0;\n  let mut current_group_paren_count_start_end_start_end_end_start_end = 0;\n  let mut current_group_paren_count_start_end_start_end_end_start_end_end = 0;\n  let mut current_group_paren_count_start_end_start_end_end_start_end_end_start = 0;\n  let mut current_group_paren_count_start_end_start_end_end_start_end_end_end = 0;\n  let mut current_group_paren_count_start_end_start_end_end_start_end_end_start_end = 0;\n  let mut current_group_paren_count_start_end_start_end_end_start_end_end_start\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpysljjygp.rs:30:80\n   |\n30 |   let mut current_group_paren_count_start_end_start_end_end_start_end_end_start\n   |                                                                                ^ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpysljjygp.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n    } else if (c == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let depth = paren_stack.len();\n      result.push(depth);\n      paren_stack.push(paren_start);\n      paren_stack.push(paren_end);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpwy10lw6d.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpwy10lw6d.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpwy10lw6d.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpwy10lw6d.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpwy10lw6d.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_count_stack = Vec<isize>::new();\n  let paren_level_stack = Vec<isize>::new();\n  paren_string.split_lines().for_each(|line| {\n    if (line.starts_with(\"(\")) {\n      paren_stack.push(paren_count);\n      paren_count_stack.push(paren_count);\n      paren_level_stack.push(paren_level);\n      paren_count = 0;\n      paren_level = 0;\n    } else if (line.starts_with(\")\")) {\n      paren_count = paren_count_stack.pop();\n      paren_level = paren_level_stack.pop();\n    } else {\n      paren_count += line.count(\"(\");\n      paren_count -= line.count(\")\");\n      paren_level += line.count(\"(\");\n      paren_level -= line.count(\")\");\n    }\n  });\n  paren_stack.pop();\n  paren_count_stack.pop();\n  paren_level_stack.pop();\n  return paren_stack;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmp4o13n66f.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmp4o13n66f.rs:10:30\n   |\n10 |   let paren_count_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n10 |   let paren_count_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmp4o13n66f.rs:11:30\n   |\n11 |   let paren_level_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n11 |   let paren_level_stack = Vec::<isize>::new();\n   |                              ++\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4o13n66f.rs:13:8\n   |\n13 |     if (line.starts_with(\"(\")) {\n   |        ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (line.starts_with(\"(\")) {\n13 +     if line.starts_with(\"(\") {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4o13n66f.rs:19:15\n   |\n19 |     } else if (line.starts_with(\")\")) {\n   |               ^                     ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (line.starts_with(\")\")) {\n19 +     } else if line.starts_with(\")\") {\n   | \n\nerror[E0599]: no method named `split_lines` found for struct `String` in the current scope\n  --> /tmp/tmp4o13n66f.rs:12:16\n   |\n12 |   paren_string.split_lines().for_each(|line| {\n   |                ^^^^^^^^^^^ help: there is an associated function with a similar name: `splitn`\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nFor m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n      current_nesting++;\n      if (current_nesting > max_nesting) {\n        max_nesting = current_nesting;\n        max_nesting_index = current_index;\n      }\n    } else if (c == ')') {\n      current_nesting--;\n      if (current_nesting < 0) {\n        throw \"Invalid parentheses\";\n      }\n      paren_count += 1;\n      if (paren_count_stack.len() > 0) {\n        paren_count = paren_count_stack.last();\n        paren_count_stack.pop();\n      }\n      if (paren_stack.len() > 0) {\n        let index = paren_stack.last();\n        paren_stack.pop();\n        current_index = index;\n      }\n    }\n  }\n\n  if (paren_stack.len() > 0) {\n    throw \"Invalid parentheses\";\n  }\n\n  return max_nesting_index;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpch_g13wx.rs:17:8\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpch_g13wx.rs:17:12\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpch_g13wx.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpch_g13wx.rs:17:13\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpch_g13wx.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(c);\n    } else if (c == ')') {\n      if (paren_stack.len() == 0) {\n        panic(\"Invalid input\");\n      }\n      let last = paren_stack.pop();\n      if (last != '(') {\n        max_nesting = max(max_nesting, paren_stack.len());\n      }\n    }\n  }\n  max_nesting = max(max_nesting, paren_stack.len());\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n --> /tmp/tmpn9x4j58p.rs:9:8\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n --> /tmp/tmpn9x4j58p.rs:9:12\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |           -^ expected one of `)`, `,`, `@`, or `|`\n  |           |\n  |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n --> /tmp/tmpn9x4j58p.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n --> /tmp/tmpn9x4j58p.rs:9:13\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n --> /tmp/tmpn9x4j58p.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let result = Vec::new();\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(i);\n    } else if (paren_string[i] == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let paren_count = paren_end - paren_start;\n      result.push(paren_count);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp18wgfdrc.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp18wgfdrc.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp18wgfdrc.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp18wgfdrc.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp18wgfdrc.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_index = 0;\n  let mut max_nesting_index_index_index = 0;\n  let mut max_nesting_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpn8aje_b3.rs:26:89\n   |\n26 |   let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_\n   |                                                                                         ^ help: add `;` here\n27 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpn8aje_b3.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_index = 0;\n  let paren_string_len = paren_string.len();\n  for (i in 0..paren_string_len) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count += 1;\n      current_nesting += 1;\n      if (current_nesting > max_nesting) {\n        max_nesting = current_nesting;\n        max_nesting_index = current_index;\n      }\n    } else if (c == ')') {\n      current_nesting -= 1;\n      if (current_nesting == 0) {\n        current_index = paren_stack.pop();\n        paren_count -= 1;\n      }\n    }\n  }\n  let result = Vec::new();\n  for (i in 0..max_nesting) {\n    result.push(max_nesting_index - i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpej8mu924.rs:15:10\n   |\n15 |   for (i in 0..paren_string_len) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpej8mu924.rs:15:7\n   |\n15 |   for (i in 0..paren_string_len) {\n   |       ^                        ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i in 0..paren_string_len) {\n15 +   for i in 0..paren_string_len {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpej8mu924.rs:34:10\n   |\n34 |   for (i in 0..max_nesting) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpej8mu924.rs:34:7\n   |\n34 |   for (i in 0..max_nesting) {\n   |       ^                   ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n34 -   for (i in 0..max_nesting) {\n34 +   for i in 0..max_nesting {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpej8mu924.rs:17:8\n   |\n17 |     if (c == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (c == '(') {\n17 +     if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpej8mu924.rs:21:10\n   |\n21 |       if (current_nesting > max_nesting) {\n   |          ^                             ^\n   |\nhelp: remove these parentheses\n   |\n21 -       if (current_nesting > max_nesting) {\n21 +       if current_nesting > max_nesting {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpej8mu924.rs:25:15\n   |\n25 |     } else if (c == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n25 -     } else if (c == ')') {\n25 +     } else if c == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpej8mu924.rs:27:10\n   |\n27 |       if (current_nesting == 0) {\n   |          ^                    ^\n   |\nhelp: remove th",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_depth_stack = Vec::new();\n  paren_depth_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count += 1;\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_depth_stack.push(paren_depth);\n    } else if (c == ')') {\n      paren_count -= 1;\n      paren_end = i;\n      if (paren_count == 0) {\n        paren_count = paren_count_stack.pop();\n        paren_depth = paren_depth_stack.pop();\n        paren_start = paren_stack.pop();\n        paren_end = i;\n      }\n    } else if (c == ' ') {\n      if (paren_count == 0) {\n        paren_count = paren_count_stack.pop();\n        paren_depth = paren_depth_stack.pop();\n        paren_start = paren_stack.pop();\n        paren_end = i;\n      }\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = paren_start; i < paren_end; i++) {\n    result.push(paren_depth);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmprvgg1e2l.rs:17:8\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmprvgg1e2l.rs:17:12\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmprvgg1e2l.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmprvgg1e2l.rs:17:13\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmprvgg1e2l.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_max = 0;\n  let paren_depth_max = 0;\n  let paren_start_max = 0;\n  let paren_end_max = 0;\n  let paren_count_max_prev = 0;\n  let paren_depth_max_prev = 0;\n  let paren_start_max_prev = 0;\n  let paren_end_max_prev = 0;\n  let paren_count_max_prev_prev = 0;\n  let paren_depth_max_prev_prev = 0;\n  let paren_start_max_prev_prev = 0;\n  let paren_end_max_prev_prev = 0;\n  let paren_count_max_prev_prev_prev = 0;\n  let paren_depth_max_prev_prev_prev = 0;\n  let paren_start_max_prev_prev_prev = 0;\n  let paren_end_max_prev_prev_prev = 0;\n  let paren_count_max_prev_prev_prev_prev = 0;\n  let paren_depth_max_prev_prev_prev_prev = 0;\n  let paren_start_max_prev_prev_prev_prev = 0;\n  let paren_end_max_prev_prev_prev_prev = 0;\n  let paren_count_max_prev_prev_prev_prev_prev = 0;\n  let paren_depth_max_prev_prev_prev_prev_prev = 0;\n  let paren_start_max_prev_prev_prev_prev_prev = 0;\n  let paren_end_max_prev_prev_prev_prev_prev = 0;\n  let paren_count_max_prev_prev_prev_prev_prev_prev = 0;\n  let paren_depth_max_prev_prev_prev_prev_prev_prev = 0;\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmps45z88sg.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror[E0308]: mismatched types\n --> /tmp/tmps45z88sg.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let max_nesting = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count = 0;\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(paren_count);\n      paren_count += 1;\n    } else if (i == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        paren_end = i;\n        max_nesting = paren_stack.pop();\n      }\n    }\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpmu12x8f1.rs:15:10\n   |\n15 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpmu12x8f1.rs:15:7\n   |\n15 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i in paren_string) {\n15 +   for i in paren_string {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmu12x8f1.rs:16:8\n   |\n16 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i == '(') {\n16 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmu12x8f1.rs:19:15\n   |\n19 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (i == ')') {\n19 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmu12x8f1.rs:21:10\n   |\n21 |       if (paren_count == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n21 -       if (paren_count == 0) {\n21 +       if paren_count == 0 {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpmu12x8f1.rs:15:13\n   |\n15 |   for (i in paren_string) {\n   |             ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmpmu12x8f1.rs:16:11\n   |\n16 |     if (i == '(') {\n   |           ^^ no implementation for `{integer} == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_of_open_paren = 0;\n  let mut max_nesting_index_of_close_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_close_paren = 0;\n  let mut max_nesting_index_of_close_paren_of_open_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_open_paren = 0;\n  let mut max_nesting_index_of_close_paren_of_open_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_close_paren = 0;\n  let mut max_nesting_index_of_close_paren_of_close_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_close_paren = 0;\n  let mut max_nesting_index_of_close_paren_of_open_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_open_paren = 0;\n  let mut max_nesting_index_of_close_paren_of_open_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_close_paren = 0;\n  let mut max_nesting_index_of_close_paren_of_close_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_open_paren = 0;\n  let mut max_nesting_index_of_close_paren_of_open_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_close_paren = 0;\n  let mut max_nesting_index_of_close_paren_of_close_paren = 0;\n  let mut max_nesting_index_of_open_paren_of_open_paren = 0;\n  let\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmp7ucnvls1.rs:31:1\n   |\n31 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for i in paren_string.iter() {\n    if i == '(' {\n      paren_stack.push(i);\n    } else if i == ')' {\n      paren_stack.pop();\n      if paren_stack.len() == 0 {\n        result.push(i - '0');\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpx3sqedzf.rs:10:25\n   |\n10 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmpx3sqedzf.rs:11:10\n   |\n11 |     if i == '(' {\n   |          ^^ no implementation for `{integer} == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx3sqedzf.rs:13:20\n   |\n13 |     } else if i == ')' {\n   |                    ^^^ expected integer, found `char`\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmpx3sqedzf.rs:13:17\n   |\n13 |     } else if i == ')' {\n   |                 ^^ no implementation for `{integer} == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: cannot subtract `char` from `{integer}`\n  --> /tmp/tmpx3sqedzf.rs:16:23\n   |\n16 |         result.push(i - '0');\n   |                       ^ no implementation for `{integer} - char`\n   |\n   = help: the trait `Sub<char>` is not implemented for `{integer}`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for i in paren_string.chars() {\n    if paren_stack.len() == 0 {\n      result.push(0);\n    }\n    if paren_stack.len() == 1 {\n      if paren_stack[0] == 0 {\n        paren_stack.push(1);\n      } else {\n        paren_stack.pop();\n        result.push(paren_stack.len());\n      }\n    }\n    if paren_stack.len() == 2 {\n      if paren_stack[0] == 0 {\n        paren_stack.push(1);\n      } else if paren_stack[1] == 0 {\n        paren_stack.pop();\n        result.push(paren_stack.len());\n      } else {\n        paren_stack.pop();\n        result.push(paren_stack.len());\n      }\n    }\n  }\n  result.push(paren_stack.len());\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmphdbd55az.rs:35:10\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                 ---------- expected `Vec<isize>` because of return type\n...\n35 |   return result;\n   |          ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_prev = 0;\n  let paren_depth_prev = 0;\n  let paren_start_prev = 0;\n  let paren_end_prev = 0;\n  let paren_count_next = 0;\n  let paren_depth_next = 0;\n  let paren_start_next = 0;\n  let paren_end_next = 0;\n  paren_string.chars().for_each(|c| {\n    if (c == '(') {\n      paren_count += 1;\n      paren_depth += 1;\n      paren_start = paren_end;\n      paren_count_prev = paren_count;\n      paren_depth_prev = paren_depth;\n      paren_start_prev = paren_start;\n      paren_end_prev = paren_end;\n    } else if (c == ')') {\n      paren_count -= 1;\n      paren_depth -= 1;\n      paren_end = paren_start;\n      paren_count_next = paren_count;\n      paren_depth_next = paren_depth;\n      paren_start_next = paren_start;\n      paren_end_next = paren_end;\n    }\n  });\n  let max_depth = paren_depth_prev;\n  let max_start = paren_start_prev;\n  let max_end = paren_end_prev;\n  let max_count = paren_count_prev;\n  for (let i = paren_count_next; i > 0; i -= 1) {\n    if (paren_depth_next > max_depth) {\n      max_depth = paren_depth_next;\n      max_start = paren_start_next;\n      max_end = paren_end_next;\n      max_count = i;\n    }\n    paren_depth_next = paren_depth_prev;\n    paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpiul0hllj.rs:59:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n43 |   for (let i = paren_count_next; i > 0; i -= 1) {\n   |                                                 - this delimiter might not be properly closed...\n...\n52 | }\n   | - ...as it matches this but it has different indentation\n...\n59 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpiul0hllj.rs:43:8\n   |\n43 |   for (let i = paren_count_next; i > 0; i -= 1) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpiul0hllj.rs:43:12\n   |\n43 |   for (let i = paren_count_next; i > 0; i -= 1) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpiul0hllj.rs:43:14\n   |\n43 |   for (let i = paren_count_next; i > 0; i -= 1) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpiul0hllj.rs:43:13\n   |\n43 |   for (let i = paren_count_next; i > 0; i -= 1) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpiul0hllj.rs:43:14\n   |\n43 |   for (let i = paren_count_next; i > 0; i -= 1) {\n   |              ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiul0hllj.rs:21:8\n   |\n21 |     if (c == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n21 -     if (c == '(') {\n21 +     if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiul0hllj.rs:29:15\n   |\n29 |     } else if (c == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n29 -     } else if (c == ')') {\n29 +     } else if c == ')' {\n   | \n\nerror: abort",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  for i in paren_string.iter() {\n    if i == '(' {\n      current_level += 1;\n    } else if i == ')' {\n      current_level -= 1;\n    }\n    if current_level == 0 {\n      result.push(i.len());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n --> /tmp/tmps4k9n7yg.rs:9:25\n  |\n9 |   for i in paren_string.iter() {\n  |                         ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n  |\n9 |   for i in paren_string.chars() {\n  |                         ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  for i in paren_string.iter() {\n    if i == '(' {\n      current_level += 1;\n    } else if i == ')' {\n      current_level -= 1;\n    }\n    if current_level == 0 {\n      result.push(i - '0');\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n --> /tmp/tmp3yaojb4i.rs:9:25\n  |\n9 |   for i in paren_string.iter() {\n  |                         ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n  |\n9 |   for i in paren_string.chars() {\n  |                         ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let current_nesting = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(current_nesting);\n      current_nesting += 1;\n    } else if (c == ')') {\n      current_nesting -= 1;\n      if (current_nesting < 0) {\n        panic!(\"Invalid parentheses string\");\n      }\n      if (paren_stack.len() == 0 || paren_stack.last() != current_nesting) {\n        panic!(\"Invalid parentheses string\");\n      }\n      paren_stack.pop();\n    }\n    if (current_nesting > max_nesting) {\n      max_nesting = current_nesting;\n    }\n  }\n  if (paren_stack.len() != 0) {\n    panic!(\"Invalid parentheses string\");\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpxgs3lrps.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpxgs3lrps.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpxgs3lrps.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpxgs3lrps.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpxgs3lrps.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut depth = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n      depth += 1;\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(depth);\n      } else if stack.last() == '(' {\n        stack.pop();\n        depth -= 1;\n      } else {\n        result.push(depth);\n      }\n    }\n  }\n  result.push(depth);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp_dv7b43f.rs:17:33\n   |\n17 |       } else if stack.last() == '(' {\n   |                                 ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&char>`\n              found type `char`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let paren_count = 0;\n  let paren_count_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n  let paren_count_stack_size = 0;\n  let paren_count_stack_size_index = 0;\n  let paren_count_stack_size_size = 0;\n  let paren_count_stack_size_size_index = 0;\n  let paren_count_stack_size_size_size = 0;\n  let paren_count_stack_size_size_size_index = 0;\n  let paren_count_stack_size_size_size_size = 0;\n  let paren_count_stack_size_size_size_size_index = 0;\n  let paren_count_stack_size_size_size_size_size = 0;\n  let paren_count_stack_size_size_size_size_size_index = 0;\n  let paren_count_stack_size_size_size_size_size_size = 0;\n  let paren_count_stack_size_size_size_size_size_size_index = 0;\n  let paren_count_stack_size_size_size_size_size_size_size = 0;\n  let paren_count_stack_size_size_size_size_size_size_size_index = 0;\n  let paren_count_stack_size_size_size_size_size_size_size_size = 0;\n  let paren_count_stack_size_size_size_size_size_size_size_size_index = 0;\n  let paren_count_stack_size_size_size_size_size_size_size_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_7445utw.rs:35:60\n   |\n35 |   let paren_count_stack_size_size_size_size_size_size_size_\n   |                                                            ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_7445utw.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut level = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      level += 1;\n    } else if (c == ')') {\n      level -= 1;\n    } else if (c == ' ' && level == 0) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n --> /tmp/tmpdpkeo17m.rs:9:8\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n --> /tmp/tmpdpkeo17m.rs:9:12\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |           -^ expected one of `)`, `,`, `@`, or `|`\n  |           |\n  |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n --> /tmp/tmpdpkeo17m.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n --> /tmp/tmpdpkeo17m.rs:9:13\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n --> /tmp/tmpdpkeo17m.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  for (i, paren in parens.iter()) {\n    if (paren == \"\") continue;\n    let nesting = 0;\n    for (j, c in paren.iter()) {\n      if (c == \")\") {\n        nesting--;\n      } else if (c == \"(\") {\n        nesting++;\n      }\n      if (nesting > max_nesting) {\n        max_nesting = nesting;\n        max_nesting_index = j;\n      }\n    }\n  }\n  let result = Vec::new();\n  for (i, paren in parens.iter()) {\n    if (paren == \"\") continue;\n    let nesting = 0;\n    for (j, c in paren.iter()) {\n      if (c == \")\") {\n        nesting--;\n      } else if (c == \"(\") {\n        nesting++;\n      }\n      if (nesting == max_nesting) {\n        result.push(i);\n        result.push(j);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpb4ewx367.rs:10:17\n   |\n10 |   for (i, paren in parens.iter()) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpb4ewx367.rs:10:7\n   |\n10 |   for (i, paren in parens.iter()) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (i, paren in parens.iter()) {\n10 +   for i, paren in parens.iter() {\n   | \n\nerror: expected `{`, found keyword `continue`\n  --> /tmp/tmpb4ewx367.rs:11:22\n   |\n11 |     if (paren == \"\") continue;\n   |     --               ^^^^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n11 |     if (paren == \"\") { continue };\n   |                      +          +\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpb4ewx367.rs:26:17\n   |\n26 |   for (i, paren in parens.iter()) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpb4ewx367.rs:26:7\n   |\n26 |   for (i, paren in parens.iter()) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n26 -   for (i, paren in parens.iter()) {\n26 +   for i, paren in parens.iter() {\n   | \n\nerror: expected `{`, found keyword `continue`\n  --> /tmp/tmpb4ewx367.rs:27:22\n   |\n27 |     if (paren == \"\") continue;\n   |     --               ^^^^^^^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n   |\nhelp: try placing this code inside a block\n   |\n27 |     if (paren == \"\") { continue };\n   |                      +          +\n\nerror[E0599]: no method named `iter` found for struct `std::str::Split` in the current scope\n  --> /tmp/tmpb4ewx367.rs:10:27\n   |\n10 |   for (i, paren in parens.iter()) {\n   |                           ^^^^ method not found in `std::str::Split<'_, &str>`\n\nerror[E0599]: no m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut level = 0;\n  let mut last_level = 0;\n  let mut last_group = 0;\n  let mut last_group_start = 0;\n  let mut last_group_end = 0;\n  let mut last_group_start_pos = 0;\n  let mut last_group_end_pos = 0;\n  let mut last_group_start_pos_pos = 0;\n  let mut last_group_end_pos_pos = 0;\n  let mut last_group_start_pos_pos_pos = 0;\n  let mut last_group_end_pos_pos_pos = 0;\n  let mut last_group_start_pos_pos_pos_pos = 0;\n  let mut last_group_end_pos_pos_pos_pos = 0;\n  let mut last_group_start_pos_pos_pos_pos_pos = 0;\n  let mut last_group_end_pos_pos_pos_pos_pos = 0;\n  let mut last_group_start_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_end_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_start_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_end_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_start_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_end_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_start_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_end_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_start_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut last_group_end_pos_pos_pos_pos_pos_pos_pos\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpn4eg29so.rs:32:53\n   |\n32 |   let mut last_group_end_pos_pos_pos_pos_pos_pos_pos\n   |                                                     ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpn4eg29so.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_prev = 0;\n  let paren_depth_prev = 0;\n  let paren_start_prev = 0;\n  let paren_end_prev = 0;\n  let paren_count_next = 0;\n  let paren_depth_next = 0;\n  let paren_start_next = 0;\n  let paren_end_next = 0;\n  let paren_count_next_prev = 0;\n  let paren_depth_next_prev = 0;\n  let paren_start_next_prev = 0;\n  let paren_end_next_prev = 0;\n  let paren_count_next_next = 0;\n  let paren_depth_next_next = 0;\n  let paren_start_next_next = 0;\n  let paren_end_next_next = 0;\n  let paren_count_next_next_prev = 0;\n  let paren_depth_next_next_prev = 0;\n  let paren_start_next_next_prev = 0;\n  let paren_end_next_next_prev = 0;\n  let paren_count_next_next_next = 0;\n  let paren_depth_next_next_next = 0;\n  let paren_start_next_next_next = 0;\n  let paren_end_next_next_next = 0;\n  let paren_count_next_next_next_prev = 0;\n  let paren_depth_next_next_next_prev = 0;\n  let paren_start_next_next_next_prev = 0;\n  let paren_end_next_next_next_prev = 0;\n  let paren_count_next_next_next_next = 0;\n  let paren_depth_next_next_next_next = 0;\n  let paren_start_next_next_next\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpce0s91_w.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpce0s91_w.rs:42:33\n   |\n42 |   let paren_start_next_next_next\n   |                                 ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpce0s91_w.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let result = Vec::new();\n  let paren_count = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count += 1;\n    } else if (c == ')') {\n      paren_stack.pop();\n      paren_count -= 1;\n    } else if (paren_stack.len() == 0) {\n      result.push(paren_count);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpid9yo4ok.rs:11:8\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpid9yo4ok.rs:11:12\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpid9yo4ok.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpid9yo4ok.rs:11:13\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpid9yo4ok.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  let paren_level_stack = Vec::new();\n  paren_count_stack.push(0);\n  paren_level_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      paren_level_stack.push(paren_level);\n      paren_stack.push(paren_start);\n      paren_start = i;\n      paren_level += 1;\n    } else if (i == ')') {\n      paren_count -= 1;\n      paren_count_stack.pop();\n      paren_level_stack.pop();\n      paren_end = i;\n      if (paren_count == 0) {\n        paren_stack.pop();\n        if (paren_stack.is_empty()) {\n          return paren_count_stack.pop();\n        }\n      }\n    }\n  }\n  return paren_count_stack.pop();\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpnrlu9bs2.rs:16:10\n   |\n16 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpnrlu9bs2.rs:16:7\n   |\n16 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n16 -   for (i in paren_string) {\n16 +   for i in paren_string {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnrlu9bs2.rs:17:8\n   |\n17 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (i == '(') {\n17 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnrlu9bs2.rs:24:15\n   |\n24 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n24 -     } else if (i == ')') {\n24 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnrlu9bs2.rs:29:10\n   |\n29 |       if (paren_count == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n29 -       if (paren_count == 0) {\n29 +       if paren_count == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnrlu9bs2.rs:31:12\n   |\n31 |         if (paren_stack.is_empty()) {\n   |            ^                      ^\n   |\nhelp: remove these parentheses\n   |\n31 -         if (paren_stack.is_empty()) {\n31 +         if paren_stack.is_empty() {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpnrlu9bs2.rs:16:13\n   |\n16 |   for (i in paren_string) {\n   |             ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmpnrlu9bs2.rs",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let max_nesting = 0;\n  let current_nesting = 0;\n  let current_paren = 0;\n  let current_char = 0;\n  let paren_string_len = paren_string.len();\n  for (current_char = 0; current_char < paren_string_len; current_char += 1) {\n    let current_char_as_char = paren_string[current_char];\n    if (current_char_as_char == '(') {\n      paren_stack.push(current_paren);\n      paren_count += 1;\n      current_paren += 1;\n      current_nesting += 1;\n    } else if (current_char_as_char == ')') {\n      current_nesting -= 1;\n      if (current_nesting == 0) {\n        current_paren -= 1;\n        if (paren_count > max_nesting) {\n          max_nesting = paren_count;\n        }\n        paren_count -= 1;\n      }\n    }\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppamyixuf.rs:14:21\n   |\n14 |   for (current_char = 0; current_char < paren_string_len; current_char += 1) {\n   |                     ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppamyixuf.rs:14:20\n   |\n14 |   for (current_char = 0; current_char < paren_string_len; current_char += 1) {\n   |                    ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppamyixuf.rs:14:21\n   |\n14 |   for (current_char = 0; current_char < paren_string_len; current_char += 1) {\n   |                     ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n      paren_count_stack_index++;\n    } else if (c == ')') {\n      paren_count++;\n      if (paren_count > max_nesting) {\n        max_nesting = paren_count;\n        max_nesting_index = paren_count_stack_index;\n      }\n      paren_count_stack_index--;\n      paren_count = paren_count_stack[paren_count_stack_index];\n      if (paren_stack.len() > 0) {\n        paren_stack.pop();\n        paren_count_stack.pop();\n      }\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < max_nesting_index; i++) {\n    result.push(max_nesting);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmptlr2x77r.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmptlr2x77r.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmptlr2x77r.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmptlr2x77r.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmptlr2x77r.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \")\") {\n      if stack.len() == 0 {\n        result.push_back(0);\n      } else {\n        result.push_back(stack.len() - 1);\n      }\n      stack.pop();\n    } else {\n      stack.push(paren.len());\n    }\n  }\n  if stack.len() != 0 {\n    result.push_back(stack.len());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpzkl71u1s.rs:23:3\n   |\n20 |     } else {\n   |            - this opening brace...\n21 |       stack.push(paren.len());\n22 |     }\n   |     - ...matches this closing brace\n23 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpzkl71u1s.rs:9:40\n   |\n9  |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n10 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpzkl71u1s.rs:6:60\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            ^ unclosed delimiter\n...\n13 |     if paren == \")\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let result = Vec::new();\n  for p in parens {\n    let parens_count = count_parens(p);\n    result.push(parens_count);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `count_parens` in this scope\n  --> /tmp/tmpxxbd7_au.rs:10:24\n   |\n10 |     let parens_count = count_parens(p);\n   |                        ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  paren_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n      paren_stack.push(paren_depth);\n      paren_depth = 0;\n      paren_start = i;\n    } else if (i == ')') {\n      paren_count = paren_count_stack.pop();\n      paren_depth = paren_stack.pop();\n      paren_end = i;\n    } else {\n      paren_count += 1;\n      if (paren_depth == 0) {\n        paren_start = i;\n      }\n      paren_depth += 1;\n    }\n  }\n  paren_count_stack.pop();\n  paren_stack.pop();\n  let result = Vec::new();\n  for (i in paren_count_stack) {\n    result.push(paren_count_stack[i]);\n  }\n  for (i in paren_stack) {\n    result.push(paren_stack[i]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpqbxe9gw5.rs:15:10\n   |\n15 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpqbxe9gw5.rs:15:7\n   |\n15 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i in paren_string) {\n15 +   for i in paren_string {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpqbxe9gw5.rs:37:10\n   |\n37 |   for (i in paren_count_stack) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpqbxe9gw5.rs:37:7\n   |\n37 |   for (i in paren_count_stack) {\n   |       ^                      ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n37 -   for (i in paren_count_stack) {\n37 +   for i in paren_count_stack {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpqbxe9gw5.rs:40:10\n   |\n40 |   for (i in paren_stack) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpqbxe9gw5.rs:40:7\n   |\n40 |   for (i in paren_stack) {\n   |       ^                ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n40 -   for (i in paren_stack) {\n40 +   for i in paren_stack {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqbxe9gw5.rs:16:8\n   |\n16 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i == '(') {\n16 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqbxe9gw5.rs:22:15\n   |\n22 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == ')') {\n22 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqbx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let result = Vec::new();\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      paren_level += 1;\n    } else if (c == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        paren_level -= 1;\n        if (paren_level == 0) {\n          result.push(paren_count_stack.pop());\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpltu8b7kr.rs:17:8\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpltu8b7kr.rs:17:12\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpltu8b7kr.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpltu8b7kr.rs:17:13\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpltu8b7kr.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_max = 0;\n  let paren_count_stack_max_max_index = 0;\n  let paren_count_stack_max_max_max = 0;\n  let paren_count_stack_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max_index = 0;\n  let paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpcuxsu17r.rs:33:12\n   |\n33 |   let paren\n   |            ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcuxsu17r.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(i);\n    } else if (paren_string[i] == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let paren_count = paren_end - paren_start;\n      result.push(paren_count);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmph0f9x4_l.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmph0f9x4_l.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmph0f9x4_l.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmph0f9x4_l.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmph0f9x4_l.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n    } else if (c == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let depth = paren_stack.len();\n      result.push(paren_end - paren_start);\n      if (depth > 0) {\n        paren_stack.push(i);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppw5nnc5j.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppw5nnc5j.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppw5nnc5j.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppw5nnc5j.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppw5nnc5j.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_max = 0;\n  let paren_count_stack_max_max_index = 0;\n  let paren_count_stack_max_max_max = 0;\n  let paren_count_stack_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max_index = 0;\n  let paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpcuxsu17r.rs:33:12\n   |\n33 |   let paren\n   |            ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcuxsu17r.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_group = 0;\n  let mut current_group = 0;\n  let mut current_group_start = 0;\n  let mut current_group_end = 0;\n  let mut current_group_start_index = 0;\n  let mut current_group_end_index = 0;\n  let mut current_group_start_index_in_paren = 0;\n  let mut current_group_end_index_in_paren = 0;\n  let mut current_group_start_index_in_paren_in_paren = 0;\n  let mut current_group_end_index_in_paren_in_paren = 0;\n  let mut current_group_start_index_in_paren_in_paren_in_paren = 0;\n  let mut current_group_end_index_in_paren_in_paren_in_paren = 0;\n  let mut current_group_start_index_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut current_group_end_index_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut current_group_start_index_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut current_group_end_index_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut current_group_start_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut current_group_end_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut current_group_start_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut current_group_end_index_in_paren_in_paren_in_paren_in_paren_in_paren_in\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpjgzm9l8k.rs:29:82\n   |\n29 |   let mut current_group_end_index_in_paren_in_paren_in_paren_in_paren_in_paren_in\n   |                                                                                  ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpjgzm9l8k.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(paren_count);\n      paren_count += 1;\n      paren_depth += 1;\n    } else if (paren_string[i] == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        paren_depth -= 1;\n      }\n      if (paren_depth == 0) {\n        paren_stack.pop();\n      }\n    }\n  }\n  return paren_stack;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp22e9k79c.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp22e9k79c.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp22e9k79c.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp22e9k79c.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp22e9k79c.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_depth = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(paren_count);\n      paren_count_stack.push(paren_count);\n      paren_count += 1;\n      paren_start = i;\n      paren_depth += 1;\n    } else if (i == ')') {\n      paren_count -= 1;\n      paren_end = i;\n      paren_depth -= 1;\n      if (paren_depth == 0) {\n        max_nesting = max(max_nesting, paren_count_stack.pop());\n      }\n    }\n  }\n  max_nesting = max(max_nesting, paren_count_stack.pop());\n  let result = Vec::new();\n  for (i in paren_stack) {\n    result.push(max_nesting - paren_count_stack.pop() + paren_count);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpnu15a4fm.rs:15:10\n   |\n15 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpnu15a4fm.rs:15:7\n   |\n15 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i in paren_string) {\n15 +   for i in paren_string {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpnu15a4fm.rs:33:10\n   |\n33 |   for (i in paren_stack) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpnu15a4fm.rs:33:7\n   |\n33 |   for (i in paren_stack) {\n   |       ^                ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n33 -   for (i in paren_stack) {\n33 +   for i in paren_stack {\n   | \n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpnu15a4fm.rs:27:23\n   |\n27 |         max_nesting = max(max_nesting, paren_count_stack.pop());\n   |                       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpnu15a4fm.rs:31:17\n   |\n31 |   max_nesting = max(max_nesting, paren_count_stack.pop());\n   |                 ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnu15a4fm.rs:16:8\n   |\n16 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i == '(') {\n16 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpnu15a4fm.rs:22:15\n   |\n22 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == ')') {\n22 +     } else if i ==",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_start = 0;\n  let mut max_nesting_index_end = 0;\n  let mut max_nesting_index_start_end = 0;\n  let mut max_nesting_index_start_end_index = 0;\n  let mut max_nesting_index_start_end_index_start = 0;\n  let mut max_nesting_index_start_end_index_end = 0;\n  let mut max_nesting_index_start_end_index_start_end = 0;\n  let mut max_nesting_index_start_end_index_start_end_index = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_start = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_end = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_start_end = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_start_end_index = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_start_end_index_start = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_start_end_index_end = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_start_end_index_start_end = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_start_end_index_start_end_index = 0;\n  let mut max_nesting_index_start_end_index_start_end_index_start_end_index_start_end_index_start = 0;\n  let mut max_nesting_index_start_end_index_start_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpsyol6ylt.rs:28:51\n   |\n28 |   let mut max_nesting_index_start_end_index_start_\n   |                                                   ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpsyol6ylt.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let paren_count = 0;\n  let paren_count_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n    } else if (i == ')') {\n      paren_count += 1;\n      if (paren_stack.is_empty()) {\n        throw \"Invalid input\";\n      }\n      let paren_count_in_stack = paren_count_stack.pop();\n      if (paren_count_in_stack != paren_count) {\n        throw \"Invalid input\";\n      }\n      paren_count = paren_count_in_stack;\n      if (paren_count > max_nesting) {\n        max_nesting = paren_count;\n        max_nesting_index = current_nesting_index;\n      }\n      current_nesting += 1;\n      if (current_nesting > max_nesting) {\n        max_nesting = current_nesting;\n        max_nesting_index = current_nesting_index;\n      }\n      current_nesting = current_nesting - 1;\n      current_nesting_index = paren_stack.pop();\n    }\n    current_char = i;\n  }\n  if (!paren_stack.is_empty()) {\n    throw \"Invalid input\";\n  }\n  return max_nesting_index;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp201hn8qf.rs:18:10\n   |\n18 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp201hn8qf.rs:18:7\n   |\n18 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n18 -   for (i in paren_string) {\n18 +   for i in paren_string {\n   | \n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid input\"`\n  --> /tmp/tmp201hn8qf.rs:26:15\n   |\n26 |         throw \"Invalid input\";\n   |               ^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid input\"`\n  --> /tmp/tmp201hn8qf.rs:30:15\n   |\n30 |         throw \"Invalid input\";\n   |               ^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid input\"`\n  --> /tmp/tmp201hn8qf.rs:48:11\n   |\n48 |     throw \"Invalid input\";\n   |           ^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp201hn8qf.rs:19:8\n   |\n19 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -     if (i == '(') {\n19 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp201hn8qf.rs:23:15\n   |\n23 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n23 -     } else if (i == ')') {\n23 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp201hn8qf.rs:25:10\n   |\n25 |       if (paren_stack.is_empty()) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n25 -       if (paren_stack.is_empty()) {\n25 +       if paren_stack.is_empty() {\n   | \n\nwarning: unn",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current = 0;\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_index = 0;\n  let mut max_nesting_index_index_index = 0;\n  let mut max_nesting_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index_index\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpohcoylbd.rs:26:106\n   |\n26 |   let mut max_nesting_index_index_index_index_index_index_index_index_index_index_index_index_index_index\n   |                                                                                                          ^ help: add `;` here\n27 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpohcoylbd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let max_nesting_count = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_nesting_count = 0;\n  let current_char = 0;\n  let paren_count = 0;\n  let paren_index = 0;\n  let paren_count_index = 0;\n  let paren_count_count = 0;\n  let paren_count_count_index = 0;\n  let paren_count_count_count = 0;\n  let paren_count_count_count_index = 0;\n  let paren_count_count_count_count = 0;\n  let paren_count_count_count_count_index = 0;\n  let paren_count_count_count_count_count = 0;\n  let paren_count_count_count_count_count_index = 0;\n  let paren_count_count_count_count_count_count = 0;\n  let paren_count_count_count_count_count_count_index = 0;\n  let paren_count_count_count_count_count_count_count = 0;\n  let paren_count_count_count_count_count_count_count_index = 0;\n  let paren_count_count_count_count_count_count_count_count = 0;\n  let paren_count_count_count_count_count_count_count_count_index = 0;\n  let paren_count_count_count_count_count_count_count_count_count = 0;\n  let paren_count_count_count_count_count_count_count_count_count_index = 0;\n  let paren_count_count_count_count_count_count_count_count_count_count = 0;\n  let paren_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let p\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp8mk7oepq.rs:37:8\n   |\n37 |   let p\n   |        ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8mk7oepq.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n    } else if (c == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let depth = paren_stack.len();\n      result.push(paren_end - paren_start);\n      if (depth > 0) {\n        paren_stack.push(i);\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppw5nnc5j.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppw5nnc5j.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppw5nnc5j.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppw5nnc5j.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppw5nnc5j.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_prev = 0;\n  let mut max_level_index_next = 0;\n  let mut max_level_index_next_prev = 0;\n  let mut max_level_index_next_next = 0;\n  let mut max_level_index_next_next_prev = 0;\n  let mut max_level_index_next_next_next = 0;\n  let mut max_level_index_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpx4a5tru4.rs:31:31\n   |\n31 |   let mut max_level_index_next\n   |                               ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpx4a5tru4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let result = Vec::new();\n  let max_nesting = 0;\n  for (let paren in parens) {\n    let nesting = count_nested_parens(paren);\n    if (nesting > max_nesting) {\n      max_nesting = nesting;\n    }\n    result.push(nesting);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpqrtzf414.rs:10:8\n   |\n10 |   for (let paren in parens) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `paren`\n  --> /tmp/tmpqrtzf414.rs:10:12\n   |\n10 |   for (let paren in parens) {\n   |           -^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpqrtzf414.rs:10:18\n   |\n10 |   for (let paren in parens) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpqrtzf414.rs:10:7\n   |\n10 |   for (let paren in parens) {\n   |       ^                   ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (let paren in parens) {\n10 +   for let paren in parens {\n   | \n\nerror[E0425]: cannot find function `count_nested_parens` in this scope\n  --> /tmp/tmpqrtzf414.rs:11:19\n   |\n11 |     let nesting = count_nested_parens(paren);\n   |                   ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqrtzf414.rs:12:8\n   |\n12 |     if (nesting > max_nesting) {\n   |        ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (nesting > max_nesting) {\n12 +     if nesting > max_nesting {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqrtzf414.rs:10:7\n   |\n10 |   for (let paren in parens) {\n   |       ^^^^^^^^^^    ------ this expression has type `Option<&str>`\n   |       |\n   |       expected `str`, found tuple\n   |\n   = note: expected type `str`\n             found tuple `(_, _)`\n\nerror: aborting due to 6 previous errors; 1 warning emitted\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \")\") {\n      if !stack.is_empty() {\n        stack.pop();\n      }\n      result.push(stack.is_empty() ? 0 : stack.last());\n    } else {\n      stack.push(stack.is_empty() ? 0 : stack.last() + 1);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpwde29xkn.rs:21:3\n   |\n18 |     } else {\n   |            - this opening brace...\n19 |       stack.push(stack.is_empty() ? 0 : stack.last() + 1);\n20 |     }\n   |     - ...matches this closing brace\n21 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpwde29xkn.rs:9:40\n   |\n9  |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n10 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpwde29xkn.rs:6:60\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            ^ unclosed delimiter\n...\n13 |     if paren == \")\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n  let result = Vec::new();\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count_stack_index++;\n      paren_count++;\n    } else if (paren_string[i] == ')') {\n      paren_count_stack_index--;\n      paren_count = paren_count_stack[paren_count_stack_index];\n      if (paren_count > max_nesting) {\n        max_nesting = paren_count;\n        max_nesting_index = paren_stack.len() - 1;\n      }\n      paren_stack.pop();\n    }\n  }\n  for (let i = max_nesting_index; i >= 0; i--) {\n    result.push_back(paren_count_stack[i]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp8_17mcwo.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp8_17mcwo.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp8_17mcwo.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp8_17mcwo.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp8_17mcwo.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count_stack = Vec<isize>::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack_max = 0;\n\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_max = 0;\n\n  let paren_count_stack_max_max_index = 0;\n\n  let paren_count_stack_max_max_max = 0;\n\n  let paren_count_stack_max_max_max_index = 0;\n\n  let paren_count_stack_max_max_max_max = 0;\n\n  let paren_count_stack_max_max_max_max_index = 0;\n\n  let paren_count_stack_max_max_max_max_max = 0;\n\n  let paren_count_stack_max_max_max_max_max_index = 0;\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      paren_count_stack_index = paren_count_stack.len() - 1;\n      paren_count_stack_max = paren_count_stack_max_index;\n      paren_count_stack_max_max = paren_count_stack_max_max_index;\n      paren_count_stack_max_max_max = paren_count_stack_max_max_max_index;\n      paren_count_stack_max_max_max_max = paren_count_stack_max_max_max_max_index;\n      paren_count_stack_max_max_max_max_max = paren_count_stack_max\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpjvr1ai3d.rs:53:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n35 |   for (let i = 0; i < paren_string.len(); i++) {\n   |                                                - unclosed delimiter\n36 |     let c = paren_string[i];\n37 |     if (c == '(') {\n   |                   - this delimiter might not be properly closed...\n...\n46 | }\n   | - ...as it matches this but it has different indentation\n...\n53 | }\n   |   ^\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpjvr1ai3d.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpjvr1ai3d.rs:12:30\n   |\n12 |   let paren_count_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n12 |   let paren_count_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpjvr1ai3d.rs:35:8\n   |\n35 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpjvr1ai3d.rs:35:12\n   |\n35 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpjvr1ai3d.rs:35:14\n   |\n35 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpjvr1ai3d.rs:35:13\n   |\n35 |   for (let i = 0; i < paren_string.len(); i+",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let result = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count += 1;\n    } else if (c == ')') {\n      paren_stack.pop();\n      paren_count -= 1;\n      if (paren_stack.len() == 0) {\n        result.push(paren_depth);\n        paren_depth = 0;\n      } else {\n        paren_depth += 1;\n      }\n    }\n  }\n  result.push(paren_depth);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp0uheq6h_.rs:12:8\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp0uheq6h_.rs:12:12\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp0uheq6h_.rs:12:14\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp0uheq6h_.rs:12:13\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp0uheq6h_.rs:12:14\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec<isize>::new();\n  let paren_level_stack = Vec<isize>::new();\n  let paren_start_stack = Vec<isize>::new();\n  let paren_end_stack = Vec<isize>::new();\n  paren_stack.push(0);\n  paren_count_stack.push(0);\n  paren_level_stack.push(0);\n  paren_start_stack.push(0);\n  paren_end_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_count += 1;\n      paren_level += 1;\n      paren_start = paren_end;\n      paren_end = paren_start + 1;\n      paren_count_stack.push(paren_count);\n      paren_level_stack.push(paren_level);\n      paren_start_stack.push(paren_start);\n      paren_end_stack.push(paren_end);\n    } else if (i == ')') {\n      paren_count -= 1;\n      paren_level -= 1;\n      if (paren_count == 0) {\n        paren_end = paren_start_stack.pop();\n        paren_start = paren_end_stack.pop();\n        paren_count = paren_count_stack.pop();\n        paren_level = paren_level_stack.pop();\n        paren_end = paren_start + 1;\n        paren_start_stack.push(paren_start);\n        paren_end_stack.push(paren_end);\n        paren_count_stack.push(paren_count);\n        paren_level_stack.push(paren_level);\n      }\n    }\n  }\n  let result = Vec<isize>::new();\n  for (i in paren_stack) {\n    result.push(paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbr9p5nol.rs:57:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n48 |   for (i in paren_stack) {\n   |                          - this delimiter might not be properly closed...\n49 |     result.push(paren\n50 | }\n   | - ...as it matches this but it has different indentation\n...\n57 | }\n   |   ^\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpbr9p5nol.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpbr9p5nol.rs:12:30\n   |\n12 |   let paren_count_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n12 |   let paren_count_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpbr9p5nol.rs:13:30\n   |\n13 |   let paren_level_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n13 |   let paren_level_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpbr9p5nol.rs:14:30\n   |\n14 |   let paren_start_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n14 |   let paren_start_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpbr9p5nol.rs:15:28\n   |\n15 |   let paren_end_stack = Vec<isize>::new();\n   |                            ^     ^\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_start = 0;\n  let paren_count_end = 0;\n  let paren_count_start_end = 0;\n  let paren_count_start_end_start = 0;\n  let paren_count_start_end_end = 0;\n  let paren_count_start_end_start_end = 0;\n  let paren_count_start_end_end_start = 0;\n  let paren_count_start_end_end_end = 0;\n  let paren_count_start_end_start_end_start = 0;\n  let paren_count_start_end_end_start_end_end = 0;\n  let paren_count_start_end_start_end_start_end = 0;\n  let paren_count_start_end_end_start_end_end = 0;\n  let paren_count_start_end_start_end_start_end_start = 0;\n  let paren_count_start_end_end_start_end_end_start = 0;\n  let paren_count_start_end_start_end_start_end_end = 0;\n  let paren_count_start_end_start_end_start_end_start_end = 0;\n  let paren_count_start_end_start_end_start_end_end_start = 0;\n  let paren_count_start_end_start_end_start_end_end_end = 0;\n  let paren_count_start_end_start_end_start_end_start_end_start = 0;\n  let paren_count_start_end_start_end_start_end_end_start_end_end = 0;\n  let paren_count_start_end_start_end_start_end_start_end\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpu1vv7aaq.rs:34:58\n   |\n34 |   let paren_count_start_end_start_end_start_end_start_end\n   |                                                          ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpu1vv7aaq.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_len = 0;\n  let paren_depth = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_count++;\n      paren_stack.push(paren_count);\n      paren_start = i;\n      paren_end = i;\n      paren_len = 1;\n      paren_depth = paren_stack.last();\n    } else if (paren_string[i] == ')') {\n      paren_count--;\n      if (paren_count == 0) {\n        paren_count_stack.pop();\n        paren_end = i;\n        paren_len = i - paren_start + 1;\n        if (paren_len > max_nesting) {\n          max_nesting = paren_len;\n        }\n        if (paren_depth == paren_stack.last()) {\n          paren_stack.pop();\n        }\n      }\n    }\n  }\n  return paren_stack.map(x => x - 1);\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp46jdzebf.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp46jdzebf.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp46jdzebf.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp46jdzebf.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp46jdzebf.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let paren_count = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(paren_count);\n      paren_count += 1;\n    } else if (paren_string[i] == ')') {\n      paren_count -= 1;\n      if (paren_count < 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      if (paren_stack.len() == 0 || paren_stack.last() != paren_count) {\n        panic!(\"Mismatched parentheses\");\n      }\n      paren_stack.pop();\n      if (paren_stack.len() > max_nesting) {\n        max_nesting = paren_stack.len();\n      }\n    }\n  }\n  if (paren_stack.len() != 0) {\n    panic!(\"Mismatched parentheses\");\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp0g8c2563.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp0g8c2563.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp0g8c2563.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp0g8c2563.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp0g8c2563.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let current_char_index = 0;\n  let paren_count = 0;\n  let paren_count_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(current_nesting);\n      current_nesting += 1;\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      current_char_index += 1;\n    } else if (i == ')') {\n      current_nesting -= 1;\n      paren_count = paren_count_stack.pop();\n      paren_count_index = paren_count_stack.pop();\n      if (paren_count_index > max_nesting_index) {\n        max_nesting_index = paren_count_index;\n        max_nesting = paren_count;\n      }\n      if (current_nesting == 0) {\n        current_char_index += 1;\n      }\n    } else {\n      current_char_index += 1;\n    }\n  }\n  return max_nesting_index;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp7w_w5eyg.rs:19:10\n   |\n19 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp7w_w5eyg.rs:19:7\n   |\n19 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n19 -   for (i in paren_string) {\n19 +   for i in paren_string {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7w_w5eyg.rs:20:8\n   |\n20 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (i == '(') {\n20 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7w_w5eyg.rs:26:15\n   |\n26 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n26 -     } else if (i == ')') {\n26 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7w_w5eyg.rs:30:10\n   |\n30 |       if (paren_count_index > max_nesting_index) {\n   |          ^                                     ^\n   |\nhelp: remove these parentheses\n   |\n30 -       if (paren_count_index > max_nesting_index) {\n30 +       if paren_count_index > max_nesting_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7w_w5eyg.rs:34:10\n   |\n34 |       if (current_nesting == 0) {\n   |          ^                    ^\n   |\nhelp: remove these parentheses\n   |\n34 -       if (current_nesting == 0) {\n34 +       if current_nesting == 0 {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp7w_w5eyg.rs:19:13\n   |\n19 |   for (i in paren_string) {\n   |             ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E03",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_stack_stack = Vec::new();\n  paren_stack_stack.push(paren_stack);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count += 1;\n      paren_stack.push(paren_count);\n      paren_count_stack.push(paren_count);\n      paren_level += 1;\n      paren_stack_stack.push(paren_stack);\n      paren_start = i;\n    } else if (c == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        paren_end = i;\n        let paren_count_stack_top = paren_count_stack.pop();\n        let paren_stack_stack_top = paren_stack_stack.pop();\n        let paren_count_stack_top_val = paren_count_stack_top.pop();\n        let paren_stack_stack_top_val = paren_stack_stack_top.pop();\n        let paren_count_stack_top_val_val = paren_count_stack_top_val.pop();\n        let paren_stack_stack_top_val_val = paren_stack_stack_top_val.pop();\n        let paren_count_stack_top_val_val_val = paren_count_stack_top_val_val.pop();\n        let paren_stack_stack_top_val_val_val = paren_stack_stack_top_val_val.pop();\n        let paren_count_stack_top_val_val_val_val = paren_count_stack_top_val_val_val.pop();\n        let paren_stack_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcekag6jx.rs:47:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |                                                - unclosed delimiter\n...\n26 |     } else if (c == ')') {\n   |                          - unclosed delimiter\n27 |       paren_count -= 1;\n28 |       if (paren_count == 0) {\n   |                             - this delimiter might not be properly closed...\n...\n40 | }\n   | - ...as it matches this but it has different indentation\n...\n47 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpcekag6jx.rs:17:8\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpcekag6jx.rs:17:12\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpcekag6jx.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcekag6jx.rs:17:13\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpcekag6jx.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut level = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      level += 1;\n    } else if (paren_string[i] == ')') {\n      level -= 1;\n    }\n    if (level == 0) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n --> /tmp/tmpb_ve0i6s.rs:9:8\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n --> /tmp/tmpb_ve0i6s.rs:9:12\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |           -^ expected one of `)`, `,`, `@`, or `|`\n  |           |\n  |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n --> /tmp/tmpb_ve0i6s.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n --> /tmp/tmpb_ve0i6s.rs:9:13\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n --> /tmp/tmpb_ve0i6s.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut count = 0;\n  for i in paren_string.iter() {\n    if i == '(' {\n      stack.push(count);\n      count += 1;\n    } else if i == ')' {\n      count -= 1;\n      if count == 0 {\n        result.push(stack.pop());\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpgxrkr578.rs:10:25\n   |\n10 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgxrkr578.rs:21:10\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                 ---------- expected `Vec<isize>` because of return type\n...\n21 |   return result;\n   |          ^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<{integer}>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  let paren_depth_stack = Vec::new();\n\n  for (i, c in paren_string.iter()) {\n    if (c == '(') {\n      paren_stack.push(paren_count);\n      paren_count_stack.push(paren_count);\n      paren_depth_stack.push(paren_depth);\n      paren_count += 1;\n      paren_depth += 1;\n      paren_start = i;\n    } else if (c == ')') {\n      paren_count -= 1;\n      paren_depth -= 1;\n      paren_end = i;\n    }\n  }\n\n  let max_depth = 0;\n  let max_depth_start = 0;\n  let max_depth_end = 0;\n  for (i, depth in paren_depth_stack.iter()) {\n    if (depth > max_depth) {\n      max_depth = depth;\n      max_depth_start = paren_start;\n      max_depth_end = paren_end;\n    }\n  }\n\n  let max_count = 0;\n  let max_count_start = 0;\n  let max_count_end = 0;\n  for (i, count in paren_count_stack.iter()) {\n    if (count > max_count) {\n      max_count = count;\n      max_count_start = paren_start;\n      max_count_end = paren_end;\n    }\n  }\n\n  let max_depth_count = 0;\n  let max_depth_count_start = 0;\n  let max_depth_count_end = 0;\n  for (i, depth in paren_depth_stack.iter()) {\n    if (depth == max_depth) {\n      max_depth_count += 1;\n      max_depth_count_start = paren_start;\n      max_depth_count_end =\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdccsq6n8.rs:67:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n55 |   for (i, depth in paren_depth_stack.iter()) {\n   |                                              - unclosed delimiter\n56 |     if (depth == max_depth) {\n   |                             - this delimiter might not be properly closed...\n...\n60 | }\n   | - ...as it matches this but it has different indentation\n...\n67 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpdccsq6n8.rs:15:13\n   |\n15 |   for (i, c in paren_string.iter()) {\n   |             ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpdccsq6n8.rs:15:7\n   |\n15 |   for (i, c in paren_string.iter()) {\n   |       ^                           ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i, c in paren_string.iter()) {\n15 +   for i, c in paren_string.iter() {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpdccsq6n8.rs:33:17\n   |\n33 |   for (i, depth in paren_depth_stack.iter()) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpdccsq6n8.rs:33:7\n   |\n33 |   for (i, depth in paren_depth_stack.iter()) {\n   |       ^                                    ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n33 -   for (i, depth in paren_depth_stack.iter()) {\n33 +   for i, depth in paren_depth_stack.iter() {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpdccsq6n8.rs:44:17\n   |\n44 |   for (i, count in paren_count_stack.iter()) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpdccsq6n8.rs:44:7\n   |\n44 |   for (i, count in paren_count_stack.iter()) {\n   |       ^       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  for i in paren_string.iter() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(0);\n      } else {\n        result.push(stack.pop());\n      }\n    }\n  }\n  if !stack.is_empty() {\n    result.push_back(stack.pop());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n --> /tmp/tmpthg11211.rs:9:25\n  |\n9 |   for i in paren_string.iter() {\n  |                         ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n  |\n9 |   for i in paren_string.chars() {\n  |                         ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpthg11211.rs:16:21\n   |\n16 |         result.push(stack.pop());\n   |                     ^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<{integer}>` in the current scope\n  --> /tmp/tmpthg11211.rs:21:12\n   |\n21 |     result.push_back(stack.pop());\n   |            ^^^^^^^^^ method not found in `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_max = 0;\n  let paren_count_stack_max_max_index = 0;\n  let paren_count_stack_max_max_max = 0;\n  let paren_count_stack_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmps2kd7390.rs:34:41\n   |\n34 |   let paren_count_stack_max_max_max_max_\n   |                                         ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmps2kd7390.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let result = Vec::new();\n  let max_nesting = 0;\n  for p in parens {\n    let parens = p.split(\"(\");\n    let nesting = 0;\n    for p in parens {\n      if p == \")\") {\n        nesting--;\n      } else if p == \"(\") {\n        nesting++;\n      }\n      if nesting > max_nesting {\n        max_nesting = nesting;\n      }\n    }\n    result.push_back(max_nesting);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp0uz1yql_.rs:24:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - this opening brace...\n...\n22 |     }\n   |     - ...matches this closing brace\n23 |     result.push_back(max_nesting);\n24 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp0uz1yql_.rs:13:21\n   |\n13 |     for p in parens {\n   |                     ^ unclosed delimiter\n14 |       if p == \")\") {\n   |                  ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp0uz1yql_.rs:10:19\n   |\n10 |   for p in parens {\n   |                   ^ unclosed delimiter\n...\n16 |       } else if p == \"(\") {\n   |                         ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      stack.push(c);\n    } else if (c == ')') {\n      if (stack.len() == 0) {\n        result.push(max_nesting);\n        max_nesting = 0;\n        max_nesting_index = 0;\n      } else {\n        max_nesting = max(max_nesting, stack.len());\n        max_nesting_index = stack.len();\n        stack.pop();\n      }\n    }\n  }\n\n  if (stack.len() != 0) {\n    result.push(max_nesting);\n  }\n\n  result.push(max_nesting_index);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpcci71s_1.rs:12:8\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpcci71s_1.rs:12:12\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpcci71s_1.rs:12:14\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcci71s_1.rs:12:13\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpcci71s_1.rs:12:14\n   |\n12 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n\n  let mut result = Vec::new();\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n    } else if (c == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let paren_len = paren_end - paren_start;\n      result.push(paren_len);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp__6a4nxh.rs:11:8\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp__6a4nxh.rs:11:12\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp__6a4nxh.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp__6a4nxh.rs:11:13\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp__6a4nxh.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut count = 0;\n  let mut max_count = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(count);\n      count += 1;\n    } else if i == ')' {\n      count -= 1;\n      if count == 0 {\n        result.push(stack.pop());\n        max_count = max(max_count, stack.pop());\n      } else {\n        stack.push(count);\n      }\n    }\n  }\n  result.push(max_count);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpxkgo2_4q.rs:19:21\n   |\n19 |         max_count = max(max_count, stack.pop());\n   |                     ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxkgo2_4q.rs:25:15\n   |\n25 |   result.push(max_count);\n   |               ^^^^^^^^^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<{integer}>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n25 |   result.push(Some(max_count));\n   |               +++++         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxkgo2_4q.rs:26:10\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                 ---------- expected `Vec<isize>` because of return type\n...\n26 |   return result;\n   |          ^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<{integer}>>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for i in paren_string.iter() {\n    if paren_stack.len() == 0 {\n      result.push(0);\n    } else {\n      let paren_level = paren_stack.last();\n      if paren_string[i] == '(' {\n        paren_stack.push(paren_level + 1);\n      } else if paren_string[i] == ')' {\n        paren_stack.pop();\n        if paren_stack.len() == 0 {\n          result.push(paren_level);\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpywfmt632.rs:10:25\n   |\n10 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror[E0369]: cannot add `{integer}` to `Option<&{integer}>`\n  --> /tmp/tmpywfmt632.rs:16:38\n   |\n16 |         paren_stack.push(paren_level + 1);\n   |                          ----------- ^ - {integer}\n   |                          |\n   |                          Option<&{integer}>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpywfmt632.rs:20:23\n   |\n20 |           result.push(paren_level);\n   |                       ^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<&{integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n    } else if (c == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let depth = paren_stack.len();\n      result.push(depth);\n      paren_stack.push(paren_start);\n      paren_stack.push(paren_end);\n    }\n  }\n  result.push(paren_stack.len());\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpp8p63mbx.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpp8p63mbx.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpp8p63mbx.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpp8p63mbx.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpp8p63mbx.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  for (let chr of paren_string) {\n    if (chr == '(') {\n      stack.push(level);\n      level += 1;\n    } else if (chr == ')') {\n      level -= 1;\n      if (level == 0) {\n        result.push(stack.pop());\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpk8tzq_s5.rs:10:8\n   |\n10 |   for (let chr of paren_string) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `chr`\n  --> /tmp/tmpk8tzq_s5.rs:10:12\n   |\n10 |   for (let chr of paren_string) {\n   |           -^^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpk8tzq_s5.rs:10:16\n   |\n10 |   for (let chr of paren_string) {\n   |               -^^ expected one of `)`, `,`, `@`, or `|`\n   |               |\n   |               help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `paren_string`\n  --> /tmp/tmpk8tzq_s5.rs:10:19\n   |\n10 |   for (let chr of paren_string) {\n   |                  -^^^^^^^^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |                  |\n   |                  help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpk8tzq_s5.rs:10:32\n   |\n10 |   for (let chr of paren_string) {\n   |                                ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpk8tzq_s5.rs:21:3\n   |\n21 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n21 |   { return result; }\n   |   +                +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max = 0;\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_count_stack_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp6fy6osy9.rs:56:25\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - closing delimiter possibly meant for this\n...\n56 |   paren_count_stack.push(0\n   |                         ^ unclosed delimiter\n57 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6fy6osy9.rs:56:3\n   |\n6  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                   ---------- expected `Vec<isize>` because of return type\n...\n56 | /   paren_count_stack.push(0\n57 | | }\n   | |_^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_count = 0;\n  let mut max_level_count_index = 0;\n  let mut max_level_count_count = 0;\n  let mut max_level_count_count_index = 0;\n  let mut max_level_count_count_count = 0;\n  let mut max_level_count_count_count_index = 0;\n  let mut max_level_count_count_count_count = 0;\n  let mut max_level_count_count_count_count_index = 0;\n  let mut max_level_count_count_count_count_count = 0;\n  let mut max_level_count_count_count_count_count_index = 0;\n  let mut max_level_count_count_count_count_count_count = 0;\n  let mut max_level_count_count_count_count_count_count_index = 0;\n  let mut max_level_count_count_count_count_count_count_count = 0;\n  let mut max_level_count_count_count_count_count_count_count_index = 0;\n  let mut max_level_count_count_count_count_count_count_count_count = 0;\n  let mut max_level_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_level_count_count_count_count_count_count_count_count_count = 0;\n  let mut max_level_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_level_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut max_level_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_level_count_count_count_count_count_count_count_count_count_count_count = 0\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpx5y0tys3.rs:31:90\n   |\n31 |   let mut max_level_count_count_count_count_count_count_count_count_count_count_count = 0\n   |                                                                                          ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpx5y0tys3.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      current_level += 1;\n      if (current_level > max_level) {\n        max_level = current_level;\n      }\n    } else if (paren_string[i] == ')') {\n      current_level -= 1;\n    }\n    if (current_level == 0) {\n      result.push(max_level);\n      max_level = 0;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpc2etdpyo.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpc2etdpyo.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpc2etdpyo.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpc2etdpyo.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpc2etdpyo.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren = 0;\n  for (i in paren_string) {\n    if (i == '(') {\n      current_level += 1;\n      if (current_level > max_level) {\n        max_level = current_level;\n        max_level_index = i.len();\n        max_level_index_in_paren = 0;\n        max_level_index_in_paren_in_paren = 0;\n        max_level_index_in_paren_in_paren_in_paren = 0;\n        max_level_index_in_paren_in_paren_in_paren_in_paren = 0;\n      }\n    } else if (i == ')') {\n      current_level -= 1;\n      if (current_level < max_level) {\n        max_level = current_level;\n        max_level_index = i.len();\n        max_level_index_in_paren = 0;\n        max_level_index_in_paren_in_paren = 0;\n        max_level_index_in_paren_in_paren_in_paren = 0;\n        max_level_index_in_paren_in_paren_in_paren_in_paren = 0;\n      }\n    } else if (i == ' ') {\n      if (current_level == max_level) {\n        result.push(max_level_index);\n      }\n    } else if (i == '(') {\n      if (current_level == max_level) {\n        max_level_index_in_paren += 1;\n      }\n    } else if (i == ')') {\n      if\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbq2gyntw.rs:53:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n15 |   for (i in paren_string) {\n   |                           - unclosed delimiter\n...\n44 |     } else if (i == ')') {\n   |                          - this delimiter might not be properly closed...\n45 |       if\n46 | }\n   | - ...as it matches this but it has different indentation\n...\n53 | }\n   |   ^\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpbq2gyntw.rs:15:10\n   |\n15 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpbq2gyntw.rs:15:7\n   |\n15 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i in paren_string) {\n15 +   for i in paren_string {\n   | \n\nerror: expected expression, found `}`\n  --> /tmp/tmpbq2gyntw.rs:46:1\n   |\n46 | }\n   | ^ expected expression\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbq2gyntw.rs:16:8\n   |\n16 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i == '(') {\n16 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbq2gyntw.rs:18:10\n   |\n18 |       if (current_level > max_level) {\n   |          ^                         ^\n   |\nhelp: remove these parentheses\n   |\n18 -       if (current_level > max_level) {\n18 +       if current_level > max_level {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbq2gyntw.rs:26:15\n   |\n26 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n26 -     } else if (i == ')') {\n26 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  paren_stack.push(0);\n  for (i in paren_string) {\n    if (i == \" \") {\n      if (paren_count == 0) {\n        paren_count_stack.push(0);\n        paren_stack.push(0);\n      }\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n      paren_start = i;\n      paren_end = i;\n    } else if (i == \")\") {\n      paren_count++;\n      paren_end = i;\n    } else if (i == \"(\") {\n      paren_count++;\n      paren_end = i;\n      paren_count_stack.push(paren_count);\n      paren_stack.push(paren_count);\n    }\n  }\n  paren_count_stack.push(paren_count);\n  paren_stack.push(paren_count);\n  let result = Vec::new();\n  for (i in paren_count_stack) {\n    if (paren_count_stack[i] == 0) {\n      result.push(paren_stack[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpfcoca1di.rs:15:10\n   |\n15 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpfcoca1di.rs:15:7\n   |\n15 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i in paren_string) {\n15 +   for i in paren_string {\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpfcoca1di.rs:26:18\n   |\n26 |       paren_count++;\n   |                  ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n26 |       { let tmp = paren_count; paren_count += 1; tmp };\n   |       +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n26 -       paren_count++;\n26 +       paren_count += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpfcoca1di.rs:29:18\n   |\n29 |       paren_count++;\n   |                  ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n29 |       { let tmp = paren_count; paren_count += 1; tmp };\n   |       +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n29 -       paren_count++;\n29 +       paren_count += 1;\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpfcoca1di.rs:38:10\n   |\n38 |   for (i in paren_count_stack) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpfcoca1di.rs:38:7\n   |\n38 |   for (i in paren_count_stack) {\n   |       ^                      ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n38 -   for (i in paren_count_stack) {\n38 +   for i in paren_count_stack {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfcoca1di.rs:16:8\n   |\n16 |     if (i == \" \") {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i == \" \") {\n16 +     if i == \" \" {\n   | \n\nwarning: unnecessary parentheses aroun",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n      level += 1;\n    } else if i == ')' {\n      if level == 0 {\n        result.push(0);\n      } else {\n        result.push(level);\n      }\n      level -= 1;\n      if level == 0 {\n        stack.pop();\n      }\n    }\n  }\n  if level != 0 {\n    result.push(level);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[2, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp433wbwow.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(paren_count);\n      paren_count += 1;\n    } else if (i == ')') {\n      paren_count -= 1;\n      if (paren_count < 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      if (paren_stack.len() == 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      paren_end = i;\n      paren_start = paren_stack.pop();\n      max_nesting = max(max_nesting, paren_start - paren_end);\n    }\n  }\n  if (paren_stack.len() != 0) {\n    panic!(\"Mismatched parentheses\");\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp8i3sq913.rs:12:10\n   |\n12 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp8i3sq913.rs:12:7\n   |\n12 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n12 -   for (i in paren_string) {\n12 +   for i in paren_string {\n   | \n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp8i3sq913.rs:26:21\n   |\n26 |       max_nesting = max(max_nesting, paren_start - paren_end);\n   |                     ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8i3sq913.rs:13:8\n   |\n13 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i == '(') {\n13 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8i3sq913.rs:16:15\n   |\n16 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (i == ')') {\n16 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8i3sq913.rs:18:10\n   |\n18 |       if (paren_count < 0) {\n   |          ^               ^\n   |\nhelp: remove these parentheses\n   |\n18 -       if (paren_count < 0) {\n18 +       if paren_count < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8i3sq913.rs:21:10\n   |\n21 |       if (paren_stack.len() == 0) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n21 -       if (paren_stack.len() == 0) {\n21 +       if paren_stack.len() == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8i3sq913.rs:29:6\n   |\n29 |   if (paren_stack.len() != 0) {\n   |      ^                      ^\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  paren_stack.push(0);\n\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_stack_size = paren_stack.len();\n\n  let paren_string_len = paren_string.len();\n  for (let i = 0; i < paren_string_len; i++) {\n    let ch = paren_string[i];\n    if (ch == '(') {\n      paren_count += 1;\n      paren_stack.push(i);\n    } else if (ch == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        paren_level += 1;\n        if (paren_level == 1) {\n          paren_stack.pop();\n        }\n      } else {\n        paren_stack.push(i);\n      }\n    }\n  }\n\n  let max_nesting = 0;\n  for (let i = 0; i < paren_stack_size; i++) {\n    let paren_start = paren_stack[i];\n    let paren_end = paren_stack[i + 1];\n    let nesting = paren_end - paren_start;\n    if (nesting > max_nesting) {\n      max_nesting = nesting;\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < paren_stack_size; i++) {\n    let paren_start = paren_stack[i];\n    let paren_end = paren_stack[i + 1];\n    if (paren_start == paren_end) {\n      result.push(0);\n    } else {\n      result.push(paren_end - paren_start);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpijru462v.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpijru462v.rs:15:8\n   |\n15 |   for (let i = 0; i < paren_string_len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpijru462v.rs:15:12\n   |\n15 |   for (let i = 0; i < paren_string_len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpijru462v.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string_len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpijru462v.rs:15:13\n   |\n15 |   for (let i = 0; i < paren_string_len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpijru462v.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string_len; i++) {\n   |              ^ expected expression\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let paren_count = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(paren_count);\n      paren_count += 1;\n    } else if (paren_string[i] == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        max_nesting = max(max_nesting, paren_stack.len());\n        paren_stack.pop();\n      }\n    }\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpda2m4m87.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpda2m4m87.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpda2m4m87.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpda2m4m87.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpda2m4m87.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_index = 0;\n  let mut max_index_in_level = 0;\n  let mut max_index_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut max_index_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      current_level += 1;\n      if (current_level > max_level) {\n        max_level = current_level;\n        max_index = i;\n      }\n    } else if (c == ')') {\n      current_level -= 1;\n      if (current_level == max_level) {\n        max_index_in_level = i;\n        max_index_in_level_in_level = max_index;\n        max_index_in_level_in_level_in_level = max_index_in_level;\n        max_index_in_level_in_level_in_level_in_level = max_index_in_level_in_level_in_level;\n        max_index_in_level_in_level_in_level_in_level_in_level = max_index_in_level_in_level_in_level_in_level_in_level;\n        max_index_in_level_in_level_in_level_in_level_in_level_in_level = max_index_in_level_in_level_in_level_in_level_in_level_in_level;\n      }\n    }\n  }\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp41lxe9bd.rs:17:8\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp41lxe9bd.rs:17:12\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp41lxe9bd.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp41lxe9bd.rs:17:13\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp41lxe9bd.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result: Vec<isize> = Vec![];\n  let mut paren_stack: Vec<isize> = Vec![];\n  paren_stack.push(0);\n  for isize i = 0; i < paren_string.len(); i++ {\n    if paren_string[i] == '(' {\n      paren_stack.push(i);\n    } else if paren_string[i] == ')' {\n      if paren_stack.len() == 0 {\n        panic!(\"Mismatched parentheses\");\n      }\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let depth = paren_end - paren_start;\n      result.push(depth);\n    }\n  }\n  if paren_stack.len() != 0 {\n    panic!(\"Mismatched parentheses\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpf1eh8pxm.rs:10:12\n   |\n10 |   for isize i = 0; i < paren_string.len(); i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpf1eh8pxm.rs:10:18\n   |\n10 |   for isize i = 0; i < paren_string.len(); i++ {\n   |                  ^ expected `{`\n\nerror: cannot find macro `Vec` in this scope\n  --> /tmp/tmpf1eh8pxm.rs:7:32\n   |\n7  |     let mut result: Vec<isize> = Vec![];\n   |                                  ^^^ help: a macro with a similar name exists (notice the capitalization): `vec`\n   |\n   = note: `Vec` is in scope, but it is a struct, not a macro\n\nerror: cannot find macro `Vec` in this scope\n  --> /tmp/tmpf1eh8pxm.rs:8:37\n   |\n8  |     let mut paren_stack: Vec<isize> = Vec![];\n   |                                       ^^^ help: a macro with a similar name exists (notice the capitalization): `vec`\n   |\n   = note: `Vec` is in scope, but it is a struct, not a macro\n\nerror: aborting due to 4 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  for (let chr of paren_string) {\n    if (chr == '(') {\n      stack.push(level);\n      level += 1;\n    } else if (chr == ')') {\n      level -= 1;\n      if (level == 0) {\n        result.push(stack.pop());\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpk8tzq_s5.rs:10:8\n   |\n10 |   for (let chr of paren_string) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `chr`\n  --> /tmp/tmpk8tzq_s5.rs:10:12\n   |\n10 |   for (let chr of paren_string) {\n   |           -^^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpk8tzq_s5.rs:10:16\n   |\n10 |   for (let chr of paren_string) {\n   |               -^^ expected one of `)`, `,`, `@`, or `|`\n   |               |\n   |               help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `paren_string`\n  --> /tmp/tmpk8tzq_s5.rs:10:19\n   |\n10 |   for (let chr of paren_string) {\n   |                  -^^^^^^^^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |                  |\n   |                  help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpk8tzq_s5.rs:10:32\n   |\n10 |   for (let chr of paren_string) {\n   |                                ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpk8tzq_s5.rs:21:3\n   |\n21 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n21 |   { return result; }\n   |   +                +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for i in paren_string.chars() {\n    if paren_stack.len() == 0 {\n      result.push(0);\n    }\n    let paren_level = paren_stack.pop();\n    if paren_string[i] == '(' {\n      paren_stack.push(paren_level + 1);\n    } else if paren_string[i] == ')' {\n      paren_stack.push(paren_level - 1);\n    }\n    result.push(paren_stack.len());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp1jhdsxzd.rs:15:8\n   |\n15 |     if paren_string[i] == '(' {\n   |        ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0369]: cannot add `{integer}` to `Option<{integer}>`\n  --> /tmp/tmp1jhdsxzd.rs:16:36\n   |\n16 |       paren_stack.push(paren_level + 1);\n   |                        ----------- ^ - {integer}\n   |                        |\n   |                        Option<{integer}>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp1jhdsxzd.rs:17:15\n   |\n17 |     } else if paren_string[i] == ')' {\n   |               ^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0369]: cannot subtract `{integer}` from `Option<{integer}>`\n  --> /tmp/tmp1jhdsxzd.rs:18:36\n   |\n18 |       paren_stack.push(paren_level - 1);\n   |                        ----------- ^ - {integer}\n   |                        |\n   |                        Option<{integer}>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1jhdsxzd.rs:22:10\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let max_nesting = 0;\n  let start = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(paren_count);\n      paren_count++;\n    } else if (paren_string[i] == ')') {\n      paren_count--;\n      if (paren_stack.len() > 0 && paren_stack.last() == paren_count) {\n        max_nesting = paren_stack.pop();\n      }\n    }\n    if (paren_stack.len() > 0 && paren_stack.last() == paren_count) {\n      start = i;\n    }\n  }\n  return Vec::from(start, max_nesting);\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpouccrmhn.rs:11:8\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpouccrmhn.rs:11:12\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpouccrmhn.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpouccrmhn.rs:11:13\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpouccrmhn.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  let mut last_level = 0;\n  let mut last_paren = 0;\n  let mut last_paren_pos = 0;\n  let mut last_paren_pos_end = 0;\n  let mut last_paren_pos_start = 0;\n  let mut last_paren_pos_start_end = 0;\n  let mut last_paren_pos_start_start = 0;\n  let mut last_paren_pos_start_start_end = 0;\n  let mut last_paren_pos_start_start_start = 0;\n  let mut last_paren_pos_start_start_start_end = 0;\n  let mut last_paren_pos_start_start_start_start = 0;\n  let mut last_paren_pos_start_start_start_start_end = 0;\n  let mut last_paren_pos_start_start_start_start_start = 0;\n  let mut last_paren_pos_start_start_start_start_start_end = 0;\n  let mut last_paren_pos_start_start_start_start_start_start = 0;\n  let mut last_paren_pos_start_start_start_start_start_start_end = 0;\n  let mut last_paren_pos_start_start_start_start_start_start_start = 0;\n  let mut last_paren_pos_start_start_start_start_start_start_start_end = 0;\n  let mut last_paren_pos_start_start_start_start_start_start_start_start = 0;\n  let mut last_paren_pos_start_start_start_start_start_start_start_start_end = 0;\n  let mut last_paren_pos_start_start_start_start_start_start_start_start_start = 0;\n  let mut last_paren_pos_start_start_start_start_start_start_start_start_start_end = 0;\n  let mut last_paren_pos_start_start_start_start_start_start_start_start\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp3x_i4_cg.rs:32:73\n   |\n32 |   let mut last_paren_pos_start_start_start_start_start_start_start_start\n   |                                                                         ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp3x_i4_cg.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_prev = 0;\n  let mut max_level_index_next = 0;\n  let mut max_level_index_prev_next = 0;\n  let mut max_level_index_prev_next_prev = 0;\n  let mut max_level_index_prev_next_next = 0;\n  let mut max_level_index_prev_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_prev_next_next_next_next\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp72c53_jf.rs:28:51\n   |\n28 |   let mut max_level_index_prev_next_next_next_next\n   |                                                   ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp72c53_jf.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_prev = 0;\n  let mut max_level_index_next = 0;\n  let mut max_level_index_next_prev = 0;\n  let mut max_level_index_next_next = 0;\n  let mut max_level_index_next_next_prev = 0;\n  let mut max_level_index_next_next_next = 0;\n  let mut max_level_index_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpx4a5tru4.rs:31:31\n   |\n31 |   let mut max_level_index_next\n   |                               ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpx4a5tru4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n    } else if (c == ')') {\n      paren_count += 1;\n      if (paren_stack.len() == 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let paren_nesting = paren_count_stack.pop() - 1;\n      if (paren_nesting > max_nesting) {\n        max_nesting = paren_nesting;\n        max_nesting_index = paren_start;\n      }\n    }\n  }\n\n  if (paren_stack.len() != 0) {\n    panic!(\"Mismatched parentheses\");\n  }\n\n  return max_nesting_index;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpduiblnki.rs:15:8\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpduiblnki.rs:15:12\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpduiblnki.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpduiblnki.rs:15:13\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpduiblnki.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_index = 0;\n  let mut max_paren_index = 0;\n  let mut max_paren_level = 0;\n  let mut paren_index = 0;\n  let mut paren_level = 0;\n  let mut paren_count = 0;\n  let mut paren_count_in_level = 0;\n  let mut paren_count_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level_in_level = 0;\n  let mut paren_count_in_level_in_level_in_level_in_level_in_level_in_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp7rvn2yhx.rs:27:71\n   |\n27 |   let mut paren_count_in_level_in_level_in_level_in_level_in_level_in_\n   |                                                                       ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp7rvn2yhx.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_string_len = paren_string.len();\n  for (let i = 0; i < paren_string_len; i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n    } else if (c == ')') {\n      if (paren_stack.len() == 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      let paren_start_index = paren_stack.pop();\n      let paren_count_start = paren_count_stack.pop();\n      if (paren_count_start > max_nesting) {\n        max_nesting = paren_count_start;\n        max_nesting_index = i;\n      }\n      paren_count -= 1;\n    }\n  }\n\n  if (paren_stack.len() != 0) {\n    panic!(\"Mismatched parentheses\");\n  }\n\n  let result = Vec::new();\n  for (let i = max_nesting_index; i < paren_string_len; i++) {\n    result.push(1);\n  }\n  for (let i = 0; i < max_nesting; i++) {\n    result.push(0);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpd36i1ibu.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpd36i1ibu.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpd36i1ibu.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpd36i1ibu.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpd36i1ibu.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_found = false;\n  let mut is_open = false;\n  let mut is_close = false;\n  let mut is_open_found = false;\n  let mut is_close_found = false;\n  let mut is_open_index = 0;\n  let mut is_close_index = 0;\n  let mut is_open_index_found = false;\n  let mut is_close_index_found = false;\n  let mut is_open_index_found_at_least_once = false;\n  let mut is_close_index_found_at_least_once = false;\n  let mut is_open_index_found_at_least_twice = false;\n  let mut is_close_index_found_at_least_twice = false;\n  let mut is_open_index_found_at_least_thrice = false;\n  let mut is_close_index_found_at_least_thrice = false;\n  let mut is_open_index_found_at_least_four = false;\n  let mut is_close_index_found_at_least_four = false;\n  let mut is_open_index_found_at_least_five = false;\n  let mut is_close_index_found_at_least_five = false;\n  let mut is_open_index_found_at_least_six = false;\n  let mut is_close_index_found_at_least_six = false;\n  let mut is_open_index_found_at_least_seven = false;\n  let mut is_close_index_found_at_least_seven = false;\n  let mut is_open_index_found_at_least_eight = false;\n  let mut is_close_index_found_at_least_eight = false;\n  let mut is_open_index_found_at_least_nine = false;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmpixc1ya3a.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_index = 0;\n  let paren_count_max = 0;\n  let paren_count_min = 0;\n  let paren_count_max_index = 0;\n  let paren_count_min_index = 0;\n  let paren_count_max_stack = 0;\n  let paren_count_min_stack = 0;\n  let paren_count_max_stack_index = 0;\n  let paren_count_min_stack_index = 0;\n  let paren_count_max_stack_stack = 0;\n  let paren_count_min_stack_stack = 0;\n  let paren_count_max_stack_stack_index = 0;\n  let paren_count_min_stack_stack_index = 0;\n  let paren_count_max_stack_stack_stack = 0;\n  let paren_count_min_stack_stack_stack = 0;\n  let paren_count_max_stack_stack_stack_index = 0;\n  let paren_count_min_stack_stack_stack_index = 0;\n  let paren_count_max_stack_stack_stack_stack = 0;\n  let paren_count_min_stack_stack_stack_stack = 0;\n  let paren_count_max_stack_stack_stack_stack_index = 0;\n  let paren_count_min_stack_stack_stack_stack_index = 0;\n  let paren_count_max_stack_stack_stack_stack_stack = 0;\n  let paren_count_min_stack_stack_stack_stack_stack = 0;\n  let paren_count_max_stack_stack_stack_stack_stack_index = 0;\n  let paren_count_min_stack_stack_stack_stack_stack_index = 0;\n  let paren_count_max_stack_stack_stack_stack_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmptdoceduk.rs:37:52\n   |\n37 |   let paren_count_max_stack_stack_stack_stack_stack\n   |                                                    ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmptdoceduk.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_of_last_open_paren = 0;\n  let mut max_nesting_index_of_last_close_paren = 0;\n  let mut last_open_paren_index = 0;\n  let mut last_close_paren_index = 0;\n  let mut last_open_paren_index_of_last_open_paren = 0;\n  let mut last_close_paren_index_of_last_close_paren = 0;\n  let mut last_open_paren_index_of_last_close_paren = 0;\n  let mut last_close_paren_index_of_last_open_paren = 0;\n  let mut last_open_paren_index_of_last_open_paren = 0;\n  let mut last_close_paren_index_of_last_open_paren = 0;\n  let mut last_open_paren_index_of_last_close_paren = 0;\n  let mut last_close_paren_index_of_last_close_paren = 0;\n  let mut last_open_paren_index_of_last_close_paren = 0;\n  let mut last_close_paren_index_of_last_open_paren = 0;\n  let mut last_open_paren_index_of_last_open_paren = 0;\n  let mut last_close_paren_index_of_last_open_paren = 0;\n  let mut last_open_paren_index_of_last_close_paren = 0;\n  let mut last_close_paren_index_of_last_close_paren = 0;\n  let mut last_open_paren_index_of_last_close_paren = 0;\n  let mut last_close_paren_index_of_last_open_paren = 0;\n  let mut last_open_paren_index_of_last_open_paren = 0;\n  let mut last_close_paren_index_of_last_open_paren = 0;\n  let\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmp685anoz_.rs:34:1\n   |\n34 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  for i in paren_string.iter() {\n    if i == '(' {\n      current_level += 1;\n      max_level = max(max_level, current_level);\n    } else if i == ')' {\n      current_level -= 1;\n    }\n    if current_level == 0 {\n      result.push(max_level);\n      max_level = 0;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpjvr0o9qu.rs:13:19\n   |\n13 |       max_level = max(max_level, current_level);\n   |                   ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpjvr0o9qu.rs:10:25\n   |\n10 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  let paren_depth_stack = Vec::new();\n  paren_count_stack.push(0);\n  paren_depth_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_count_stack.push(paren_count);\n      paren_depth_stack.push(paren_depth);\n      paren_count = 0;\n      paren_depth = 0;\n      paren_start = i;\n    } else if (paren_string[i] == ')') {\n      paren_count = paren_count_stack.pop();\n      paren_depth = paren_depth_stack.pop();\n      paren_end = i;\n      if (paren_count == 0) {\n        paren_stack.push(paren_end - paren_start);\n      }\n    } else if (paren_string[i] == '(') {\n      paren_count += 1;\n      paren_depth += 1;\n    } else if (paren_string[i] == ')') {\n      paren_depth -= 1;\n    }\n  }\n  paren_stack.push(paren_end - paren_start);\n  return paren_stack;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpzyfzca26.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpzyfzca26.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpzyfzca26.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpzyfzca26.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpzyfzca26.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  for i in paren_string.iter() {\n    if i == '(' {\n      current_level += 1;\n      if current_level > max_level {\n        max_level = current_level;\n      }\n    } else if i == ')' {\n      current_level -= 1;\n    }\n    if current_level == 0 {\n      result.push_back(max_level);\n      max_level = 0;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp2a3s9323.rs:10:25\n   |\n10 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp2a3s9323.rs:20:14\n   |\n20 |       result.push_back(max_level);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let current_level = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(i);\n      current_level += 1;\n    } else if (paren_string[i] == ')') {\n      if (current_level == 0) {\n        throw \"Invalid parentheses\";\n      }\n      current_level -= 1;\n      if (current_level == 0) {\n        max_nesting = max_nesting + 1;\n        paren_stack.pop();\n      }\n    }\n  }\n  if (current_level != 0) {\n    throw \"Invalid parentheses\";\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp6bkrq3vq.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp6bkrq3vq.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp6bkrq3vq.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp6bkrq3vq.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp6bkrq3vq.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_in_stack = 0;\n  let mut max_nesting_index_in_stack_in_stack = 0;\n  let mut max_nesting_index_in_stack_in_stack_in_stack = 0;\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      stack.push(i);\n    } else if (c == ')') {\n      if (stack.len() == 0) {\n        result.push(0);\n      } else {\n        let index = stack.pop();\n        let nesting = stack.len();\n        if (nesting > max_nesting) {\n          max_nesting = nesting;\n          max_nesting_index = index;\n          max_nesting_index_in_stack = stack.len();\n          max_nesting_index_in_stack_in_stack = stack.len();\n          max_nesting_index_in_stack_in_stack_in_stack = stack.len();\n        }\n        result.push(nesting);\n      }\n    }\n  }\n\n  if (stack.len() != 0) {\n    result.push(0);\n  }\n\n  result.push(max_nesting);\n  result.push(max_nesting_index);\n  result.push(max_nesting_index_in_stack);\n  result.push(max_nesting_index_in_stack_in_stack);\n  result.push(max_nesting_index_in_stack_in_stack_in_stack);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpmy8ssrwn.rs:15:8\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpmy8ssrwn.rs:15:12\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpmy8ssrwn.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpmy8ssrwn.rs:15:13\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpmy8ssrwn.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for isize i = 0; i < paren_string.len(); i++ {\n    let c = paren_string[i];\n    if c == '(' {\n      paren_stack.push(i);\n    } else if c == ')' {\n      if paren_stack.len() == 0 {\n        result.push(i);\n      } else {\n        result.push(paren_stack.pop());\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpwv7kxyuf.rs:10:12\n   |\n10 |   for isize i = 0; i < paren_string.len(); i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpwv7kxyuf.rs:10:18\n   |\n10 |   for isize i = 0; i < paren_string.len(); i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let paren_depth = 0;\n  let max_depth = 0;\n  let max_count = 0;\n  let max_count_index = 0;\n  let max_depth_index = 0;\n  let current_index = 0;\n  let current_count = 0;\n  let current_depth = 0;\n  let current_count_index = 0;\n  let current_depth_index = 0;\n  let current_paren_count = 0;\n  let current_paren_depth = 0;\n  let current_paren_count_index = 0;\n  let current_paren_depth_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_index = 0;\n  let current_paren_count_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp4eupcjpd.rs:49:27\n   |\n49 |   let current_paren_count_\n   |                           ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4eupcjpd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \")\") {\n      if stack.len() == 0 {\n        result.push_back(0);\n      } else {\n        result.push_back(stack.len() - 1);\n      }\n      stack.pop();\n    } else {\n      stack.push(paren.len());\n    }\n  }\n  if stack.len() != 0 {\n    result.push_back(stack.len());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpzkl71u1s.rs:23:3\n   |\n20 |     } else {\n   |            - this opening brace...\n21 |       stack.push(paren.len());\n22 |     }\n   |     - ...matches this closing brace\n23 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpzkl71u1s.rs:9:40\n   |\n9  |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n10 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpzkl71u1s.rs:6:60\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            ^ unclosed delimiter\n...\n13 |     if paren == \")\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(paren_count);\n  paren_stack.push(paren_count);\n  paren_string.chars().for_each(|c| {\n    if (c == '(') {\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      paren_stack.push(paren_count);\n      paren_level += 1;\n    } else if (c == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        paren_count = paren_count_stack.pop();\n        paren_stack.pop();\n        paren_level -= 1;\n      }\n    }\n  });\n  return paren_stack.map(|i| i + 1);\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7ftbc6pe.rs:14:8\n   |\n14 |     if (c == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -     if (c == '(') {\n14 +     if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7ftbc6pe.rs:19:15\n   |\n19 |     } else if (c == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (c == ')') {\n19 +     } else if c == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp7ftbc6pe.rs:21:10\n   |\n21 |       if (paren_count == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n21 -       if (paren_count == 0) {\n21 +       if paren_count == 0 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ftbc6pe.rs:22:23\n   |\n8  |   let paren_count = 0;\n   |                     - expected due to this value\n...\n22 |         paren_count = paren_count_stack.pop();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\nerror[E0599]: `Vec<{integer}>` is not an iterator\n   --> /tmp/tmp7ftbc6pe.rs:28:22\n    |\n28  |     return paren_stack.map(|i| i + 1);\n    |                        ^^^ `Vec<{integer}>` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<{integer}>: Iterator`\n            which is required by `&mut Vec<{integer}>: Iterator`\n            `[{integer}]: Iterator`\n            which is required by `&mut [{integer}]: Iterator`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpfzxfqtr1.rs:23:38\n   |\n23 |   let mut max_level_index_in_paren_in\n   |                                      ^ help: add `;` here\n24 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfzxfqtr1.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let paren_count = 0;\n  let paren_count_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n      current_nesting++;\n      current_nesting_index = i;\n    } else if (c == ')') {\n      current_nesting--;\n      if (current_nesting == 0) {\n        max_nesting = max(max_nesting, current_nesting);\n        max_nesting_index = i;\n      }\n      paren_count = paren_count_stack.pop();\n      paren_count_index = paren_stack.pop();\n    } else {\n      paren_count++;\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < max_nesting; i++) {\n    result.push(max_nesting_index - i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp7lasjtp0.rs:19:8\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp7lasjtp0.rs:19:12\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp7lasjtp0.rs:19:14\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp7lasjtp0.rs:19:13\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp7lasjtp0.rs:19:14\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  let paren_count_stack_index = 0;\n  let paren_count_stack_size = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_size = 0;\n  let paren_count_stack_max_max = 0;\n  let paren_count_stack_max_max_index = 0;\n  let paren_count_stack_max_max_size = 0;\n  let paren_count_stack_max_max_max = 0;\n  let paren_count_stack_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_size = 0;\n  let paren_count_stack_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_size = 0;\n  let paren_count_stack_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_size = 0;\n  let paren_count_stack_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_size = 0;\n  let paren_count_stack_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_index = 0\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp8py9tubr.rs:34:62\n   |\n34 |   let paren_count_stack_max_max_max_max_max_max_max_index = 0\n   |                                                              ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8py9tubr.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_depth = 0;\n  let mut max_depth_index = 0;\n  let mut depth = 0;\n  let mut index = 0;\n  let mut paren_count = 0;\n  let mut paren_index = 0;\n  let mut paren_count_index = 0;\n  let mut paren_count_index_prev = 0;\n  let mut paren_count_index_next = 0;\n  let mut paren_count_index_next_prev = 0;\n  let mut paren_count_index_next_next = 0;\n  let mut paren_count_index_next_next_prev = 0;\n  let mut paren_count_index_next_next_next = 0;\n  let mut paren_count_index_next_next_next_prev = 0;\n  let mut paren_count_index_next_next_next_next = 0;\n  let mut paren_count_index_next_next_next_next_prev = 0;\n  let mut paren_count_index_next_next_next_next_next = 0;\n  let mut paren_count_index_next_next_next_next_next_prev = 0;\n  let mut paren_count_index_next_next_next_next_next_next = 0;\n  let mut paren_count_index_next_next_next_next_next_next_prev = 0;\n  let mut paren_count_index_next_next_next_next_next_next_next = 0;\n  let mut paren_count_index_next_next_next_next_next_next_next_prev = 0;\n  let mut paren_count_index_next_next_next_next_next_next_next_next = 0;\n  let mut paren_count_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut paren_count_index_next_next_next_next_next_next_next_next_next = 0;\n  let mut paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpb2qd1q3x.rs:34:16\n   |\n34 |   let mut paren\n   |                ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpb2qd1q3x.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(paren_count);\n      paren_count_stack.push(paren_count);\n      paren_count += 1;\n    } else if (i == ')') {\n      paren_count -= 1;\n      if (paren_count_stack.pop() == 0) {\n        max_nesting = paren_stack.pop();\n        max_nesting_index = paren_index;\n      }\n    }\n    paren_index += 1;\n  }\n\n  let result = Vec::new();\n  for (i in paren_stack) {\n    result.push_back(max_nesting - paren_stack.pop());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpfjqcckcw.rs:16:10\n   |\n16 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpfjqcckcw.rs:16:7\n   |\n16 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n16 -   for (i in paren_string) {\n16 +   for i in paren_string {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpfjqcckcw.rs:32:10\n   |\n32 |   for (i in paren_stack) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpfjqcckcw.rs:32:7\n   |\n32 |   for (i in paren_stack) {\n   |       ^                ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n32 -   for (i in paren_stack) {\n32 +   for i in paren_stack {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfjqcckcw.rs:17:8\n   |\n17 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (i == '(') {\n17 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfjqcckcw.rs:21:15\n   |\n21 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n21 -     } else if (i == ')') {\n21 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfjqcckcw.rs:23:10\n   |\n23 |       if (paren_count_stack.pop() == 0) {\n   |          ^                            ^\n   |\nhelp: remove these parentheses\n   |\n23 -       if (paren_count_stack.pop() == 0) {\n23 +       if paren_count_stack.pop() == 0 {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpfjqcckcw.rs:16:13\n   |\n16 |   for (i in paren_string) {\n   |             ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterato",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n    } else if (c == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let depth = paren_end - paren_start;\n      result.push(depth);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp3_n0ayo1.rs:11:8\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp3_n0ayo1.rs:11:12\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp3_n0ayo1.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp3_n0ayo1.rs:11:13\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp3_n0ayo1.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  let mut max_level = 0;\n  let mut max_index = 0;\n  let mut max_index_start = 0;\n  let mut max_index_end = 0;\n  let mut max_index_start_end = 0;\n  let mut max_index_start_end_start = 0;\n  let mut max_index_start_end_end = 0;\n  let mut max_index_start_end_start_end = 0;\n  let mut max_index_start_end_end_start = 0;\n  let mut max_index_start_end_end_end = 0;\n  let mut max_index_start_end_start_end_start = 0;\n  let mut max_index_start_end_end_start_end_end = 0;\n  let mut max_index_start_end_start_end_end_start = 0;\n  let mut max_index_start_end_end_start_end_end_start = 0;\n  let mut max_index_start_end_end_start_end_end_end = 0;\n  let mut max_index_start_end_start_end_end_start_end = 0;\n  let mut max_index_start_end_end_start_end_end_start_end = 0;\n  let mut max_index_start_end_end_start_end_end_start_end_start = 0;\n  let mut max_index_start_end_end_start_end_end_start_end_end = 0;\n  let mut max_index_start_end_end_start_end_end_start_end_start_end = 0;\n  let mut max_index_start_end_end_start_end_end_start_end_end_start = 0;\n  let mut max_index_start_end_end_start_end_end_start_end_end_end = 0;\n  let mut max_index_start_end_end_start_end_end_start_end_end_start_end = 0;\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmp6l_q37e8.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let paren_count = 0;\n  let paren_count_index = 0;\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(current_nesting);\n      current_nesting += 1;\n      paren_count += 1;\n      paren_count_index += 1;\n    } else if (i == ')') {\n      current_nesting -= 1;\n      if (current_nesting == 0) {\n        current_nesting = paren_stack.pop();\n        max_nesting = max(max_nesting, current_nesting);\n        max_nesting_index = paren_count_index;\n      }\n      paren_count -= 1;\n      paren_count_index -= 1;\n    }\n  }\n  return max_nesting_index;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp06sifgik.rs:16:10\n   |\n16 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp06sifgik.rs:16:7\n   |\n16 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n16 -   for (i in paren_string) {\n16 +   for i in paren_string {\n   | \n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp06sifgik.rs:26:23\n   |\n26 |         max_nesting = max(max_nesting, current_nesting);\n   |                       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp06sifgik.rs:17:8\n   |\n17 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (i == '(') {\n17 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp06sifgik.rs:22:15\n   |\n22 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == ')') {\n22 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp06sifgik.rs:24:10\n   |\n24 |       if (current_nesting == 0) {\n   |          ^                    ^\n   |\nhelp: remove these parentheses\n   |\n24 -       if (current_nesting == 0) {\n24 +       if current_nesting == 0 {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmp06sifgik.rs:16:13\n   |\n16 |   for (i in paren_string) {\n   |             ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp06sifgik.rs:25:27\n   |\n11 |   let cu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let current_nesting = 0;\n  let current_index = 0;\n  let next_index = 0;\n  let next_char = paren_string[0];\n  while (next_index < paren_string.len()) {\n    if (next_char == '(') {\n      paren_stack.push(current_nesting);\n      current_nesting += 1;\n    } else if (next_char == ')') {\n      current_nesting -= 1;\n      if (current_nesting < 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      if (current_nesting == 0) {\n        next_index += 1;\n        next_char = paren_string[next_index];\n        continue;\n      }\n    }\n    max_nesting = max(max_nesting, current_nesting);\n    current_index = next_index;\n    next_index += 1;\n    next_char = paren_string[next_index];\n  }\n  return max_nesting == 0 ? Vec::new() : Vec::new(max_nesting);\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `Vec`\n  --> /tmp/tmpi2ojh1gm.rs:34:29\n   |\n34 |   return max_nesting == 0 ? Vec::new() : Vec::new(max_nesting);\n   |                             ^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpi2ojh1gm.rs:29:19\n   |\n29 |     max_nesting = max(max_nesting, current_nesting);\n   |                   ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi2ojh1gm.rs:14:9\n   |\n14 |   while (next_index < paren_string.len()) {\n   |         ^                               ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (next_index < paren_string.len()) {\n14 +   while next_index < paren_string.len() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi2ojh1gm.rs:15:8\n   |\n15 |     if (next_char == '(') {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (next_char == '(') {\n15 +     if next_char == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi2ojh1gm.rs:18:15\n   |\n18 |     } else if (next_char == ')') {\n   |               ^                ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (next_char == ')') {\n18 +     } else if next_char == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi2ojh1gm.rs:20:10\n   |\n20 |       if (current_nesting < 0) {\n   |          ^                   ^\n   |\nhelp: remove these parentheses\n   |\n20 -       if (current_nesting < 0) {\n20 +       if current_nesting < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpi2ojh1gm.rs:23:10\n   |\n23 |       if (current_nesting == 0) {\n   |          ^                    ^\n   |\nhelp: remove these parentheses\n   |\n23 -       if (current_nesting == 0) {\n23 +       if curre",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_index = 0;\n  let current_char = paren_string[current_index];\n  while (current_index < paren_string.len) {\n    if (current_char == '(') {\n      current_nesting += 1;\n      if (current_nesting > max_nesting) {\n        max_nesting = current_nesting;\n        max_nesting_index = current_index;\n      }\n    } else if (current_char == ')') {\n      current_nesting -= 1;\n      if (current_nesting == 0) {\n        paren_stack.pop();\n        current_index += 1;\n      }\n    }\n    current_index += 1;\n    current_char = paren_string[current_index];\n  }\n  return paren_stack;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmpu3mbitmx.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpu3mbitmx.rs:14:9\n   |\n14 |   while (current_index < paren_string.len) {\n   |         ^                                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (current_index < paren_string.len) {\n14 +   while current_index < paren_string.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpu3mbitmx.rs:15:8\n   |\n15 |     if (current_char == '(') {\n   |        ^                   ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (current_char == '(') {\n15 +     if current_char == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpu3mbitmx.rs:17:10\n   |\n17 |       if (current_nesting > max_nesting) {\n   |          ^                             ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (current_nesting > max_nesting) {\n17 +       if current_nesting > max_nesting {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpu3mbitmx.rs:21:15\n   |\n21 |     } else if (current_char == ')') {\n   |               ^                   ^\n   |\nhelp: remove these parentheses\n   |\n21 -     } else if (current_char == ')') {\n21 +     } else if current_char == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpu3mbitmx.rs:23:10\n   |\n23 |       if (current_nesting == 0) {\n   |          ^                    ^\n   |\nhelp: remove these parentheses\n   |\n23 -       if (current_nesting == 0) {\n23 +       if current_nesting == 0 {\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpu3mbitmx.rs:13:22\n   |\n13 |   let current_char ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren = 0;\n  for (i in paren_string.chars()) {\n    if (i == '(') {\n      current_level += 1;\n      if (current_level > max_level) {\n        max_level = current_level;\n        max_level_index = i;\n      }\n    } else if (i == ')') {\n      current_level -= 1;\n      if (current_level < 0) {\n        result.push(max_level);\n        max_level = 0;\n        max_level_index = 0;\n      }\n    }\n  }\n  result.push(max_level);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp5jm6ic0y.rs:15:10\n   |\n15 |   for (i in paren_string.chars()) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp5jm6ic0y.rs:15:7\n   |\n15 |   for (i in paren_string.chars()) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i in paren_string.chars()) {\n15 +   for i in paren_string.chars() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5jm6ic0y.rs:16:8\n   |\n16 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (i == '(') {\n16 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5jm6ic0y.rs:18:10\n   |\n18 |       if (current_level > max_level) {\n   |          ^                         ^\n   |\nhelp: remove these parentheses\n   |\n18 -       if (current_level > max_level) {\n18 +       if current_level > max_level {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5jm6ic0y.rs:22:15\n   |\n22 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (i == ')') {\n22 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5jm6ic0y.rs:24:10\n   |\n24 |       if (current_level < 0) {\n   |          ^                 ^\n   |\nhelp: remove these parentheses\n   |\n24 -       if (current_level < 0) {\n24 +       if current_level < 0 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5jm6ic0y.rs:20:27\n   |\n10 |   let mut max_level_index = 0;\n   |                             - expected due to this value\n...\n20 |         max_level_index = i;\n   |                           ^ expected integer, found `char`\n\nerror: aborting due to 3 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let max_nesting = 0;\n  let current_nesting = 0;\n  let current_char = 0;\n  let current_char_is_open = false;\n  let current_char_is_close = false;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count += 1;\n      current_nesting += 1;\n      current_char_is_open = true;\n    } else if (c == ')') {\n      if (current_char_is_open) {\n        current_nesting -= 1;\n        current_char_is_open = false;\n      } else {\n        current_nesting -= 1;\n        current_char_is_close = true;\n      }\n      if (current_nesting == 0) {\n        max_nesting = max(max_nesting, current_nesting);\n        paren_stack.pop();\n        paren_count -= 1;\n      }\n    }\n    current_char = c;\n  }\n  max_nesting = max(max_nesting, current_nesting);\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpc6yogljb.rs:14:8\n   |\n14 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpc6yogljb.rs:14:12\n   |\n14 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpc6yogljb.rs:14:14\n   |\n14 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpc6yogljb.rs:14:13\n   |\n14 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpc6yogljb.rs:14:14\n   |\n14 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_depth = 0;\n  let mut max_depth_index = 0;\n  let mut max_depth_count = 0;\n  let mut max_depth_count_index = 0;\n  let mut max_depth_count_count = 0;\n  let mut max_depth_count_count_index = 0;\n  let mut max_depth_count_count_count = 0;\n  let mut max_depth_count_count_count_index = 0;\n  let mut max_depth_count_count_count_count = 0;\n  let mut max_depth_count_count_count_count_index = 0;\n  let mut max_depth_count_count_count_count_count = 0;\n  let mut max_depth_count_count_count_count_count_index = 0;\n  let mut max_depth_count_count_count_count_count_count = 0;\n  let mut max_depth_count_count_count_count_count_count_index = 0;\n  let mut max_depth_count_count_count_count_count_count_count = 0;\n  let mut max_depth_count_count_count_count_count_count_count_index = 0;\n  let mut max_depth_count_count_count_count_count_count_count_count = 0;\n  let mut max_depth_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_depth_count_count_count_count_count_count_count_count_count = 0;\n  let mut max_depth_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_depth_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut max_depth_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_depth_count_count_count_count_count_count_count_count_count_count_count = 0\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmplbcofha9.rs:31:90\n   |\n31 |   let mut max_depth_count_count_count_count_count_count_count_count_count_count_count = 0\n   |                                                                                          ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmplbcofha9.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n      level += 1;\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(level);\n        level = 0;\n      } else {\n        stack.pop();\n        level -= 1;\n      }\n    }\n  }\n  result.push(level);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp69bo4uoj.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      stack.push(i);\n      level += 1;\n    } else if (paren_string[i] == ')') {\n      if (level == 0) {\n        result.push(i);\n      } else {\n        level -= 1;\n      }\n    }\n  }\n  result.push(paren_string.len());\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpctxu26ma.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpctxu26ma.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpctxu26ma.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpctxu26ma.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpctxu26ma.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(paren_count);\n      paren_count = 0;\n      paren_start = i;\n      paren_end = i;\n      paren_depth++;\n    } else if (paren_string[i] == ')') {\n      paren_count++;\n      paren_end = i;\n      paren_depth--;\n      if (paren_depth == 0) {\n        paren_stack.pop();\n      }\n    }\n  }\n\n  let max_depth = paren_stack.len();\n  let depth = 0;\n  let result = Vec::new();\n  for (let i = 0; i < paren_stack.len(); i++) {\n    if (paren_stack[i] == paren_count) {\n      depth = paren_depth;\n    }\n    result.push_back(depth);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpj8ubwkg_.rs:13:8\n   |\n13 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpj8ubwkg_.rs:13:12\n   |\n13 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpj8ubwkg_.rs:13:14\n   |\n13 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpj8ubwkg_.rs:13:13\n   |\n13 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpj8ubwkg_.rs:13:14\n   |\n13 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  for i in paren_string.iter() {\n    if i == '(' {\n      current_level += 1;\n      max_level = max(max_level, current_level);\n    } else if i == ')' {\n      current_level -= 1;\n    }\n    if current_level == 0 {\n      result.push_back(max_level);\n      max_level = 0;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpkaj9zvdv.rs:13:19\n   |\n13 |       max_level = max(max_level, current_level);\n   |                   ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpkaj9zvdv.rs:10:25\n   |\n10 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpkaj9zvdv.rs:18:14\n   |\n18 |       result.push_back(max_level);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    let ch = paren_string[i];\n    if (ch == '(') {\n      paren_stack.push(i);\n    } else if (ch == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let level = paren_end - paren_start;\n      result.push(level);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp_6cufud4.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp_6cufud4.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp_6cufud4.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp_6cufud4.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp_6cufud4.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n    } else if (paren_string[i] == ')') {\n      paren_count += 1;\n      if (paren_stack.len() > 0) {\n        paren_count += paren_count_stack.pop();\n        if (paren_count > max_nesting) {\n          max_nesting = paren_count;\n          max_nesting_index = i;\n        }\n      }\n      paren_stack.pop();\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < paren_stack.len(); i++) {\n    result.push(max_nesting_index - paren_stack[i]);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpszbqihj1.rs:15:8\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpszbqihj1.rs:15:12\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpszbqihj1.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpszbqihj1.rs:15:13\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpszbqihj1.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\" {\n      continue;\n    }\n    if paren[0] == '(' {\n      stack.push(paren);\n    } else if paren[0] == ')' {\n      if stack.is_empty() {\n        result.push(0);\n      } else {\n        result.push(stack.pop().len());\n      }\n    }\n  }\n  if !stack.is_empty() {\n    result.push(stack.pop().len());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpsitmeoi_.rs:13:8\n   |\n13 |     if paren[0] == '(' {\n   |        ^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<{integer}>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpsitmeoi_.rs:15:15\n   |\n15 |     } else if paren[0] == ')' {\n   |               ^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<{integer}>` for `str`\n\nerror[E0599]: no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpsitmeoi_.rs:19:33\n   |\n19 |         result.push(stack.pop().len());\n   |                                 ^^^ method not found in `Option<&str>`\n\nerror[E0599]: no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpsitmeoi_.rs:24:29\n   |\n24 |     result.push(stack.pop().len());\n   |                             ^^^ method not found in `Option<&str>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let current_char_index = 0;\n  let paren_count = 0;\n  let paren_count_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(current_nesting);\n      current_nesting += 1;\n      current_nesting_index += 1;\n      paren_count += 1;\n      paren_count_index += 1;\n    } else if (i == ')') {\n      current_nesting -= 1;\n      current_nesting_index += 1;\n      paren_count -= 1;\n      paren_count_index += 1;\n      if (current_nesting == 0) {\n        max_nesting = max(max_nesting, current_nesting);\n        max_nesting_index = current_nesting_index;\n      }\n    }\n    current_char = paren_string[current_char_index];\n    current_char_index += 1;\n  }\n  let result = Vec::new();\n  for (i in paren_stack) {\n    result.push_back(max_nesting == i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpwltfa07p.rs:19:10\n   |\n19 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpwltfa07p.rs:19:7\n   |\n19 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n19 -   for (i in paren_string) {\n19 +   for i in paren_string {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpwltfa07p.rs:40:10\n   |\n40 |   for (i in paren_stack) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpwltfa07p.rs:40:7\n   |\n40 |   for (i in paren_stack) {\n   |       ^                ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n40 -   for (i in paren_stack) {\n40 +   for i in paren_stack {\n   | \n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpwltfa07p.rs:32:23\n   |\n32 |         max_nesting = max(max_nesting, current_nesting);\n   |                       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwltfa07p.rs:20:8\n   |\n20 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     if (i == '(') {\n20 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwltfa07p.rs:26:15\n   |\n26 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n26 -     } else if (i == ')') {\n26 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwltfa07p.rs:31:10\n   |\n31 |       if (current_nesting == 0) {\n   |          ^                    ^\n   |\nhelp: remove these parentheses\n   |\n31 -       if (current_nesting == 0) {\n31 +       if current_nesting ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_depth = 0;\n  let mut max_depth_index = 0;\n  let mut max_depth_index_prev = 0;\n  let mut max_depth_index_next = 0;\n  let mut max_depth_index_prev_next = 0;\n  let mut max_depth_index_prev_next_prev = 0;\n  let mut max_depth_index_prev_next_next = 0;\n  let mut max_depth_index_prev_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_depth_index_prev_next_next_next_next\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp9ntgexc6.rs:28:51\n   |\n28 |   let mut max_depth_index_prev_next_next_next_next\n   |                                                   ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9ntgexc6.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(paren_count);\n      paren_count_stack.push(paren_count);\n      paren_count += 1;\n    } else if (i == ')') {\n      paren_count -= 1;\n      if (paren_count_stack.pop() == 0) {\n        max_nesting = paren_stack.pop();\n        max_nesting_index = i;\n      }\n    }\n  }\n  return max_nesting_index;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpxtivqfcu.rs:14:10\n   |\n14 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpxtivqfcu.rs:14:7\n   |\n14 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n14 -   for (i in paren_string) {\n14 +   for i in paren_string {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxtivqfcu.rs:15:8\n   |\n15 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n15 -     if (i == '(') {\n15 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxtivqfcu.rs:19:15\n   |\n19 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (i == ')') {\n19 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxtivqfcu.rs:21:10\n   |\n21 |       if (paren_count_stack.pop() == 0) {\n   |          ^                            ^\n   |\nhelp: remove these parentheses\n   |\n21 -       if (paren_count_stack.pop() == 0) {\n21 +       if paren_count_stack.pop() == 0 {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpxtivqfcu.rs:14:13\n   |\n14 |   for (i in paren_string) {\n   |             ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxtivqfcu.rs:21:38\n   |\n21 |       if (paren_count_stack.pop() == 0) {\n   |                                      ^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<{integer}>`\n              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n21 |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let result = Vec::new();\n  let paren_count = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_count += 1;\n      paren_stack.push(paren_count);\n    } else if (paren_string[i] == ')') {\n      paren_count -= 1;\n      if (paren_count == 0) {\n        result.push(paren_stack.pop());\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpd5slejlc.rs:11:8\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpd5slejlc.rs:11:12\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpd5slejlc.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpd5slejlc.rs:11:13\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpd5slejlc.rs:11:14\n   |\n11 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count_stack.push(paren_count);\n      paren_count_stack_index++;\n      paren_count++;\n    } else if (c == ')') {\n      paren_count_stack_index--;\n      paren_count = paren_count_stack[paren_count_stack_index];\n      if (paren_count > max_nesting) {\n        max_nesting = paren_count;\n        max_nesting_index = paren_stack.len() - 1;\n      }\n      paren_stack.pop();\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < paren_stack.len(); i++) {\n    result.push_back(max_nesting_index - i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpsc_778pk.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpsc_778pk.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpsc_778pk.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpsc_778pk.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpsc_778pk.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n\n  for i in paren_string.iter() {\n    if i == '(' {\n      stack.push(i);\n      level += 1;\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(level);\n      } else {\n        stack.pop();\n        level -= 1;\n      }\n    }\n  }\n\n  if !stack.is_empty() {\n    result.push(level);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpd1wbg0d4.rs:11:25\n   |\n11 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n11 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(paren_count);\n      paren_count += 1;\n    } else if (i == ')') {\n      paren_count -= 1;\n      if (paren_count < 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      if (paren_stack.len() == 0) {\n        panic!(\"Mismatched parentheses\");\n      }\n      paren_end = i;\n      max_nesting = max(max_nesting, paren_stack.len());\n      paren_stack.pop();\n    }\n  }\n\n  if (paren_stack.len() != 0) {\n    panic!(\"Mismatched parentheses\");\n  }\n\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpa18cz1cv.rs:13:10\n   |\n13 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpa18cz1cv.rs:13:7\n   |\n13 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n13 -   for (i in paren_string) {\n13 +   for i in paren_string {\n   | \n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpa18cz1cv.rs:26:21\n   |\n26 |       max_nesting = max(max_nesting, paren_stack.len());\n   |                     ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa18cz1cv.rs:14:8\n   |\n14 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -     if (i == '(') {\n14 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa18cz1cv.rs:17:15\n   |\n17 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (i == ')') {\n17 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa18cz1cv.rs:19:10\n   |\n19 |       if (paren_count < 0) {\n   |          ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -       if (paren_count < 0) {\n19 +       if paren_count < 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa18cz1cv.rs:22:10\n   |\n22 |       if (paren_stack.len() == 0) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n22 -       if (paren_stack.len() == 0) {\n22 +       if paren_stack.len() == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa18cz1cv.rs:31:6\n   |\n31 |   if (paren_stack.len() != 0) {\n   |      ^                      ^\n   |\nhelp",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  for (i in 0..parens.len) {\n    let paren_count = 0;\n    let paren_index = 0;\n    for (j in 0..parens[i].len) {\n      if (parens[i][j] == '(') {\n        paren_count += 1;\n      } else if (parens[i][j] == ')') {\n        paren_count -= 1;\n      }\n      if (paren_count == 0) {\n        break;\n      }\n      paren_index += 1;\n    }\n    if (paren_count > max_nesting) {\n      max_nesting = paren_count;\n      max_nesting_index = i;\n    }\n  }\n  let result = Vec::new();\n  for (i in 0..max_nesting_index) {\n    result.push_back(max_nesting);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp5a2in1ht.rs:10:10\n   |\n10 |   for (i in 0..parens.len) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp5a2in1ht.rs:10:7\n   |\n10 |   for (i in 0..parens.len) {\n   |       ^                  ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (i in 0..parens.len) {\n10 +   for i in 0..parens.len {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp5a2in1ht.rs:13:12\n   |\n13 |     for (j in 0..parens[i].len) {\n   |            ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp5a2in1ht.rs:13:9\n   |\n13 |     for (j in 0..parens[i].len) {\n   |         ^                     ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n13 -     for (j in 0..parens[i].len) {\n13 +     for j in 0..parens[i].len {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp5a2in1ht.rs:30:10\n   |\n30 |   for (i in 0..max_nesting_index) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp5a2in1ht.rs:30:7\n   |\n30 |   for (i in 0..max_nesting_index) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n30 -   for (i in 0..max_nesting_index) {\n30 +   for i in 0..max_nesting_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5a2in1ht.rs:14:10\n   |\n14 |       if (parens[i][j] == '(') {\n   |          ^                   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -       if (parens[i][j] == '(') {\n14 +       if parens[i][j] == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp5a2in1ht.rs:16:17\n   |\n16 |       } else if (parens[i][j] == ')') {\n   |                 ^                   ^\n   |\nhelp: remove these parentheses\n   |\n16 - ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_level_index_in_paren_in\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpfzxfqtr1.rs:23:38\n   |\n23 |   let mut max_level_index_in_paren_in\n   |                                      ^ help: add `;` here\n24 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfzxfqtr1.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  for (i in paren_string) {\n    if (i == '(') {\n      paren_stack.push(paren_count);\n      paren_count += 1;\n      paren_depth += 1;\n    } else if (i == ')') {\n      paren_count -= 1;\n      paren_depth -= 1;\n      if (paren_depth == 0) {\n        paren_end = i;\n        paren_start = paren_stack.pop();\n        break;\n      }\n    }\n  }\n  let result = Vec::new();\n  for (i in paren_start..paren_end) {\n    result.push(paren_count);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmppj21mxb9.rs:12:10\n   |\n12 |   for (i in paren_string) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmppj21mxb9.rs:12:7\n   |\n12 |   for (i in paren_string) {\n   |       ^                 ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n12 -   for (i in paren_string) {\n12 +   for i in paren_string {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmppj21mxb9.rs:28:10\n   |\n28 |   for (i in paren_start..paren_end) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmppj21mxb9.rs:28:7\n   |\n28 |   for (i in paren_start..paren_end) {\n   |       ^                           ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n28 -   for (i in paren_start..paren_end) {\n28 +   for i in paren_start..paren_end {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppj21mxb9.rs:13:8\n   |\n13 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i == '(') {\n13 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppj21mxb9.rs:17:15\n   |\n17 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (i == ')') {\n17 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppj21mxb9.rs:20:10\n   |\n20 |       if (paren_depth == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n20 -       if (paren_depth == 0) {\n20 +       if paren_depth == 0 {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmppj21mxb9.rs:12:13\n   |\n12 |   for (i in paren_string) {\n   |             ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut depth = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      stack.push(c);\n      depth += 1;\n    } else if (c == ')') {\n      if (stack.is_empty()) {\n        result.push(depth);\n      } else {\n        stack.pop();\n        depth -= 1;\n      }\n    }\n  }\n  if (!stack.is_empty()) {\n    result.push(depth);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpxg0vty25.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpxg0vty25.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpxg0vty25.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpxg0vty25.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpxg0vty25.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  for paren in paren_string.split(\" \") {\n    if paren == \"\") {\n      continue;\n    }\n    if paren == \")\") {\n      if stack.len() == 0 {\n        result.push(0);\n      } else {\n        result.push(stack.len() - 1);\n      }\n      stack.pop();\n    } else {\n      stack.push(stack.len() + 1);\n    }\n  }\n  if stack.len() != 0 {\n    result.push(stack.len());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp8gtx9cwh.rs:23:3\n   |\n20 |     } else {\n   |            - this opening brace...\n21 |       stack.push(stack.len() + 1);\n22 |     }\n   |     - ...matches this closing brace\n23 |   }\n   |   ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp8gtx9cwh.rs:9:40\n   |\n9  |   for paren in paren_string.split(\" \") {\n   |                                        ^ unclosed delimiter\n10 |     if paren == \"\") {\n   |                   ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp8gtx9cwh.rs:6:60\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            ^ unclosed delimiter\n...\n13 |     if paren == \")\") {\n   |                    ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_index = 0;\n  let mut max_index_of_level = 0;\n  let mut max_index_of_level_of_current_level = 0;\n  let mut max_index_of_level_of_current_level_of_current_level = 0;\n  let mut max_index_of_level_of_current_level_of_current_level_of_current_level = 0;\n  for (i, c in paren_string) {\n    if (c == '(') {\n      current_level += 1;\n      if (current_level > max_level) {\n        max_level = current_level;\n        max_index = i;\n      }\n    } else if (c == ')') {\n      current_level -= 1;\n      if (current_level == max_level) {\n        max_index_of_level = i;\n        max_index_of_level_of_current_level = max_index;\n        max_index_of_level_of_current_level_of_current_level = max_index_of_level;\n        max_index_of_level_of_current_level_of_current_level_of_current_level = max_index_of_level_of_current_level;\n      }\n    }\n  }\n  result.push(max_level);\n  result.push(max_index_of_level);\n  result.push(max_index_of_level_of_current_level);\n  result.push(max_index_of_level_of_current_level_of_current_level);\n  result.push(max_index_of_level_of_current_level_of_current_level_of_current_level);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmppq34ddqa.rs:15:13\n   |\n15 |   for (i, c in paren_string) {\n   |             ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmppq34ddqa.rs:15:7\n   |\n15 |   for (i, c in paren_string) {\n   |       ^                    ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i, c in paren_string) {\n15 +   for i, c in paren_string {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppq34ddqa.rs:16:8\n   |\n16 |     if (c == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -     if (c == '(') {\n16 +     if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppq34ddqa.rs:18:10\n   |\n18 |       if (current_level > max_level) {\n   |          ^                         ^\n   |\nhelp: remove these parentheses\n   |\n18 -       if (current_level > max_level) {\n18 +       if current_level > max_level {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppq34ddqa.rs:22:15\n   |\n22 |     } else if (c == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (c == ')') {\n22 +     } else if c == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppq34ddqa.rs:24:10\n   |\n24 |       if (current_level == max_level) {\n   |          ^                          ^\n   |\nhelp: remove these parentheses\n   |\n24 -       if (current_level == max_level) {\n24 +       if current_level == max_level {\n   | \n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmppq34ddqa.rs:15:16\n   |\n15 |   for (i, c in paren_string) {\n   |                ^^^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror: ab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push_back(i);\n    } else if (c == ')') {\n      if (paren_stack.is_empty()) {\n        max_nesting = 0;\n      } else {\n        max_nesting = max(max_nesting, paren_stack.len());\n        paren_stack.pop_back();\n      }\n    }\n  }\n  max_nesting = max(max_nesting, paren_stack.len());\n  return paren_stack.map(i => i - max_nesting);\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n --> /tmp/tmpz0m_k0v5.rs:9:8\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n --> /tmp/tmpz0m_k0v5.rs:9:12\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |           -^ expected one of `)`, `,`, `@`, or `|`\n  |           |\n  |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n --> /tmp/tmpz0m_k0v5.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n --> /tmp/tmpz0m_k0v5.rs:9:13\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n --> /tmp/tmpz0m_k0v5.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result: Vec<isize> = Vec::new();\n  let mut stack: Vec<isize> = Vec::new();\n  let mut max_level: isize = 0;\n  let mut max_level_index: isize = 0;\n  let mut max_level_count: isize = 0;\n  let mut max_level_count_index: isize = 0;\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(i);\n      } else {\n        stack.pop();\n      }\n    } else if stack.is_empty() {\n      result.push(i);\n    } else {\n      if stack.last() == '(' {\n        stack.pop();\n        stack.push(i);\n      } else {\n        stack.push(i);\n      }\n    }\n\n    if stack.last() == '(' {\n      max_level = max(max_level, stack.len());\n      max_level_index = stack.len() - 1;\n      max_level_count = max(max_level_count, stack.len());\n      max_level_count_index = stack.len() - 1;\n    }\n  }\n\n  result.push(max_level);\n  result.push(max_level_index);\n  result.push(max_level_count);\n  result.push(max_level_count_index);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpg9oxl8ds.rs:35:19\n   |\n35 |       max_level = max(max_level, stack.len());\n   |                   ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpg9oxl8ds.rs:37:25\n   |\n37 |       max_level_count = max(max_level_count, stack.len());\n   |                         ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9oxl8ds.rs:16:18\n   |\n16 |       stack.push(i);\n   |                  ^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9oxl8ds.rs:19:21\n   |\n19 |         result.push(i);\n   |                     ^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9oxl8ds.rs:24:19\n   |\n24 |       result.push(i);\n   |                   ^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9oxl8ds.rs:26:26\n   |\n26 |       if stack.last() == '(' {\n   |                          ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&isize>`\n              found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9oxl8ds.rs:28:20\n   |\n28 |         stack.push(i);\n   |                    ^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9oxl8ds.rs:30:20\n   |\n30 |         stack.push(i);\n   |                    ^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9oxl8ds.rs:34:24\n   |\n34 |     if stack.last() == '(' {\n   |                        ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&isize>`\n              found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9oxl8ds.rs:36:25\n   |\n10 |   let mut max_level_index: isize = 0;\n   |                            ----- expected due to this type\n...\n36 |       max_level_index = st",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for i in paren_string.chars() {\n    if paren_stack.len() == 0 {\n      result.push(0);\n    }\n    if paren_stack.len() > 0 {\n      if paren_stack.last() == 0 {\n        paren_stack.pop();\n        result.push(0);\n      } else {\n        result.push(paren_stack.last());\n      }\n    }\n    if paren_stack.len() == 0 {\n      if i == '(' {\n        paren_stack.push(0);\n      } else if i == ')' {\n        paren_stack.push(1);\n      }\n    } else {\n      if i == '(' {\n        paren_stack.push(0);\n      } else if i == ')' {\n        paren_stack.pop();\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpw456iwrq.rs:15:32\n   |\n15 |       if paren_stack.last() == 0 {\n   |                                ^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<&{integer}>`\n              found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw456iwrq.rs:19:21\n   |\n19 |         result.push(paren_stack.last());\n   |                     ^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<&{integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  for (i, paren in parens.iter()) {\n    if (paren.is_empty()) {\n      continue;\n    }\n    let nesting = paren.count(\"(\");\n    if (nesting > max_nesting) {\n      max_nesting = nesting;\n      max_nesting_index = i;\n    }\n  }\n  let result = Vec::new();\n  for (i, paren in parens.iter()) {\n    if (paren.is_empty()) {\n      continue;\n    }\n    if (paren.count(\"(\") > max_nesting) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpxzk47map.rs:10:17\n   |\n10 |   for (i, paren in parens.iter()) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpxzk47map.rs:10:7\n   |\n10 |   for (i, paren in parens.iter()) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (i, paren in parens.iter()) {\n10 +   for i, paren in parens.iter() {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpxzk47map.rs:21:17\n   |\n21 |   for (i, paren in parens.iter()) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpxzk47map.rs:21:7\n   |\n21 |   for (i, paren in parens.iter()) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -   for (i, paren in parens.iter()) {\n21 +   for i, paren in parens.iter() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxzk47map.rs:11:8\n   |\n11 |     if (paren.is_empty()) {\n   |        ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (paren.is_empty()) {\n11 +     if paren.is_empty() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxzk47map.rs:15:8\n   |\n15 |     if (nesting > max_nesting) {\n   |        ^                     ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (nesting > max_nesting) {\n15 +     if nesting > max_nesting {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxzk47map.rs:22:8\n   |\n22 |     if (paren.is_empty()) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n22 -     if (paren.is_empty()) {\n22 +     if paren.is_empty() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxzk47map.rs:25:8\n   |\n25 |     if (paren.count(\"(\") > max_nesting) {\n   |   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  for (i, c in paren_string.chars()) {\n    if (c == '(') {\n      paren_stack.push_back(i);\n    } else if (c == ')') {\n      if (paren_stack.is_empty()) {\n        max_nesting = 0;\n      } else {\n        max_nesting = max(max_nesting, paren_stack.pop());\n      }\n    }\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n --> /tmp/tmpebjtj9ng.rs:9:13\n  |\n9 |   for (i, c in paren_string.chars()) {\n  |             ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n --> /tmp/tmpebjtj9ng.rs:9:7\n  |\n9 |   for (i, c in paren_string.chars()) {\n  |       ^                            ^\n  |\nhelp: remove parentheses in `for` loop\n  |\n9 -   for (i, c in paren_string.chars()) {\n9 +   for i, c in paren_string.chars() {\n  | \n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpebjtj9ng.rs:16:23\n   |\n16 |         max_nesting = max(max_nesting, paren_stack.pop());\n   |                       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpebjtj9ng.rs:10:8\n   |\n10 |     if (c == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -     if (c == '(') {\n10 +     if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpebjtj9ng.rs:12:15\n   |\n12 |     } else if (c == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n12 -     } else if (c == ')') {\n12 +     } else if c == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpebjtj9ng.rs:13:10\n   |\n13 |       if (paren_stack.is_empty()) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n13 -       if (paren_stack.is_empty()) {\n13 +       if paren_stack.is_empty() {\n   | \n\nerror[E0308]: mismatched types\n --> /tmp/tmpebjtj9ng.rs:9:7\n  |\n9 |   for (i, c in paren_string.chars()) {\n  |       ^^^^^    -------------------- this expression has type `Option<char>`\n  |       |\n  |       expected `char`, found tuple\n  |\n  = note: expected type `char`\n            found tuple `(_, _)`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec<isize>::new();\n  let paren_depth_stack = Vec<isize>::new();\n\n  paren_stack.push(0);\n  paren_count_stack.push(0);\n  paren_depth_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count_stack.push(paren_count);\n      paren_depth_stack.push(paren_depth);\n      paren_count = 0;\n      paren_depth = 0;\n      paren_start = i;\n    } else if (c == ')') {\n      paren_count = paren_count_stack.pop();\n      paren_depth = paren_depth_stack.pop();\n      paren_end = i;\n      if (paren_count == 0) {\n        paren_stack.pop();\n        if (paren_stack.len() == 0) {\n          return paren_depth_stack.pop();\n        }\n      }\n    } else {\n      paren_count += 1;\n      if (c == '(') {\n        paren_depth += 1;\n      } else if (c == ')') {\n        paren_depth -= 1;\n      }\n    }\n  }\n  return paren_depth_stack.pop();\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: comparison operators cannot be chained\n --> /tmp/tmplml5besc.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmplml5besc.rs:12:30\n   |\n12 |   let paren_count_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n12 |   let paren_count_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmplml5besc.rs:13:30\n   |\n13 |   let paren_depth_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n13 |   let paren_depth_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmplml5besc.rs:19:8\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmplml5besc.rs:19:12\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmplml5besc.rs:19:14\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmplml5besc.rs:19:13\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmplml5besc.rs:19:14\n   |\n19 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: ab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  let paren_level_stack = Vec::new();\n  let paren_start_stack = Vec::new();\n  let paren_end_stack = Vec::new();\n\n  paren_string.chars().for_each(|c| {\n    if (c == '(') {\n      paren_count += 1;\n      paren_count_stack.push_back(paren_count);\n      paren_level_stack.push_back(paren_level);\n      paren_start_stack.push_back(paren_start);\n      paren_end_stack.push_back(paren_end);\n      paren_stack.push_back(paren_level);\n      paren_level += 1;\n      paren_start = paren_end;\n    } else if (c == ')') {\n      paren_count -= 1;\n      paren_count_stack.pop_back();\n      paren_level_stack.pop_back();\n      paren_start_stack.pop_back();\n      paren_end_stack.pop_back();\n      paren_stack.pop_back();\n      paren_level -= 1;\n      paren_end = paren_start;\n    } else if (c == ' ') {\n      if (paren_count == 0) {\n        paren_count_stack.pop_back();\n        paren_level_stack.pop_back();\n        paren_start_stack.pop_back();\n        paren_end_stack.pop_back();\n        paren_stack.pop_back();\n        paren_level -= 1;\n        paren_end = paren_start;\n      } else {\n        paren_end += 1;\n      }\n    }\n  });\n\n  let max_level = paren_stack.max();\n  let max_count = paren_count_stack.max();\n  let max_level_stack = paren_level_stack.max();\n  let max_count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp9l6vc_x4.rs:54:16\n   |\n54 |   let max_count\n   |                ^ help: add `;` here\n55 | }\n   | - unexpected token\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9l6vc_x4.rs:18:8\n   |\n18 |     if (c == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n18 -     if (c == '(') {\n18 +     if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9l6vc_x4.rs:27:15\n   |\n27 |     } else if (c == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n27 -     } else if (c == ')') {\n27 +     } else if c == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9l6vc_x4.rs:36:15\n   |\n36 |     } else if (c == ' ') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n36 -     } else if (c == ' ') {\n36 +     } else if c == ' ' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp9l6vc_x4.rs:37:10\n   |\n37 |       if (paren_count == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n37 -       if (paren_count == 0) {\n37 +       if paren_count == 0 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp9l6vc_x4.rs:20:25\n   |\n20 |       paren_count_stack.push_back(paren_count);\n   |                         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp9l6vc_x4.rs:21:25\n   |\n21 |       paren_level_stack.push_back(paren_level);\n   |                         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp9l6vc_x4.rs:22:25\n   |\n22 |       paren_start_stack.push_back(paren_start);\n   |                         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  for (i in 0..len(parens)) {\n    let paren_count = count_parens(parens[i]);\n    if (paren_count > max_nesting) {\n      max_nesting = paren_count;\n      max_nesting_index = i;\n    }\n  }\n  let result = Vec::new();\n  for (i in 0..max_nesting_index) {\n    result.push_back(max_nesting);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp_avfquzc.rs:10:10\n   |\n10 |   for (i in 0..len(parens)) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp_avfquzc.rs:10:7\n   |\n10 |   for (i in 0..len(parens)) {\n   |       ^                   ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (i in 0..len(parens)) {\n10 +   for i in 0..len(parens) {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmp_avfquzc.rs:18:10\n   |\n18 |   for (i in 0..max_nesting_index) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmp_avfquzc.rs:18:7\n   |\n18 |   for (i in 0..max_nesting_index) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n18 -   for (i in 0..max_nesting_index) {\n18 +   for i in 0..max_nesting_index {\n   | \n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp_avfquzc.rs:10:16\n   |\n10 |   for (i in 0..len(parens)) {\n   |                ^^^ not found in this scope\n\nerror[E0425]: cannot find function `count_parens` in this scope\n  --> /tmp/tmp_avfquzc.rs:11:23\n   |\n11 |     let paren_count = count_parens(parens[i]);\n   |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_avfquzc.rs:12:8\n   |\n12 |     if (paren_count > max_nesting) {\n   |        ^                         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (paren_count > max_nesting) {\n12 +     if paren_count > max_nesting {\n   | \n\nerror[E0608]: cannot index into a value of type `std::str::Split<'_, &str>`\n  --> /tmp/tmp_avfquzc.rs:11:36\n   |\n11 |     let paren_count = count_parens(parens[i]);\n   |                                    ^^^^^^^^^\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_max = 0;\n  let paren_count_stack_max_max_index = 0;\n  let paren_count_stack_max_max_max = 0;\n  let paren_count_stack_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max_index = 0;\n  let paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpcuxsu17r.rs:33:12\n   |\n33 |   let paren\n   |            ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcuxsu17r.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_count = 0;\n  let mut current_level_count = 0;\n  let mut current_level_index = 0;\n  let mut current_level_count_index = 0;\n  let mut current_level_count_count = 0;\n  let mut current_level_count_count_index = 0;\n  let mut current_level_count_count_count = 0;\n  let mut current_level_count_count_count_index = 0;\n  let mut current_level_count_count_count_count = 0;\n  let mut current_level_count_count_count_count_index = 0;\n  let mut current_level_count_count_count_count_count = 0;\n  let mut current_level_count_count_count_count_count_index = 0;\n  let mut current_level_count_count_count_count_count_count = 0;\n  let mut current_level_count_count_count_count_count_count_index = 0;\n  let mut current_level_count_count_count_count_count_count_count = 0;\n  let mut current_level_count_count_count_count_count_count_count_index = 0;\n  let mut current_level_count_count_count_count_count_count_count_count = 0;\n  let mut current_level_count_count_count_count_count_count_count_count_index = 0;\n  let mut current_level_count_count_count_count_count_count_count_count_count = 0;\n  let mut current_level_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut current_level_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut current_level_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut current_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpdh_577lg.rs:33:24\n   |\n33 |   let mut current_level\n   |                        ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdh_577lg.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_in_stack = 0;\n  let mut max_nesting_index_in_stack_in_stack = 0;\n  let mut max_nesting_index_in_stack_in_stack_in_stack = 0;\n  let mut max_nesting_index_in_stack_in_stack_in_stack_in_stack = 0;\n\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n      max_nesting = 0;\n      max_nesting_index = 0;\n      max_nesting_index_in_stack = 0;\n      max_nesting_index_in_stack_in_stack = 0;\n      max_nesting_index_in_stack_in_stack_in_stack = 0;\n      max_nesting_index_in_stack_in_stack_in_stack_in_stack = 0;\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(max_nesting);\n      } else {\n        if max_nesting > stack.last() {\n          max_nesting = stack.last();\n          max_nesting_index = stack.len();\n          max_nesting_index_in_stack = stack.len() - 1;\n          max_nesting_index_in_stack_in_stack = stack.len() - 2;\n          max_nesting_index_in_stack_in_stack_in_stack = stack.len() - 3;\n          max_nesting_index_in_stack_in_stack_in_stack_in_stack = stack.len() - 4;\n        }\n        stack.pop();\n      }\n    } else if i == ' ' {\n      if max_nesting > stack.last() {\n        max_nesting = stack.last();\n        max_nesting_index = stack.len();\n        max_nesting_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl2jo2nk4.rs:51:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n16 |   for i in paren_string.chars() {\n   |                                 - unclosed delimiter\n...\n39 |     } else if i == ' ' {\n   |                        - unclosed delimiter\n40 |       if max_nesting > stack.last() {\n   |                                     - this delimiter might not be properly closed...\n...\n44 | }\n   | - ...as it matches this but it has different indentation\n...\n51 | }\n   |   ^\n\nerror[E0425]: cannot find value `max_nesting_` in this scope\n  --> /tmp/tmpl2jo2nk4.rs:43:9\n   |\n43 |         max_nesting_\n   |         ^^^^^^^^^^^^ help: a local variable with a similar name exists: `max_nesting`\n\nerror[E0277]: can't compare `{integer}` with `Option<&char>`\n  --> /tmp/tmpl2jo2nk4.rs:29:24\n   |\n29 |         if max_nesting > stack.last() {\n   |                        ^ no implementation for `{integer} < Option<&char>` and `{integer} > Option<&char>`\n   |\n   = help: the trait `PartialOrd<Option<&char>>` is not implemented for `{integer}`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2jo2nk4.rs:30:25\n   |\n9  |   let mut max_nesting = 0;\n   |                         - expected due to this value\n...\n30 |           max_nesting = stack.last();\n   |                         ^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<&char>`\n\nerror[E0277]: can't compare `{integer}` with `Option<&char>`\n  --> /tmp/tmpl2jo2nk4.rs:40:22\n   |\n40 |       if max_nesting > stack.last() {\n   |                      ^ no implementation for `{integer} < Option<&char>` and `{integer} > Opt",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_start = 0;\n  let mut max_level_index_end = 0;\n  let mut max_level_index_start_end = 0;\n  let mut max_level_index_start_end_index = 0;\n  let mut max_level_index_start_end_index_start = 0;\n  let mut max_level_index_start_end_index_end = 0;\n  let mut max_level_index_start_end_index_start_end = 0;\n  let mut max_level_index_start_end_index_start_end_index = 0;\n  let mut max_level_index_start_end_index_start_end_index_start = 0;\n  let mut max_level_index_start_end_index_start_end_index_end = 0;\n  let mut max_level_index_start_end_index_start_end_index_start_end = 0;\n  let mut max_level_index_start_end_index_start_end_index_start_end_index = 0;\n  let mut max_level_index_start_end_index_start_end_index_start_end_index_start = 0;\n  let mut max_level_index_start_end_index_start_end_index_start_end_index_end = 0;\n  let mut max_level_index_start_end_index_start_end_index_start_end_index_start_end = 0;\n  let mut max_level_index_start_end_index_start_end_index_start_end_index_start_end_index = 0;\n  let mut max_level_index_start_end_index_start_end_index_start_end_index_start_end_index_start = 0;\n  let mut max_level_index_start_end_index_start_end_index_start_end_index_start_end_index_end = 0;\n  let\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected pattern, found `}`\n  --> /tmp/tmplz1suaif.rs:30:1\n   |\n30 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_level = 0;\n  for i in paren_string.chars() {\n    if i == '(' {\n      stack.push(i);\n    } else if i == ')' {\n      if stack.is_empty() {\n        result.push(max_level);\n        max_level = 0;\n      } else {\n        max_level = max(max_level, stack.pop());\n      }\n    }\n  }\n  result.push(max_level);\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpdqga4103.rs:18:21\n   |\n18 |         max_level = max(max_level, stack.pop());\n   |                     ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n\n  for (i, c in paren_string.iter()) {\n    if (c == '(') {\n      paren_stack.push_back(paren_count);\n      paren_count += 1;\n      paren_start = i;\n    } else if (c == ')') {\n      paren_count -= 1;\n      paren_end = i;\n      if (paren_count == 0) {\n        paren_depth = paren_stack.pop();\n      }\n    }\n  }\n\n  return paren_depth;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpde2xwv3j.rs:13:13\n   |\n13 |   for (i, c in paren_string.iter()) {\n   |             ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpde2xwv3j.rs:13:7\n   |\n13 |   for (i, c in paren_string.iter()) {\n   |       ^                           ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n13 -   for (i, c in paren_string.iter()) {\n13 +   for i, c in paren_string.iter() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpde2xwv3j.rs:14:8\n   |\n14 |     if (c == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -     if (c == '(') {\n14 +     if c == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpde2xwv3j.rs:18:15\n   |\n18 |     } else if (c == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (c == ')') {\n18 +     } else if c == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpde2xwv3j.rs:21:10\n   |\n21 |       if (paren_count == 0) {\n   |          ^                ^\n   |\nhelp: remove these parentheses\n   |\n21 -       if (paren_count == 0) {\n21 +       if paren_count == 0 {\n   | \n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpde2xwv3j.rs:13:29\n   |\n13 |   for (i, c in paren_string.iter()) {\n   |                             ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n13 |   for (i, c in paren_string.chars()) {\n   |                             ~~~~~\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpde2xwv3j.rs:15:19\n   |\n15 |       paren_stack.push_back(paren_count);\n   |                   ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0308]:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  for (i := 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(paren_count);\n      paren_count_stack.push(paren_count);\n      paren_count = 0;\n    } else if (paren_string[i] == ')') {\n      paren_count = paren_count_stack.pop();\n      if (paren_count > max_nesting) {\n        max_nesting = paren_count;\n        max_nesting_index = i;\n      }\n    } else {\n      paren_count += 1;\n    }\n  }\n\n  let result = Vec::new();\n  for (i := max_nesting_index; i < paren_string.len(); i++) {\n    result.push(paren_stack.pop());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> /tmp/tmpovqgsxn6.rs:15:10\n   |\n15 |   for (i := 0; i < paren_string.len(); i++) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpovqgsxn6.rs:15:9\n   |\n15 |   for (i := 0; i < paren_string.len(); i++) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `:`\n  --> /tmp/tmpovqgsxn6.rs:15:10\n   |\n15 |   for (i := 0; i < paren_string.len(); i++) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  for (i in 0..parens.len) {\n    let nesting = count_nesting_parens(parens[i]);\n    if (nesting > max_nesting) {\n      max_nesting = nesting;\n      max_nesting_index = i;\n    }\n  }\n  let result = Vec::new();\n  for (i in 0..max_nesting_index) {\n    result.push_back(count_nesting_parens(parens[i]));\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpegzw9dz_.rs:10:10\n   |\n10 |   for (i in 0..parens.len) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpegzw9dz_.rs:10:7\n   |\n10 |   for (i in 0..parens.len) {\n   |       ^                  ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (i in 0..parens.len) {\n10 +   for i in 0..parens.len {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpegzw9dz_.rs:18:10\n   |\n18 |   for (i in 0..max_nesting_index) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpegzw9dz_.rs:18:7\n   |\n18 |   for (i in 0..max_nesting_index) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n18 -   for (i in 0..max_nesting_index) {\n18 +   for i in 0..max_nesting_index {\n   | \n\nerror[E0425]: cannot find function `count_nesting_parens` in this scope\n  --> /tmp/tmpegzw9dz_.rs:11:19\n   |\n11 |     let nesting = count_nesting_parens(parens[i]);\n   |                   ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `count_nesting_parens` in this scope\n  --> /tmp/tmpegzw9dz_.rs:19:22\n   |\n19 |     result.push_back(count_nesting_parens(parens[i]));\n   |                      ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpegzw9dz_.rs:12:8\n   |\n12 |     if (nesting > max_nesting) {\n   |        ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (nesting > max_nesting) {\n12 +     if nesting > max_nesting {\n   | \n\nerror[E0609]: no field `len` on type `std::str::Split<'_, &str>`\n  --> /tmp/tmpegzw9dz_.rs:10:23\n   |\n10 |   for (i in 0..parens.len) {\n   |                       ^^^ unknown field\n\nerror[E0608]: cannot index into a value of type `std::str::Split<'_, &s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_prev = 0;\n  let mut max_level_index_next = 0;\n  let mut max_level_index_next_prev = 0;\n  let mut max_level_index_next_next = 0;\n  let mut max_level_index_next_next_prev = 0;\n  let mut max_level_index_next_next_next = 0;\n  let mut max_level_index_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut max_level_index_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_level_index_next\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpx4a5tru4.rs:31:31\n   |\n31 |   let mut max_level_index_next\n   |                               ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpx4a5tru4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  let mut max_level = 0;\n  let mut max_level_index = 0;\n  let mut max_level_index_prev = 0;\n  let mut max_level_index_next = 0;\n  let mut max_level_index_prev_prev = 0;\n  let mut max_level_index_next_next = 0;\n  let mut max_level_index_prev_prev_prev = 0;\n  let mut max_level_index_next_next_next = 0;\n  let mut max_level_index_prev_prev_prev_prev = 0;\n  let mut max_level_index_next_next_next_next = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      stack.push(i);\n      level += 1;\n    } else if (c == ')') {\n      if (level == 0) {\n        result.push(i);\n        continue;\n      }\n      if (level == 1) {\n        result.push(i);\n        continue;\n      }\n      if (level == 2) {\n        result.push(i);\n        continue;\n      }\n      if (level == 3) {\n        result.push(i);\n        continue;\n      }\n      if (level == 4) {\n        result.push(i);\n        continue;\n      }\n      if (level == 5) {\n        result.push(i);\n        continue;\n      }\n      if (level == 6) {\n        result.push(i);\n        continue;\n      }\n      if (level == 7) {\n        result.push(i);\n        continue;\n      }\n      if (level == 8) {\n        result.push(i);\n        continue;\n      }\n      if (level == 9) {\n        result.push(i);\n        continue;\n      }\n      if (level == 10) {\n        result.push(i);\n\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwmmm_wma.rs:76:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n20 |   for (let i = 0; i < paren_string.len(); i++) {\n   |                                                - unclosed delimiter\n...\n25 |     } else if (c == ')') {\n   |                          - unclosed delimiter\n...\n66 |       if (level == 10) {\n   |                        - this delimiter might not be properly closed...\n...\n69 | }\n   | - ...as it matches this but it has different indentation\n...\n76 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpwmmm_wma.rs:20:8\n   |\n20 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpwmmm_wma.rs:20:12\n   |\n20 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpwmmm_wma.rs:20:14\n   |\n20 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpwmmm_wma.rs:20:13\n   |\n20 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpwmmm_wma.rs:20:14\n   |\n20 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  let paren_count_stack_index = 0;\n  let paren_count_stack_size = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_size = 0;\n  let paren_count_stack_max_max = 0;\n  let paren_count_stack_max_max_index = 0;\n  let paren_count_stack_max_max_size = 0;\n  let paren_count_stack_max_max_max = 0;\n  let paren_count_stack_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_size = 0;\n  let paren_count_stack_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_size = 0;\n  let paren_count_stack_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_size = 0;\n  let paren_count_stack_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_size = 0;\n  let paren_count_stack_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_index = 0\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpdz621n8m.rs:34:62\n   |\n34 |   let paren_count_stack_max_max_max_max_max_max_max_index = 0\n   |                                                              ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpdz621n8m.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_start = 0;\n  let paren_count_end = 0;\n  let paren_count_start_end = 0;\n  let paren_count_start_end_start = 0;\n  let paren_count_start_end_end = 0;\n  let paren_count_start_end_start_end = 0;\n  let paren_count_start_end_end_start = 0;\n  let paren_count_start_end_end_end = 0;\n  let paren_count_start_end_start_end_start = 0;\n  let paren_count_start_end_end_start_end_end = 0;\n  let paren_count_start_end_start_end_end_start = 0;\n  let paren_count_start_end_end_start_end_end = 0;\n  let paren_count_start_end_start_end_end_start_end = 0;\n  let paren_count_start_end_end_start_end_end_start_end = 0;\n  let paren_count_start_end_end_start_end_end_start_end_start = 0;\n  let paren_count_start_end_end_start_end_end_start_end_end = 0;\n  let paren_count_start_end_end_start_end_end_start_end_start = 0;\n  let paren_count_start_end_end_start_end_end_start_end_end = 0;\n  let paren_count_start_end_end_start_end_end_start_end_start = 0;\n  let paren_count_start_end_end_start_end_end_start_end_end = 0;\n  let paren_count_start_end_end\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp1cek6_vk.rs:34:32\n   |\n34 |   let paren_count_start_end_end\n   |                                ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1cek6_vk.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec<isize>::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec<isize>::new();\n  let paren_depth_stack = Vec<isize>::new();\n  let paren_start_stack = Vec<isize>::new();\n  let paren_end_stack = Vec<isize>::new();\n  paren_count_stack.push(0);\n  paren_depth_stack.push(0);\n  paren_start_stack.push(0);\n  paren_end_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count_stack.push(paren_count);\n      paren_depth_stack.push(paren_depth);\n      paren_start_stack.push(paren_start);\n      paren_end_stack.push(paren_end);\n      paren_count = 0;\n      paren_depth = 0;\n      paren_start = i;\n      paren_end = i;\n    } else if (c == ')') {\n      paren_count = paren_count_stack.pop();\n      paren_depth = paren_depth_stack.pop();\n      paren_start = paren_start_stack.pop();\n      paren_end = paren_end_stack.pop();\n      if (paren_count == 0) {\n        paren_count = paren_count_stack.pop();\n        paren_depth = paren_depth_stack.pop();\n        paren_start = paren_start_stack.pop();\n        paren_end = paren_end_stack.pop();\n      }\n    } else if (c == ' ') {\n      if (paren_count == 0) {\n        paren_count = paren_count_stack.pop();\n        paren_depth = paren_depth_stack.pop();\n        paren_start = p\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpou54r1ig.rs:54:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n20 |   for (let i = 0; i < paren_string.len(); i++) {\n   |                                                - unclosed delimiter\n...\n42 |     } else if (c == ' ') {\n   |                          - unclosed delimiter\n43 |       if (paren_count == 0) {\n   |                             - this delimiter might not be properly closed...\n...\n47 | }\n   | - ...as it matches this but it has different indentation\n...\n54 | }\n   |   ^\n\nerror: comparison operators cannot be chained\n --> /tmp/tmpou54r1ig.rs:7:24\n  |\n7 |   let paren_stack = Vec<isize>::new();\n  |                        ^     ^\n  |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n  |\n7 |   let paren_stack = Vec::<isize>::new();\n  |                        ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpou54r1ig.rs:12:30\n   |\n12 |   let paren_count_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n12 |   let paren_count_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpou54r1ig.rs:13:30\n   |\n13 |   let paren_depth_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n13 |   let paren_depth_stack = Vec::<isize>::new();\n   |                              ++\n\nerror: comparison operators cannot be chained\n  --> /tmp/tmpou54r1ig.rs:14:30\n   |\n14 |   let paren_start_stack = Vec<isize>::new();\n   |                              ^     ^\n   |\nhelp: use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n   |\n14 |   let paren_start_stack = Vec::<isize>::new();\n   |           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  for (i, paren in parens.iter()) {\n    if (paren.is_empty()) {\n      continue;\n    }\n    let nesting = paren.count(\"(\");\n    if (nesting > max_nesting) {\n      max_nesting = nesting;\n      max_nesting_index = i;\n    }\n  }\n  let result = Vec::new();\n  for (i, paren in parens.iter()) {\n    if (paren.is_empty()) {\n      continue;\n    }\n    if (i == max_nesting_index) {\n      result.push(max_nesting);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpuj8i3bl7.rs:10:17\n   |\n10 |   for (i, paren in parens.iter()) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpuj8i3bl7.rs:10:7\n   |\n10 |   for (i, paren in parens.iter()) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (i, paren in parens.iter()) {\n10 +   for i, paren in parens.iter() {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpuj8i3bl7.rs:21:17\n   |\n21 |   for (i, paren in parens.iter()) {\n   |                 ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpuj8i3bl7.rs:21:7\n   |\n21 |   for (i, paren in parens.iter()) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -   for (i, paren in parens.iter()) {\n21 +   for i, paren in parens.iter() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuj8i3bl7.rs:11:8\n   |\n11 |     if (paren.is_empty()) {\n   |        ^                ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (paren.is_empty()) {\n11 +     if paren.is_empty() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuj8i3bl7.rs:15:8\n   |\n15 |     if (nesting > max_nesting) {\n   |        ^                     ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (nesting > max_nesting) {\n15 +     if nesting > max_nesting {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuj8i3bl7.rs:22:8\n   |\n22 |     if (paren.is_empty()) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n22 -     if (paren.is_empty()) {\n22 +     if paren.is_empty() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpuj8i3bl7.rs:25:8\n   |\n25 |     if (i == max_nesting_index) {\n   |        ^  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_index = 0;\n  let current_char = 0;\n  let current_char_index = 0;\n  let current_paren_index = 0;\n  let current_paren_count = 0;\n  let current_paren_stack = Vec::new();\n  let current_paren_stack_index = 0;\n  let current_paren_stack_count = 0;\n  let current_paren_stack_count_index = 0;\n  let current_paren_stack_count_count = 0;\n  let current_paren_stack_count_count_index = 0;\n  let current_paren_stack_count_count_count = 0;\n  let current_paren_stack_count_count_count_index = 0;\n  let current_paren_stack_count_count_count_count = 0;\n  let current_paren_stack_count_count_count_count_index = 0;\n  let current_paren_stack_count_count_count_count_count = 0;\n  let current_paren_stack_count_count_count_count_count_index = 0;\n  let current_paren_stack_count_count_count_count_count_count = 0;\n  let current_paren_stack_count_count_count_count_count_count_index = 0;\n  let current_paren_stack_count_count_count_count_count_count_count = 0;\n  let current_paren_stack_count_count_count_count_count_count_count_index = 0;\n  let current_paren_stack_count_count_count_count_count_count_count_count = 0;\n  let current_paren_stack_count_count_count_count_count_count_count_count_index = 0;\n  let current_paren_stack_count_count_count_count_count_count_count_count_count = 0;\n  let current_paren_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp6dr_ie2n.rs:37:21\n   |\n37 |   let current_paren_\n   |                     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp6dr_ie2n.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  for (i in 0..parens.len) {\n    let nesting = 0;\n    for (j in 0..i) {\n      if (parens[j] == \"(\" && parens[i] == \")\") {\n        nesting--;\n      } else if (parens[j] == \")\" && parens[i] == \"(\" && nesting == 0) {\n        nesting++;\n      }\n    }\n    if (nesting > max_nesting) {\n      max_nesting = nesting;\n      max_nesting_index = i;\n    }\n  }\n  let result = Vec::new();\n  for (i in 0..max_nesting_index) {\n    result.append(i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplqxgqqnw.rs:10:10\n   |\n10 |   for (i in 0..parens.len) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplqxgqqnw.rs:10:7\n   |\n10 |   for (i in 0..parens.len) {\n   |       ^                  ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (i in 0..parens.len) {\n10 +   for i in 0..parens.len {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplqxgqqnw.rs:12:12\n   |\n12 |     for (j in 0..i) {\n   |            ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplqxgqqnw.rs:12:9\n   |\n12 |     for (j in 0..i) {\n   |         ^         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n12 -     for (j in 0..i) {\n12 +     for j in 0..i {\n   | \n\nerror: expected expression, found `;`\n  --> /tmp/tmplqxgqqnw.rs:14:18\n   |\n14 |         nesting--;\n   |                  ^ expected expression\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmplqxgqqnw.rs:16:16\n   |\n16 |         nesting++;\n   |                ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |         { let tmp = nesting; nesting += 1; tmp };\n   |         +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n16 -         nesting++;\n16 +         nesting += 1;\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmplqxgqqnw.rs:25:10\n   |\n25 |   for (i in 0..max_nesting_index) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmplqxgqqnw.rs:25:7\n   |\n25 |   for (i in 0..max_nesting_index) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n25 -   for (i in 0..max_nesting_index) {\n25 +   for i in 0..max_nesting_index {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplqxgqqnw.rs:13:10\n   |\n13 |       if (parens[j] ==",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let paren_count = 0;\n  let paren_index = 0;\n  let paren_depth = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_depth = 0;\n  let paren_count_stack_max_depth_index = 0;\n  let paren_count_stack_max_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index = 0;\n  let paren_count_stack_max_depth_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth_depth_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth_depth_depth_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth_depth_depth_depth_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth_depth_depth_depth_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth_depth_depth_depth_depth_depth_depth = 0;\n  let paren_count_stack_max_depth_depth_index_depth_depth_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp1z1t9svd.rs:32:64\n   |\n32 |   let paren_count_stack_max_depth_depth_index_depth_depth_depth\n   |                                                                ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp1z1t9svd.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_top = 0;\n  let paren_count_stack_top_prev = 0;\n  let paren_count_stack_top_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let paren_count_stack_top_prev_prev\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpr23_eg26.rs:29:38\n   |\n29 |   let paren_count_stack_top_prev_prev\n   |                                      ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpr23_eg26.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for i in paren_string.iter() {\n    if paren_stack.len() == 0 {\n      result.push(0);\n    } else {\n      let paren_level = paren_stack.last();\n      if paren_string[i] == '(' {\n        paren_stack.push(paren_level + 1);\n      } else if paren_string[i] == ')' {\n        paren_stack.pop();\n      }\n      result.push(paren_stack.len());\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpkjr9epce.rs:10:25\n   |\n10 |   for i in paren_string.iter() {\n   |                         ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   for i in paren_string.chars() {\n   |                         ~~~~~\n\nerror[E0369]: cannot add `{integer}` to `Option<&{integer}>`\n  --> /tmp/tmpkjr9epce.rs:16:38\n   |\n16 |         paren_stack.push(paren_level + 1);\n   |                          ----------- ^ - {integer}\n   |                          |\n   |                          Option<&{integer}>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkjr9epce.rs:23:10\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                 ---------- expected `Vec<isize>` because of return type\n...\n23 |   return result;\n   |          ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut current_level = 0;\n  let mut current_group = 0;\n  let mut current_group_start = 0;\n  let mut current_group_end = 0;\n  let mut current_group_paren_count = 0;\n  let mut current_group_paren_count_start = 0;\n  let mut current_group_paren_count_end = 0;\n  let mut current_group_paren_count_start_end = 0;\n  let mut current_group_paren_count_start_end_start = 0;\n  let mut current_group_paren_count_start_end_end = 0;\n  let mut current_group_paren_count_start_end_start_end = 0;\n  let mut current_group_paren_count_start_end_end_start = 0;\n  let mut current_group_paren_count_start_end_end_end = 0;\n  let mut current_group_paren_count_start_end_end_start_end = 0;\n  let mut current_group_paren_count_start_end_end_end_start = 0;\n  let mut current_group_paren_count_start_end_end_end_end = 0;\n  let mut current_group_paren_count_start_end_end_end_start_end = 0;\n  let mut current_group_paren_count_start_end_end_end_end_start = 0;\n  let mut current_group_paren_count_start_end_end_end_end_end = 0;\n  let mut current_group_paren_count_start_end_end_end_end_start_end = 0;\n  let mut current_group_paren_count_start_end_end_end_end_end_start = 0;\n  let mut current_group_paren_count_start_end_end_end_end_end_end = 0;\n  let mut current_group_paren_count_start_end_end_end_end_end_start_end = 0;\n  let mut current_group_paren_count_start_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpiject7zj.rs:31:66\n   |\n31 |   let mut current_group_paren_count_start_end_end_end_end_end_end\n   |                                                                  ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpiject7zj.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren = 0;\n  let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpnn4ubguj.rs:21:115\n   |\n21 |   let mut max_nesting_index_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of_last_paren_of\n   |                                                                                                                   ^ help: add `;` here\n22 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnn4ubguj.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut level = 0;\n  let mut max_level = 0;\n  let mut max_index = 0;\n  let mut max_count = 0;\n  let mut max_count_index = 0;\n  let mut max_count_count = 0;\n  let mut max_count_count_index = 0;\n  let mut max_count_count_count = 0;\n  let mut max_count_count_count_index = 0;\n  let mut max_count_count_count_count = 0;\n  let mut max_count_count_count_count_index = 0;\n  let mut max_count_count_count_count_count = 0;\n  let mut max_count_count_count_count_count_index = 0;\n  let mut max_count_count_count_count_count_count = 0;\n  let mut max_count_count_count_count_count_count_index = 0;\n  let mut max_count_count_count_count_count_count_count = 0;\n  let mut max_count_count_count_count_count_count_count_index = 0;\n  let mut max_count_count_count_count_count_count_count_count = 0;\n  let mut max_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_count_count_count_count_count_count_count_count_count = 0;\n  let mut max_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut max_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_count_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut max_count_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut max_count_count_count_count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp8at9c52f.rs:33:38\n   |\n33 |   let mut max_count_count_count_count\n   |                                      ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8at9c52f.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_string_iter = paren_string.iter();\n  let paren_char = paren_string_iter.next();\n  while !paren_string_iter.is_done() {\n    if paren_char == '(' {\n      paren_stack.push(paren_count);\n      paren_count_stack.push(paren_count);\n      paren_count += 1;\n    } else if paren_char == ')' {\n      paren_count -= 1;\n      if paren_count == 0 {\n        max_nesting = max(max_nesting, paren_count_stack.pop());\n        max_nesting_index = paren_stack.pop();\n      }\n    }\n    paren_char = paren_string_iter.next();\n  }\n\n  let result = Vec::new();\n  for (isize i = 0; i < max_nesting; i += 1) {\n    result.push(max_nesting_index - i);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpef0tjoy5.rs:33:14\n   |\n33 |   for (isize i = 0; i < max_nesting; i += 1) {\n   |             -^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpef0tjoy5.rs:33:16\n   |\n33 |   for (isize i = 0; i < max_nesting; i += 1) {\n   |                ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpef0tjoy5.rs:33:15\n   |\n33 |   for (isize i = 0; i < max_nesting; i += 1) {\n   |               ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpef0tjoy5.rs:33:16\n   |\n33 |   for (isize i = 0; i < max_nesting; i += 1) {\n   |                ^ expected expression\n\nerror[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpef0tjoy5.rs:25:23\n   |\n25 |         max_nesting = max(max_nesting, paren_count_stack.pop());\n   |                       ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpef0tjoy5.rs:15:40\n   |\n15 |   let paren_string_iter = paren_string.iter();\n   |                                        ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n15 |   let paren_string_iter = paren_string.chars();\n   |                                        ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpef0tjoy5.rs:26:29\n   |\n10 |   let max_nesting_index = 0;\n   |                           - expected due to this value\n...\n26 |         max_nesting_index = paren_stack.pop();\n   |                             ^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n              found enum `Option<{integer}>`\n\nerror: aborting due to 7 previous errors\n\nSome errors have ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let current_nesting = 0;\n  let paren_count = 0;\n  let paren_index = 0;\n  let paren_start_index = 0;\n  let paren_end_index = 0;\n  let paren_start_char = '(';\n  let paren_end_char = ')';\n  let paren_char = paren_start_char;\n  let paren_char_count = 0;\n  let paren_char_index = 0;\n  let paren_char_start_index = 0;\n  let paren_char_end_index = 0;\n  let paren_char_start_char = paren_start_char;\n  let paren_char_end_char = paren_end_char;\n  let paren_char_count = 0;\n  let paren_char_index = 0;\n  let paren_char_start_index = 0;\n  let paren_char_end_index = 0;\n  let paren_char_start_char = paren_start_char;\n  let paren_char_end_char = paren_end_char;\n  let paren_char_count = 0;\n  let paren_char_index = 0;\n  let paren_char_start_index = 0;\n  let paren_char_end_index = 0;\n  let paren_char_start_char = paren_start_char;\n  let paren_char_end_char = paren_end_char;\n  let paren_char_count = 0;\n  let paren_char_index = 0;\n  let paren_char_start_index = 0;\n  let paren_char_end_index = 0;\n  let paren_char_start_char = paren_start_char;\n  let paren_char_end_char = paren_end_char;\n  let paren_char_count = 0;\n  let paren_char_index = 0;\n  let paren_char_start_index =\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected expression, found `}`\n  --> /tmp/tmpad4qi6ys.rs:44:1\n   |\n44 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let current_nesting = 0;\n  let current_nesting_index = 0;\n  let current_char = 0;\n  let current_char_index = 0;\n  let current_paren_index = 0;\n  let current_paren_stack_index = 0;\n  let current_paren_stack = Vec::new();\n  let current_paren_stack_size = 0;\n  let current_paren_stack_size_index = 0;\n  let current_paren_stack_size_stack = Vec::new();\n  let current_paren_stack_size_stack_index = 0;\n  let current_paren_stack_size_stack_size = 0;\n  let current_paren_stack_size_stack_size_index = 0;\n  let current_paren_stack_size_stack_size_stack = Vec::new();\n  let current_paren_stack_size_stack_size_stack_index = 0;\n  let current_paren_stack_size_stack_size_stack_size = 0;\n  let current_paren_stack_size_stack_size_stack_size_index = 0;\n  let current_paren_stack_size_stack_size_stack_size_stack = Vec::new();\n  let current_paren_stack_size_stack_size_stack_size_stack_index = 0;\n  let current_paren_stack_size_stack_size_stack_size_stack_size = 0;\n  let current_paren_stack_size_stack_size_stack_size_stack_size_index = 0;\n  let current_paren_stack_size_stack_size_stack_size_stack_size_stack = Vec::new();\n  let current_paren_stack_size_stack_size_stack_size_stack_size_stack_index = 0;\n  let current_paren_stack_size_stack_size_stack_size_stack_size_stack_size = 0;\n  let current_paren_stack_size_stack_size_stack_\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp4mlg7hc4.rs:35:49\n   |\n35 |   let current_paren_stack_size_stack_size_stack_\n   |                                                 ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4mlg7hc4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let parens = paren_string.split(\" \");\n  let result = Vec::new();\n  let max_depth = 0;\n  for (let paren in parens) {\n    let depth = count_nested_parens(paren);\n    if (depth > max_depth) {\n      max_depth = depth;\n    }\n  }\n  for (let paren in parens) {\n    let depth = count_nested_parens(paren);\n    if (depth == max_depth) {\n      result.push(depth);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpub4fvg9c.rs:10:8\n   |\n10 |   for (let paren in parens) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `paren`\n  --> /tmp/tmpub4fvg9c.rs:10:12\n   |\n10 |   for (let paren in parens) {\n   |           -^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpub4fvg9c.rs:10:18\n   |\n10 |   for (let paren in parens) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpub4fvg9c.rs:10:7\n   |\n10 |   for (let paren in parens) {\n   |       ^                   ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (let paren in parens) {\n10 +   for let paren in parens {\n   | \n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpub4fvg9c.rs:16:8\n   |\n16 |   for (let paren in parens) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `paren`\n  --> /tmp/tmpub4fvg9c.rs:16:12\n   |\n16 |   for (let paren in parens) {\n   |           -^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpub4fvg9c.rs:16:18\n   |\n16 |   for (let paren in parens) {\n   |                  ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpub4fvg9c.rs:16:7\n   |\n16 |   for (let paren in parens) {\n   |       ^                   ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n16 -   for (let paren in parens) {\n16 +   for let paren in parens {\n   | \n\nerror[E0425]: cannot find function `count_nested_parens` in this scope\n  --> /tmp/tmpub4fvg9c.rs:11:17\n   |\n11 |     let depth = count_nested_parens(paren);\n   |                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot fi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_in_paren = 0;\n  let mut max_nesting_index_in_paren_in_paren = 0;\n  let mut max_nesting_index_in_paren_in_paren_in_paren = 0;\n  let mut max_nesting_index_in_paren_in_paren_in_paren_in_paren = 0;\n  let mut max_nesting_index_in_paren_in_paren_in_paren_in_paren_in_paren = 0;\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      stack.push(c);\n    } else if (c == ')') {\n      if (stack.is_empty()) {\n        result.push(0);\n      } else {\n        let last = stack.pop();\n        if (last == '(') {\n          max_nesting = max_nesting + 1;\n          max_nesting_index = i;\n          max_nesting_index_in_paren = 0;\n          max_nesting_index_in_paren_in_paren = 0;\n          max_nesting_index_in_paren_in_paren_in_paren = 0;\n          max_nesting_index_in_paren_in_paren_in_paren_in_paren = 0;\n        } else if (last == '(') {\n          max_nesting = max_nesting + 1;\n          max_nesting_index = i;\n          max_nesting_index_in_paren = 0;\n          max_nesting_index_in_paren_in_paren = 0;\n          max_nesting_index_in_paren_in_paren_in_paren = 0;\n          max_nesting_index_in_paren_in_paren_in_paren_in_paren = 0;\n        } else if (last ==\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnhpaohwy.rs:48:3\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - unclosed delimiter\n...\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |                                                - unclosed delimiter\n...\n21 |     } else if (c == ')') {\n   |                          - unclosed delimiter\n...\n24 |       } else {\n   |              - this delimiter might not be properly closed...\n...\n41 | }\n   | - ...as it matches this but it has different indentation\n...\n48 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpnhpaohwy.rs:17:8\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpnhpaohwy.rs:17:12\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpnhpaohwy.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpnhpaohwy.rs:17:13\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpnhpaohwy.rs:17:14\n   |\n17 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpnhpaohwy.rs:40:19\n   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |                                                            - closing delimiter possibly meant for this\n...\n40 |         } else if (last ==\n   |                   ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 7 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let result = Vec::new();\n  for (i in paren_string.chars()) {\n    if (i == '(') {\n      paren_stack.push(0);\n    } else if (i == ')') {\n      if (paren_stack.len() == 0) {\n        panic(\"Invalid paren string\");\n      }\n      let level = paren_stack.pop();\n      result.push(level);\n    }\n  }\n  if (paren_stack.len() != 0) {\n    panic(\"Invalid paren string\");\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmph44l2ab4.rs:10:10\n   |\n10 |   for (i in paren_string.chars()) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmph44l2ab4.rs:10:7\n   |\n10 |   for (i in paren_string.chars()) {\n   |       ^                         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n10 -   for (i in paren_string.chars()) {\n10 +   for i in paren_string.chars() {\n   | \n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmph44l2ab4.rs:15:9\n   |\n15 |         panic(\"Invalid paren string\");\n   |         ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n15 |         panic!(\"Invalid paren string\");\n   |              +\n\nerror[E0423]: expected function, found macro `panic`\n  --> /tmp/tmph44l2ab4.rs:22:5\n   |\n22 |     panic(\"Invalid paren string\");\n   |     ^^^^^ not a function\n   |\nhelp: use `!` to invoke the macro\n   |\n22 |     panic!(\"Invalid paren string\");\n   |          +\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph44l2ab4.rs:11:8\n   |\n11 |     if (i == '(') {\n   |        ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -     if (i == '(') {\n11 +     if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph44l2ab4.rs:13:15\n   |\n13 |     } else if (i == ')') {\n   |               ^        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     } else if (i == ')') {\n13 +     } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph44l2ab4.rs:14:10\n   |\n14 |       if (paren_stack.len() == 0) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n14 -       if (paren_stack.len() == 0) {\n14 +       if paren_stack.len() == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmph44l2ab4.rs:21:6\n   |\n21 |   if (paren_stack.len() != 0) {\n   |      ^             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_depth = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_max = 0;\n  let paren_depth_max = 0;\n  let paren_start_max = 0;\n  let paren_end_max = 0;\n  let paren_count_max_prev = 0;\n  let paren_depth_max_prev = 0;\n  let paren_start_max_prev = 0;\n  let paren_end_max_prev = 0;\n  let paren_count_max_prev_prev = 0;\n  let paren_depth_max_prev_prev = 0;\n  let paren_start_max_prev_prev = 0;\n  let paren_end_max_prev_prev = 0;\n  let paren_count_max_prev_prev_prev = 0;\n  let paren_depth_max_prev_prev_prev = 0;\n  let paren_start_max_prev_prev_prev = 0;\n  let paren_end_max_prev_prev_prev = 0;\n  let paren_count_max_prev_prev_prev_prev = 0;\n  let paren_depth_max_prev_prev_prev_prev = 0;\n  let paren_start_max_prev_prev_prev_prev = 0;\n  let paren_end_max_prev_prev_prev_prev = 0;\n  let paren_count_max_prev_prev_prev_prev_prev = 0;\n  let paren_depth_max_prev_prev_prev_prev_prev = 0;\n  let paren_start_max_prev_prev_prev_prev_prev = 0;\n  let paren_end_max_prev_prev_prev_prev_prev = 0;\n  let paren_count_max_prev_prev_prev_prev_prev_prev = 0;\n  let paren_depth_max_prev_prev_prev_prev_prev_prev = 0;\n  let paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpfkd3tfg4.rs:38:12\n   |\n38 |   let paren\n   |            ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfkd3tfg4.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  let paren_string_len = paren_string.len();\n  for (let i = 0; i < paren_string_len; i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n    } else if (c == ')') {\n      paren_count = paren_count_stack.pop();\n      if (paren_count > max_nesting) {\n        max_nesting = paren_count;\n        max_nesting_index = i;\n      }\n      paren_stack.pop();\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = max_nesting_index; i >= 0; i--) {\n    result.push(paren_count);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpce7b7x_9.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpce7b7x_9.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpce7b7x_9.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpce7b7x_9.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpce7b7x_9.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string_len; i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut paren_stack = Vec::new();\n  paren_stack.push(0);\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n    } else if (c == ')') {\n      let paren_start = paren_stack.pop();\n      let paren_end = i;\n      let paren_len = paren_end - paren_start;\n      result.push(paren_len);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpob485_uh.rs:10:8\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpob485_uh.rs:10:12\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpob485_uh.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpob485_uh.rs:10:13\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpob485_uh.rs:10:14\n   |\n10 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_string_iter = paren_string.iter();\n  let paren_string_end = paren_string.end();\n  let paren_string_next = paren_string_iter.next();\n  while (paren_string_next) {\n    if (paren_string_next == '(') {\n      paren_stack.push(paren_count);\n      paren_count = 0;\n      paren_level += 1;\n    } else if (paren_string_next == ')') {\n      paren_count += 1;\n      if (paren_stack.is_empty()) {\n        paren_level -= 1;\n      } else {\n        paren_count = paren_stack.pop();\n      }\n    }\n    paren_string_next = paren_string_iter.next();\n  }\n  paren_level -= paren_stack.pop();\n  return paren_level;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4z2a1sps.rs:13:9\n   |\n13 |   while (paren_string_next) {\n   |         ^                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (paren_string_next) {\n13 +   while paren_string_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4z2a1sps.rs:14:8\n   |\n14 |     if (paren_string_next == '(') {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (paren_string_next == '(') {\n14 +     if paren_string_next == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4z2a1sps.rs:18:15\n   |\n18 |     } else if (paren_string_next == ')') {\n   |               ^                        ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (paren_string_next == ')') {\n18 +     } else if paren_string_next == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4z2a1sps.rs:20:10\n   |\n20 |       if (paren_stack.is_empty()) {\n   |          ^                      ^\n   |\nhelp: remove these parentheses\n   |\n20 -       if (paren_stack.is_empty()) {\n20 +       if paren_stack.is_empty() {\n   | \n\nerror[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp4z2a1sps.rs:10:40\n   |\n10 |   let paren_string_iter = paren_string.iter();\n   |                                        ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n10 |   let paren_string_iter = paren_string.chars();\n   |                                        ~~~~~\n\nerror[E0599]: no method named `end` found for struct `String` in the current scope\n  --> /tmp/tmp4z2a1sps.rs:11:39\n   |\n11 |   let paren_string_end = paren_string.end();\n   |                                       ^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4z2a1sps.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  for (let i = 0; i < paren_string.len(); i++) {\n    if (paren_string[i] == '(') {\n      paren_stack.push(i);\n    } else if (paren_string[i] == ')') {\n      if (paren_stack.len() == 0) {\n        max_nesting = 0;\n      } else {\n        max_nesting = max_nesting + 1;\n      }\n      paren_stack.pop();\n    }\n  }\n  let result = Vec::new();\n  for (let i = 0; i < paren_stack.len(); i++) {\n    result.push(max_nesting);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n --> /tmp/tmplk74yyk7.rs:9:8\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n --> /tmp/tmplk74yyk7.rs:9:12\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |           -^ expected one of `)`, `,`, `@`, or `|`\n  |           |\n  |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n --> /tmp/tmplk74yyk7.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n --> /tmp/tmplk74yyk7.rs:9:13\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n --> /tmp/tmplk74yyk7.rs:9:14\n  |\n9 |   for (let i = 0; i < paren_string.len(); i++) {\n  |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let paren_count = 0;\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_stack.push(i);\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n    } else if (c == ')') {\n      paren_count_stack.pop();\n      paren_count -= 1;\n      if (paren_count == 0) {\n        let paren_start = paren_stack.pop();\n        max_nesting = max(max_nesting, paren_count_stack.last());\n        max_nesting_index = i;\n      }\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = 0; i < paren_stack.len(); i++) {\n    let paren_start = paren_stack[i];\n    let paren_end = paren_start + 1;\n    for (; paren_end < max_nesting_index; paren_end++) {\n      if (paren_string[paren_end] == '(') {\n        break;\n      }\n    }\n    result.push(paren_count_stack.last());\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpbn0thmzq.rs:15:8\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpbn0thmzq.rs:15:12\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpbn0thmzq.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpbn0thmzq.rs:15:13\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpbn0thmzq.rs:15:14\n   |\n15 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  paren_stack.push(0);\n  let max_nesting = 0;\n  let max_nesting_index = 0;\n  let paren_count = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  let paren_count_stack_index = 0;\n  let paren_count_stack_max = 0;\n  let paren_count_stack_max_index = 0;\n  let paren_count_stack_max_max = 0;\n  let paren_count_stack_max_max_index = 0;\n  let paren_count_stack_max_max_max = 0;\n  let paren_count_stack_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_index = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max = 0;\n  let paren_count_stack_max_max_max_max_max_max_max_max_max_index = 0;\n  let paren\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpcuxsu17r.rs:33:12\n   |\n33 |   let paren\n   |            ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcuxsu17r.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut max_nesting = 0;\n  let mut max_nesting_index = 0;\n  let mut max_nesting_index_prev = 0;\n  let mut max_nesting_index_next = 0;\n  let mut max_nesting_index_next_prev = 0;\n  let mut max_nesting_index_next_next = 0;\n  let mut max_nesting_index_next_next_prev = 0;\n  let mut max_nesting_index_next_next_next = 0;\n  let mut max_nesting_index_next_next_next_prev = 0;\n  let mut max_nesting_index_next_next_next_next = 0;\n  let mut max_nesting_index_next_next_next_next_prev = 0;\n  let mut max_nesting_index_next_next_next_next_next = 0;\n  let mut max_nesting_index_next_next_next_next_next_prev = 0;\n  let mut max_nesting_index_next_next_next_next_next_next = 0;\n  let mut max_nesting_index_next_next_next_next_next_next_prev = 0;\n  let mut max_nesting_index_next_next_next_next_next_next_next = 0;\n  let mut max_nesting_index_next_next_next_next_next_next_next_prev = 0;\n  let mut max_nesting_index_next_next_next_next_next_next_next_next = 0;\n  let mut max_nesting_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut max_nesting_index_next_next_next_next_next_next_next_next_next = 0;\n  let mut max_nesting_index_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut max_nesting_index_next_next_next_next_next_next\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmptmibptqm.rs:30:58\n   |\n30 |   let mut max_nesting_index_next_next_next_next_next_next\n   |                                                          ^ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmptmibptqm.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |    -------------------                          ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let paren_count = 0;\n  let paren_level = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_count_stack = Vec::new();\n  paren_count_stack.push(0);\n  paren_stack.push(0);\n\n  for (let i = 0; i < paren_string.len(); i++) {\n    let c = paren_string[i];\n    if (c == '(') {\n      paren_count += 1;\n      paren_count_stack.push(paren_count);\n      paren_stack.push(paren_level);\n      paren_level += 1;\n      paren_start = i;\n    } else if (c == ')') {\n      paren_count -= 1;\n      paren_count_stack.pop();\n      paren_level -= 1;\n      if (paren_count_stack.len() == 0) {\n        paren_end = i;\n        break;\n      }\n    }\n  }\n\n  let result = Vec::new();\n  for (let i = paren_start; i < paren_end; i++) {\n    result.push(paren_level);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmplo2_ikbv.rs:16:8\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmplo2_ikbv.rs:16:12\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmplo2_ikbv.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmplo2_ikbv.rs:16:13\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmplo2_ikbv.rs:16:14\n   |\n16 |   for (let i = 0; i < paren_string.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let open_parens = 0;\n  let max_nesting = 0;\n  for i in paren_string.chars() {\n    if paren_stack.len() == 0 {\n      if (i == '(') {\n        open_parens += 1;\n      } else if (i == ')') {\n        open_parens -= 1;\n      }\n    } else {\n      if (i == '(') {\n        open_parens += 1;\n      } else if (i == ')') {\n        open_parens -= 1;\n      } else if (open_parens == 0) {\n        paren_stack.push(i);\n      } else if (open_parens == 1) {\n        if (paren_stack.len() > max_nesting) {\n          max_nesting = paren_stack.len();\n        }\n        paren_stack.pop();\n      }\n    }\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptwpk663i.rs:12:10\n   |\n12 |       if (i == '(') {\n   |          ^        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -       if (i == '(') {\n12 +       if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptwpk663i.rs:14:17\n   |\n14 |       } else if (i == ')') {\n   |                 ^        ^\n   |\nhelp: remove these parentheses\n   |\n14 -       } else if (i == ')') {\n14 +       } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptwpk663i.rs:18:10\n   |\n18 |       if (i == '(') {\n   |          ^        ^\n   |\nhelp: remove these parentheses\n   |\n18 -       if (i == '(') {\n18 +       if i == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptwpk663i.rs:20:17\n   |\n20 |       } else if (i == ')') {\n   |                 ^        ^\n   |\nhelp: remove these parentheses\n   |\n20 -       } else if (i == ')') {\n20 +       } else if i == ')' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptwpk663i.rs:22:17\n   |\n22 |       } else if (open_parens == 0) {\n   |                 ^                ^\n   |\nhelp: remove these parentheses\n   |\n22 -       } else if (open_parens == 0) {\n22 +       } else if open_parens == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptwpk663i.rs:24:17\n   |\n24 |       } else if (open_parens == 1) {\n   |                 ^                ^\n   |\nhelp: remove these parentheses\n   |\n24 -       } else if (open_parens == 1) {\n24 +       } else if open_parens == 1 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmptwpk663i.rs:25:12\n   |\n25 |         if (paren_stack.len() > max_nesting) {\n   |            ^                               ^\n   |\nhelp: remove these parentheses\n   |\n25 -         if (paren_stack.len() > max_nesting) {\n25 +         if paren_stack.len() > max_nesting {\n   | \n\nerror[E0308]: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let paren_stack = Vec::new();\n  let max_nesting = 0;\n  let current_nesting = 0;\n  let paren_count = 0;\n  let paren_start = 0;\n  let paren_end = 0;\n  let paren_iter = Iterator::from(paren_string);\n  while (paren_iter.has_next()) {\n    let ch = paren_iter.next();\n    if (ch == '(') {\n      paren_stack.push_back(paren_count);\n      paren_count += 1;\n      current_nesting += 1;\n      if (current_nesting > max_nesting) {\n        max_nesting = current_nesting;\n      }\n    } else if (ch == ')') {\n      paren_count -= 1;\n      current_nesting -= 1;\n      if (current_nesting < 0) {\n        throw \"Invalid parentheses\";\n      }\n      if (paren_stack.is_empty()) {\n        throw \"Invalid parentheses\";\n      }\n      paren_end = paren_stack.pop();\n      if (paren_end != paren_count) {\n        throw \"Invalid parentheses\";\n      }\n    }\n  }\n  if (current_nesting != 0) {\n    throw \"Invalid parentheses\";\n  }\n  return max_nesting;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292607,
      "stdout": "",
      "stderr": "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid parentheses\"`\n  --> /tmp/tmpj76npmbp.rs:27:15\n   |\n27 |         throw \"Invalid parentheses\";\n   |               ^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid parentheses\"`\n  --> /tmp/tmpj76npmbp.rs:30:15\n   |\n30 |         throw \"Invalid parentheses\";\n   |               ^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid parentheses\"`\n  --> /tmp/tmpj76npmbp.rs:34:15\n   |\n34 |         throw \"Invalid parentheses\";\n   |               ^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nerror: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `\"Invalid parentheses\"`\n  --> /tmp/tmpj76npmbp.rs:39:11\n   |\n39 |     throw \"Invalid parentheses\";\n   |           ^^^^^^^^^^^^^^^^^^^^^ expected one of 8 possible tokens\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpj76npmbp.rs:14:9\n   |\n14 |   while (paren_iter.has_next()) {\n   |         ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (paren_iter.has_next()) {\n14 +   while paren_iter.has_next() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj76npmbp.rs:16:8\n   |\n16 |     if (ch == '(') {\n   |        ^         ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (ch == '(') {\n16 +     if ch == '(' {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj76npmbp.rs:20:10\n   |\n20 |       if (current_nesting > max_nesting) {\n   |          ^                             ^\n   |\nhelp: remove these parentheses\n   |\n20 -       if (current_nesting > max_nesting) {\n20 +       if current_nesting > max_nesting {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj76npmbp.rs:23:15\n   |\n23 |     } el",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n/// For each of the group, output the deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"(()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut stack = Vec::new();\n  let mut level = 0;\n  for (let chr of paren_string) {\n    if (chr == '(') {\n      stack.push(level);\n      level += 1;\n    } else if (chr == ')') {\n      level -= 1;\n      if (level == 0) {\n        result.push(stack.pop());\n      }\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![4]);\n}\n",
      "timestamp": 1664292606,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpk8tzq_s5.rs:10:8\n   |\n10 |   for (let chr of paren_string) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `chr`\n  --> /tmp/tmpk8tzq_s5.rs:10:12\n   |\n10 |   for (let chr of paren_string) {\n   |           -^^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpk8tzq_s5.rs:10:16\n   |\n10 |   for (let chr of paren_string) {\n   |               -^^ expected one of `)`, `,`, `@`, or `|`\n   |               |\n   |               help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `paren_string`\n  --> /tmp/tmpk8tzq_s5.rs:10:19\n   |\n10 |   for (let chr of paren_string) {\n   |                  -^^^^^^^^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |                  |\n   |                  help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpk8tzq_s5.rs:10:32\n   |\n10 |   for (let chr of paren_string) {\n   |                                ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmpk8tzq_s5.rs:21:3\n   |\n21 |   return result;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n21 |   { return result; }\n   |   +                +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}