{
  "name": "HumanEval_77_iscube",
  "language": "rs",
  "prompt": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n",
  "tests": "}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    return b == 0 || b == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpfd45ifmr.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    if b == 0 {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpmy4v7q11.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpdhx15y3k.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    if a % 3 == 0 {\n        return true\n    }\n    return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpa5hnanjv.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let n = a;\n  while (n % 3 == 0) {\n    n /= 3;\n  }\n  return n == 1;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2kgh41o0.rs:19:9\n   |\n19 |   while (n % 3 == 0) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -   while (n % 3 == 0) {\n19 +   while n % 3 == 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmp2kgh41o0.rs:20:5\n   |\n18 |   let n = a;\n   |       -\n   |       |\n   |       first assignment to `n`\n   |       help: consider making this binding mutable: `mut n`\n19 |   while (n % 3 == 0) {\n20 |     n /= 3;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let i = a;\n  while (i > 0) {\n    if (i % 3 != 0) {\n      return false;\n    }\n    i /= 3;\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppk4xr2e5.rs:19:9\n   |\n19 |   while (i > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -   while (i > 0) {\n19 +   while i > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppk4xr2e5.rs:20:8\n   |\n20 |     if (i % 3 != 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i % 3 != 0) {\n20 +     if i % 3 != 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmppk4xr2e5.rs:23:5\n   |\n18 |   let i = a;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n23 |     i /= 3;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let i = a % a;\n    if i == 0 {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpjms6sfvj.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let n = a;\n    let i = 1;\n    while (n % i == 0) {\n        n /= i;\n        i *= i;\n    }\n    return n == 1;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjhavgx7n.rs:20:11\n   |\n20 |     while (n % i == 0) {\n   |           ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -     while (n % i == 0) {\n20 +     while n % i == 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpjhavgx7n.rs:21:9\n   |\n18 |     let n = a;\n   |         -\n   |         |\n   |         first assignment to `n`\n   |         help: consider making this binding mutable: `mut n`\n...\n21 |         n /= i;\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpjhavgx7n.rs:22:9\n   |\n19 |     let i = 1;\n   |         -\n   |         |\n   |         first assignment to `i`\n   |         help: consider making this binding mutable: `mut i`\n...\n22 |         i *= i;\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    if b == 0 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmprha40fpw.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let b = a % a;\n  if b == 0 {\n    return true;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpgoubn56i.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    if b == 0 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmprha40fpw.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpc4rthy1o.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    if b == 0 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmprha40fpw.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return false\n  }\n  if a == 0 {\n    return true\n  }\n  return a % a == 0\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpik273ic4.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let i = a % a;\n  if i == 0 {\n    return true;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpesdz4z8i.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmprtk6azye.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let a_abs = abs(a);\n  let a_cube = a_abs * a_abs * a_abs;\n  return a_cube == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpbi8sx0di.rs:18:15\n   |\n18 |   let a_abs = abs(a);\n   |               ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let i = a % a;\n  if i == 0 {\n    return true;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpesdz4z8i.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let i = a;\n    while (i % 3 == 0) {\n        i /= 3;\n    }\n    return i == 1;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn1ygfxyv.rs:19:11\n   |\n19 |     while (i % 3 == 0) {\n   |           ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -     while (i % 3 == 0) {\n19 +     while i % 3 == 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpn1ygfxyv.rs:20:9\n   |\n18 |     let i = a;\n   |         -\n   |         |\n   |         first assignment to `i`\n   |         help: consider making this binding mutable: `mut i`\n19 |     while (i % 3 == 0) {\n20 |         i /= 3;\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let i = a;\n    while i > 0 {\n        let r = i % 10;\n        if r != 0 && r != 1 && r != 4 && r != 7 {\n            return false;\n        }\n        i /= 10;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpxub56lnz.rs:24:9\n   |\n18 |     let i = a;\n   |         -\n   |         |\n   |         first assignment to `i`\n   |         help: consider making this binding mutable: `mut i`\n...\n24 |         i /= 10;\n   |         ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmprtk6azye.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpa7q9wb6b.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let i = a;\n  while (i > 0) {\n    i = i - i % 3;\n  }\n  return i == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi8ypkqre.rs:19:9\n   |\n19 |   while (i > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -   while (i > 0) {\n19 +   while i > 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpi8ypkqre.rs:20:5\n   |\n18 |   let i = a;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n19 |   while (i > 0) {\n20 |     i = i - i % 3;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let i = a;\n    while (i > 0) {\n        i = i - i % 3;\n    }\n    return i == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp7z9flc_g.rs:19:11\n   |\n19 |     while (i > 0) {\n   |           ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -     while (i > 0) {\n19 +     while i > 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp7z9flc_g.rs:20:9\n   |\n18 |     let i = a;\n   |         -\n   |         |\n   |         first assignment to `i`\n   |         help: consider making this binding mutable: `mut i`\n19 |     while (i > 0) {\n20 |         i = i - i % 3;\n   |         ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let i = a;\n  while (i > 0) {\n    i = i - i % 3;\n  }\n  return i == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpi8ypkqre.rs:19:9\n   |\n19 |   while (i > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -   while (i > 0) {\n19 +   while i > 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpi8ypkqre.rs:20:5\n   |\n18 |   let i = a;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n19 |   while (i > 0) {\n20 |     i = i - i % 3;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    if b == 0 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmprha40fpw.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let i = a % a;\n    if i == 0 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpb9w7mwij.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let i = a % a;\n  if i == 0 {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpptyhc8bp.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    if b == 0 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmprha40fpw.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let b = a % a;\n  if b == 0 {\n    return true;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpgoubn56i.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let n = a;\n    while n > 0 {\n        if n % 3 != 0 {\n            return false;\n        }\n        n /= 3;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpsflx5oos.rs:23:9\n   |\n18 |     let n = a;\n   |         -\n   |         |\n   |         first assignment to `n`\n   |         help: consider making this binding mutable: `mut n`\n...\n23 |         n /= 3;\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let n = a;\n  let i = 1;\n  while (i * i * i <= n) {\n    if (n % i == 0) {\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  return n == 1;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcilby_6e.rs:20:9\n   |\n20 |   while (i * i * i <= n) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -   while (i * i * i <= n) {\n20 +   while i * i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcilby_6e.rs:21:8\n   |\n21 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n21 -     if (n % i == 0) {\n21 +     if n % i == 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpcilby_6e.rs:22:7\n   |\n18 |   let n = a;\n   |       -\n   |       |\n   |       first assignment to `n`\n   |       help: consider making this binding mutable: `mut n`\n...\n22 |       n /= i;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpcilby_6e.rs:24:7\n   |\n19 |   let i = 1;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n24 |       i += 1;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    return b == 0 || b == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpfd45ifmr.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let b = a % a;\n  return b == 0 || b == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpdpw4fs4f.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let b = a % a;\n  return b == 0 || b == a;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpdpw4fs4f.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  } else {\n    return false\n  }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpo0yr3iuo.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return false\n  }\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp1r6xny84.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n    let b = a % a;\n    if b == 0 {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpmy4v7q11.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let i = a;\n  while (i > 0) {\n    if (i % 3 != 0) {\n      return false;\n    }\n    i /= 3;\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppk4xr2e5.rs:19:9\n   |\n19 |   while (i > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n19 -   while (i > 0) {\n19 +   while i > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppk4xr2e5.rs:20:8\n   |\n20 |     if (i % 3 != 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (i % 3 != 0) {\n20 +     if i % 3 != 0 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmppk4xr2e5.rs:23:5\n   |\n18 |   let i = a;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n23 |     i /= 3;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpdhx15y3k.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return false\n  }\n  return true\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpads6d97y.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  match a {\n    0 => true,\n    1 => false,\n    2 => false,\n    3 => true,\n    4 => false,\n    5 => true,\n    6 => false,\n    7 => true,\n    8 => false,\n    9 => true,\n    10 => false,\n    11 => true,\n    12 => false,\n    13 => true,\n    14 => false,\n    15 => true,\n    16 => false,\n    17 => true,\n    18 => false,\n    19 => true,\n    20 => false,\n    21 => true,\n    22 => false,\n    23 => true,\n    24 => false,\n    25 => true,\n    26 => false,\n    27 => true,\n    28 => false,\n    29 => true,\n    30 => false,\n    31 => true,\n    32 => false,\n    33 => true,\n    34 => false,\n    35 => true,\n    36 => false,\n    37 => true,\n    38 => false,\n    39 => true,\n    40 => false,\n    41 => true,\n    42 => false,\n    43 => true,\n    44 => false,\n    45 => true,\n    46 => false,\n    47 => true,\n    48 => false,\n    49 => true,\n    50 => false,\n    51 => true,\n    52 => false,\n    53 => true,\n    54 => false,\n    55 => true,\n    56 => false,\n    57 => true,\n    58 => false,\n    59 => true,\n    60 => false,\n    61 => true,\n    62 => false,\n    63 => true,\n    64 => false,\n    65 => true,\n    66 => false,\n    67 => true,\n    68 => false,\n    69 => true,\n    70 => false,\n    71 => true,\n    72 => false,\n    73 => true,\n    74 => false,\n    75 => true,\n    76 => false,\n    77 => true,\n    78 => false,\n    79 => true,\n    80 => false,\n    81 => true,\n    82 => false,\n    83 => true,\n    84 =>\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmpod59zvgp.rs:116:3\n    |\n17  | fn iscube(a: isize) -> bool {\n    |                             - unclosed delimiter\n18  |   match a {\n    |           - this delimiter might not be properly closed...\n...\n104 | }\n    | - ...as it matches this but it has different indentation\n...\n116 | }\n    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpod59zvgp.rs:104:1\n    |\n103 |     84 =>\n    |        -- while parsing the `match` arm starting here\n104 | }\n    | ^ expected expression\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpod59zvgp.rs:18:3\n    |\n18  | /   match a {\n19  | |     0 => true,\n20  | |     1 => false,\n21  | |     2 => false,\n...   |\n103 | |     84 =>\n104 | | }\n    | | ^- help: consider using a semicolon here\n    | |_|\n    |   expected `()`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpod59zvgp.rs:17:24\n   |\n17 | fn iscube(a: isize) -> bool {\n   |    ------              ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a < 0 {\n    return false\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbnswaeba.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  let n = a;\n  let i = 1;\n  while (n > 0) {\n    let d = n % 10;\n    if (d != 0 && d != i) {\n      return false;\n    }\n    n /= 10;\n    i *= 10;\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpdecvus80.rs:20:9\n   |\n20 |   while (n > 0) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n20 -   while (n > 0) {\n20 +   while n > 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdecvus80.rs:22:8\n   |\n22 |     if (d != 0 && d != i) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n22 -     if (d != 0 && d != i) {\n22 +     if d != 0 && d != i {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `n`\n  --> /tmp/tmpdecvus80.rs:25:5\n   |\n18 |   let n = a;\n   |       -\n   |       |\n   |       first assignment to `n`\n   |       help: consider making this binding mutable: `mut n`\n...\n25 |     n /= 10;\n   |     ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpdecvus80.rs:26:5\n   |\n19 |   let i = 1;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n26 |     i *= 10;\n   |     ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a % 3 == 0 {\n    return true\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp84t03wms.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a < 0 {\n    return false\n  }\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp1r6xny84.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function that takes an integer a and returns true \n/// if this ingeger is a cube of some integer number.\n/// Note: you may assume the input is always valid.\n/// Examples:\n/// >>> iscube(1)\n/// true\n/// >>> iscube(2)\n/// false\n/// >>> iscube(-1)\n/// true\n/// >>> iscube(64)\n/// true\n/// >>> iscube(0)\n/// true\n/// >>> iscube(180)\n/// false\nfn iscube(a: isize) -> bool {\n  if a == 0 {\n    return true\n  }\n  if a % 3 == 0 {\n    return iscube(a / 3)\n  }\n  return false\n}\n\nfn main() {\n    let candidate = iscube;\n    assert_eq!(candidate(1), true);\n    assert_eq!(candidate(2), false);\n    assert_eq!(candidate(-1), true);\n    assert_eq!(candidate(64), true);\n    assert_eq!(candidate(180), false);\n    assert_eq!(candidate(1000), true);\n    assert_eq!(candidate(0), true);\n    assert_eq!(candidate(1729), false);\n}\n",
      "timestamp": 1664292876,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstaxw382.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    }
  ]
}