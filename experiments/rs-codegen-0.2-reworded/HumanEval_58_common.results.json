{
  "name": "HumanEval_58_common",
  "language": "rs",
  "prompt": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.slice(i, l1_len));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpz9w418vn.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz9w418vn.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpz9w418vn.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpz9w418vn.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.slice(i, l1_len));\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpz9w418vn.rs:23:31\n   |\n23 |   return Vec::from_iter(c, l1.slice(i, l1_len));\n   |                               ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n23 |   return Vec::from_iter(c, l1.as_slice(i, l1_len));\n   |                               ~~~~~~~~\n\nerror: aborting due to 2 previous",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n  let mut l1_next = true;\n  let mut l2_next = true;\n  let mut common_next = true;\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  let mut l1_index = 0;\n  let mut l2_index = 0;\n  let mut common_index = 0;\n  let mut l1_last = false;\n  let mut l2_last = false;\n  let mut common_last = false;\n  let mut l1_has_next = false;\n  let mut l2_has_next = false;\n  let mut common_has_next = false;\n  let mut l1_has_last = false;\n  let mut l2_has_last = false;\n  let mut common_has_last = false;\n  let mut l1_has_index = false;\n  let mut l2_has_index = false;\n  let mut common_has_index = false;\n  let mut l1_has_next_index = false;\n  let mut l2_has_next_index = false;\n  let mut common_has_next_index = false;\n  let mut l1_has_last_index = false;\n  let mut l2_has_last_index = false;\n  let mut common_has_last_index = false;\n  let mut l1_has_next_last = false;\n  let mut l2_has_next_last = false;\n  let mut common_has_next_last = false;\n  let mut l1_has_last_last = false;\n  let mut l2_has_last_last = false;\n  let mut common_has_last_last = false;\n  let mut l1_has_index_last = false;\n  let mut l2_has_index_last = false;\n  let mut common_has_index_last = false;\n  let mut l1_has_next_index_\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpfjecryt0.rs:46:29\n   |\n46 |   let mut l1_has_next_index_\n   |                             ^ help: add `;` here\n47 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfjecryt0.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp60ixshf8.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:11:8\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1.data[i] == l2.data[j]) {\n11 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:15:15\n   |\n15 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1.data[i] < l2.data[j]) {\n15 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:12\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:26\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp0u402t79.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0u402t79.rs:12:8\n   |\n12 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1.data[i] == l2.data[j]) {\n12 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0u402t79.rs:16:15\n   |\n16 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (l1.data[i] < l2.data[j]) {\n16 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp0u402t79.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp0u402t79.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp0u402t79.rs:12:12\n   |\n12 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp0u402t79.rs:12:26\n   |\n12 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp0u402t79",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n  let mut l1_next = true;\n  let mut l2_next = true;\n  let mut common_next = true;\n  while (l1_next && l2_next) {\n    if (l1_next && l2_next) {\n      if (l1_iter.next() != l2_iter.next()) {\n        l1_next = false;\n        l2_next = false;\n      }\n    } else {\n      l1_next = false;\n      l2_next = false;\n    }\n  }\n  while (l1_next) {\n    l1_next = l1_iter.next();\n    common_next = true;\n    l2_next = l2_iter.next();\n    while (l2_next && common_next) {\n      if (l1_next == l2_next) {\n        common_next = false;\n      } else {\n        l2_next = l2_iter.next();\n      }\n    }\n    if (common_next) {\n      common.append(l1_next);\n    }\n    l1_next = l1_iter.next();\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqxw7d1ei.rs:13:9\n   |\n13 |   while (l1_next && l2_next) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_next && l2_next) {\n13 +   while l1_next && l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqxw7d1ei.rs:14:8\n   |\n14 |     if (l1_next && l2_next) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1_next && l2_next) {\n14 +     if l1_next && l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqxw7d1ei.rs:15:10\n   |\n15 |       if (l1_iter.next() != l2_iter.next()) {\n   |          ^                                ^\n   |\nhelp: remove these parentheses\n   |\n15 -       if (l1_iter.next() != l2_iter.next()) {\n15 +       if l1_iter.next() != l2_iter.next() {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqxw7d1ei.rs:24:9\n   |\n24 |   while (l1_next) {\n   |         ^       ^\n   |\nhelp: remove these parentheses\n   |\n24 -   while (l1_next) {\n24 +   while l1_next {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqxw7d1ei.rs:28:11\n   |\n28 |     while (l2_next && common_next) {\n   |           ^                      ^\n   |\nhelp: remove these parentheses\n   |\n28 -     while (l2_next && common_next) {\n28 +     while l2_next && common_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqxw7d1ei.rs:29:10\n   |\n29 |       if (l1_next == l2_next) {\n   |          ^                  ^\n   |\nhelp: remove these parentheses\n   |\n29 -       if (l1_next == l2_next) {\n29 +       if l1_next == l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqxw7d1ei.rs:35:8\n   |\n35 |     if (common_next) {\n   |        ^           ^\n   |\nhelp: remove these parentheses\n   |\n35 -     if (common_next) {\n35 +     if common_next {\n   | \n\nerror[E0308]: mismatched ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      result.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvj7exh3_.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvj7exh3_.rs:12:8\n   |\n12 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1[i] == l2[j]) {\n12 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvj7exh3_.rs:16:15\n   |\n16 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (l1[i] < l2[j]) {\n16 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpvj7exh3_.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpvj7exh3_.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvj7exh3_.rs:13:21\n   |\n13 |       result.append(l1[i]);\n   |                     ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_iter = l1.iter();\n  let l2_iter = l2.iter();\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    let l1_val = l1_iter.next().value;\n    let l2_val = l2_iter.next().value;\n    if (l1_val == l2_val) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1_val < l2_val) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, [l1_iter.next().value]);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpx1wf0pfb.rs:14:9\n   |\n14 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n14 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx1wf0pfb.rs:17:8\n   |\n17 |     if (l1_val == l2_val) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (l1_val == l2_val) {\n17 +     if l1_val == l2_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpx1wf0pfb.rs:21:15\n   |\n21 |     } else if (l1_val < l2_val) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     } else if (l1_val < l2_val) {\n21 +     } else if l1_val < l2_val {\n   | \n\nerror[E0609]: no field `value` on type `Option<&isize>`\n  --> /tmp/tmpx1wf0pfb.rs:15:33\n   |\n15 |     let l1_val = l1_iter.next().value;\n   |                                 ^^^^^\n\nerror[E0609]: no field `value` on type `Option<&isize>`\n  --> /tmp/tmpx1wf0pfb.rs:16:33\n   |\n16 |     let l2_val = l2_iter.next().value;\n   |                                 ^^^^^\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpx1wf0pfb.rs:27:15\n   |\n27 |   return Vec::from_iter(common_len, [l1_iter.next().value]);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0609]: no field `value` on type `Option<&isize>`\n  --> /tmp/tmpx1wf0pfb.rs:27:53\n   |\n27 |   return Vec::from_iter(common_len, [l1_iter.next().value]);\n   |                                                     ^^^^^\n\ner",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbs_3ojld.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:11:16\n    |\n11  |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  let common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return l1.slice(common_idx, common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp_rqj244s.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_rqj244s.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp_rqj244s.rs:19:15\n   |\n19 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n19 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp_rqj244s.rs:25:13\n   |\n25 |   return l1.slice(common_idx, common_len);\n   |             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n25 |   return l1.as_slice(common_idx, common_len);\n   |             ~~~~~~~~\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_iter = iter(l1);\n  let l2_iter = iter(l2);\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let common_len = l1_len < l2_len ? l1_len : l2_len;\n  let common_iter = iter(l1_len);\n  for (let i = 0; i < common_len; i += 1) {\n    let l1_val = l1_iter.next();\n    let l2_val = l2_iter.next();\n    if (l1_val != l2_val) {\n      common_iter.next();\n    } else {\n      common_iter.next(l1_val);\n    }\n  }\n  return Vec::from_iter(common_iter);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `l1_len`\n  --> /tmp/tmpi8j27i3x.rs:11:38\n   |\n11 |   let common_len = l1_len < l2_len ? l1_len : l2_len;\n   |                                      ^^^^^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror[E0425]: cannot find function `iter` in this scope\n --> /tmp/tmpi8j27i3x.rs:7:17\n  |\n7 |   let l1_iter = iter(l1);\n  |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find function `iter` in this scope\n --> /tmp/tmpi8j27i3x.rs:8:17\n  |\n8 |   let l2_iter = iter(l2);\n  |                 ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfj4j6zrl.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj4j6zrl.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj4j6zrl.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpfj4j6zrl.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `add` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpfj4j6zrl.rs:14:23\n   |\n14 |       common = common.add(l1[l1_idx]);\n   |                       ^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj_o1u6z.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj_o1u6z.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter3 = iter1.next();\n  let mut iter4 = iter2.next();\n  while (iter3.is_ok() && iter4.is_ok()) {\n    if (iter3.get() == iter4.get()) {\n      result.append(iter3.get());\n      iter3 = iter1.next();\n      iter4 = iter2.next();\n    } else if (iter3.get() < iter4.get()) {\n      iter3 = iter1.next();\n    } else {\n      iter4 = iter2.next();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgc7jyjr8.rs:12:9\n   |\n12 |   while (iter3.is_ok() && iter4.is_ok()) {\n   |         ^                              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (iter3.is_ok() && iter4.is_ok()) {\n12 +   while iter3.is_ok() && iter4.is_ok() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgc7jyjr8.rs:13:8\n   |\n13 |     if (iter3.get() == iter4.get()) {\n   |        ^                          ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (iter3.get() == iter4.get()) {\n13 +     if iter3.get() == iter4.get() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgc7jyjr8.rs:17:15\n   |\n17 |     } else if (iter3.get() < iter4.get()) {\n   |               ^                         ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (iter3.get() < iter4.get()) {\n17 +     } else if iter3.get() < iter4.get() {\n   | \n\nerror[E0599]: no method named `is_ok` found for enum `Option` in the current scope\n  --> /tmp/tmpgc7jyjr8.rs:12:16\n   |\n12 |   while (iter3.is_ok() && iter4.is_ok()) {\n   |                ^^^^^ method not found in `Option<&isize>`\n\nerror[E0599]: no method named `is_ok` found for enum `Option` in the current scope\n  --> /tmp/tmpgc7jyjr8.rs:12:33\n   |\n12 |   while (iter3.is_ok() && iter4.is_ok()) {\n   |                                 ^^^^^ method not found in `Option<&isize>`\n\nerror[E0599]: no method named `get` found for enum `Option` in the current scope\n  --> /tmp/tmpgc7jyjr8.rs:13:15\n   |\n13 |     if (iter3.get() == iter4.get()) {\n   |               ^^^ method not found in `Option<&isize>`\n\nerror[E0599]: no method named `get` found for enum `Option` in the current scope\n  --> /tmp/tmpgc7jyjr8.rs:13:30\n   |\n13 |     if (iter3.get() == iter4.get()) {\n   |                              ^^^ method not found in `Option<&isize>`\n\nerror[E0599]: no method named `get` found for enum `Option` in the current scope\n  --> /t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let cmp = (a, b) => a - b;\n  let l1_sorted = l1.sort(cmp);\n  let l2_sorted = l2.sort(cmp);\n  let i = 0;\n  let j = 0;\n  let common = Vec::new(0);\n  while (i < l1_sorted.len && j < l2_sorted.len) {\n    if (l1_sorted[i] == l2_sorted[j]) {\n      common = common.concat(l1_sorted[i]);\n      i += 1;\n      j += 1;\n    } else if (l1_sorted[i] < l2_sorted[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `=>`\n --> /tmp/tmphbvpj6gl.rs:7:20\n  |\n7 |   let cmp = (a, b) => a - b;\n  |                    ^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk4hm8lvh.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk4hm8lvh.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter = iter1;\n  let mut iter_next = iter2;\n  let mut iter_next_next = iter1;\n  let mut iter_next_next_next = iter2;\n  let mut iter_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmphmzg4d4_.rs:28:30\n   |\n28 |   let mut iter_next_next_next\n   |                              ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmphmzg4d4_.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let result = Vec::new(l1_len);\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      result[c] = l1[i];\n      i += 1;\n      j += 1;\n      c += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  result.len_unsafe(c);\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpenamftji.rs:13:9\n   |\n13 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l1_len && j < l2_len) {\n13 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpenamftji.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpenamftji.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpenamftji.rs:12:16\n    |\n12  |   let result = Vec::new(l1_len);\n    |                ^^^^^^^^ ------ supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `len_unsafe` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpenamftji.rs:25:10\n   |\n25 |   result.len_unsafe(c);\n   |          ^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n\n  let mut first = true;\n  let mut found = false;\n  let mut last = false;\n\n  for (let i = 0; i < l1.len(); i++) {\n    let a = iter1.next();\n    let b = iter2.next();\n\n    if (a == b) {\n      if (first) {\n        first = false;\n        iter_result.next(a);\n      }\n      found = true;\n    } else {\n      if (found) {\n        last = true;\n        break;\n      }\n    }\n  }\n\n  if (!last) {\n    iter_result.next(0);\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpk0kdx9lz.rs:16:8\n   |\n16 |   for (let i = 0; i < l1.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpk0kdx9lz.rs:16:12\n   |\n16 |   for (let i = 0; i < l1.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpk0kdx9lz.rs:16:14\n   |\n16 |   for (let i = 0; i < l1.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpk0kdx9lz.rs:16:13\n   |\n16 |   for (let i = 0; i < l1.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpk0kdx9lz.rs:16:14\n   |\n16 |   for (let i = 0; i < l1.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk4hm8lvh.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common_len = 0;\n  let mut common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = l1_idx + 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_elements(common_len, l1[common_idx]);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpzfycilk4.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzfycilk4.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzfycilk4.rs:19:15\n   |\n19 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n19 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_elements` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpzfycilk4.rs:25:15\n   |\n25 |   return Vec::from_elements(common_len, l1[common_idx]);\n   |               ^^^^^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj_o1u6z.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk4hm8lvh.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpj4as_6w0.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj4as_6w0.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj4as_6w0.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpj4as_6w0.rs:23:10\n   |\n23 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter = Iterator::from_iter(l1);\n  let mut iter2 = Iterator::from_iter(l2);\n  let mut iter3 = Iterator::from_iter(l1);\n  let mut iter4 = Iterator::from_iter(l2);\n  let mut iter5 = Iterator::from_iter(l1);\n  let mut iter6 = Iterator::from_iter(l2);\n  let mut iter7 = Iterator::from_iter(l1);\n  let mut iter8 = Iterator::from_iter(l2);\n  let mut iter9 = Iterator::from_iter(l1);\n  let mut iter10 = Iterator::from_iter(l2);\n  let mut iter11 = Iterator::from_iter(l1);\n  let mut iter12 = Iterator::from_iter(l2);\n  let mut iter13 = Iterator::from_iter(l1);\n  let mut iter14 = Iterator::from_iter(l2);\n  let mut iter15 = Iterator::from_iter(l1);\n  let mut iter16 = Iterator::from_iter(l2);\n  let mut iter17 = Iterator::from_iter(l1);\n  let mut iter18 = Iterator::from_iter(l2);\n  let mut iter19 = Iterator::from_iter(l1);\n  let mut iter20 = Iterator::from_iter(l2);\n  let mut iter21 = Iterator::from_iter(l1);\n  let mut iter22 = Iterator::from_iter(l2);\n  let mut iter23 = Iterator::from_iter(l1);\n  let mut iter24 = Iterator::from_iter(l2);\n  let mut iter25 = Iterator::from_iter(l1);\n  let mut iter26 = Iterator::from_iter(l2);\n  let mut iter27 = Iterator::from_iter(l1);\n  let mut iter28 = Iterator::from_iter(l2);\n  let mut iter29 = Iterator::from_iter(l1);\n  let mut iter30 = Iterator::from\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpnv13qree.rs:37:34\n   |\n37 |   let mut iter30 = Iterator::from\n   |                                  ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nwarning: trait objects without an explicit `dyn` are deprecated\n --> /tmp/tmpnv13qree.rs:8:18\n  |\n8 |   let mut iter = Iterator::from_iter(l1);\n  |                  ^^^^^^^^\n  |\n  = note: `#[warn(bare_trait_objects)]` on by default\n  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: use `dyn`\n  |\n8 |   let mut iter = <dyn Iterator>::from_iter(l1);\n  |                  ++++         +\n\nerror[E0191]: the value of the associated type `Item` (from trait `Iterator`) must be specified\n --> /tmp/tmpnv13qree.rs:8:18\n  |\n8 |   let mut iter = Iterator::from_iter(l1);\n  |                  ^^^^^^^^ help: specify the associated type: `Iterator<Item = Type>`\n\nerror[E0599]: no function or associated item named `from_iter` found for trait object `dyn Iterator` in the current scope\n --> /tmp/tmpnv13qree.rs:8:28\n  |\n8 |   let mut iter = Iterator::from_iter(l1);\n  |                            ^^^^^^^^^ function or associated item not found in `dyn Iterator`\n\nwarning: trait objects without an explicit `dyn` are deprecated\n --> /tmp/tmpnv13qree.rs:9:19\n  |\n9 |   let mut iter2 = Iterator::from_iter(l2);\n  |                   ^^^^^^^^\n  |\n  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: use `dyn`\n  |\n9 |   let mut iter2 = <dyn Iterator>::from_iter(l2);\n  |                   ++++         +\n\nerror[E0191]: the value of the associated type `Item` (from trait `Iterator`) must be specified\n --> /tmp/tmpnv13qree.rs:9:19\n  |\n9 |   let mut iter2 = Iterator::from_iter(l2);\n  |                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let r = l2.len();\n  let common = Vec::new(0);\n  while (i < l && j < r) {\n    if (l1[i] == l2[j]) {\n      common = common.concat(l1[i]);\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common.take(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprc0a7czr.rs:13:9\n   |\n13 |   while (i < l && j < r) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < r) {\n13 +   while i < l && j < r {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprc0a7czr.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprc0a7czr.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmprc0a7czr.rs:12:16\n    |\n12  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmprc0a7czr.rs:15:23\n    |\n15  |       common = common.concat(l1[i]);\n    |                       ^^^^^^ ----- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: `Vec<_>` is not an iterator\n   --> /tmp/tmprc0a7czr.rs:25:17\n    |\n25  |     return common.take(c);\n    |                   ^^^^ `Vec<_>` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<_>: Iterator`\n            which is required by `&mut Vec<_>: Iterator`\n            `[_]: Iterator`\n            which is required by `&mut [_]: Iterator`\n    = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_iter = iter(l1);\n  let l2_iter = iter(l2);\n  let l1_next = l1_iter.next();\n  let l2_next = l2_iter.next();\n  let l1_done = false;\n  let l2_done = false;\n  let result = Vec::new();\n  while (!(l1_done && l2_done)) {\n    if (l1_next < l2_next) {\n      l1_next = l1_iter.next();\n    } else if (l2_next < l1_next) {\n      l2_next = l2_iter.next();\n    } else {\n      result = result.concat(l1_next);\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `iter` in this scope\n --> /tmp/tmpol410a1n.rs:7:17\n  |\n7 |   let l1_iter = iter(l1);\n  |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find function `iter` in this scope\n --> /tmp/tmpol410a1n.rs:8:17\n  |\n8 |   let l2_iter = iter(l2);\n  |                 ^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpol410a1n.rs:14:9\n   |\n14 |   while (!(l1_done && l2_done)) {\n   |         ^                     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (!(l1_done && l2_done)) {\n14 +   while !(l1_done && l2_done) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpol410a1n.rs:15:8\n   |\n15 |     if (l1_next < l2_next) {\n   |        ^                 ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (l1_next < l2_next) {\n15 +     if l1_next < l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpol410a1n.rs:17:15\n   |\n17 |     } else if (l2_next < l1_next) {\n   |               ^                 ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l2_next < l1_next) {\n17 +     } else if l2_next < l1_next {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpol410a1n.rs:20:23\n    |\n20  |       result = result.concat(l1_next);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpol410a1n.rs:20:23\n    |\n20  |       result = result.concat(l1_next);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerr",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  let common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      common_idx += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_idx, common_len, l1.data);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpdcxdej20.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdcxdej20.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpdcxdej20.rs:19:15\n   |\n19 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n19 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpdcxdej20.rs:25:15\n   |\n25 |   return Vec::from_iter(common_idx, common_len, l1.data);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmpdcxdej20.rs:25:52\n   |\n25 |   return Vec::from_iter(common_idx, common_len, l1.data);\n   |                                                    ^^^^ unknown field\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0599, E0609.\nFor more information about an error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_slice(l1.data.slice(i, l1.len - c));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpg23fj29g.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpg23fj29g.rs:12:8\n   |\n12 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1.data[i] == l2.data[j]) {\n12 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpg23fj29g.rs:16:15\n   |\n16 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (l1.data[i] < l2.data[j]) {\n16 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpg23fj29g.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpg23fj29g.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmpg23fj29g.rs:12:12\n   |\n12 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmpg23fj29g.rs:12:26\n   |\n12 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmpg23fj29g",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpzf57zw06.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpzf57zw06.rs:21:15\n   |\n21 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_all());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpsmckf73c.rs:12:9\n   |\n12 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l && j < m) {\n12 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsmckf73c.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpsmckf73c.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpsmckf73c.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpsmckf73c.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpsmckf73c.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.iter().collect_all());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_all` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpsmckf73c.rs:23:38\n   |\n23 |   return Vec",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbz092w_q.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpbz092w_q.rs:21:10\n   |\n21 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n  let mut iter_l1 = l1.iter();\n  let mut iter_l2 = l2.iter();\n  let mut iter_l1_next = iter_l1.next();\n  let mut iter_l2_next = iter_l2.next();\n  let mut iter_result_next = iter_result.next();\n  let mut iter_result_next_next = iter_result_next.next();\n  let mut iter_l1_next_next = iter_l1_next.next();\n  let mut iter_l2_next_next = iter_l2_next.next();\n  let mut iter_result_next_next_next = iter_result_next_next.next();\n  let mut iter_result_next_next_next_next = iter_result_next_next_next.next();\n  let mut iter_result_next_next_next_next_next = iter_result_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next = iter_result_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next_next = iter_result_next_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next_next_next = iter_result_next_next_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next_next_next_next = iter_result_next_next_next_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next_next_next_next_next = iter_result_next_next_next_next_next_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpvonns6w6.rs:27:52\n   |\n27 |   let mut iter_result_next_next_next_next_next_next\n   |                                                    ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpvonns6w6.rs:16:52\n   |\n16 |   let mut iter_result_next_next = iter_result_next.next();\n   |                                                    ^^^^ method not found in `Option<&_>`\n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpvonns6w6.rs:17:44\n   |\n17 |   let mut iter_l1_next_next = iter_l1_next.next();\n   |                                            ^^^^ method not found in `Option<&isize>`\n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpvonns6w6.rs:18:44\n   |\n18 |   let mut iter_l2_next_next = iter_l2_next.next();\n   |                                            ^^^^ method not found in `Option<&isize>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpvonns6w6.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpp1fsz3h1.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp1fsz3h1.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp1fsz3h1.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpp1fsz3h1.rs:23:10\n   |\n23 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbs_3ojld.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:11:16\n    |\n11  |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common_iter = Vec::new();\n  let mut l1_is_iter = l1.iter();\n  let mut l2_is_iter = l2.iter();\n  let mut l1_is_next = l1_is_iter.next();\n  let mut l2_is_next = l2_is_iter.next();\n  let mut common_is_next = common_iter.next();\n  let mut l1_is_done = false;\n  let mut l2_is_done = false;\n  let mut common_is_done = false;\n  while (!l1_is_done && !l2_is_done) {\n    if (l1_is_next.is_some() && l2_is_next.is_some()) {\n      if (l1_is_next.unwrap() == l2_is_next.unwrap()) {\n        common_is_next.set(l1_is_next.unwrap());\n        l1_is_next = l1_is_iter.next();\n        l2_is_next = l2_is_iter.next();\n      } else {\n        l1_is_done = true;\n        l2_is_done = true;\n      }\n    } else if (l1_is_next.is_some()) {\n      l1_is_done = true;\n    } else if (l2_is_next.is_some()) {\n      l2_is_done = true;\n    }\n  }\n  return common_iter;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpalm0yrig.rs:18:9\n   |\n18 |   while (!l1_is_done && !l2_is_done) {\n   |         ^                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n18 -   while (!l1_is_done && !l2_is_done) {\n18 +   while !l1_is_done && !l2_is_done {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpalm0yrig.rs:19:8\n   |\n19 |     if (l1_is_next.is_some() && l2_is_next.is_some()) {\n   |        ^                                            ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (l1_is_next.is_some() && l2_is_next.is_some()) {\n19 +     if l1_is_next.is_some() && l2_is_next.is_some() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpalm0yrig.rs:20:10\n   |\n20 |       if (l1_is_next.unwrap() == l2_is_next.unwrap()) {\n   |          ^                                          ^\n   |\nhelp: remove these parentheses\n   |\n20 -       if (l1_is_next.unwrap() == l2_is_next.unwrap()) {\n20 +       if l1_is_next.unwrap() == l2_is_next.unwrap() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpalm0yrig.rs:28:15\n   |\n28 |     } else if (l1_is_next.is_some()) {\n   |               ^                    ^\n   |\nhelp: remove these parentheses\n   |\n28 -     } else if (l1_is_next.is_some()) {\n28 +     } else if l1_is_next.is_some() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpalm0yrig.rs:30:15\n   |\n30 |     } else if (l2_is_next.is_some()) {\n   |               ^                    ^\n   |\nhelp: remove these parentheses\n   |\n30 -     } else if (l2_is_next.is_some()) {\n30 +     } else if l2_is_next.is_some() {\n   | \n\nerror[E0599]: no method named `next` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpalm0yrig.rs:14:40\n   |\n14 |   let mut common_is_next = common_iter.next();\n   |                                        ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to previous error; 5 warnings",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.drop(i).append(l2.drop(j)));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy90w8var.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy90w8var.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy90w8var.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpy90w8var.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.drop(i).append(l2.drop(j)));\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0040]: explicit use of destructor method\n  --> /tmp/tmpy90w8var.rs:23:31\n   |\n23 |   return Vec::from_iter(c, l1.drop(i).append(l2.drop(j)));\n   |                            ---^^^^---\n   |                            |  |\n   |                            |  explicit destructor calls not allowed\n   |                            help: consider using `drop` function: `drop(l1)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpy90w8var.rs:23:31\n    |\n23  |   return Vec::from_iter(c, l1.drop(i).append(l2.drop(j)));\n    |                               ^^^^ - supplied 1 argument\n    |               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj_o1u6z.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  for i in 0..l1.len {\n    if l1.data[i] == l2.data[i] {\n      c += 1;\n    }\n  }\n  let r = Vec::new(c);\n  let j = 0;\n  for i in 0..l1.len {\n    if l1.data[i] == l2.data[i] {\n      r.data[j] = l1.data[i];\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n --> /tmp/tmp9hvh10fq.rs:8:18\n  |\n8 |   for i in 0..l1.len {\n  |                  ^^^ private field\n  |\nhelp: a method `len` also exists, call it with parentheses\n  |\n8 |   for i in 0..l1.len() {\n  |                     ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n --> /tmp/tmp9hvh10fq.rs:9:11\n  |\n9 |     if l1.data[i] == l2.data[i] {\n  |           ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n --> /tmp/tmp9hvh10fq.rs:9:25\n  |\n9 |     if l1.data[i] == l2.data[i] {\n  |                         ^^^^ unknown field\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp9hvh10fq.rs:13:11\n    |\n13  |   let r = Vec::new(c);\n    |           ^^^^^^^^ - supplied 1 argument\n    |           |\n    |           expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp9hvh10fq.rs:15:18\n   |\n15 |   for i in 0..l1.len {\n   |                  ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n15 |   for i in 0..l1.len() {\n   |                     ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp9hvh10fq.rs:16:11\n   |\n16 |     if l1.data[i] == l2.data[i] {\n   |           ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp9hvh10fq.rs:16:25\n   |\n16 |     if l1.data[i] == l2.data[i] {\n   |                         ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<_>`\n  --> /tmp/tmp9hvh10fq.rs:17:9\n   |\n17 |       r.data[j] = l1.data[i];\n   |         ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp9hvh10fq.rs:17:22\n   |\n17 |       r.data[j] = l1.data[i];\n   |                      ^^^^ unknown field\n\nerror: aborting due to 9 previous errors\n\nSome errors have detailed explanations: E0061, E0609, E0616.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common_idx = 0;\n  let mut common_len = 0;\n  let mut l1_val = 0;\n  let mut l2_val = 0;\n  let mut common_val = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    l1_val = l1[l1_idx];\n    l2_val = l2[l2_idx];\n    if (l1_val < l2_val) {\n      l1_idx += 1;\n    } else if (l1_val > l2_val) {\n      l2_idx += 1;\n    } else {\n      common_idx += 1;\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    }\n  }\n  if (l1_idx < l1_len) {\n    common_len += l1_len - l1_idx;\n  }\n  if (l2_idx < l2_len) {\n    common_len += l2_len - l2_idx;\n  }\n  let mut common_vec = Vec::new(common_len);\n  for (let i = 0; i < common_len; i += 1) {\n    common_vec[i] = common_val;\n  }\n  return common_vec;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpvxj7iui6.rs:37:8\n   |\n37 |   for (let i = 0; i < common_len; i += 1) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpvxj7iui6.rs:37:12\n   |\n37 |   for (let i = 0; i < common_len; i += 1) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpvxj7iui6.rs:37:14\n   |\n37 |   for (let i = 0; i < common_len; i += 1) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpvxj7iui6.rs:37:13\n   |\n37 |   for (let i = 0; i < common_len; i += 1) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpvxj7iui6.rs:37:14\n   |\n37 |   for (let i = 0; i < common_len; i += 1) {\n   |              ^ expected expression\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvxj7iui6.rs:16:9\n   |\n16 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n16 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvxj7iui6.rs:19:8\n   |\n19 |     if (l1_val < l2_val) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (l1_val < l2_val) {\n19 +     if l1_val < l2_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvxj7iui6.rs:21:15\n   |\n21 |     } else if (l1_val > l2_val) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     } else if (l1_val > l2_val) {\n21 +     } else if l1_val > l2_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvxj7iui6.rs:30:6\n   |\n30 |   if (l1_idx < l1_len) {\n   |     ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpj4as_6w0.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj4as_6w0.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj4as_6w0.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpj4as_6w0.rs:23:10\n   |\n23 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpw3wj7mcb.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw3wj7mcb.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw3wj7mcb.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpw3wj7mcb.rs:21:15\n   |\n21 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpw3wj7mcb.rs:21:47\n   |\n21 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n  let mut iter_l1 = l1.iter();\n  let mut iter_l2 = l2.iter();\n  let mut iter_result_next = iter_result.next();\n  let mut iter_l1_next = iter_l1.next();\n  let mut iter_l2_next = iter_l2.next();\n  let mut iter_result_next_next = iter_result_next.next();\n  let mut iter_l1_next_next = iter_l1_next.next();\n  let mut iter_l2_next_next = iter_l2_next.next();\n  let mut iter_result_next_next_next = iter_result_next_next.next();\n  let mut iter_l1_next_next_next = iter_l1_next_next.next();\n  let mut iter_l2_next_next_next = iter_l2_next_next.next();\n  let mut iter_result_next_next_next_next = iter_result_next_next_next.next();\n  let mut iter_l1_next_next_next_next = iter_l1_next_next_next.next();\n  let mut iter_l2_next_next_next_next = iter_l2_next_next_next.next();\n  let mut iter_result_next_next_next_next_next = iter_result_next_next_next_next.next();\n  let mut iter_l1_next_next_next_next_next = iter_l1_next_next_next_next.next();\n  let mut iter_l2_next_next_next_next_next = iter_l2_next_next_next_next.next();\n  let mut iter_result_next_next_next_next_next_next = iter_result_next_next_next_next_next.next();\n  let mut iter_l1_next_next_next_next_next_next = iter_\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpa8v0elmm.rs:29:56\n   |\n29 |   let mut iter_l1_next_next_next_next_next_next = iter_\n   |                                                        ^ help: add `;` here\n30 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `iter_` in this scope\n  --> /tmp/tmpa8v0elmm.rs:29:51\n   |\n29 |   let mut iter_l1_next_next_next_next_next_next = iter_\n   |                                                   ^^^^^ help: a local variable with a similar name exists: `iter1`\n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpa8v0elmm.rs:16:52\n   |\n16 |   let mut iter_result_next_next = iter_result_next.next();\n   |                                                    ^^^^ method not found in `Option<&_>`\n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpa8v0elmm.rs:17:44\n   |\n17 |   let mut iter_l1_next_next = iter_l1_next.next();\n   |                                            ^^^^ method not found in `Option<&isize>`\n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpa8v0elmm.rs:18:44\n   |\n18 |   let mut iter_l2_next_next = iter_l2_next.next();\n   |                                            ^^^^ method not found in `Option<&isize>`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpa8v0elmm.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk4hm8lvh.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn23u00bw.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpn23u00bw.rs:21:10\n   |\n21 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbz092w_q.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpbz092w_q.rs:21:10\n   |\n21 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmp15w_lj6c.rs:24:7\n   |\n24 |     [&](isize i) { return l1[i] == l2[i]; }\n   |       ^ expected expression\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n  --> /tmp/tmp15w_lj6c.rs:25:4\n   |\n25 |   ));\n   |    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp15w_lj6c.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp15w_lj6c.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp15w_lj6c.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter = Iterator::from_iter(l1);\n  let mut iter2 = Iterator::from_iter(l2);\n  let mut iter_next = Iterator::from_iter(l1);\n  let mut iter2_next = Iterator::from_iter(l2);\n  let mut iter_next2 = Iterator::from_iter(l1);\n  let mut iter2_next2 = Iterator::from_iter(l2);\n  let mut iter_next3 = Iterator::from_iter(l1);\n  let mut iter2_next3 = Iterator::from_iter(l2);\n  let mut iter_next4 = Iterator::from_iter(l1);\n  let mut iter2_next4 = Iterator::from_iter(l2);\n  let mut iter_next5 = Iterator::from_iter(l1);\n  let mut iter2_next5 = Iterator::from_iter(l2);\n  let mut iter_next6 = Iterator::from_iter(l1);\n  let mut iter2_next6 = Iterator::from_iter(l2);\n  let mut iter_next7 = Iterator::from_iter(l1);\n  let mut iter2_next7 = Iterator::from_iter(l2);\n  let mut iter_next8 = Iterator::from_iter(l1);\n  let mut iter2_next8 = Iterator::from_iter(l2);\n  let mut iter_next9 = Iterator::from_iter(l1);\n  let mut iter2_next9 = Iterator::from_iter(l2);\n  let mut iter_next10 = Iterator::from_iter(l1);\n  let mut iter2_next10 = Iterator::from_iter(l2);\n  let mut iter_next11 = Iterator::from_iter(l1);\n  let mut iter2_next11 = Iterator::from_iter(l2);\n  let mut iter_next12 = Iterator::from_iter(l1);\n  let mut iter2_next12 = Iterator::from_iter(l2);\n  let mut\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected identifier, found `}`\n  --> /tmp/tmpkf0kx_0l.rs:35:1\n   |\n35 | }\n   | ^ expected identifier\n\nwarning: trait objects without an explicit `dyn` are deprecated\n --> /tmp/tmpkf0kx_0l.rs:8:18\n  |\n8 |   let mut iter = Iterator::from_iter(l1);\n  |                  ^^^^^^^^\n  |\n  = note: `#[warn(bare_trait_objects)]` on by default\n  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: use `dyn`\n  |\n8 |   let mut iter = <dyn Iterator>::from_iter(l1);\n  |                  ++++         +\n\nerror[E0191]: the value of the associated type `Item` (from trait `Iterator`) must be specified\n --> /tmp/tmpkf0kx_0l.rs:8:18\n  |\n8 |   let mut iter = Iterator::from_iter(l1);\n  |                  ^^^^^^^^ help: specify the associated type: `Iterator<Item = Type>`\n\nerror[E0599]: no function or associated item named `from_iter` found for trait object `dyn Iterator` in the current scope\n --> /tmp/tmpkf0kx_0l.rs:8:28\n  |\n8 |   let mut iter = Iterator::from_iter(l1);\n  |                            ^^^^^^^^^ function or associated item not found in `dyn Iterator`\n\nwarning: trait objects without an explicit `dyn` are deprecated\n --> /tmp/tmpkf0kx_0l.rs:9:19\n  |\n9 |   let mut iter2 = Iterator::from_iter(l2);\n  |                   ^^^^^^^^\n  |\n  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n  = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\nhelp: use `dyn`\n  |\n9 |   let mut iter2 = <dyn Iterator>::from_iter(l2);\n  |                   ++++         +\n\nerror[E0191]: the value of the associated type `Item` (from trait `Iterator`) must be specified\n --> /tmp/tmpkf0kx_0l.rs:9:19\n  |\n9 |   let mut iter2 = Iterator::from_iter(l2);\n  |                   ^^^^^^^^ help: specify the associated type: `Iterator<Item = Type>`\n\nerror[E0599]: no fu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpj4as_6w0.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj4as_6w0.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpj4as_6w0.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpj4as_6w0.rs:23:10\n   |\n23 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n  let mut l1_next = l1_iter.next();\n  let mut l2_next = l2_iter.next();\n  let mut common_next = common.iter().next();\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  let mut l1_last = l1_next;\n  let mut l2_last = l2_next;\n  let mut common_last = common_next;\n  let mut l1_next_next = l1_iter.next();\n  let mut l2_next_next = l2_iter.next();\n  let mut common_next_next = common.iter().next();\n  let mut l1_next_done = false;\n  let mut l2_next_done = false;\n  let mut common_next_done = false;\n  let mut l1_next_last = l1_next_next;\n  let mut l2_next_last = l2_next_next;\n  let mut common_next_last = common_next_next;\n  while (!(l1_done && l2_done && common_done)) {\n    if (!l1_done && !l2_done) {\n      if (l1_next < l2_next) {\n        l1_next_next = l1_iter.next();\n        l1_next_done = false;\n        l1_next_last = l1_next_next;\n        l1_next = l1_next_next;\n      } else if (l2_next < l1_next) {\n        l2_next_next = l2_iter.next();\n        l2_next_done = false;\n        l2_next_last = l2_next_next;\n        l2_next = l2_next_next;\n      } else {\n        common_next_next = common.iter().next();\n        common_next_done = false;\n        common_\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpo50bjlyi.rs:52:3\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                                                         - unclosed delimiter\n...\n28 |   while (!(l1_done && l2_done && common_done)) {\n   |                                                - unclosed delimiter\n29 |     if (!l1_done && !l2_done) {\n   |                               - unclosed delimiter\n...\n40 |       } else {\n   |              - this delimiter might not be properly closed...\n...\n44 | }\n   | - ...as it matches this but it has different indentation\n...\n52 | }\n   |   ^\n\nerror[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpo50bjlyi.rs:47:21\n   |\n47 |     let candidate = common;\n   |                     ^^^^^^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0425]: cannot find value `common_` in this scope\n  --> /tmp/tmpo50bjlyi.rs:43:9\n   |\n43 |         common_\n   |         ^^^^^^^ help: a local variable with a similar name exists: `common`\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpo50bjlyi.rs:28:9\n   |\n28 |   while (!(l1_done && l2_done && common_done)) {\n   |         ^                                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n28 -   while (!(l1_done && l2_done && common_done)) {\n28 +   while !(l1_done && l2_done && common_done) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo50bjlyi.rs:29:8\n   |\n29 |     if (!l1_done && !l2_done) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n29 -     if (!l1_done && !l2_done) {\n29 +     if !l1_done && !l2_done {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo50bjlyi.rs:30:10\n   |\n30 |       if (l1_next < l2_next) {\n   |          ^                 ^\n   |\nhelp: remove these parentheses\n   |\n30 -       if (l1_next < l2_next) {\n30 +       if l1_next < l2_next {\n   | \n\nwarning: unnecessary paren",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbs_3ojld.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:11:16\n    |\n11  |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.len());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgxeygqxz.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgxeygqxz.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgxeygqxz.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpgxeygqxz.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.len());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpp1fsz3h1.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp1fsz3h1.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp1fsz3h1.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpp1fsz3h1.rs:23:10\n   |\n23 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = 0;\n  let mut l2_iter = 0;\n  let mut common_iter = 0;\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut common_len = 0;\n  let mut common_vec = Vec::new(0);\n\n  while (l1_iter < l1_len && l2_iter < l2_len) {\n    if (l1[l1_iter] < l2[l2_iter]) {\n      l1_iter += 1;\n    } else if (l1[l1_iter] > l2[l2_iter]) {\n      l2_iter += 1;\n    } else {\n      common_iter += 1;\n      l1_iter += 1;\n      l2_iter += 1;\n    }\n  }\n\n  common_len = common_iter;\n  common_vec = Vec::new(common_len);\n\n  while (l1_iter < l1_len) {\n    common_vec.append(l1[l1_iter]);\n    l1_iter += 1;\n  }\n\n  while (l2_iter < l2_len) {\n    common_vec.append(l2[l2_iter]);\n    l2_iter += 1;\n  }\n\n  return common_vec;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy84djo1t.rs:15:9\n   |\n15 |   while (l1_iter < l1_len && l2_iter < l2_len) {\n   |         ^                                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n15 -   while (l1_iter < l1_len && l2_iter < l2_len) {\n15 +   while l1_iter < l1_len && l2_iter < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy84djo1t.rs:16:8\n   |\n16 |     if (l1[l1_iter] < l2[l2_iter]) {\n   |        ^                         ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (l1[l1_iter] < l2[l2_iter]) {\n16 +     if l1[l1_iter] < l2[l2_iter] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy84djo1t.rs:18:15\n   |\n18 |     } else if (l1[l1_iter] > l2[l2_iter]) {\n   |               ^                         ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_iter] > l2[l2_iter]) {\n18 +     } else if l1[l1_iter] > l2[l2_iter] {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy84djo1t.rs:30:9\n   |\n30 |   while (l1_iter < l1_len) {\n   |         ^                ^\n   |\nhelp: remove these parentheses\n   |\n30 -   while (l1_iter < l1_len) {\n30 +   while l1_iter < l1_len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpy84djo1t.rs:35:9\n   |\n35 |   while (l2_iter < l2_len) {\n   |         ^                ^\n   |\nhelp: remove these parentheses\n   |\n35 -   while (l2_iter < l2_len) {\n35 +   while l2_iter < l2_len {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpy84djo1t.rs:13:24\n    |\n13  |   let mut common_vec = Vec::new(0);\n    |                        ^^^^^^^^ - supplied 1 argument\n    |                        |\n    |                        expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpy84djo1t.rs:28:16\n    |\n28  | ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbz092w_q.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpbz092w_q.rs:21:10\n   |\n21 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpt4z50en3.rs:12:9\n   |\n12 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l && j < m) {\n12 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4z50en3.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt4z50en3.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpt4z50en3.rs:23:10\n   |\n23 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphpsavch9.rs:12:9\n   |\n12 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l && j < m) {\n12 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphpsavch9.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphpsavch9.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmphpsavch9.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmphpsavch9.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmphpsavch9.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmphpsavch9.rs:23:38\n   |\n23 |   retu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common_iter = Vec::new();\n  let mut l1_next = l1_iter.next();\n  let mut l2_next = l2_iter.next();\n  let mut common_next = common_iter.next();\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  while (!l1_done && !l2_done) {\n    if (l1_next < l2_next) {\n      l1_next = l1_iter.next();\n    } else if (l2_next < l1_next) {\n      l2_next = l2_iter.next();\n    } else {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1_iter.next();\n      l2\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpeloa4hwy.rs:58:3\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                                                         - unclosed delimiter\n...\n16 |   while (!l1_done && !l2_done) {\n   |                                - unclosed delimiter\n...\n46 |     if (l1_next == l2_next) {\n   |                             - this delimiter might not be properly closed...\n...\n50 | }\n   | - ...as it matches this but it has different indentation\n...\n58 | }\n   |   ^\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpeloa4hwy.rs:16:9\n   |\n16 |   while (!l1_done && !l2_done) {\n   |         ^                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (!l1_done && !l2_done) {\n16 +   while !l1_done && !l2_done {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeloa4hwy.rs:17:8\n   |\n17 |     if (l1_next < l2_next) {\n   |        ^                 ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (l1_next < l2_next) {\n17 +     if l1_next < l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeloa4hwy.rs:19:15\n   |\n19 |     } else if (l2_next < l1_next) {\n   |               ^                 ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l2_next < l1_next) {\n19 +     } else if l2_next < l1_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeloa4hwy.rs:26:8\n   |\n26 |     if (l1_next == l2_next) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n26 -     if (l1_next == l2_next) {\n26 +     if l1_next == l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpeloa4hwy.rs:31:8\n   |\n31 |     if (l1_next == l2_next) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n31 -     if (l1_next == l2_next) {\n31 +     if l1_next == l2_next {\n   | \n\nwarning: unnecessary parentheses around `if`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return l1.slice(common_idx, common_idx + common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nms8s4t.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nms8s4t.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nms8s4t.rs:19:15\n   |\n19 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n19 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp8nms8s4t.rs:25:13\n   |\n25 |   return l1.slice(common_idx, common_idx + common_len);\n   |             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n25 |   return l1.as_slice(common_idx, common_idx + common_len);\n   |             ~~~~~~~~\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter = iter1;\n  let mut iter_next = iter2;\n  let mut iter_next_next = iter1;\n  let mut iter_next_next_next = iter2;\n  let mut iter_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmphmzg4d4_.rs:28:30\n   |\n28 |   let mut iter_next_next_next\n   |                              ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmphmzg4d4_.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj_o1u6z.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      c += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(c, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmplfgpv3s7.rs:14:9\n   |\n14 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n14 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplfgpv3s7.rs:15:8\n   |\n15 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (l1[l1_idx] == l2[l2_idx]) {\n15 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmplfgpv3s7.rs:19:15\n   |\n19 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n19 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmplfgpv3s7.rs:25:15\n   |\n25 |   return Vec::from_iter(c, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn23u00bw.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpn23u00bw.rs:21:10\n   |\n21 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common_idx = 0;\n  let mut common_len = 0;\n  let mut common_idx_list = vec![];\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx_list.push(l1_idx);\n      l1_idx += 1;\n      l2_idx += 1;\n      common_idx += 1;\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return vec![common_idx_list.len(), common_idx, common_len];\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkqwnb_f5.rs:15:9\n   |\n15 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n15 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n15 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkqwnb_f5.rs:16:8\n   |\n16 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (l1[l1_idx] == l2[l2_idx]) {\n16 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkqwnb_f5.rs:22:15\n   |\n22 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n22 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkqwnb_f5.rs:29:15\n   |\n29 |   return vec![common_idx_list.len(), common_idx, common_len];\n   |               ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n29 |   return vec![common_idx_list.len().try_into().unwrap(), common_idx, common_len];\n   |                                    ++++++++++++++++++++\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp0uohywa_.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0uohywa_.rs:11:8\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1.data[i] == l2.data[j]) {\n11 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp0uohywa_.rs:15:15\n   |\n15 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1.data[i] < l2.data[j]) {\n15 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp0uohywa_.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp0uohywa_.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp0uohywa_.rs:11:12\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp0uohywa_.rs:11:26\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp0uohywa_",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpo9uhu9wh.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9uhu9wh.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpo9uhu9wh.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpo9uhu9wh.rs:11:16\n    |\n11  |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `add` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpo9uhu9wh.rs:14:23\n   |\n14 |       result = result.add(l1[l1_idx]);\n   |                       ^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  let common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = l1_idx + 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len, common_idx, l1.data);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1jd75cyp.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1jd75cyp.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1jd75cyp.rs:19:15\n   |\n19 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n19 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp1jd75cyp.rs:25:47\n   |\n25 |   return Vec::from(common_len, common_idx, l1.data);\n   |                                               ^^^^ unknown field\n\nerror[E0061]: this function takes 1 argument but 3 arguments were supplied\n   --> /tmp/tmp1jd75cyp.rs:25:10\n    |\n25  |   return Vec::from(common_len, common_idx, l1.data);\n    |          ^^^^^^^^^ ----------  ----------  ------- supplied 3 arguments\n    |          |\n    |          expected 1 argument\n    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0609.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphpsavch9.rs:12:9\n   |\n12 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l && j < m) {\n12 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphpsavch9.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphpsavch9.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmphpsavch9.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmphpsavch9.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmphpsavch9.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmphpsavch9.rs:23:38\n   |\n23 |   retu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpivfbqhse.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpivfbqhse.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpivfbqhse.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpivfbqhse.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpivfbqhse.rs:23:38\n   |\n23 |   return Vec::from_iter(c, l1.iter().collect_to_vec());\n   |                                      ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn23u00bw.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpn23u00bw.rs:21:10\n   |\n21 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpydm7yzlg.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpydm7yzlg.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpydm7yzlg.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 1 argument but 3 arguments were supplied\n   --> /tmp/tmpydm7yzlg.rs:23:10\n    |\n23  |   return Vec::from(common_len, l1_idx, l2_idx);\n    |          ^^^^^^^^^ ----------  ------  ------ supplied 3 arguments\n    |          |\n    |          expected 1 argument\n    |\nnote: associated function defined here\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      common.append(l1.data[i]);\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpv716kp2k.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpv716kp2k.rs:11:8\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1.data[i] == l2.data[j]) {\n11 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpv716kp2k.rs:15:15\n   |\n15 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1.data[i] < l2.data[j]) {\n15 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpv716kp2k.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpv716kp2k.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmpv716kp2k.rs:11:12\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmpv716kp2k.rs:11:26\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmpv716kp2k",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfj4j6zrl.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj4j6zrl.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj4j6zrl.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpfj4j6zrl.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `add` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpfj4j6zrl.rs:14:23\n   |\n14 |       common = common.add(l1[l1_idx]);\n   |                       ^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbs_3ojld.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:11:16\n    |\n11  |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcx7jnpgc.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcx7jnpgc.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcx7jnpgc.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nwarning: variable `c` is assigned to, but never used\n --> /tmp/tmpcx7jnpgc.rs:7:7\n  |\n7 |   let c = 0;\n  |       ^\n  |\n  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using `_c` instead\n\nerror[E0384]: cannot assign twice to immutable variable `c`\n  --> /tmp/tmpcx7jnpgc.rs:15:7\n   |\n7  |   let c = 0;\n   |       -\n   |       |\n   |       first assignment to `c`\n   |       help: consider making this binding mutable: `mut c`\n...\n15 |       c += 1;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmpcx7jnpgc.rs:16:7\n   |\n12 |   let r = vec![];\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n...\n16 |       r = vec![l1[i]];\n   |       ^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpcx7jnpgc.rs:17:7\n   |\n8  |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n17 |       i += 1;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_iter = l1.iter();\n  let l2_iter = l2.iter();\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(l1_len);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    let l1_val = l1_iter.next();\n    let l2_val = l2_iter.next();\n    if (l1_val == l2_val) {\n      result.append(l1_val);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1_val < l2_val) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpiig5z7hk.rs:14:9\n   |\n14 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n14 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiig5z7hk.rs:17:8\n   |\n17 |     if (l1_val == l2_val) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (l1_val == l2_val) {\n17 +     if l1_val == l2_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpiig5z7hk.rs:21:15\n   |\n21 |     } else if (l1_val < l2_val) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n21 -     } else if (l1_val < l2_val) {\n21 +     } else if l1_val < l2_val {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpiig5z7hk.rs:13:16\n    |\n13  |   let result = Vec::new(l1_len);\n    |                ^^^^^^^^ ------ supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiig5z7hk.rs:18:21\n   |\n18 |       result.append(l1_val);\n   |                     ^^^^^^ expected `&mut Vec<_>`, found enum `Option`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found enum `Option<&isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpivfbqhse.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpivfbqhse.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpivfbqhse.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpivfbqhse.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpivfbqhse.rs:23:38\n   |\n23 |   return Vec::from_iter(c, l1.iter().collect_to_vec());\n   |                                      ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcx7jnpgc.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcx7jnpgc.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcx7jnpgc.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nwarning: variable `c` is assigned to, but never used\n --> /tmp/tmpcx7jnpgc.rs:7:7\n  |\n7 |   let c = 0;\n  |       ^\n  |\n  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using `_c` instead\n\nerror[E0384]: cannot assign twice to immutable variable `c`\n  --> /tmp/tmpcx7jnpgc.rs:15:7\n   |\n7  |   let c = 0;\n   |       -\n   |       |\n   |       first assignment to `c`\n   |       help: consider making this binding mutable: `mut c`\n...\n15 |       c += 1;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmpcx7jnpgc.rs:16:7\n   |\n12 |   let r = vec![];\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n...\n16 |       r = vec![l1[i]];\n   |       ^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpcx7jnpgc.rs:17:7\n   |\n8  |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n17 |       i += 1;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let r = l2.len;\n  while (i < l && j < r) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8g2o92sh.rs:12:9\n   |\n12 |   while (i < l && j < r) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l && j < r) {\n12 +   while i < l && j < r {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8g2o92sh.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8g2o92sh.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp8g2o92sh.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp8g2o92sh.rs:11:14\n   |\n11 |   let r = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let r = l2.len();\n   |                 ++\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmp8g2o92sh.rs:23:10\n   |\n23 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 othe",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmp15w_lj6c.rs:24:7\n   |\n24 |     [&](isize i) { return l1[i] == l2[i]; }\n   |       ^ expected expression\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n  --> /tmp/tmp15w_lj6c.rs:25:4\n   |\n25 |   ));\n   |    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp15w_lj6c.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp15w_lj6c.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp15w_lj6c.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common = Vec::new();\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn4ycco6w.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn4ycco6w.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn4ycco6w.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpn4ycco6w.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpn4ycco6w.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common_iter = Vec::new();\n  let mut l1_next = l1.next();\n  let mut l2_next = l2.next();\n  let mut common_next = common_iter.next();\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  while (!(l1_done && l2_done && common_done)) {\n    if (!l1_done && !l2_done) {\n      if (l1_next < l2_next) {\n        l1_next = l1.next();\n      } else if (l1_next > l2_next) {\n        l2_next = l2.next();\n      } else {\n        common_next = l1_next;\n        l1_next = l1.next();\n        l2_next = l2.next();\n      }\n    } else if (!l1_done && common_done) {\n      l1_next = l1.next();\n    } else if (l2_done && !common_done) {\n      l2_next = l2.next();\n    }\n    if (l1_next == l2_next) {\n      common_next = l1_next;\n      l1_next = l1.next();\n      l2_next = l2.next();\n    } else if (l1_next < l2_next) {\n      l1_done = true;\n    } else {\n      l2_done = true;\n    }\n    common_done = l1_done && l2_done;\n    common_iter.next(common_next);\n  }\n  return common_iter;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpt6mpmqil.rs:16:9\n   |\n16 |   while (!(l1_done && l2_done && common_done)) {\n   |         ^                                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (!(l1_done && l2_done && common_done)) {\n16 +   while !(l1_done && l2_done && common_done) {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt6mpmqil.rs:17:8\n   |\n17 |     if (!l1_done && !l2_done) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (!l1_done && !l2_done) {\n17 +     if !l1_done && !l2_done {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt6mpmqil.rs:18:10\n   |\n18 |       if (l1_next < l2_next) {\n   |          ^                 ^\n   |\nhelp: remove these parentheses\n   |\n18 -       if (l1_next < l2_next) {\n18 +       if l1_next < l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt6mpmqil.rs:20:17\n   |\n20 |       } else if (l1_next > l2_next) {\n   |                 ^                 ^\n   |\nhelp: remove these parentheses\n   |\n20 -       } else if (l1_next > l2_next) {\n20 +       } else if l1_next > l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt6mpmqil.rs:27:15\n   |\n27 |     } else if (!l1_done && common_done) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n27 -     } else if (!l1_done && common_done) {\n27 +     } else if !l1_done && common_done {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt6mpmqil.rs:29:15\n   |\n29 |     } else if (l2_done && !common_done) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n29 -     } else if (l2_done && !common_done) {\n29 +     } else if l2_done && !common_done {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpt6mpmqil.rs:32:8\n   |\n32 |     if (l1_next == l2_next) {",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcx7jnpgc.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcx7jnpgc.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcx7jnpgc.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nwarning: variable `c` is assigned to, but never used\n --> /tmp/tmpcx7jnpgc.rs:7:7\n  |\n7 |   let c = 0;\n  |       ^\n  |\n  = note: `#[warn(unused_variables)]` on by default\n  = note: consider using `_c` instead\n\nerror[E0384]: cannot assign twice to immutable variable `c`\n  --> /tmp/tmpcx7jnpgc.rs:15:7\n   |\n7  |   let c = 0;\n   |       -\n   |       |\n   |       first assignment to `c`\n   |       help: consider making this binding mutable: `mut c`\n...\n15 |       c += 1;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `r`\n  --> /tmp/tmpcx7jnpgc.rs:16:7\n   |\n12 |   let r = vec![];\n   |       -\n   |       |\n   |       first assignment to `r`\n   |       help: consider making this binding mutable: `mut r`\n...\n16 |       r = vec![l1[i]];\n   |       ^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpcx7jnpgc.rs:17:7\n   |\n8  |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n17 |       i += 1;\n   |       ^^^^^^ cannot assign twice to immutable variable\n\nerro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.len());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgxeygqxz.rs:12:9\n   |\n12 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l1_len && j < l2_len) {\n12 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgxeygqxz.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgxeygqxz.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpgxeygqxz.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.len());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n  let mut iter_l1 = l1.iter();\n  let mut iter_l2 = l2.iter();\n\n  while (true) {\n    let mut v1 = iter_l1.next();\n    let mut v2 = iter_l2.next();\n    let mut v_result = iter_result.next();\n\n    if (v1.is_undefined() || v2.is_undefined()) {\n      break;\n    }\n\n    if (v1.unwrap() == v2.unwrap()) {\n      v_result = v1;\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpp3u_sh8f.rs:14:9\n   |\n14 |   while (true) {\n   |         ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (true) {\n14 +   while true {\n   | \n\nwarning: denote infinite loops with `loop { ... }`\n  --> /tmp/tmpp3u_sh8f.rs:14:3\n   |\n14 |   while (true) {\n   |   ^^^^^^^^^^^^ help: use `loop`\n   |\n   = note: `#[warn(while_true)]` on by default\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp3u_sh8f.rs:19:8\n   |\n19 |     if (v1.is_undefined() || v2.is_undefined()) {\n   |        ^                                      ^\n   |\nhelp: remove these parentheses\n   |\n19 -     if (v1.is_undefined() || v2.is_undefined()) {\n19 +     if v1.is_undefined() || v2.is_undefined() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp3u_sh8f.rs:23:8\n   |\n23 |     if (v1.unwrap() == v2.unwrap()) {\n   |        ^                          ^\n   |\nhelp: remove these parentheses\n   |\n23 -     if (v1.unwrap() == v2.unwrap()) {\n23 +     if v1.unwrap() == v2.unwrap() {\n   | \n\nerror[E0599]: no method named `is_undefined` found for enum `Option` in the current scope\n  --> /tmp/tmpp3u_sh8f.rs:19:12\n   |\n19 |     if (v1.is_undefined() || v2.is_undefined()) {\n   |            ^^^^^^^^^^^^ help: there is an associated function with a similar name: `is_none`\n\nerror[E0599]: no method named `is_undefined` found for enum `Option` in the current scope\n  --> /tmp/tmpp3u_sh8f.rs:19:33\n   |\n19 |     if (v1.is_undefined() || v2.is_undefined()) {\n   |                                 ^^^^^^^^^^^^ help: there is an associated function with a similar name: `is_none`\n\nerror: aborting due to 2 previous errors; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp60ixshf8.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:11:8\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1.data[i] == l2.data[j]) {\n11 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:15:15\n   |\n15 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1.data[i] < l2.data[j]) {\n15 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:12\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:26\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfj4j6zrl.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj4j6zrl.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj4j6zrl.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpfj4j6zrl.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `add` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpfj4j6zrl.rs:14:23\n   |\n14 |       common = common.add(l1[l1_idx]);\n   |                       ^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  let common_idx = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      common_idx = l1_idx;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len, common_idx, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphzrdnnuc.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphzrdnnuc.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphzrdnnuc.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 1 argument but 4 arguments were supplied\n   --> /tmp/tmphzrdnnuc.rs:23:10\n    |\n23  |   return Vec::from(common_len, common_idx, l1_idx, l2_idx);\n    |          ^^^^^^^^^ ----------  ----------  ------  ------ supplied 4 arguments\n    |          |\n    |          expected 1 argument\n    |\nnote: associated function defined here\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut cnt = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmpzc0f2uho.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjj_o1u6z.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjj_o1u6z.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpjj_o1u6z.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn23u00bw.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpn23u00bw.rs:21:10\n   |\n21 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbz092w_q.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpbz092w_q.rs:21:10\n   |\n21 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn23u00bw.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpn23u00bw.rs:21:10\n   |\n21 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len();\n  let m = l2.len();\n  let r = Vec::new(l);\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      r[c] = l1[i];\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  r.len_unsafe(c);\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpc4gv86un.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc4gv86un.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc4gv86un.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpc4gv86un.rs:12:11\n    |\n12  |   let r = Vec::new(l);\n    |           ^^^^^^^^ - supplied 1 argument\n    |           |\n    |           expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `len_unsafe` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpc4gv86un.rs:25:5\n   |\n25 |   r.len_unsafe(c);\n   |     ^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      common.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpm1io_atm.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm1io_atm.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpm1io_atm.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpm1io_atm.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpm1io_atm.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm1io_atm.rs:12:21\n   |\n12 |       common.append(l1[i]);\n   |                     ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmp15w_lj6c.rs:24:7\n   |\n24 |     [&](isize i) { return l1[i] == l2[i]; }\n   |       ^ expected expression\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n  --> /tmp/tmp15w_lj6c.rs:25:4\n   |\n25 |   ));\n   |    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp15w_lj6c.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp15w_lj6c.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp15w_lj6c.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn23u00bw.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpn23u00bw.rs:21:10\n   |\n21 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter = iter1;\n  let mut iter_next = iter2;\n  let mut iter_next_next = iter1;\n  let mut iter_next_next_next = iter2;\n  let mut iter_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmphmzg4d4_.rs:28:30\n   |\n28 |   let mut iter_next_next_next\n   |                              ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmphmzg4d4_.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmpb0gplcb2.rs:22:7\n   |\n22 |     [&](isize i) { return l1[i] == l2[i]; }\n   |       ^ expected expression\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n  --> /tmp/tmpb0gplcb2.rs:23:4\n   |\n23 |   ));\n   |    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb0gplcb2.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb0gplcb2.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb0gplcb2.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n\n  let mut l1_next = true;\n  let mut l2_next = true;\n  let mut common_next = true;\n\n  while (l1_next && l2_next) {\n    if (l1_next && l2_next) {\n      if (l1_iter.next() != l2_iter.next()) {\n        l1_next = false;\n        l2_next = false;\n      }\n    } else {\n      l1_next = false;\n      l2_next = false;\n    }\n  }\n\n  while (l1_next || l2_next) {\n    if (l1_next) {\n      common.append(l1_iter.next());\n      l1_next = l1_iter.next();\n    }\n    if (l2_next) {\n      common.append(l2_iter.next());\n      l2_next = l2_iter.next();\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpql4kcnxr.rs:15:9\n   |\n15 |   while (l1_next && l2_next) {\n   |         ^                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n15 -   while (l1_next && l2_next) {\n15 +   while l1_next && l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpql4kcnxr.rs:16:8\n   |\n16 |     if (l1_next && l2_next) {\n   |        ^                  ^\n   |\nhelp: remove these parentheses\n   |\n16 -     if (l1_next && l2_next) {\n16 +     if l1_next && l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpql4kcnxr.rs:17:10\n   |\n17 |       if (l1_iter.next() != l2_iter.next()) {\n   |          ^                                ^\n   |\nhelp: remove these parentheses\n   |\n17 -       if (l1_iter.next() != l2_iter.next()) {\n17 +       if l1_iter.next() != l2_iter.next() {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpql4kcnxr.rs:27:9\n   |\n27 |   while (l1_next || l2_next) {\n   |         ^                  ^\n   |\nhelp: remove these parentheses\n   |\n27 -   while (l1_next || l2_next) {\n27 +   while l1_next || l2_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpql4kcnxr.rs:28:8\n   |\n28 |     if (l1_next) {\n   |        ^       ^\n   |\nhelp: remove these parentheses\n   |\n28 -     if (l1_next) {\n28 +     if l1_next {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpql4kcnxr.rs:32:8\n   |\n32 |     if (l2_next) {\n   |        ^       ^\n   |\nhelp: remove these parentheses\n   |\n32 -     if (l2_next) {\n32 +     if l2_next {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpql4kcnxr.rs:29:21\n   |\n29 |       common.append(l1_iter.next());\n   |                     ^^^^^^^^^^^^^^ expected `&mut Vec<_>`, found enum `Option`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpql4kc",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter_result = result.iter();\n  let mut iter_l1 = l1.iter();\n  let mut iter_l2 = l2.iter();\n  let mut iter_result_next = iter_result.next();\n  let mut iter_l1_next = iter_l1.next();\n  let mut iter_l2_next = iter_l2.next();\n  let mut iter_result_next_next = iter_result_next.next();\n  let mut iter_l1_next_next = iter_l1_next.next();\n  let mut iter_l2_next_next = iter_l2_next.next();\n  let mut iter_result_next_next_next = iter_result_next_next.next();\n  let mut iter_l1_next_next_next = iter_l1_next_next.next();\n  let mut iter_l2_next_next_next = iter_l2_next_next.next();\n  let mut iter_result_next_next_next_next = iter_result_next_next_next.next();\n  let mut iter_l1_next_next_next_next = iter_l1_next_next_next.next();\n  let mut iter_l2_next_next_next_next = iter_l2_next_next_next.next();\n  let mut iter_result_next_next_next_next_next = iter_result_next_next_next_next.next();\n  let mut iter_l1_next_next_next_next_next = iter_l1_next_next_next_next.next();\n  let mut iter_l2_next_next_next_next_next = iter_l2_next_next_next_next.next();\n\n  while (iter_result_next.has_next()) {\n    let mut val = iter_result_next.next();\n    let mut val_next = iter_result_next_next.next();\n    let mut val_next_next = iter_\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpt5vpk6n9.rs:41:3\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                                                         - unclosed delimiter\n...\n29 |   while (iter_result_next.has_next()) {\n   |                                       - this delimiter might not be properly closed...\n...\n33 | }\n   | - ...as it matches this but it has different indentation\n...\n41 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpt5vpk6n9.rs:32:34\n   |\n32 |     let mut val_next_next = iter_\n   |                                  ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `iter_` in this scope\n  --> /tmp/tmpt5vpk6n9.rs:32:29\n   |\n32 |     let mut val_next_next = iter_\n   |                             ^^^^^ help: a local variable with a similar name exists: `iter1`\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpt5vpk6n9.rs:29:9\n   |\n29 |   while (iter_result_next.has_next()) {\n   |         ^                           ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n29 -   while (iter_result_next.has_next()) {\n29 +   while iter_result_next.has_next() {\n   | \n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpt5vpk6n9.rs:16:52\n   |\n16 |   let mut iter_result_next_next = iter_result_next.next();\n   |                                                    ^^^^ method not found in `Option<&_>`\n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpt5vpk6n9.rs:17:44\n   |\n17 |   let mut iter_l1_next_next = iter_l1_next.next();\n   |                                            ^^^^ method not found in `Option<&isize>`\n\nerror[E0599]: no method named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpt5vpk6n9.rs:18:44\n   |\n18 |   let mut iter_l2_next_next = iter_l2_next.next();\n   |                                            ^^^^ method not found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut c = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return c;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpc9r0sh9k.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc9r0sh9k.rs:12:8\n   |\n12 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1[i] == l2[j]) {\n12 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc9r0sh9k.rs:16:15\n   |\n16 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (l1[i] < l2[j]) {\n16 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpc9r0sh9k.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpc9r0sh9k.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmphpsavch9.rs:12:9\n   |\n12 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (i < l && j < m) {\n12 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphpsavch9.rs:13:8\n   |\n13 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[i] == l2[j]) {\n13 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphpsavch9.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmphpsavch9.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmphpsavch9.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmphpsavch9.rs:23:15\n   |\n23 |   return Vec::from_iter(c, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmphpsavch9.rs:23:38\n   |\n23 |   retu",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp60ixshf8.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:11:8\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1.data[i] == l2.data[j]) {\n11 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:15:15\n   |\n15 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1.data[i] < l2.data[j]) {\n15 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:12\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:26\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = 0;\n  let mut l2_iter = 0;\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_common = 0;\n  let mut l2_common = 0;\n  let mut l1_common_len = 0;\n  let mut l2_common_len = 0;\n  let mut l1_common_iter = 0;\n  let mut l2_common_iter = 0;\n  let mut l1_common_iter_len = 0;\n  let mut l2_common_iter_len = 0;\n  let mut l1_common_iter_iter = 0;\n  let mut l2_common_iter_iter = 0;\n  let mut l1_common_iter_iter_len = 0;\n  let mut l2_common_iter_iter_len = 0;\n  let mut l1_common_iter_iter_iter = 0;\n  let mut l2_common_iter_iter_iter = 0;\n  let mut l1_common_iter_iter_iter_len = 0;\n  let mut l2_common_iter_iter_iter_len = 0;\n  let mut l1_common_iter_iter_iter_iter = 0;\n  let mut l2_common_iter_iter_iter_iter = 0;\n  let mut l1_common_iter_iter_iter_iter_len = 0;\n  let mut l2_common_iter_iter_iter_iter_len = 0;\n  let mut l1_common_iter_iter_iter_iter_iter = 0;\n  let mut l2_common_iter_iter_iter_iter_iter = 0;\n  let mut l1_common_iter_iter_iter_iter_iter_len = 0;\n  let mut l2_common_iter_iter_iter_iter_iter_len = 0;\n  let mut l1_common_iter_iter_iter_iter_iter_iter = 0;\n  let mut l2_common_iter_iter_iter_iter_iter_iter = 0;\n  let mut l1_common_\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpb9i0svs9.rs:37:21\n   |\n37 |   let mut l1_common_\n   |                     ^ help: add `;` here\n38 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpb9i0svs9.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpojcquwmf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpojcquwmf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpojcquwmf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpojcquwmf.rs:11:20\n    |\n11  |   let mut common = Vec::new(0);\n    |                    ^^^^^^^^ - supplied 1 argument\n    |                    |\n    |                    expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpojcquwmf.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpojcquwmf.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8xq68ikm.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8xq68ikm.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8xq68ikm.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp8xq68ikm.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `add` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp8xq68ikm.rs:15:23\n   |\n15 |       common = common.add(l1[l1_idx]);\n   |                       ^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      result.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvj7exh3_.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvj7exh3_.rs:12:8\n   |\n12 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1[i] == l2[j]) {\n12 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvj7exh3_.rs:16:15\n   |\n16 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (l1[i] < l2[j]) {\n16 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpvj7exh3_.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpvj7exh3_.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvj7exh3_.rs:13:21\n   |\n13 |       result.append(l1[i]);\n   |                     ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let cmp = (a, b) => a - b;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let l1_idx_next = 0;\n  let l2_idx_next = 0;\n  let l1_idx_prev = 0;\n  let l2_idx_prev = 0;\n  let l1_idx_min = 0;\n  let l2_idx_min = 0;\n  let l1_idx_max = 0;\n  let l2_idx_max = 0;\n  let l1_idx_min_prev = 0;\n  let l2_idx_min_prev = 0;\n  let l1_idx_max_prev = 0;\n  let l2_idx_max_prev = 0;\n  let l1_idx_min_next = 0;\n  let l2_idx_min_next = 0;\n  let l1_idx_max_next = 0;\n  let l2_idx_max_next = 0;\n  let l1_idx_min_next_prev = 0;\n  let l2_idx_min_next_prev = 0;\n  let l1_idx_max_next_prev = 0;\n  let l2_idx_max_next_prev = 0;\n  let l1_idx_min_next_next = 0;\n  let l2_idx_min_next_next = 0;\n  let l1_idx_max_next_next = 0;\n  let l2_idx_max_next_next = 0;\n  let l1_idx_min_next_next_prev = 0;\n  let l2_idx_min_next_next_prev = 0;\n  let l1_idx_max_next_next_prev = 0;\n  let l2_idx_max_next_next_prev = 0;\n  let l1_idx_min_next_\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `=>`\n --> /tmp/tmpy4uqy9kd.rs:7:20\n  |\n7 |   let cmp = (a, b) => a - b;\n  |                    ^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l = l1.len;\n  let m = l2.len;\n  let r = vec![];\n  while (i < l && j < m) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      r = vec![l1[i]];\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpk4hm8lvh.rs:13:9\n   |\n13 |   while (i < l && j < m) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l && j < m) {\n13 +   while i < l && j < m {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpk4hm8lvh.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:10:14\n   |\n10 |   let l = l1.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   let l = l1.len();\n   |                 ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpk4hm8lvh.rs:11:14\n   |\n11 |   let m = l2.len;\n   |              ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let m = l2.len();\n   |                 ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmp15w_lj6c.rs:24:7\n   |\n24 |     [&](isize i) { return l1[i] == l2[i]; }\n   |       ^ expected expression\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n  --> /tmp/tmp15w_lj6c.rs:25:4\n   |\n25 |   ));\n   |    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp15w_lj6c.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp15w_lj6c.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp15w_lj6c.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut l1_last = false;\n  let mut l2_last = false;\n  let mut common_idx = 0;\n  let mut common_last = false;\n  while (l1_iter.next()) {\n    if (l2_iter.next()) {\n      if (l1_iter.get() == l2_iter.get()) {\n        if (!l1_last && !l2_last) {\n          common.push(l1_iter.get());\n          common_idx += 1;\n        }\n      } else {\n        l1_last = l1_iter.last();\n        l2_last = l2_iter.last();\n        if (!l1_last && !l2_last) {\n          common.push(l1_iter.get());\n          common_idx += 1;\n        }\n      }\n    } else {\n      l1_last = l1_iter.last();\n      if (!l1_last) {\n        common.push(l1_iter.get());\n        common_idx += 1;\n      }\n      l2_last = true;\n    }\n  }\n  while (l2_iter.next()) {\n    if (l1_iter.next()) {\n      if (l1_iter.get() == l2_iter.get()) {\n        if (!l1_last && !l2_last) {\n          common.push(l1_iter.get());\n          common_idx += 1;\n        }\n      } else {\n        l1_last = l1_iter.last();\n        l2_last = l2_iter.last();\n        if (!l1_last && !l2_last) {\n          common.push(l1_iter.get());\n          common_idx += 1;\n        }\n      }\n    } else {\n      l1_last = true;\n\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293473,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfo9fotp3.rs:66:3\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                                                         - unclosed delimiter\n...\n40 |   while (l2_iter.next()) {\n   |                          - unclosed delimiter\n...\n55 |     } else {\n   |            - this delimiter might not be properly closed...\n...\n58 | }\n   | - ...as it matches this but it has different indentation\n...\n66 | }\n   |   ^\n\nerror[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpfo9fotp3.rs:61:21\n   |\n61 |     let candidate = common;\n   |                     ^^^^^^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfo9fotp3.rs:16:9\n   |\n16 |   while (l1_iter.next()) {\n   |         ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n16 -   while (l1_iter.next()) {\n16 +   while l1_iter.next() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfo9fotp3.rs:17:8\n   |\n17 |     if (l2_iter.next()) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n17 -     if (l2_iter.next()) {\n17 +     if l2_iter.next() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfo9fotp3.rs:18:10\n   |\n18 |       if (l1_iter.get() == l2_iter.get()) {\n   |          ^                              ^\n   |\nhelp: remove these parentheses\n   |\n18 -       if (l1_iter.get() == l2_iter.get()) {\n18 +       if l1_iter.get() == l2_iter.get() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfo9fotp3.rs:19:12\n   |\n19 |         if (!l1_last && !l2_last) {\n   |            ^                    ^\n   |\nhelp: remove these parentheses\n   |\n19 -         if (!l1_last && !l2_last) {\n19 +         if !l1_last && !l2_last {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfo9fotp3.rs:26:12\n   |\n26 |         if (!l1_last && !",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpxwsixzht.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxwsixzht.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxwsixzht.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpxwsixzht.rs:11:16\n    |\n11  |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpxwsixzht.rs:15:23\n    |\n15  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpxwsixzht.rs:15:23\n    |\n15  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbz092w_q.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpbz092w_q.rs:21:10\n   |\n21 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = 0;\n  let mut l2_iter = 0;\n  let mut common_iter = 0;\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut common_len = 0;\n  let mut common_vec = Vec::new(0);\n  let mut l1_val = 0;\n  let mut l2_val = 0;\n  let mut common_val = 0;\n  while (l1_iter < l1_len && l2_iter < l2_len) {\n    l1_val = l1[l1_iter];\n    l2_val = l2[l2_iter];\n    if (l1_val < l2_val) {\n      l1_iter += 1;\n    } else if (l1_val > l2_val) {\n      l2_iter += 1;\n    } else {\n      common_val = l1_val;\n      common_iter += 1;\n      l1_iter += 1;\n      l2_iter += 1;\n    }\n  }\n  common_len = common_iter;\n  for (; l1_iter < l1_len; l1_iter += 1) {\n    l1_val = l1[l1_iter];\n    if (l1_val != common_val) {\n      common_vec = common_vec.concat(l1[l1_iter]);\n    }\n  }\n  for (; l2_iter < l2_len; l2_iter += 1) {\n    l2_val = l2[l2_iter];\n    if (l2_val != common_val) {\n      common_vec = common_vec.concat(l2[l2_iter]);\n    }\n  }\n  return common_vec;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmpgyaq_3ws.rs:32:8\n   |\n32 |   for (; l1_iter < l1_len; l1_iter += 1) {\n   |        ^ expected pattern\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgyaq_3ws.rs:17:9\n   |\n17 |   while (l1_iter < l1_len && l2_iter < l2_len) {\n   |         ^                                    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -   while (l1_iter < l1_len && l2_iter < l2_len) {\n17 +   while l1_iter < l1_len && l2_iter < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgyaq_3ws.rs:20:8\n   |\n20 |     if (l1_val < l2_val) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (l1_val < l2_val) {\n20 +     if l1_val < l2_val {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgyaq_3ws.rs:22:15\n   |\n22 |     } else if (l1_val > l2_val) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n22 -     } else if (l1_val > l2_val) {\n22 +     } else if l1_val > l2_val {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpgyaq_3ws.rs:13:24\n    |\n13  |   let mut common_vec = Vec::new(0);\n    |                        ^^^^^^^^ - supplied 1 argument\n    |                        |\n    |                        expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpp1fsz3h1.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp1fsz3h1.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpp1fsz3h1.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpp1fsz3h1.rs:23:10\n   |\n23 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_counts = Vec::with_capacity(l1.len);\n  let mut l2_counts = Vec::with_capacity(l2.len);\n  let mut common = Vec::with_capacity(0);\n\n  for (let i = 0; i < l1.len; i++) {\n    let l1_count = l1_counts.get(i);\n    let l2_count = l2_counts.get(i);\n    if (l1_count == 0 && l2_count == 0) {\n      continue;\n    }\n    if (l1_count == 0 || l2_count == 0) {\n      common = common.concat(l1_counts.slice(i));\n      break;\n    }\n    if (l1[i] == l2[i]) {\n      l1_counts[i] += 1;\n    } else {\n      l1_counts[i] = 1;\n      l2_counts[i] = 1;\n    }\n  }\n\n  for (let i = 0; i < l1.len; i++) {\n    if (l1_counts[i] == 0) {\n      continue;\n    }\n    common = common.concat(l1_counts.slice(i));\n    break;\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpjs6vu35f.rs:11:8\n   |\n11 |   for (let i = 0; i < l1.len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpjs6vu35f.rs:11:12\n   |\n11 |   for (let i = 0; i < l1.len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpjs6vu35f.rs:11:14\n   |\n11 |   for (let i = 0; i < l1.len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpjs6vu35f.rs:11:13\n   |\n11 |   for (let i = 0; i < l1.len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpjs6vu35f.rs:11:14\n   |\n11 |   for (let i = 0; i < l1.len; i++) {\n   |              ^ expected expression\n\nerror[E0616]: field `len` of struct `Vec` is private\n --> /tmp/tmpjs6vu35f.rs:7:45\n  |\n7 |   let mut l1_counts = Vec::with_capacity(l1.len);\n  |                                             ^^^ private field\n  |\nhelp: a method `len` also exists, call it with parentheses\n  |\n7 |   let mut l1_counts = Vec::with_capacity(l1.len());\n  |                                                ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n --> /tmp/tmpjs6vu35f.rs:8:45\n  |\n8 |   let mut l2_counts = Vec::with_capacity(l2.len);\n  |                                             ^^^ private field\n  |\nhelp: a method `len` also exists, call it with parentheses\n  |\n8 |   let mut l2_counts = Vec::with_capacity(l2.len());\n  |                                                ++\n\nerror: aborting due to 7 previous errors\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let l1_iter = l1.iter();\n  let l2_iter = l2.iter();\n  let l1_next = l1_iter.next();\n  let l2_next = l2_iter.next();\n  while (l1_next.is_some() && l2_next.is_some()) {\n    if (l1_next.unwrap() == l2_next.unwrap()) {\n      c += 1;\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    } else if (l1_next.unwrap() < l2_next.unwrap()) {\n      l1_next = l1_iter.next();\n    } else {\n      l2_next = l2_iter.next();\n    }\n  }\n  let r = Vec::new(c);\n  l1_iter = l1.iter();\n  l2_iter = l2.iter();\n  l1_next = l1_iter.next();\n  l2_next = l2_iter.next();\n  while (l1_next.is_some() && l2_next.is_some()) {\n    if (l1_next.unwrap() == l2_next.unwrap()) {\n      r = r.append(l1_next.unwrap());\n      l1_next = l1_iter.next();\n      l2_next = l2_iter.next();\n    } else if (l1_next.unwrap() < l2_next.unwrap()) {\n      l1_next = l1_iter.next();\n    } else {\n      l2_next = l2_iter.next();\n    }\n  }\n  return r;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpraq366ns.rs:12:9\n   |\n12 |   while (l1_next.is_some() && l2_next.is_some()) {\n   |         ^                                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_next.is_some() && l2_next.is_some()) {\n12 +   while l1_next.is_some() && l2_next.is_some() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpraq366ns.rs:13:8\n   |\n13 |     if (l1_next.unwrap() == l2_next.unwrap()) {\n   |        ^                                    ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1_next.unwrap() == l2_next.unwrap()) {\n13 +     if l1_next.unwrap() == l2_next.unwrap() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpraq366ns.rs:17:15\n   |\n17 |     } else if (l1_next.unwrap() < l2_next.unwrap()) {\n   |               ^                                   ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1_next.unwrap() < l2_next.unwrap()) {\n17 +     } else if l1_next.unwrap() < l2_next.unwrap() {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpraq366ns.rs:28:9\n   |\n28 |   while (l1_next.is_some() && l2_next.is_some()) {\n   |         ^                                      ^\n   |\nhelp: remove these parentheses\n   |\n28 -   while (l1_next.is_some() && l2_next.is_some()) {\n28 +   while l1_next.is_some() && l2_next.is_some() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpraq366ns.rs:29:8\n   |\n29 |     if (l1_next.unwrap() == l2_next.unwrap()) {\n   |        ^                                    ^\n   |\nhelp: remove these parentheses\n   |\n29 -     if (l1_next.unwrap() == l2_next.unwrap()) {\n29 +     if l1_next.unwrap() == l2_next.unwrap() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpraq366ns.rs:33:15\n   |\n33 |     } else if (l1_next.unwrap() < l2_next.unwrap()) {\n   |               ^                                   ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let cmp = (a, b) => a - b;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    let a = l1[l1_idx];\n    let b = l2[l2_idx];\n    if (cmp(a, b) < 0) {\n      l1_idx += 1;\n    } else if (cmp(a, b) > 0) {\n      l2_idx += 1;\n    } else {\n      common = common.concat(a);\n      l1_idx += 1;\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `=>`\n --> /tmp/tmpibvctr9j.rs:7:20\n  |\n7 |   let cmp = (a, b) => a - b;\n  |                    ^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      result.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpvj7exh3_.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvj7exh3_.rs:12:8\n   |\n12 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1[i] == l2[j]) {\n12 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpvj7exh3_.rs:16:15\n   |\n16 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (l1[i] < l2[j]) {\n16 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpvj7exh3_.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpvj7exh3_.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvj7exh3_.rs:13:21\n   |\n13 |       result.append(l1[i]);\n   |                     ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let result = Vec::new(l1_len);\n  while (i < l1_len && j < l2_len) {\n    if (l1[i] == l2[j]) {\n      result[c] = l1[i];\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  result.len_unsafe(c);\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8ofnd2pw.rs:13:9\n   |\n13 |   while (i < l1_len && j < l2_len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < l1_len && j < l2_len) {\n13 +   while i < l1_len && j < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8ofnd2pw.rs:14:8\n   |\n14 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[i] == l2[j]) {\n14 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8ofnd2pw.rs:19:15\n   |\n19 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[i] < l2[j]) {\n19 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp8ofnd2pw.rs:12:16\n    |\n12  |   let result = Vec::new(l1_len);\n    |                ^^^^^^^^ ------ supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `len_unsafe` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp8ofnd2pw.rs:25:10\n   |\n25 |   result.len_unsafe(c);\n   |          ^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut cnt = 0;\n  let mut res = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      cnt += 1;\n      res.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  if (cnt == 0) {\n    return Vec::new();\n  }\n  return res;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpru075t_q.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpru075t_q.rs:12:8\n   |\n12 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1[i] == l2[j]) {\n12 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpru075t_q.rs:17:15\n   |\n17 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i] < l2[j]) {\n17 +     } else if l1[i] < l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpru075t_q.rs:23:6\n   |\n23 |   if (cnt == 0) {\n   |      ^        ^\n   |\nhelp: remove these parentheses\n   |\n23 -   if (cnt == 0) {\n23 +   if cnt == 0 {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpru075t_q.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpru075t_q.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpru075t_q.rs:14:18\n   |\n14 |       res.append(l1[i]);\n   |                  ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\ner",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpki2opgua.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpki2opgua.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpki2opgua.rs:15:23\n    |\n15  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp60ixshf8.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:11:8\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1.data[i] == l2.data[j]) {\n11 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:15:15\n   |\n15 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1.data[i] < l2.data[j]) {\n15 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:12\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:26\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpzf57zw06.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpzf57zw06.rs:21:15\n   |\n21 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut r = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmplonsj2st.rs:70:16\n   |\n70 |   let mut s = 0\n   |                ^ help: add `;` here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmplonsj2st.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_counts = Vec::new();\n  let mut l2_counts = Vec::new();\n  let mut common = Vec::new();\n  let mut l1_index = 0;\n  let mut l2_index = 0;\n  let mut l1_count = 0;\n  let mut l2_count = 0;\n  let mut l1_common = 0;\n  let mut l2_common = 0;\n\n  for (let i = 0; i < l1.len; i++) {\n    if (l1_counts.contains(l1[i])) {\n      l1_counts[l1[i]] += 1;\n    } else {\n      l1_counts.push(l1[i]);\n      l1_count += 1;\n    }\n  }\n\n  for (let i = 0; i < l2.len; i++) {\n    if (l2_counts.contains(l2[i])) {\n      l2_counts[l2[i]] += 1;\n    } else {\n      l2_counts.push(l2[i]);\n      l2_count += 1;\n    }\n  }\n\n  for (let i = 0; i < l1_counts.len; i++) {\n    if (l1_counts[i] == l2_counts[i]) {\n      common.push(l1_counts[i]);\n      l1_common += 1;\n      l2_common += 1;\n    }\n  }\n\n  for (let i = 0; i < l1_counts.len; i++) {\n    if (l1_counts[i] > l2_counts[i]) {\n      l1_count -= l1_counts[i];\n      l1_index += 1;\n    } else if (l1_counts[i] < l2_counts[i]) {\n      l2_count -= l2_counts[i];\n      l2_index += 1;\n    }\n  }\n\n  for (let i = 0; i < l1_counts.len; i++) {\n    if\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbtq4cz9k.rs:63:3\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                                                         - unclosed delimiter\n...\n53 |   for (let i = 0; i < l1_counts.len; i++) {\n   |                                           - this delimiter might not be properly closed...\n54 |     if\n55 | }\n   | - ...as it matches this but it has different indentation\n...\n63 | }\n   |   ^\n\nerror: expected identifier, found keyword `let`\n  --> /tmp/tmpbtq4cz9k.rs:17:8\n   |\n17 |   for (let i = 0; i < l1.len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpbtq4cz9k.rs:17:12\n   |\n17 |   for (let i = 0; i < l1.len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpbtq4cz9k.rs:17:14\n   |\n17 |   for (let i = 0; i < l1.len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpbtq4cz9k.rs:17:13\n   |\n17 |   for (let i = 0; i < l1.len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpbtq4cz9k.rs:17:14\n   |\n17 |   for (let i = 0; i < l1.len; i++) {\n   |              ^ expected expression\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbs_3ojld.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbs_3ojld.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:11:16\n    |\n11  |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbs_3ojld.rs:14:23\n    |\n14  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut i = 0;\n  let mut j = 0;\n  let mut common_len = 0;\n  let mut common_idx = 0;\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut l1_idx_next = 0;\n  let mut l2_idx_next = 0;\n  let mut l1_idx_prev = 0;\n  let mut l2_idx_prev = 0;\n  let mut l1_idx_prev_next = 0;\n  let mut l2_idx_prev_next = 0;\n  let mut l1_idx_next_next = 0;\n  let mut l2_idx_next_next = 0;\n  let mut l1_idx_prev_prev = 0;\n  let mut l2_idx_prev_prev = 0;\n  let mut l1_idx_next_prev = 0;\n  let mut l2_idx_next_prev = 0;\n  let mut l1_idx_prev_prev_next = 0;\n  let mut l2_idx_prev_prev_next = 0;\n  let mut l1_idx_next_prev_next = 0;\n  let mut l2_idx_next_prev_next = 0;\n  let mut l1_idx_prev_prev_prev = 0;\n  let mut l2_idx_prev_prev_prev = 0;\n  let mut l1_idx_next_prev_prev = 0;\n  let mut l2_idx_next_prev_prev = 0;\n  let mut l1_idx_prev_prev_prev_next = 0;\n  let mut l2_idx_prev_prev_prev_next = 0;\n  let mut l1_idx_next_prev_prev_prev = 0;\n  let mut l2_idx_next_prev_prev_prev = 0;\n  let mut l1_idx_prev_prev_prev_\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwqp5c40k.rs:39:33\n   |\n39 |   let mut l1_idx_prev_prev_prev_\n   |                                 ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpwqp5c40k.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_while(\n    [&](isize i) { return l1[i] == l2[i]; }\n  ));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected expression, found `]`\n  --> /tmp/tmpb0gplcb2.rs:22:7\n   |\n22 |     [&](isize i) { return l1[i] == l2[i]; }\n   |       ^ expected expression\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n  --> /tmp/tmpb0gplcb2.rs:23:4\n   |\n23 |   ));\n   |    ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpb0gplcb2.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb0gplcb2.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpb0gplcb2.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpzf57zw06.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpzf57zw06.rs:21:15\n   |\n21 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let cmp = (a, b) => a - b;\n  let l1_sorted = l1.sort(cmp);\n  let l2_sorted = l2.sort(cmp);\n  let i = 0;\n  let j = 0;\n  let common = Vec::new();\n  while (i < l1_sorted.len && j < l2_sorted.len) {\n    if (l1_sorted.data[i] == l2_sorted.data[j]) {\n      common = common.concat(l1_sorted.data[i]);\n      i += 1;\n      j += 1;\n    } else if (l1_sorted.data[i] < l2_sorted.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `=>`\n --> /tmp/tmp6dc6tz2_.rs:7:20\n  |\n7 |   let cmp = (a, b) => a - b;\n  |                    ^^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut c = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c.append(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return c;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgklrcvc_.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgklrcvc_.rs:12:8\n   |\n12 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1[i] == l2[j]) {\n12 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgklrcvc_.rs:16:15\n   |\n16 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (l1[i] < l2[j]) {\n16 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpgklrcvc_.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpgklrcvc_.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgklrcvc_.rs:13:16\n   |\n13 |       c.append(l1[i]);\n   |                ^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut iter1 = l1.iter();\n  let mut iter2 = l2.iter();\n  let mut iter = iter1;\n  let mut iter_next = iter2;\n  let mut iter_next_next = iter1;\n  let mut iter_next_next_next = iter2;\n  let mut iter_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter1;\n  let mut iter_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next = iter2;\n  let mut iter_next_next_next\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmphmzg4d4_.rs:28:30\n   |\n28 |   let mut iter_next_next_next\n   |                              ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmphmzg4d4_.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut c = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpocb8wqre.rs:70:16\n   |\n70 |   let mut t = 0\n   |                ^ help: add `;` here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpocb8wqre.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2nispvvf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2nispvvf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror[E0599]: no method named `collect_to_vec` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmp2nispvvf.rs:23:47\n   |\n23 |   return Vec::from_iter(common_len, l1.iter().collect_to_vec());\n   |                                               ^^^^^^^^^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut common_len = 0;\n  let mut i1 = 0;\n  let mut i2 = 0;\n  let mut j1 = 0;\n  let mut j2 = 0;\n  while (i1 < l1_len && i2 < l2_len) {\n    if (l1[i1] < l2[i2]) {\n      i1 += 1;\n    } else if (l1[i1] > l2[i2]) {\n      i2 += 1;\n    } else {\n      common_len += 1;\n      i1 += 1;\n      i2 += 1;\n    }\n  }\n  if (i1 < l1_len) {\n    j1 = i1;\n    while (j1 < l1_len) {\n      if (l1[j1] < l2[i2]) {\n        j1 += 1;\n      } else {\n        break;\n      }\n    }\n    l1_len = j1 - i1;\n  } else if (i2 < l2_len) {\n    j2 = i2;\n    while (j2 < l2_len) {\n      if (l1[i1] < l2[j2]) {\n        j2 += 1;\n      } else {\n        break;\n      }\n    }\n    l2_len = j2 - i2;\n  }\n  let mut common = Vec::new(common_len);\n  let mut k = 0;\n  for (; k < common_len; k += 1) {\n    common[k] = l1[i1];\n    i1 += 1;\n    i2 += 1;\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmp6h0dnelh.rs:48:8\n   |\n48 |   for (; k < common_len; k += 1) {\n   |        ^ expected pattern\n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6h0dnelh.rs:14:9\n   |\n14 |   while (i1 < l1_len && i2 < l2_len) {\n   |         ^                          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n14 -   while (i1 < l1_len && i2 < l2_len) {\n14 +   while i1 < l1_len && i2 < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6h0dnelh.rs:15:8\n   |\n15 |     if (l1[i1] < l2[i2]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n15 -     if (l1[i1] < l2[i2]) {\n15 +     if l1[i1] < l2[i2] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6h0dnelh.rs:17:15\n   |\n17 |     } else if (l1[i1] > l2[i2]) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[i1] > l2[i2]) {\n17 +     } else if l1[i1] > l2[i2] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6h0dnelh.rs:25:6\n   |\n25 |   if (i1 < l1_len) {\n   |      ^           ^\n   |\nhelp: remove these parentheses\n   |\n25 -   if (i1 < l1_len) {\n25 +   if i1 < l1_len {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6h0dnelh.rs:27:11\n   |\n27 |     while (j1 < l1_len) {\n   |           ^           ^\n   |\nhelp: remove these parentheses\n   |\n27 -     while (j1 < l1_len) {\n27 +     while j1 < l1_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6h0dnelh.rs:28:10\n   |\n28 |       if (l1[j1] < l2[i2]) {\n   |          ^               ^\n   |\nhelp: remove these parentheses\n   |\n28 -       if (l1[j1] < l2[i2]) {\n28 +       if l1[j1] < l2[i2] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6h0dnelh.rs:35:13\n   |\n35 |   } else if (i2 < l2_len) {\n   |             ^           ^\n   |\nhelp: remove these parentheses\n   |\n35 -   } else i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp6tg1_wui.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp6tg1_wui.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmp6tg1_wui.rs:23:15\n   |\n23 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let l1_i = 0;\n  let l2_i = 0;\n  while (l1_i < l1.len && l2_i < l2.len) {\n    if (l1[l1_i] == l2[l2_i]) {\n      c += 1;\n      l1_i += 1;\n      l2_i += 1;\n    } else if (l1[l1_i] < l2[l2_i]) {\n      l1_i += 1;\n    } else {\n      l2_i += 1;\n    }\n  }\n  return Vec::from_iter(c, l1_i);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyu7t_c0r.rs:10:9\n   |\n10 |   while (l1_i < l1.len && l2_i < l2.len) {\n   |         ^                              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (l1_i < l1.len && l2_i < l2.len) {\n10 +   while l1_i < l1.len && l2_i < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyu7t_c0r.rs:11:8\n   |\n11 |     if (l1[l1_i] == l2[l2_i]) {\n   |        ^                    ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[l1_i] == l2[l2_i]) {\n11 +     if l1[l1_i] == l2[l2_i] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyu7t_c0r.rs:15:15\n   |\n15 |     } else if (l1[l1_i] < l2[l2_i]) {\n   |               ^                   ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_i] < l2[l2_i]) {\n15 +     } else if l1[l1_i] < l2[l2_i] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpyu7t_c0r.rs:10:20\n   |\n10 |   while (l1_i < l1.len && l2_i < l2.len) {\n   |                    ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (l1_i < l1.len() && l2_i < l2.len) {\n   |                       ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpyu7t_c0r.rs:10:37\n   |\n10 |   while (l1_i < l1.len && l2_i < l2.len) {\n   |                                     ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (l1_i < l1.len && l2_i < l2.len()) {\n   |                                        ++\n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpyu7t_c0r.rs:21:15\n   |\n21 |   return Vec::from_iter(c, l1_i);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is impleme",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from(common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpn23u00bw.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpn23u00bw.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpn23u00bw.rs:21:10\n   |\n21 |   return Vec::from(common_len);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8xq68ikm.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8xq68ikm.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8xq68ikm.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp8xq68ikm.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `add` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp8xq68ikm.rs:15:23\n   |\n15 |       common = common.add(l1[l1_idx]);\n   |                       ^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] < l2[j]) {\n      i += 1;\n    } else if (l1[i] > l2[j]) {\n      j += 1;\n    } else {\n      c += 1;\n      i += 1;\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyam5f82i.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyam5f82i.rs:12:8\n   |\n12 |     if (l1[i] < l2[j]) {\n   |        ^             ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1[i] < l2[j]) {\n12 +     if l1[i] < l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyam5f82i.rs:14:15\n   |\n14 |     } else if (l1[i] > l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n14 -     } else if (l1[i] > l2[j]) {\n14 +     } else if l1[i] > l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpyam5f82i.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpyam5f82i.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpyam5f82i.rs:22:10\n   |\n22 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<Bina",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpzf57zw06.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpzf57zw06.rs:21:15\n   |\n21 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from(c);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbz092w_q.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:11:8\n   |\n11 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1[i] == l2[j]) {\n11 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbz092w_q.rs:15:15\n   |\n15 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[i] < l2[j]) {\n15 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbz092w_q.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmpbz092w_q.rs:21:10\n   |\n21 |   return Vec::from(c);\n   |          ^^^^^^^^^ the trait `From<{integer}>` is not implemented for `Vec<_, _>`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfj4j6zrl.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj4j6zrl.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfj4j6zrl.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpfj4j6zrl.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `add` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpfj4j6zrl.rs:14:23\n   |\n14 |       common = common.add(l1[l1_idx]);\n   |                       ^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp60ixshf8.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:11:8\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1.data[i] == l2.data[j]) {\n11 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:15:15\n   |\n15 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1.data[i] < l2.data[j]) {\n15 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:12\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:26\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_iter = l1.iter();\n  let mut l2_iter = l2.iter();\n  let mut common = Vec::new();\n  let mut l1_next = false;\n  let mut l2_next = false;\n  let mut common_next = false;\n  let mut l1_done = false;\n  let mut l2_done = false;\n  let mut common_done = false;\n  let mut l1_iter_done = false;\n  let mut l2_iter_done = false;\n  let mut common_iter_done = false;\n  let mut l1_iter_next = false;\n  let mut l2_iter_next = false;\n  let mut common_iter_next = false;\n  let mut l1_iter_next_done = false;\n  let mut l2_iter_next_done = false;\n  let mut common_iter_next_done = false;\n  let mut l1_iter_next_next = false;\n  let mut l2_iter_next_next = false;\n  let mut common_iter_next_next = false;\n  let mut l1_iter_next_next_done = false;\n  let mut l2_iter_next_next_done = false;\n  let mut common_iter_next_next_done = false;\n  let mut l1_iter_next_next_next = false;\n  let mut l2_iter_next_next_next = false;\n  let mut common_iter_next_next_next = false;\n  let mut l1_iter_next_next_next_done = false;\n  let mut l2_iter_next_next_next_done = false;\n  let mut common_iter_next_next_next_done = false;\n  let mut l1_iter_next_next_next_next = false;\n  let mut l2_iter_next_next_next_next = false;\n  let mut common_iter_next_next_next_next = false;\n  let mut l1_iter_next_next_next_next_done = false;\n  let mut l2_iter_next_next_next\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp4h0hpnr6.rs:41:33\n   |\n41 |   let mut l2_iter_next_next_next\n   |                                 ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp4h0hpnr6.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut l1_len = l1.len();\n  let mut l2_len = l2.len();\n  let mut l1_idx = 0;\n  let mut l2_idx = 0;\n  let mut common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpojcquwmf.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpojcquwmf.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpojcquwmf.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpojcquwmf.rs:11:20\n    |\n11  |   let mut common = Vec::new(0);\n    |                    ^^^^^^^^ - supplied 1 argument\n    |                    |\n    |                    expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpojcquwmf.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpojcquwmf.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<s",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let result = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      result = result.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpxwsixzht.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxwsixzht.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpxwsixzht.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpxwsixzht.rs:11:16\n    |\n11  |   let result = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpxwsixzht.rs:15:23\n    |\n15  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpxwsixzht.rs:15:23\n    |\n15  |       result = result.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1[i] == l2[j]) {\n      result.push(l1[i]);\n      i += 1;\n      j += 1;\n    } else if (l1[i] < l2[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpagvpzu5o.rs:11:9\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n11 -   while (i < l1.len && j < l2.len) {\n11 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpagvpzu5o.rs:12:8\n   |\n12 |     if (l1[i] == l2[j]) {\n   |        ^              ^\n   |\nhelp: remove these parentheses\n   |\n12 -     if (l1[i] == l2[j]) {\n12 +     if l1[i] == l2[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpagvpzu5o.rs:16:15\n   |\n16 |     } else if (l1[i] < l2[j]) {\n   |               ^             ^\n   |\nhelp: remove these parentheses\n   |\n16 -     } else if (l1[i] < l2[j]) {\n16 +     } else if l1[i] < l2[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpagvpzu5o.rs:11:17\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpagvpzu5o.rs:11:31\n   |\n11 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_idx = l1_idx;\n      common_len = 1;\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return l1.slice(common_idx, common_idx + common_len);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8nms8s4t.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nms8s4t.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8nms8s4t.rs:19:15\n   |\n19 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n19 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n19 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp8nms8s4t.rs:25:13\n   |\n25 |   return l1.slice(common_idx, common_idx + common_len);\n   |             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n25 |   return l1.as_slice(common_idx, common_idx + common_len);\n   |             ~~~~~~~~\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.add(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8xq68ikm.rs:13:9\n   |\n13 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n13 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8xq68ikm.rs:14:8\n   |\n14 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (l1[l1_idx] == l2[l2_idx]) {\n14 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8xq68ikm.rs:18:15\n   |\n18 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n18 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp8xq68ikm.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `add` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp8xq68ikm.rs:15:23\n   |\n15 |       common = common.add(l1[l1_idx]);\n   |                       ^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common_len = 0;\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common_len += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return Vec::from_iter(common_len, l1_idx, l2_idx);\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpzf57zw06.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpzf57zw06.rs:15:15\n   |\n15 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n15 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0599]: no function or associated item named `from_iter` found for struct `Vec<_, _>` in the current scope\n  --> /tmp/tmpzf57zw06.rs:21:15\n   |\n21 |   return Vec::from_iter(common_len, l1_idx, l2_idx);\n   |               ^^^^^^^^^ function or associated item not found in `Vec<_, _>`\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n   |\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let c = 0;\n  let i = 0;\n  let j = 0;\n  while (i < l1.len && j < l2.len) {\n    if (l1.data[i] == l2.data[j]) {\n      c += 1;\n      i += 1;\n      j += 1;\n    } else if (l1.data[i] < l2.data[j]) {\n      i += 1;\n    } else {\n      j += 1;\n    }\n  }\n  return Vec::from_iter(c, l1.data.slice(i, l1.len));\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp60ixshf8.rs:10:9\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |         ^                        ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n10 -   while (i < l1.len && j < l2.len) {\n10 +   while i < l1.len && j < l2.len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:11:8\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n11 -     if (l1.data[i] == l2.data[j]) {\n11 +     if l1.data[i] == l2.data[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp60ixshf8.rs:15:15\n   |\n15 |     } else if (l1.data[i] < l2.data[j]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n15 -     } else if (l1.data[i] < l2.data[j]) {\n15 +     } else if l1.data[i] < l2.data[j] {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:17\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len() && j < l2.len) {\n   |                    ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmp60ixshf8.rs:10:31\n   |\n10 |   while (i < l1.len && j < l2.len) {\n   |                               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n10 |   while (i < l1.len && j < l2.len()) {\n   |                                  ++\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:12\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |            ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8.rs:11:26\n   |\n11 |     if (l1.data[i] == l2.data[j]) {\n   |                          ^^^^ unknown field\n\nerror[E0609]: no field `data` on type `Vec<isize>`\n  --> /tmp/tmp60ixshf8",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let mut common = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmppc8zseu2.rs:70:16\n   |\n70 |   let mut s = 0\n   |                ^ help: add `;` here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmppc8zseu2.rs:6:46\n  |\n6 | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------                                    ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return sorted unique common elements for two vectors.\n/// >>> common(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n/// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  let l1_len = l1.len();\n  let l2_len = l2.len();\n  let l1_idx = 0;\n  let l2_idx = 0;\n  let common = Vec::new(0);\n  while (l1_idx < l1_len && l2_idx < l2_len) {\n    if (l1[l1_idx] == l2[l2_idx]) {\n      common = common.concat(l1[l1_idx]);\n      l1_idx += 1;\n      l2_idx += 1;\n    } else if (l1[l1_idx] < l2[l2_idx]) {\n      l1_idx += 1;\n    } else {\n      l2_idx += 1;\n    }\n  }\n  return common;\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n",
      "timestamp": 1664293472,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp24784z0x.rs:12:9\n   |\n12 |   while (l1_idx < l1_len && l2_idx < l2_len) {\n   |         ^                                  ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -   while (l1_idx < l1_len && l2_idx < l2_len) {\n12 +   while l1_idx < l1_len && l2_idx < l2_len {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:13:8\n   |\n13 |     if (l1[l1_idx] == l2[l2_idx]) {\n   |        ^                        ^\n   |\nhelp: remove these parentheses\n   |\n13 -     if (l1[l1_idx] == l2[l2_idx]) {\n13 +     if l1[l1_idx] == l2[l2_idx] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp24784z0x.rs:17:15\n   |\n17 |     } else if (l1[l1_idx] < l2[l2_idx]) {\n   |               ^                       ^\n   |\nhelp: remove these parentheses\n   |\n17 -     } else if (l1[l1_idx] < l2[l2_idx]) {\n17 +     } else if l1[l1_idx] < l2[l2_idx] {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:11:16\n    |\n11  |   let common = Vec::new(0);\n    |                ^^^^^^^^ - supplied 1 argument\n    |                |\n    |                expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp24784z0x.rs:14:23\n    |\n14  |       common = common.concat(l1[l1_idx]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n           ",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}