{
  "name": "HumanEval_9_rolling_max",
  "language": "rs",
  "prompt": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value);\n      max_value = numbers[i];\n      max_index = i;\n    } else {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpng9fmacz.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpng9fmacz.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpng9fmacz.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpng9fmacz.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpng9fmacz.rs:17:14\n   |\n17 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result = result.append(max_value);\n    } else {\n      result = result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpbu96p8eo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpbu96p8eo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbu96p8eo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpbu96p8eo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbu96p8eo.rs:17:30\n   |\n17 |       result = result.append(max_value);\n   |                              ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  let max_value_index = 0;\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_value_index = i;\n    }\n    if i == max_index {\n      result.push(max_value);\n      max_value = numbers[i];\n      max_value_index = i;\n    }\n    max_index = i;\n  }\n  result.push(max_value);\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp8i3hw7xt.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp8i3hw7xt.rs:12:19\n   |\n12 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8i3hw7xt.rs:13:25\n   |\n8  |   let max_value_index = 0;\n   |                         - expected due to this value\n...\n13 |       max_value_index = i;\n   |                         ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_value_index = *i;\n   |                         +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp8i3hw7xt.rs:15:10\n   |\n15 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp8i3hw7xt.rs:17:19\n   |\n17 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `Slic",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_index_so_far_so_far = 0;\n  let max_so_far_index_so_far_so_far_so_far = 0;\n\n  for i in numbers.iter() {\n    if (i > max_so_far) {\n      max_so_far = i;\n      max_so_far_index = i;\n      max_so_far_index_so_far = max_so_far_index_so_far_so_far;\n      max_so_far_index_so_far_so_far = max_so_far_index_so_far_so_far_so_far;\n    } else if (i == max_so_far) {\n      max_so_far_index_so_far_so_far = max_so_far_index_so_far_so_far_so_far;\n      max_so_far_index_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far;\n    }\n  }\n\n  return Vec::from([max_so_far, max_so_far_index, max_so_far_index_so_far, max_so_far_index_so_far_so_far, max_so_far_index_so_far_so_far_so_far]);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find value `max_so_far_index_so_far_so_far_so_far_so_far` in this scope\n  --> /tmp/tmpwe1eauzy.rs:20:47\n   |\n20 |       max_so_far_index_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far;\n   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `max_so_far_index_so_far_so_far_so_far`\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwe1eauzy.rs:13:8\n   |\n13 |     if (i > max_so_far) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -     if (i > max_so_far) {\n13 +     if i > max_so_far {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwe1eauzy.rs:18:15\n   |\n18 |     } else if (i == max_so_far) {\n   |               ^               ^\n   |\nhelp: remove these parentheses\n   |\n18 -     } else if (i == max_so_far) {\n18 +     } else if i == max_so_far {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe1eauzy.rs:13:13\n   |\n13 |     if (i > max_so_far) {\n   |             ^^^^^^^^^^\n   |             |\n   |             expected `&isize`, found `isize`\n   |             help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe1eauzy.rs:14:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n14 |       max_so_far = i;\n   |                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwe1eauzy.rs:15:26\n   |\n7  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n15 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0277]: can't compare `&isi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_index_so_far_index = 0;\n  for i in numbers.iter() {\n    let current_max = max_so_far;\n    let current_max_index = max_so_far_index;\n    let current_max_index_so_far = max_so_far_index_so_far;\n    let current_max_index_so_far_index = max_so_far_index_so_far_index;\n    max_so_far = numbers[i];\n    max_so_far_index = i;\n    max_so_far_index_so_far = current_max_index_so_far;\n    max_so_far_index_so_far_index = current_max_index_so_far_index;\n  }\n  return Vec::from([max_so_far, max_so_far_index, max_so_far_index_so_far, max_so_far_index_so_far_index]);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpo6rkxz2u.rs:15:18\n   |\n15 |     max_so_far = numbers[i];\n   |                  ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo6rkxz2u.rs:16:24\n   |\n7  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n16 |     max_so_far_index = i;\n   |                        ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |     max_so_far_index = *i;\n   |                        +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  let max_count = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_count = 1;\n    } else if numbers[i] == max_value {\n      max_count += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpoeuq2ksl.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpoeuq2ksl.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoeuq2ksl.rs:12:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpoeuq2ksl.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpoeuq2ksl.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_value = numbers[0];\n  let max_index = 0;\n  let max_length = 1;\n  for i in numbers.iter() {\n    if i > max_value {\n      max_value = i;\n      max_index = i;\n      max_length = 1;\n    } else if i == max_value {\n      max_length += 1;\n    }\n  }\n  let max_vec = Vec::new(max_length);\n  for i in numbers.iter() {\n    if i == max_value {\n      max_vec.store(max_length - 1, max_index);\n    }\n  }\n  return max_vec;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpuko1vs7z.rs:10:12\n   |\n10 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuko1vs7z.rs:11:19\n   |\n6  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n11 |       max_value = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuko1vs7z.rs:12:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpuko1vs7z.rs:14:17\n   |\n14 |     } else if i == max_value {\n   |                 ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpuko1vs7z.rs:18:17\n    |\n18  |   let max_vec = Vec::new(max_length);\n    |                 ^^^^^^^^ ---------- supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpuko1vs7z.rs:20:10\n   |\n20 |     if i == max_value {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  let max_length = 0;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_length = 1;\n    } else if numbers[i] == max_value {\n      max_length += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp2e1cqkws.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp2e1cqkws.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2e1cqkws.rs:12:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp2e1cqkws.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp2e1cqkws.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpnclb6l4y.rs:40:14\n   |\n40 |   let max_so_\n   |              ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpnclb6l4y.rs:5:40\n  |\n5 | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  |    -----------                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpylzqam63.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpylzqam63.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpylzqam63.rs:11:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpylzqam63.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpylzqam63.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpz58q93fi.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpz58q93fi.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_value = numbers[0];\n  let max_index = 0;\n  let max_count = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_count = 1;\n    } else if numbers[i] == max_value {\n      max_count += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14yhd0hh.rs:12:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp14yhd0hh.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let max_vec = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      max_vec = max_vec.append(max_value)\n    } else {\n      max_vec = max_vec.append(numbers[i])\n    }\n  }\n  return max_vec\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp06sb3wqt.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmp06sb3wqt.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp06sb3wqt.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp06sb3wqt.rs:14:27\n   |\n14 |   let max_vec = Vec::new()\n   |                           ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp06sb3wqt.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp06sb3wqt.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp06sb3wqt.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider deref",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_count = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_count = 1\n    } else if numbers[i] == max_value {\n      max_count += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpovxv1l0d.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpovxv1l0d.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_count = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpovxv1l0d.rs:8:20\n   |\n8  |   let max_count = 1\n   |                    ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpovxv1l0d.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_count`\n  --> /tmp/tmpovxv1l0d.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_count = 1\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpovxv1l0d.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpovxv1l0d.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpovxv1l0d.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n    } else {\n      result.push_back(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmphqlek35_.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmphqlek35_.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphqlek35_.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphqlek35_.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmphqlek35_.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmphqlek35_.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqlek35_.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_count = 1;\n  for i in numbers.len() - 1 {\n    if numbers[i] > max_so_far {\n      max_so_far = numbers[i];\n      max_so_far_index = i;\n      max_so_far_count = 1;\n    } else if numbers[i] == max_so_far {\n      max_so_far_count += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.len() - max_so_far_count {\n    result.append(max_so_far);\n  }\n  result.append(max_so_far);\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: `usize` is not an iterator\n --> /tmp/tmp94v_9d3i.rs:9:12\n  |\n9 |   for i in numbers.len() - 1 {\n  |            ^^^^^^^^^^^^^^^^^ `usize` is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for `usize`\n  = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n  = note: required because of the requirements on the impl of `IntoIterator` for `usize`\n\nerror[E0277]: `usize` is not an iterator\n  --> /tmp/tmp94v_9d3i.rs:19:12\n   |\n19 |   for i in numbers.len() - max_so_far_count {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `usize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `usize`\n   = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n   = note: required because of the requirements on the impl of `IntoIterator` for `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp94v_9d3i.rs:20:19\n   |\n20 |     result.append(max_so_far);\n   |                   ^^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp94v_9d3i.rs:22:17\n   |\n22 |   result.append(max_so_far);\n   |                 ^^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  let mut max_index_set = false;\n  let mut max_value_set = false;\n  let mut max_index_changed = false;\n  let mut max_value_changed = false;\n  let mut max_index_changed_set = false;\n  let mut max_value_changed_set = false;\n  let mut max_index_changed_set_set = false;\n  let mut max_value_changed_set_set = false;\n  let mut max_index_changed_set_set_set = false;\n  let mut max_value_changed_set_set_set = false;\n  let mut max_index_changed_set_set_set_set = false;\n  let mut max_value_changed_set_set_set_set = false;\n  let mut max_index_changed_set_set_set_set_set = false;\n  let mut max_value_changed_set_set_set_set_set = false;\n  let mut max_index_changed_set_set_set_set_set_set = false;\n  let mut max_value_changed_set_set_set_set_set_set = false;\n  let mut max_index_changed_set_set_set_set_set_set_set = false;\n  let mut max_value_changed_set_set_set_set_set_set_set = false;\n  let mut max_index_changed_set_set_set_set_set_set_set_set = false;\n  let mut max_value_changed_set_set_set_set_set_set_set_set = false;\n  let mut max_index_changed_set_set_set_set_set_set_set_set_set = false;\n  let mut max_value_changed_set_set_set_set_set_set_set_set_set = false;\n  let mut max_index_changed_set_set_set_set_set_set_set_set_set_set = false;\n  let mut max_value_changed_set_set_set\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmph9x6usjh.rs:31:40\n   |\n31 |   let mut max_value_changed_set_set_set\n   |                                        ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmph9x6usjh.rs:5:40\n  |\n5 | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  |    -----------                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_index_so_far_so_far = 0;\n  for i in numbers.iter() {\n    let current_max = max_so_far;\n    let current_max_index = max_so_far_index;\n    let current_max_index_so_far = max_so_far_index_so_far;\n    let current_max_index_so_far_so_far = max_so_far_index_so_far_so_far;\n    max_so_far = i;\n    max_so_far_index = i;\n    max_so_far_index_so_far = i;\n    max_so_far_index_so_far_so_far = i;\n    if current_max < i {\n      max_so_far_index_so_far_so_far = current_max_index_so_far_so_far;\n      max_so_far_index_so_far = current_max_index_so_far;\n      max_so_far_index = current_max_index;\n      max_so_far = current_max;\n    }\n  }\n  return Vec::from([max_so_far, max_so_far_index, max_so_far_index_so_far, max_so_far_index_so_far_so_far]);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpin9jod3z.rs:15:18\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n15 |     max_so_far = i;\n   |                  ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |     max_so_far = *i;\n   |                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin9jod3z.rs:16:24\n   |\n7  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n16 |     max_so_far_index = i;\n   |                        ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |     max_so_far_index = *i;\n   |                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin9jod3z.rs:17:31\n   |\n8  |   let max_so_far_index_so_far = 0;\n   |                                 - expected due to this value\n...\n17 |     max_so_far_index_so_far = i;\n   |                               ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |     max_so_far_index_so_far = *i;\n   |                               +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin9jod3z.rs:18:38\n   |\n9  |   let max_so_far_index_so_far_so_far = 0;\n   |                                        - expected due to this value\n...\n18 |     max_so_far_index_so_far_so_far = i;\n   |                                      ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |     max_so_far_index_so_far_so_far = *i;\n   |                                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpin9jod3z.rs:19:22\n   |\n19 |     if current_max < i {\n   |                      ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |     if current_max < *i {\n   |                      +\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  let mut max_value_index = 0;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_value_index = i;\n      max_index = i;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpelo1yok_.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpelo1yok_.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpelo1yok_.rs:12:25\n   |\n8  |   let mut max_value_index = 0;\n   |                             - expected due to this value\n...\n12 |       max_value_index = i;\n   |                         ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_value_index = *i;\n   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpelo1yok_.rs:13:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n13 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpelo1yok_.rs:18:10\n   |\n18 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_index_so_far_so_far = 0;\n  let max_so_far_index_so_far_so_far_so_far = 0;\n  for i in numbers.iter() {\n    if (i > max_so_far) {\n      max_so_far = i;\n      max_so_far_index = i;\n      max_so_far_index_so_far = max_so_far_index_so_far_so_far;\n      max_so_far_index_so_far_so_far = max_so_far_index_so_far_so_far_so_far;\n    } else if (i == max_so_far) {\n      max_so_far_index_so_far_so_far = max_so_far_index_so_far_so_far_so_far;\n      max_so_far_index_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far;\n    } else {\n      max_so_far_index_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far;\n    }\n  }\n  return Vec::from(numbers.iter().map(i => i == max_so_far ? max_so_far_index_so_far_so_far_so_far : i));\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpo9rdtv2t.rs:24:41\n   |\n24 |   return Vec::from(numbers.iter().map(i => i == max_so_far ? max_so_far_index_so_far_so_far_so_far : i));\n   |                                         ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let max_vec = Vec::new(numbers.len() - 1);\n  for i in numbers.iter() {\n    if i < max_index {\n      max_vec = max_vec.push(numbers[i]);\n    } else {\n      max_vec = max_vec.push(max_value);\n    }\n  }\n  return max_vec;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpiznyz3pm.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpiznyz3pm.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiznyz3pm.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpiznyz3pm.rs:14:17\n    |\n14  |   let max_vec = Vec::new(numbers.len() - 1);\n    |                 ^^^^^^^^ ----------------- supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiznyz3pm.rs:16:12\n   |\n16 |     if i < max_index {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found integer\n   |            help: consider borrowing here: `&max_index`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpiznyz3pm.rs:17:30\n   |\n17 |       max_vec = max_vec.push(numbers[i]);\n   |                              ^^^^^^^^^^ slice in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_index_so_far_index = 0;\n  for i in numbers.iter() {\n    if i > max_so_far {\n      max_so_far = i;\n      max_so_far_index = i;\n      max_so_far_index_so_far = max_so_far_index_so_far;\n      max_so_far_index_so_far_index = max_so_far_index_so_far_index;\n    } else if i == max_so_far {\n      max_so_far_index_so_far_index = i;\n    }\n  }\n  let max_so_far_index_so_far_index_plus_one = max_so_far_index_so_far_index + 1;\n  let max_so_far_index_so_far_index_plus_two = max_so_far_index_so_far_index + 2;\n  let max_so_far_index_so_far_index_plus_three = max_so_far_index_so_far_index + 3;\n  let max_so_far_index_so_far_index_plus_four = max_so_far_index_so_far_index + 4;\n  let max_so_far_index_so_far_index_plus_five = max_so_far_index_so_far_index + 5;\n  let max_so_far_index_so_far_index_plus_six = max_so_far_index_so_far_index + 6;\n  let max_so_far_index_so_far_index_plus_seven = max_so_far_index_so_far_index + 7;\n  let max_so_far_index_so_far_index_plus_eight = max_so_far_index_so_far_index + 8;\n  let max_so_far_index_so_far_index_plus_\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_yp9iaks.rs:28:42\n   |\n28 |   let max_so_far_index_so_far_index_plus_\n   |                                          ^ help: add `;` here\n29 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_yp9iaks.rs:11:12\n   |\n11 |     if i > max_so_far {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_yp9iaks.rs:12:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       max_so_far = i;\n   |                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_so_far = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_yp9iaks.rs:13:26\n   |\n7  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n13 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp_yp9iaks.rs:16:17\n   |\n16 |     } else if i == max_so_far {\n   |                 ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_yp9iaks.rs:17:39\n   |\n9  |   let max_so_far_index_so_far_index = 0;\n   |                                       - expected due to this value\n...\n17 |       max_so_far_index_so_far_index = i;\n   |                                       ^ expected integer, found `&isize`\n   |\nhelp: consider derefere",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max = numbers[0];\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i > max {\n      max = i;\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max);\n    } else {\n      result.push_back(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmprd7qht4q.rs:9:12\n  |\n9 |     if i > max {\n  |            ^^^\n  |            |\n  |            expected `&isize`, found `isize`\n  |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprd7qht4q.rs:10:13\n   |\n6  |   let max = numbers[0];\n   |             ---------- expected due to this value\n...\n10 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprd7qht4q.rs:11:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmprd7qht4q.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmprd7qht4q.rs:17:14\n   |\n17 |       result.push_back(max);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmprd7qht4q.rs:19:14\n   |\n19 |       result.push_back(i);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n      max_value = numbers[i];\n      max_index = i;\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp3_yzy1v_.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3_yzy1v_.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3_yzy1v_.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp3_yzy1v_.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3_yzy1v_.rs:18:19\n   |\n18 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n      max_value = numbers[i];\n      max_index = i;\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp3_yzy1v_.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3_yzy1v_.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3_yzy1v_.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp3_yzy1v_.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3_yzy1v_.rs:18:19\n   |\n18 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_value = numbers[0];\n  let max_index = 0;\n  let max_length = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_length = 1;\n    } else if numbers[i] == max_value {\n      max_length += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpnm2vjg6_.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpnm2vjg6_.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnm2vjg6_.rs:12:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpnm2vjg6_.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpnm2vjg6_.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n      max_value = numbers[i]\n      max_index = i\n    } else {\n      result.push_back(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpn6n67dy0.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpn6n67dy0.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpn6n67dy0.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpn6n67dy0.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpn6n67dy0.rs:17:34\n   |\n17 |       result.push_back(max_value)\n   |                                  ^ help: add `;` here\n18 |       max_value = numbers[i]\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpn6n67dy0.rs:18:29\n   |\n18 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpn6n67dy0.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpn6n67dy0.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpz58q93fi.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpz58q93fi.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_so_far = 0;\n  for i in numbers.iter() {\n    let current_number = i;\n    if (current_number > max_so_far) {\n      max_so_far = current_number;\n      max_so_far_index = i;\n      max_so_far_index_so_far = max_so_far_so_far;\n    } else if (current_number == max_so_far) {\n      max_so_far_index_so_far = i;\n    }\n    max_so_far_so_far = max_so_far_index_so_far;\n  }\n  return numbers.map(i => i - max_so_far_so_far + max_so_far_index);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp14cxkj8d.rs:21:24\n   |\n21 |   return numbers.map(i => i - max_so_far_so_far + max_so_far_index);\n   |                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut max = 0;\n  let mut index = 0;\n\n  for i in numbers {\n    if i > max {\n      max = i;\n      index = i;\n    }\n  }\n\n  for i in numbers {\n    if i == max {\n      result.push(index);\n    } else {\n      result.push(i);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0382]: use of moved value: `numbers`\n   --> /tmp/tmpoke967rb.rs:17:12\n    |\n5   | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n    |                ------- move occurs because `numbers` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n10  |   for i in numbers {\n    |            ------- `numbers` moved due to this implicit call to `.into_iter()`\n...\n17  |   for i in numbers {\n    |            ^^^^^^^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `numbers`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for i in &numbers {\n    |            +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  let max_so_far_index = max_so_far_index;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpt4esb4y7.rs:59:3\n   |\n5  | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n   |                                                   - unclosed delimiter\n...\n47 |   for i in numbers.iter() {\n   |                           - unclosed delimiter\n48 |     let current_value = i;\n49 |     if current_value > max_so_far {\n   |                                   - this delimiter might not be properly closed...\n50 |       max_so_\n51 | }\n   | - ...as it matches this but it has different indentation\n...\n59 | }\n   |   ^\n\nerror[E0425]: cannot find value `max_so_` in this scope\n  --> /tmp/tmpt4esb4y7.rs:50:7\n   |\n50 |       max_so_\n   |       ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt4esb4y7.rs:12:24\n   |\n12 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt4esb4y7.rs:13:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n13 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt4esb4y7.rs:14:26\n   |\n9  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n14 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt4esb4y7.rs:22:24\n   |\n22 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, fou",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpz58q93fi.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpz58q93fi.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far_value {\n      max_so_far_value = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  let max_so_far_index = max_so_far_index;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far_value {\n      max_so_far_value = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far_value {\n      max_so_far_value = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far_value {\n      max_so_far_value = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  for i in\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected expression, found `}`\n  --> /tmp/tmpdh9p2v0c.rs:49:1\n   |\n49 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdh9p2v0c.rs:13:24\n   |\n13 |     if current_value > max_so_far_value {\n   |                        ^^^^^^^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdh9p2v0c.rs:14:26\n   |\n10 |   let max_so_far_value = max_so_far;\n   |                          ---------- expected due to this value\n...\n14 |       max_so_far_value = current_value;\n   |                          ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_value = *current_value;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdh9p2v0c.rs:15:26\n   |\n9  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n15 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdh9p2v0c.rs:23:24\n   |\n23 |     if current_value > max_so_far_value {\n   |                        ^^^^^^^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdh9p2v0c.rs:24:26\n   |\n19 |   let max_so_far_value = max_so_far_value;\n   |                          ---------------- expected due to this value\n...\n24 |       max_so_far_value = current_value;\n   |                          ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |       max_so_far_value = *current_value;\n   |                          +\n\nerror[E0308]: mismat",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = 0;\n  let mut max_index_found = false;\n  let mut max_value_found = false;\n  let mut max_index_found_at = 0;\n  let mut max_value_found_at = 0;\n  let mut max_index_found_at_index = 0;\n  let mut max_value_found_at_index = 0;\n  let mut max_index_found_at_value = 0;\n  let mut max_value_found_at_value = 0;\n  let mut max_index_found_at_value_index = 0;\n  let mut max_value_found_at_value_index = 0;\n  let mut max_index_found_at_value_value = 0;\n  let mut max_value_found_at_value_value = 0;\n  let mut max_index_found_at_value_value_index = 0;\n  let mut max_value_found_at_value_value_index = 0;\n  let mut max_index_found_at_value_value_value = 0;\n  let mut max_value_found_at_value_value_value = 0;\n  let mut max_index_found_at_value_value_value_index = 0;\n  let mut max_value_found_at_value_value_value_index = 0;\n  let mut max_index_found_at_value_value_value_value = 0;\n  let mut max_value_found_at_value_value_value_value = 0;\n  let mut max_index_found_at_value_value_value_value_index = 0;\n  let mut max_value_found_at_value_value_value_value_index = 0;\n  let mut max_index_found_at_value_value_value_value_value = 0;\n  let mut max_value_found_at_value_value_value_value_value = 0;\n  let mut max_index_found_at_value_value_value_value_value_index = 0;\n  let mut max_value_found_at_value_value\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp8i079kg0.rs:33:41\n   |\n33 |   let mut max_value_found_at_value_value\n   |                                         ^ help: add `;` here\n34 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8i079kg0.rs:5:40\n  |\n5 | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  |    -----------                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n    } else {\n      result.push_back(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmphqlek35_.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmphqlek35_.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphqlek35_.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphqlek35_.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmphqlek35_.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmphqlek35_.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqlek35_.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpi90tvlk3.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpi90tvlk3.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpi90tvlk3.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpi90tvlk3.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpi90tvlk3.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpi90tvlk3.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpi90tvlk3.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpi90tvlk3.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max = 0;\n  let max_index = 0;\n  let max_count = 0;\n  let result = Vec::new();\n  for i in numbers {\n    if i > max {\n      max = i;\n      max_index = i;\n      max_count = 1;\n    } else if i == max_index {\n      max_count += 1;\n    } else {\n      result = result.concat(vec![max_index, max_count]);\n      max = i;\n      max_index = i;\n      max_count = 1;\n    }\n  }\n  result = result.concat(vec![max_index, max_count]);\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpi_u2nryl.rs:18:23\n    |\n18  |       result = result.concat(vec![max_index, max_count]);\n    |                       ^^^^^^ -------------------------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpi_u2nryl.rs:24:19\n    |\n24  |   result = result.concat(vec![max_index, max_count]);\n    |                   ^^^^^^ -------------------------- supplied 1 argument\n    |                   |\n    |                   expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpi_u2nryl.rs:18:23\n    |\n18  |       result = result.concat(vec![max_index, max_count]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpi_u2nryl.rs:24:19\n    |\n24  |   result = result.concat(vec![max_index, max_count]);\n    |                   ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  let max_so_far_index = max_so_far_index;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  let max_so_far_index = max_so_far_index;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  let max_so_far_index = max_so_far_index;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpca06zm9u.rs:12:24\n   |\n12 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpca06zm9u.rs:13:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n13 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpca06zm9u.rs:14:26\n   |\n9  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n14 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpca06zm9u.rs:22:24\n   |\n22 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpca06zm9u.rs:23:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n23 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpca06zm9u.rs:24:26\n   |\n19 |   let max_so_far_index = max_so_far_index;\n   |                          ---------------- expected due to this value\n...\n24 |       max_so_far_index = i;\n   |                  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  let mut max_index_for_value = 0;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_index_for_value = i;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index_for_value {\n      result.push(max_value);\n      max_value = numbers[i];\n      max_index = i;\n      max_index_for_value = i;\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmph3s0u47e.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmph3s0u47e.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph3s0u47e.rs:12:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph3s0u47e.rs:13:29\n   |\n8  |   let mut max_index_for_value = 0;\n   |                                 - expected due to this value\n...\n13 |       max_index_for_value = i;\n   |                             ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_index_for_value = *i;\n   |                             +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmph3s0u47e.rs:18:10\n   |\n18 |     if i == max_index_for_value {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value);\n    } else {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp6jiizrtu.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp6jiizrtu.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6jiizrtu.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6jiizrtu.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp6jiizrtu.rs:17:14\n   |\n17 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value);\n      max_value = numbers[i];\n      max_index = i;\n    } else {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpng9fmacz.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpng9fmacz.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpng9fmacz.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpng9fmacz.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpng9fmacz.rs:17:14\n   |\n17 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tm",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  let mut max_index_found = false;\n  let mut max_value_found = false;\n  for i in numbers.iter() {\n    if !max_value_found && max_value < i {\n      max_value = i;\n      max_value_found = true;\n    }\n    if !max_index_found && max_index < i {\n      max_index = i;\n      max_index_found = true;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if max_index_found && max_index == i {\n      result.push(max_value);\n      max_index_found = false;\n      max_value_found = false;\n    } else {\n      result.push(i);\n    }\n  }\n  if max_index_found {\n    result.push(max_value);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpx94ebbk8.rs:11:40\n   |\n11 |     if !max_value_found && max_value < i {\n   |                                        ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |     if !max_value_found && max_value < *i {\n   |                                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx94ebbk8.rs:12:19\n   |\n7  |   let mut max_value = numbers[0];\n   |                       ---------- expected due to this value\n...\n12 |       max_value = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx94ebbk8.rs:16:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n16 |       max_index = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmpx94ebbk8.rs:15:38\n   |\n15 |     if !max_index_found && max_index < i {\n   |                                      ^ no implementation for `isize < &isize` and `isize > &isize`\n   |\n   = help: the trait `PartialOrd<&isize>` is not implemented for `isize`\n   = help: the following other types implement trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx94ebbk8.rs:22:40\n   |\n22 |     if max_index_found && max_index == i {\n   |                                        ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |     if max_index_found && max_index == *i {\n   |                                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx94ebbk8.rs:27:19\n   |\n27 |       result.push(i);\n   |       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let max_vec = Vec::new(numbers.len())\n  for i in numbers.iter() {\n    if i == max_index {\n      max_vec.push_back(max_value)\n    } else {\n      max_vec.push_back(numbers[i])\n    }\n  }\n  return max_vec\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpcj2ux8tm.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpcj2ux8tm.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpcj2ux8tm.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpcj2ux8tm.rs:14:40\n   |\n14 |   let max_vec = Vec::new(numbers.len())\n   |                                        ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpcj2ux8tm.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcj2ux8tm.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcj2ux8tm.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n      max_value = numbers[i];\n      max_index = i;\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp4z9_i7p2.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp4z9_i7p2.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4z9_i7p2.rs:11:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp4z9_i7p2.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp4z9_i7p2.rs:18:19\n   |\n18 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_index_found = false\n  for i in numbers.iter() {\n    if max_value < i {\n      max_value = i\n      max_index = i\n      max_index_found = true\n    }\n  }\n  if max_index_found {\n    return numbers.map(i => i if i == max_index else i)\n  } else {\n    return numbers\n  }\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpq4b76ze5.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpq4b76ze5.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_index_found = false\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpq4b76ze5.rs:8:30\n  |\n8 |   let max_index_found = false\n  |                              ^ help: add `;` here\n9 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpq4b76ze5.rs:11:20\n   |\n11 |       max_value = i\n   |                    ^ help: add `;` here\n12 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index_found`\n  --> /tmp/tmpq4b76ze5.rs:12:20\n   |\n12 |       max_index = i\n   |                    ^ help: add `;` here\n13 |       max_index_found = true\n   |       --------------- unexpected token\n\nerror: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpq4b76ze5.rs:17:26\n   |\n17 |     return numbers.map(i => i if i == max_index else i)\n   |                          ^^ expected one of 8 possible tokens\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if max_value < i {\n      max_value = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n    } else {\n      result.push_back(i)\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmppctpjpab.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmppctpjpab.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmppctpjpab.rs:10:20\n   |\n10 |       max_value = i\n   |                    ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppctpjpab.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmppctpjpab.rs:9:20\n  |\n9 |     if max_value < i {\n  |                    ^ expected `isize`, found `&isize`\n  |\nhelp: consider dereferencing the borrow\n  |\n9 |     if max_value < *i {\n  |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppctpjpab.rs:10:19\n   |\n7  |   let max_value = numbers[0]\n   |                   ---------- expected due to this value\n...\n10 |       max_value = i\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |       max_value = *i\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppctpjpab.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmppctpjpab.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  let mut max_found = false;\n  let mut max_found_index = 0;\n  for i in numbers.iter() {\n    if !max_found {\n      max_found = true;\n      max_found_index = i;\n      max_value = numbers[i];\n    } else if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_found_index {\n      result.push(max_value);\n      max_found = false;\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp8g7_jrdl.rs:13:25\n   |\n9  |   let mut max_found_index = 0;\n   |                             - expected due to this value\n...\n13 |       max_found_index = i;\n   |                         ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_found_index = *i;\n   |                         +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp8g7_jrdl.rs:14:19\n   |\n14 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp8g7_jrdl.rs:15:15\n   |\n15 |     } else if numbers[i] > max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp8g7_jrdl.rs:16:19\n   |\n16 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8g7_jrdl.rs:17:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n17 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max = 0;\n  let max_index = 0;\n  let max_value = 0;\n  let max_value_index = 0;\n  let max_value_value = 0;\n  let max_value_value_index = 0;\n  let max_value_value_value = 0;\n  let max_value_value_value_index = 0;\n  let max_value_value_value_value = 0;\n  let max_value_value_value_value_index = 0;\n  let max_value_value_value_value_value = 0;\n  let max_value_value_value_value_value_index = 0;\n  let max_value_value_value_value_value_value = 0;\n  let max_value_value_value_value_value_value_index = 0;\n  let max_value_value_value_value_value_value_value = 0;\n  let max_value_value_value_value_value_value_value_index = 0;\n  let max_value_value_value_value_value_value_value_value = 0;\n  let max_value_value_value_value_value_value_value_value_index = 0;\n  let max_value_value_value_value_value_value_value_value_value = 0;\n  let max_value_value_value_value_value_value_value_value_value_index = 0;\n  let max_value_value_value_value_value_value_value_value_value_value = 0;\n  let max_value_value_value_value_value_value_value_value_value_value_index = 0;\n  let max_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let max_value_value_value_value_value_value_value_value_value_value_value_index = 0;\n  let max_value_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let max_value_value_value_value_value_value_value_value_value_value_value\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpcr_9_p10.rs:31:76\n   |\n31 |   let max_value_value_value_value_value_value_value_value_value_value_value\n   |                                                                            ^ help: add `;` here\n32 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpcr_9_p10.rs:5:40\n  |\n5 | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  |    -----------                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_index_so_far_so_far = 0;\n  let max_so_far_index_so_far_so_far_so_far = 0;\n  for i in numbers.iter() {\n    let current_number = i;\n    if current_number > max_so_far {\n      max_so_far = current_number;\n      max_so_far_index = i;\n      max_so_far_index_so_far = max_so_far_index_so_far_so_far;\n      max_so_far_index_so_far_so_far = max_so_far_index_so_far_so_far_so_far;\n    } else if current_number == max_so_far {\n      max_so_far_index_so_far_so_far = max_so_far_index_so_far_so_far_so_far;\n      max_so_far_index_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far;\n    } else if current_number < max_so_far {\n      max_so_far_index_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far;\n      max_so_far_index_so_far_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far_so_far;\n    }\n  }\n  return Vec::from([max_so_far, max_so_far_index, max_so_far_index_so_far, max_so_far_index_so_far_so_far, max_so_far_index_so_far_so_far_so_far]);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find value `max_so_far_index_so_far_so_far_so_far_so_far` in this scope\n  --> /tmp/tmpbzz_g7fo.rs:20:47\n   |\n20 |       max_so_far_index_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far;\n   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `max_so_far_index_so_far_so_far_so_far`\n\nerror[E0425]: cannot find value `max_so_far_index_so_far_so_far_so_far_so_far` in this scope\n  --> /tmp/tmpbzz_g7fo.rs:22:47\n   |\n22 |       max_so_far_index_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far;\n   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `max_so_far_index_so_far_so_far_so_far`\n\nerror[E0425]: cannot find value `max_so_far_index_so_far_so_far_so_far_so_far` in this scope\n  --> /tmp/tmpbzz_g7fo.rs:23:7\n   |\n23 |       max_so_far_index_so_far_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far_so_far;\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `max_so_far_index_so_far_so_far_so_far`\n\nerror[E0425]: cannot find value `max_so_far_index_so_far_so_far_so_far_so_far_so_far` in this scope\n  --> /tmp/tmpbzz_g7fo.rs:23:54\n   |\n23 |       max_so_far_index_so_far_so_far_so_far_so_far = max_so_far_index_so_far_so_far_so_far_so_far_so_far;\n   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `max_so_far_index_so_far_so_far_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbzz_g7fo.rs:13:25\n   |\n13 |     if current_number > max_so_far {\n   |                         ^^^^^^^^^^\n   |                         |\n   |                         expected `&isize`, found `isize`\n   |                         help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbzz_g7fo.rs:14:20",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = 0;\n  let mut max_index_prev = 0;\n  let mut max_value_prev = 0;\n  let mut max_index_next = 0;\n  let mut max_value_next = 0;\n  let mut max_index_next_prev = 0;\n  let mut max_value_next_prev = 0;\n  let mut max_index_next_next = 0;\n  let mut max_value_next_next = 0;\n  let mut max_index_next_next_prev = 0;\n  let mut max_value_next_next_prev = 0;\n  let mut max_index_next_next_next = 0;\n  let mut max_value_next_next_next = 0;\n  let mut max_index_next_next_next_prev = 0;\n  let mut max_value_next_next_next_prev = 0;\n  let mut max_index_next_next_next_next = 0;\n  let mut max_value_next_next_next_next = 0;\n  let mut max_index_next_next_next_next_prev = 0;\n  let mut max_value_next_next_next_next_prev = 0;\n  let mut max_index_next_next_next_next_next = 0;\n  let mut max_value_next_next_next_next_next = 0;\n  let mut max_index_next_next_next_next_next_prev = 0;\n  let mut max_value_next_next_next_next_next_prev = 0;\n  let mut max_index_next_next_next_next_next_next = 0;\n  let mut max_value_next_next_next_next_next_next = 0;\n  let mut max_index_next_next_next_next_next_next_prev = 0;\n  let mut max_value_next_next_next_next_next_next_prev = 0;\n  let mut max_index_next_next_next_next_next_next_next = 0;\n  let mut max_value_next_next_next\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0fiy6ppr.rs:35:35\n   |\n35 |   let mut max_value_next_next_next\n   |                                   ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp0fiy6ppr.rs:5:40\n  |\n5 | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  |    -----------                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  for i in numbers.iter() {\n    if i == max_index {\n      result = result.append(max_value)\n    } else {\n      result = result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpqhf4uuvy.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpqhf4uuvy.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let result = Vec::new()\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpqhf4uuvy.rs:8:26\n  |\n8 |   let result = Vec::new()\n  |                          ^ help: add `;` here\n9 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpqhf4uuvy.rs:11:29\n   |\n11 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n12 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpqhf4uuvy.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpqhf4uuvy.rs:11:19\n   |\n11 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqhf4uuvy.rs:12:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n12 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_value = numbers[0];\n  let max_index = 0;\n  let max_length = 1;\n  for i in numbers.iter() {\n    if i > max_value {\n      max_value = i;\n      max_index = i;\n      max_length = 1;\n    } else if i == max_value {\n      max_length += 1;\n    }\n  }\n  let max_vec = Vec::new(max_length);\n  for i in numbers.iter() {\n    if i == max_value {\n      max_vec[max_length - 1] = i;\n    }\n  }\n  return max_vec;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp28h9dk5u.rs:10:12\n   |\n10 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp28h9dk5u.rs:11:19\n   |\n6  |   let max_value = numbers[0];\n   |                   ---------- expected due to this value\n...\n11 |       max_value = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp28h9dk5u.rs:12:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp28h9dk5u.rs:14:17\n   |\n14 |     } else if i == max_value {\n   |                 ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp28h9dk5u.rs:18:17\n    |\n18  |   let max_vec = Vec::new(max_length);\n    |                 ^^^^^^^^ ---------- supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp28h9dk5u.rs:20:10\n   |\n20 |     if i == max_value {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let max_vec = Vec::new(numbers.len() - 1);\n  for i in numbers.iter() {\n    if i < max_index {\n      max_vec = max_vec.push(numbers[i]);\n    } else {\n      max_vec = max_vec.push(max_value);\n    }\n  }\n  return max_vec;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpiznyz3pm.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpiznyz3pm.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiznyz3pm.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpiznyz3pm.rs:14:17\n    |\n14  |   let max_vec = Vec::new(numbers.len() - 1);\n    |                 ^^^^^^^^ ----------------- supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiznyz3pm.rs:16:12\n   |\n16 |     if i < max_index {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found integer\n   |            help: consider borrowing here: `&max_index`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpiznyz3pm.rs:17:30\n   |\n17 |       max_vec = max_vec.push(numbers[i]);\n   |                              ^^^^^^^^^^ slice in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = 0;\n  let mut max_index_start = 0;\n  let mut max_value_start = 0;\n  let mut max_index_end = 0;\n  let mut max_value_end = 0;\n  let mut max_index_current = 0;\n  let mut max_value_current = 0;\n  let mut max_index_next = 0;\n  let mut max_value_next = 0;\n  let mut max_index_previous = 0;\n  let mut max_value_previous = 0;\n  let mut max_index_previous_previous = 0;\n  let mut max_value_previous_previous = 0;\n  let mut max_index_previous_next = 0;\n  let mut max_value_previous_next = 0;\n  let mut max_index_previous_previous_previous = 0;\n  let mut max_value_previous_previous_previous = 0;\n  let mut max_index_previous_previous_next = 0;\n  let mut max_value_previous_previous_next = 0;\n  let mut max_index_previous_previous_previous_previous = 0;\n  let mut max_value_previous_previous_previous_previous = 0;\n  let mut max_index_previous_previous_previous_next = 0;\n  let mut max_value_previous_previous_previous_next = 0;\n  let mut max_index_previous_previous_previous_previous_previous = 0;\n  let mut max_value_previous_previous_previous_previous_previous = 0;\n  let mut max_index_previous_previous_previous_previous_previous_previous = 0;\n  let mut max_value_previous_previous_previous_previous_previous_previous = 0;\n  let mut max_index_previous_previous_previous_previous_previous_previous_previous = 0;\n  let mut max_value_previous_pre\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpy_2hmxfx.rs:35:33\n   |\n35 |   let mut max_value_previous_pre\n   |                                 ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpy_2hmxfx.rs:5:40\n  |\n5 | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  |    -----------                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_value = numbers[0];\n  let max_index = 0;\n  let max_count = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_count = 1;\n    } else if numbers[i] == max_value {\n      max_count += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14yhd0hh.rs:12:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp14yhd0hh.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_value = numbers[0];\n  let mut max_index = 0;\n  for i in numbers.iter() {\n    if i > max_value {\n      max_value = i;\n      max_index = i;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_value {\n      result.push_back(max_value);\n    } else {\n      result.push_back(max_value);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmpjekl3e2a.rs:9:12\n  |\n9 |     if i > max_value {\n  |            ^^^^^^^^^\n  |            |\n  |            expected `&isize`, found `isize`\n  |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjekl3e2a.rs:10:19\n   |\n6  |   let mut max_value = numbers[0];\n   |                       ---------- expected due to this value\n...\n10 |       max_value = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjekl3e2a.rs:11:19\n   |\n7  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpjekl3e2a.rs:16:10\n   |\n16 |     if i == max_value {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpjekl3e2a.rs:17:14\n   |\n17 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpjekl3e2a.rs:19:14\n   |\n19 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  let max_index_found = false;\n  for i in numbers.iter() {\n    if i > max_value {\n      max_value = i;\n      max_index = i;\n      max_index_found = true;\n    }\n    if max_index_found {\n      max_index_found = false;\n    }\n  }\n  return numbers.map(i => i if i == max_value else i);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmpzwqyg505.rs:19:24\n   |\n19 |   return numbers.map(i => i if i == max_value else i);\n   |                        ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  let mut max_index_set = false;\n  let mut max_value_set = false;\n  let mut max_index_changed = false;\n  let mut max_value_changed = false;\n  let mut max_index_changed_set = false;\n  let mut max_value_changed_set = false;\n\n  for i in numbers.iter() {\n    if !max_value_set && !max_value_changed_set {\n      max_value = i;\n      max_value_set = true;\n    }\n    if !max_index_set && !max_index_changed_set {\n      max_index = i;\n      max_index_set = true;\n    }\n    if max_value_set && max_value_changed_set {\n      max_value_changed = true;\n      max_value_changed_set = false;\n    }\n    if max_index_set && max_index_changed_set {\n      max_index_changed = true;\n      max_index_changed_set = false;\n    }\n    if max_value_set && max_value_changed {\n      max_value_changed = false;\n      max_value_changed_set = true;\n    }\n    if max_index_set && max_index_changed {\n      max_index_changed = false;\n      max_index_changed_set = true;\n    }\n  }\n  let mut result = Vec::new();\n  if max_value_set {\n    result.push(max_value);\n  }\n  if max_index_set {\n    result.push(max_index);\n  }\n  if max_value_changed_set {\n    result.push(max_value);\n  }\n  if max_index_changed_set {\n    result.push(max_index);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpiqh1amtc.rs:17:19\n   |\n7  |   let mut max_value = numbers[0];\n   |                       ---------- expected due to this value\n...\n17 |       max_value = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiqh1amtc.rs:21:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n21 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       max_index = *i;\n   |                   +\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_index_found = false\n  let result = Vec::new()\n\n  for i in numbers.iter() {\n    if !max_index_found {\n      if max_value < i {\n        max_value = i\n        max_index = i\n        max_index_found = true\n      }\n    } else {\n      if max_value < i {\n        max_value = i\n        max_index = i\n      }\n    }\n  }\n\n  result.extend(numbers.slice(0, max_index))\n  result.push(max_value)\n  result.extend(numbers.slice(max_index + 1))\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmptjb4dv44.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmptjb4dv44.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_index_found = false\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmptjb4dv44.rs:8:30\n  |\n8 |   let max_index_found = false\n  |                              ^ help: add `;` here\n9 |   let result = Vec::new()\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmptjb4dv44.rs:9:26\n   |\n9  |   let result = Vec::new()\n   |                          ^ help: add `;` here\n10 | \n11 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmptjb4dv44.rs:14:22\n   |\n14 |         max_value = i\n   |                      ^ help: add `;` here\n15 |         max_index = i\n   |         --------- unexpected token\n\nerror: expected `;`, found `max_index_found`\n  --> /tmp/tmptjb4dv44.rs:15:22\n   |\n15 |         max_index = i\n   |                      ^ help: add `;` here\n16 |         max_index_found = true\n   |         --------------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmptjb4dv44.rs:20:22\n   |\n20 |         max_value = i\n   |                      ^ help: add `;` here\n21 |         max_index = i\n   |         --------- unexpected token\n\nerror: expected `;`, found `result`\n  --> /tmp/tmptjb4dv44.rs:26:45\n   |\n26 |   result.extend(numbers.slice(0, max_index))\n   |                                             ^ help: add `;` here\n27 |   result.push(max_value)\n   |   ------ unexpected token\n\nerror: expected `;`, found `result`\n  --> /tmp/tmptjb4dv44.rs:27:25\n   |\n27 |   result.push(max_value)\n   |                         ^ help: add `;` here\n28 |   result.extend(numbers.slice(max_index + 1))\n   |   ------ unexpected token\n\nerror: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let max_vec = Vec::new(numbers.len() - 1)\n  for i in numbers.iter() {\n    if i < max_index {\n      max_vec[i] = numbers[i]\n    } else {\n      max_vec[i] = max_value\n    }\n  }\n  return max_vec\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp66fdm4ar.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmp66fdm4ar.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp66fdm4ar.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp66fdm4ar.rs:14:44\n   |\n14 |   let max_vec = Vec::new(numbers.len() - 1)\n   |                                            ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp66fdm4ar.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp66fdm4ar.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp66fdm4ar.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value);\n    } else {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp6jiizrtu.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp6jiizrtu.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6jiizrtu.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6jiizrtu.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp6jiizrtu.rs:17:14\n   |\n17 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let max_vec = Vec::new(numbers.len() - 1)\n  for i in numbers.iter() {\n    if i < max_index {\n      max_vec.store(i, numbers[i])\n    } else {\n      max_vec.store(i, max_value)\n    }\n  }\n  return max_vec\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpgtl2i79a.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpgtl2i79a.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpgtl2i79a.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpgtl2i79a.rs:14:44\n   |\n14 |   let max_vec = Vec::new(numbers.len() - 1)\n   |                                            ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpgtl2i79a.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpgtl2i79a.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgtl2i79a.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  let max_length = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_length = 1;\n    } else if numbers[i] == max_value {\n      max_length += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcudvmtyo.rs:12:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpcudvmtyo.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  return Vec::from([max_so_far_value, max_so_far_index]);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpw32oa4av.rs:12:24\n   |\n12 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw32oa4av.rs:13:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n13 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw32oa4av.rs:14:26\n   |\n9  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n14 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_index = *i;\n   |                          +\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  let max_length = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_length = 1;\n    } else if numbers[i] == max_value {\n      max_length += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcudvmtyo.rs:12:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpcudvmtyo.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_value = numbers[0];\n  let max_index = 0;\n  let max_count = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_count = 1;\n    } else if numbers[i] == max_value {\n      max_count += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp14yhd0hh.rs:12:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp14yhd0hh.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp14yhd0hh.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_hu4j9p4.rs:45:13\n   |\n45 |   let max_so\n   |             ^ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp_hu4j9p4.rs:5:40\n  |\n5 | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  |    -----------                         ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  let max_length = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_length = 1;\n    } else if numbers[i] == max_value {\n      max_length += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcudvmtyo.rs:12:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpcudvmtyo.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpcudvmtyo.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpi90tvlk3.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpi90tvlk3.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpi90tvlk3.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpi90tvlk3.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpi90tvlk3.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpi90tvlk3.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpi90tvlk3.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpi90tvlk3.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n      max_value = numbers[i];\n      max_index = i;\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp3_yzy1v_.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3_yzy1v_.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3_yzy1v_.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp3_yzy1v_.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3_yzy1v_.rs:18:19\n   |\n18 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpz58q93fi.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpz58q93fi.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value);\n    } else {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp6jiizrtu.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp6jiizrtu.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6jiizrtu.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6jiizrtu.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp6jiizrtu.rs:17:14\n   |\n17 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n    } else {\n      result.push_back(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpj4v43u_m.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpj4v43u_m.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpj4v43u_m.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpj4v43u_m.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpj4v43u_m.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpj4v43u_m.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpj4v43u_m.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpj4v43u_m.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n    } else {\n      result.push_back(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmphqlek35_.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmphqlek35_.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphqlek35_.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphqlek35_.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmphqlek35_.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmphqlek35_.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqlek35_.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  for i in numbers.iter() {\n    if (max_so_far < i) {\n      max_so_far = i;\n      max_so_far_index = i;\n      max_so_far_value = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  return Vec::from([max_so_far_value, max_so_far_index]);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpy25r8t3c.rs:12:8\n   |\n12 |     if (max_so_far < i) {\n   |        ^              ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n12 -     if (max_so_far < i) {\n12 +     if max_so_far < i {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy25r8t3c.rs:12:22\n   |\n12 |     if (max_so_far < i) {\n   |                      ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |     if (max_so_far < *i) {\n   |                      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy25r8t3c.rs:13:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n13 |       max_so_far = i;\n   |                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy25r8t3c.rs:14:26\n   |\n9  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n14 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy25r8t3c.rs:15:26\n   |\n10 |   let max_so_far_value = max_so_far;\n   |                          ---------- expected due to this value\n...\n15 |       max_so_far_value = i;\n   |                          ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_so_far_value = *i;\n   |                          +\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n    } else {\n      result.push_back(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmphqlek35_.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmphqlek35_.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphqlek35_.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphqlek35_.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmphqlek35_.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmphqlek35_.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqlek35_.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_value = numbers[0];\n  let mut max_index = 0;\n  for i in numbers.iter() {\n    if i > max_value {\n      max_value = i;\n      max_index = i;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_value {\n      result.push(max_value);\n    } else {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmp6o5bx9zk.rs:9:12\n  |\n9 |     if i > max_value {\n  |            ^^^^^^^^^\n  |            |\n  |            expected `&isize`, found `isize`\n  |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6o5bx9zk.rs:10:19\n   |\n6  |   let mut max_value = numbers[0];\n   |                       ---------- expected due to this value\n...\n10 |       max_value = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6o5bx9zk.rs:11:19\n   |\n7  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp6o5bx9zk.rs:16:10\n   |\n16 |     if i == max_value {\n   |          ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6o5bx9zk.rs:19:19\n   |\n19 |       result.push(i);\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       result.push(*i);\n   |                   +\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_index_so_far_so_far = 0;\n  for i in numbers.iter() {\n    if i > max_so_far {\n      max_so_far = i;\n      max_so_far_index = i;\n      max_so_far_index_so_far = max_so_far_index_so_far;\n      max_so_far_index_so_far_so_far = max_so_far_index_so_far_so_far;\n    } else if i == max_so_far {\n      max_so_far_index_so_far_so_far = max_so_far_index_so_far_so_far + 1;\n    }\n  }\n  let max_so_far_index_so_far_so_far_plus_1 = max_so_far_index_so_far_so_far + 1;\n  let max_so_far_index_so_far_so_far_plus_2 = max_so_far_index_so_far_so_far_plus_1 + 1;\n  let max_so_far_index_so_far_so_far_plus_3 = max_so_far_index_so_far_so_far_plus_2 + 1;\n  let max_so_far_index_so_far_so_far_plus_4 = max_so_far_index_so_far_so_far_plus_3 + 1;\n  let max_so_far_index_so_far_so_far_plus_5 = max_so_far_index_so_far_so_far_plus_4 + 1;\n  let max_so_far_index_so_far_so_far_plus_6 = max_so_far_index_so_far_so_far_plus_5 + 1;\n  let max_so_far_index_so_far_so_far_plus_7 = max_\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpye__flvj.rs:26:51\n   |\n26 |   let max_so_far_index_so_far_so_far_plus_7 = max_\n   |                                                   ^ help: add `;` here\n27 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `max_` in this scope\n  --> /tmp/tmpye__flvj.rs:26:47\n   |\n26 |   let max_so_far_index_so_far_so_far_plus_7 = max_\n   |                                               ^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpye__flvj.rs:11:12\n   |\n11 |     if i > max_so_far {\n   |            ^^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpye__flvj.rs:12:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n12 |       max_so_far = i;\n   |                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_so_far = *i;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpye__flvj.rs:13:26\n   |\n7  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n13 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpye__flvj.rs:16:17\n   |\n16 |     } else if i == max_so_far {\n   |                 ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n --> /tmp/tmpye__flvj.rs:5:40\n  |\n5 | fn rolling_max(numbers: Vec<",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 0\n  for i in numbers.iter() {\n    if i > max_value {\n      max_value = i\n      max_index = i\n      max_length = 1\n    } else if i == max_value {\n      max_length += 1\n    }\n  }\n  let max_vec = Vec::new(max_length)\n  for i in numbers.iter() {\n    if i == max_value {\n      max_vec.push_back(i)\n    }\n  }\n  return max_vec\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp9s4anrxy.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmp9s4anrxy.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 0\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmp9s4anrxy.rs:8:21\n  |\n8 |   let max_length = 0\n  |                     ^ help: add `;` here\n9 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp9s4anrxy.rs:11:20\n   |\n11 |       max_value = i\n   |                    ^ help: add `;` here\n12 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmp9s4anrxy.rs:12:20\n   |\n12 |       max_index = i\n   |                    ^ help: add `;` here\n13 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp9s4anrxy.rs:18:37\n   |\n18 |   let max_vec = Vec::new(max_length)\n   |                                     ^ help: add `;` here\n19 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9s4anrxy.rs:10:12\n   |\n10 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9s4anrxy.rs:11:19\n   |\n7  |   let max_value = numbers[0]\n   |                   ---------- expected due to this value\n...\n11 |       max_value = i\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_value = *i\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9s4anrxy.rs:12:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n12 |   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpz58q93fi.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpz58q93fi.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpz58q93fi.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpz58q93fi.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpz58q93fi.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let result = Vec::new()\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpao5xk4ss.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpao5xk4ss.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let result = Vec::new()\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpao5xk4ss.rs:8:26\n   |\n8  |   let result = Vec::new()\n   |                          ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpao5xk4ss.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpao5xk4ss.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpao5xk4ss.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpao5xk4ss.rs:13:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n13 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: cons",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  let mut max_index_start = 0;\n  let mut max_value_start = numbers[0];\n  let mut max_index_end = 0;\n  let mut max_value_end = numbers[0];\n  let mut max_index_end_start = 0;\n  let mut max_value_end_start = numbers[0];\n  let mut max_index_end_end = 0;\n  let mut max_value_end_end = numbers[0];\n\n  for i in numbers.iter() {\n    if i > max_value {\n      max_value = i;\n      max_index = i;\n      max_index_start = i;\n      max_value_start = i;\n    } else if i == max_value {\n      max_index_end = i;\n      max_value_end = i;\n      max_index_end_start = i;\n      max_value_end_start = i;\n    } else if i < max_value {\n      max_index_end = i;\n      max_value_end = i;\n      max_index_end_end = i;\n      max_value_end_end = i;\n    }\n  }\n\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_value_start {\n      result.push(max_value_start);\n    } else if i == max_value_end {\n      result.push(max_value_end);\n    } else if i == max_index_start {\n      result.push(max_index_start);\n    } else if i == max_index_end {\n      result.push(max_index_end);\n    } else if i == max_index_end_start {\n      result.push(max_index_end_start);\n    } else if i == max_index_end_end {\n      result.push(max_index_end_end);\n    } else {\n      result.push(i);\n    }\n  }\n\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp98bxf56x.rs:18:12\n   |\n18 |     if i > max_value {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found `isize`\n   |            help: consider borrowing here: `&max_value`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp98bxf56x.rs:19:19\n   |\n7  |   let mut max_value = numbers[0];\n   |                       ---------- expected due to this value\n...\n19 |       max_value = i;\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       max_value = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp98bxf56x.rs:20:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n20 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |       max_index = *i;\n   |                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp98bxf56x.rs:21:25\n   |\n8  |   let mut max_index_start = 0;\n   |                             - expected due to this value\n...\n21 |       max_index_start = i;\n   |                         ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |       max_index_start = *i;\n   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp98bxf56x.rs:22:25\n   |\n9  |   let mut max_value_start = numbers[0];\n   |                             ---------- expected due to this value\n...\n22 |       max_value_start = i;\n   |                         ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |       max_value_start = *i;\n   |                         +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp98bxf56x.rs:23:17\n   |\n23 |     } else if i == max_value {\n   |                 ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let mut result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n      max_value = numbers[i];\n      max_index = i;\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp4z9_i7p2.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp4z9_i7p2.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4z9_i7p2.rs:11:19\n   |\n6  |   let mut max_index = 0;\n   |                       - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp4z9_i7p2.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp4z9_i7p2.rs:18:19\n   |\n18 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented f",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n  let max_so_far_count = 1;\n  let max_so_far_index_count = 1;\n  let max_so_far_value_count = 1;\n  for i in numbers.iter() {\n    let value = i;\n    let count = 1;\n    if value > max_so_far {\n      max_so_far = value;\n      max_so_far_index = i;\n      max_so_far_value = value;\n      max_so_far_count = count;\n      max_so_far_index_count = count;\n      max_so_far_value_count = count;\n    } else if value == max_so_far {\n      count += 1;\n      if count > max_so_far_count {\n        max_so_far_index_count = count;\n        max_so_far_value_count = count;\n      }\n    }\n  }\n  let max_so_far_index_count_vec = Vec::from(max_so_far_index_count);\n  let max_so_far_value_count_vec = Vec::from(max_so_far_value_count);\n  return Vec::from(max_so_far_index_count_vec + max_so_far_value_count_vec);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp6324ty79.rs:15:16\n   |\n15 |     if value > max_so_far {\n   |                ^^^^^^^^^^\n   |                |\n   |                expected `&isize`, found `isize`\n   |                help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6324ty79.rs:16:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n16 |       max_so_far = value;\n   |                    ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |       max_so_far = *value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6324ty79.rs:17:26\n   |\n7  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n17 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n17 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6324ty79.rs:18:26\n   |\n8  |   let max_so_far_value = 0;\n   |                          - expected due to this value\n...\n18 |       max_so_far_value = value;\n   |                          ^^^^^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |       max_so_far_value = *value;\n   |                          +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmp6324ty79.rs:22:21\n   |\n22 |     } else if value == max_so_far {\n   |                     ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the trait bound `Vec<_, _>: From<{integer}>` is not satisfied\n  --> /tmp/tmp6324ty79.rs:30:36\n   |\n30 |   let m",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value == max_so_far {\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value == max_so_far {\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value == max_so_far {\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value == max_so_far {\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  for i in numbers.iter() {\n    let current_\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmpr3xzmoay.rs:61:3\n   |\n5  | fn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n   |                                                   - unclosed delimiter\n...\n51 |   for i in numbers.iter() {\n   |                           - this delimiter might not be properly closed...\n52 |     let current_\n53 | }\n   | - ...as it matches this but it has different indentation\n...\n61 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpr3xzmoay.rs:52:17\n   |\n52 |     let current_\n   |                 ^ help: add `;` here\n53 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3xzmoay.rs:12:24\n   |\n12 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3xzmoay.rs:13:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n13 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3xzmoay.rs:14:26\n   |\n9  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n14 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpr3xzmoay.rs:21:22\n   |\n21 |     if current_value == max_so_far {\n   |                      ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut max_index = 0;\n  let mut max_value = 0;\n  let mut max_index_prev = 0;\n  let mut max_value_prev = 0;\n  let mut max_index_next = 0;\n  let mut max_value_next = 0;\n  let mut max_index_next_prev = 0;\n  let mut max_value_next_prev = 0;\n  let mut max_index_next_next = 0;\n  let mut max_value_next_next = 0;\n\n  for i in numbers {\n    if i > max_value {\n      max_value = i;\n      max_index = i;\n    }\n    if i > max_value_prev {\n      max_value_prev = i;\n      max_index_prev = i;\n    }\n    if i > max_value_next {\n      max_value_next = i;\n      max_index_next = i;\n    }\n    if i > max_value_next_prev {\n      max_value_next_prev = i;\n      max_index_next_prev = i;\n    }\n    if i > max_value_next_next {\n      max_value_next_next = i;\n      max_index_next_next = i;\n    }\n  }\n\n  let mut max_index_prev_next = 0;\n  let mut max_value_prev_next = 0;\n  let mut max_index_next_next_prev = 0;\n  let mut max_value_next_next_prev = 0;\n  let mut max_index_next_next_next = 0;\n  let mut max_value_next_next_next = 0;\n\n  if max_index_prev > max_index_next {\n    max_index_prev_next = max_index_prev;\n    max_value_prev_next = max_value_prev;\n  }\n  if max_index_prev > max_index_next_prev {\n    max_index_prev_next = max_index_prev;\n    max_value_prev_next = max_value_prev;\n  }\n  if max_index_prev >\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected expression, found `}`\n  --> /tmp/tmp_lu5ztnm.rs:56:1\n   |\n56 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_value_index = 0\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_value_index = i\n      max_index = i\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmp0a5vsg86.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmp0a5vsg86.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_value_index = 0\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp0a5vsg86.rs:8:26\n   |\n8  |   let max_value_index = 0\n   |                          ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value_index`\n  --> /tmp/tmp0a5vsg86.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_value_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmp0a5vsg86.rs:13:26\n   |\n13 |       max_value_index = i\n   |                          ^ help: add `;` here\n14 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp0a5vsg86.rs:18:26\n   |\n18 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n19 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp0a5vsg86.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp0a5vsg86.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `S",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_value_index = 0\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_value_index = i\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpfp5v04it.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpfp5v04it.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_value_index = 0\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpfp5v04it.rs:8:26\n  |\n8 |   let max_value_index = 0\n  |                          ^ help: add `;` here\n9 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_value_index`\n  --> /tmp/tmpfp5v04it.rs:11:29\n   |\n11 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n12 |       max_value_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpfp5v04it.rs:12:26\n   |\n12 |       max_value_index = i\n   |                          ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfp5v04it.rs:16:26\n   |\n16 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n17 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpfp5v04it.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpfp5v04it.rs:11:19\n   |\n11 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[i",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far_value;\n  return vec![max_so_far_value, max_so_far_index];\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpz3t25vsg.rs:12:24\n   |\n12 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz3t25vsg.rs:13:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n13 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz3t25vsg.rs:14:26\n   |\n9  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n14 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_index = *i;\n   |                          +\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  let max_length = 1\n\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n      max_length = 1\n    } else if numbers[i] == max_value {\n      max_length += 1\n    }\n  }\n\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpi90tvlk3.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n --> /tmp/tmpi90tvlk3.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   let max_length = 1\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpi90tvlk3.rs:8:21\n   |\n8  |   let max_length = 1\n   |                     ^ help: add `;` here\n9  | \n10 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpi90tvlk3.rs:12:29\n   |\n12 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n13 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_length`\n  --> /tmp/tmpi90tvlk3.rs:13:20\n   |\n13 |       max_index = i\n   |                    ^ help: add `;` here\n14 |       max_length = 1\n   |       ---------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpi90tvlk3.rs:20:26\n   |\n20 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n21 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpi90tvlk3.rs:11:8\n   |\n11 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpi90tvlk3.rs:12:19\n   |\n12 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = 0;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = max_so_far_index;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = max_so_far_index;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  let max_so_far_index = max_so_far_index;\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n    }\n  }\n  let max_so_far_index = max_so_far_index;\n  let max_so_far_value = max_so_far;\n  let max_so_far\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp8izvoll5.rs:49:17\n   |\n49 |   let max_so_far\n   |                 ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8izvoll5.rs:12:24\n   |\n12 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8izvoll5.rs:13:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n13 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8izvoll5.rs:14:26\n   |\n9  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n14 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8izvoll5.rs:22:24\n   |\n22 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8izvoll5.rs:23:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n23 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n23 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8izvoll5.rs:24:26\n   |\n19 |   let max_so",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value);\n    } else {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp6jiizrtu.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp6jiizrtu.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6jiizrtu.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6jiizrtu.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp6jiizrtu.rs:17:14\n   |\n17 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n      max_value = numbers[i]\n      max_index = i\n    } else {\n      result.push_back(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpn6n67dy0.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpn6n67dy0.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpn6n67dy0.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpn6n67dy0.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpn6n67dy0.rs:17:34\n   |\n17 |       result.push_back(max_value)\n   |                                  ^ help: add `;` here\n18 |       max_value = numbers[i]\n   |       --------- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpn6n67dy0.rs:18:29\n   |\n18 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n19 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpn6n67dy0.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpn6n67dy0.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let mut result = Vec::new();\n  let mut max = 0;\n  let mut index = 0;\n  for i in numbers {\n    if i > max {\n      max = i;\n      index = i;\n    }\n  }\n  for i in numbers {\n    if i == index {\n      result.push(max);\n      max = 0;\n      index = 0;\n    } else {\n      max = max if max > i else i;\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found keyword `if`\n  --> /tmp/tmpknvz304f.rs:21:17\n   |\n21 |       max = max if max > i else i;\n   |                 ^^ expected one of 8 possible tokens\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value);\n    } else {\n      result.push_back(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp6jiizrtu.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp6jiizrtu.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6jiizrtu.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp6jiizrtu.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp6jiizrtu.rs:17:14\n   |\n17 |       result.push_back(max_value);\n   |              ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the c",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max = numbers[0];\n  let max_index = 0;\n  for i in numbers.iter() {\n    if i > max {\n      max = i;\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max);\n    } else {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmplgnv8w2r.rs:9:12\n  |\n9 |     if i > max {\n  |            ^^^\n  |            |\n  |            expected `&isize`, found `isize`\n  |            help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplgnv8w2r.rs:10:13\n   |\n6  |   let max = numbers[0];\n   |             ---------- expected due to this value\n...\n10 |       max = i;\n   |             ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n10 |       max = *i;\n   |             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplgnv8w2r.rs:11:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmplgnv8w2r.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplgnv8w2r.rs:19:19\n   |\n19 |       result.push(i);\n   |                   ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |       result.push(*i);\n   |                   +\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  let max_length = 1;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n      max_length = 1;\n    } else if numbers[i] == max_value {\n      max_length += 1;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result = result.append(max_value);\n    } else {\n      result = result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpn20n9j_p.rs:10:8\n   |\n10 |     if numbers[i] > max_value {\n   |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpn20n9j_p.rs:11:19\n   |\n11 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn20n9j_p.rs:12:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n12 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n12 |       max_index = *i;\n   |                   +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpn20n9j_p.rs:14:15\n   |\n14 |     } else if numbers[i] == max_value {\n   |               ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpn20n9j_p.rs:20:10\n   |\n20 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push_back(max_value)\n    } else {\n      result.push_back(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmphqlek35_.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmphqlek35_.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphqlek35_.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphqlek35_.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmphqlek35_.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmphqlek35_.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphqlek35_.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_index_so_far = 0;\n  let max_so_far_index_so_far_index = 0;\n  let max_so_far_index_so_far_index_so_far = 0;\n  for i in numbers.iter() {\n    if (i > max_so_far) {\n      max_so_far = i;\n      max_so_far_index = i;\n      max_so_far_index_so_far = max_so_far_index_so_far_index;\n      max_so_far_index_so_far_index = max_so_far_index_so_far_index_so_far;\n    } else if (i == max_so_far) {\n      max_so_far_index_so_far_index_so_far = max_so_far_index_so_far_index;\n      max_so_far_index_so_far_index = i;\n    }\n  }\n  return numbers.map((i) => i).append(max_so_far_index_so_far_index);\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `=>`\n  --> /tmp/tmpesazlnll.rs:22:26\n   |\n22 |   return numbers.map((i) => i).append(max_so_far_index_so_far_index);\n   |                          ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_so_far = numbers[0];\n  let max_so_far_index = 0;\n  let max_so_far_value = 0;\n\n  for i in numbers.iter() {\n    let current_value = i;\n    if current_value > max_so_far {\n      max_so_far = current_value;\n      max_so_far_index = i;\n      max_so_far_value = current_value;\n    }\n  }\n\n  let max_so_far_vec = Vec::new(numbers.len() - 1);\n  for i in numbers.iter() {\n    if i == max_so_far_index {\n      max_so_far_vec.append(max_so_far_value);\n    } else {\n      max_so_far_vec.append(i);\n    }\n  }\n\n  return max_so_far_vec;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpqvj9nn8w.rs:12:24\n   |\n12 |     if current_value > max_so_far {\n   |                        ^^^^^^^^^^\n   |                        |\n   |                        expected `&isize`, found `isize`\n   |                        help: consider borrowing here: `&max_so_far`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvj9nn8w.rs:13:20\n   |\n6  |   let max_so_far = numbers[0];\n   |                    ---------- expected due to this value\n...\n13 |       max_so_far = current_value;\n   |                    ^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |       max_so_far = *current_value;\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvj9nn8w.rs:14:26\n   |\n7  |   let max_so_far_index = 0;\n   |                          - expected due to this value\n...\n14 |       max_so_far_index = i;\n   |                          ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |       max_so_far_index = *i;\n   |                          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqvj9nn8w.rs:15:26\n   |\n8  |   let max_so_far_value = 0;\n   |                          - expected due to this value\n...\n15 |       max_so_far_value = current_value;\n   |                          ^^^^^^^^^^^^^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       max_so_far_value = *current_value;\n   |                          +\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpqvj9nn8w.rs:19:24\n    |\n19  |   let max_so_far_vec = Vec::new(numbers.len() - 1);\n    |                        ^^^^^^^^ ----------------- supplied 1 argument\n    |                        |\n    |                        expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpqvj9nn8w.rs:21:10\n   |\n21 |     if i == max_so_far_index {\n   |          ^^ no implementation for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_value = numbers[0];\n  let max_index = 0;\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let max_vec = Vec::new(numbers.len() - 1);\n  for i in numbers.iter() {\n    if i < max_index {\n      max_vec = max_vec.push(numbers[i]);\n    } else {\n      max_vec = max_vec.push(max_value);\n    }\n  }\n  return max_vec;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmprh619_pz.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmprh619_pz.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprh619_pz.rs:11:19\n   |\n7  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmprh619_pz.rs:14:17\n    |\n14  |   let max_vec = Vec::new(numbers.len() - 1);\n    |                 ^^^^^^^^ ----------------- supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprh619_pz.rs:16:12\n   |\n16 |     if i < max_index {\n   |            ^^^^^^^^^\n   |            |\n   |            expected `&isize`, found integer\n   |            help: consider borrowing here: `&max_index`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmprh619_pz.rs:17:30\n   |\n17 |       max_vec = max_vec.push(numbers[i]);\n   |                              ^^^^^^^^^^ slice in",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value);\n    } else {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmp72imfqos.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp72imfqos.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp72imfqos.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp72imfqos.rs:19:19\n   |\n19 |       result.push(numbers[i]);\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&is",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value)\n    } else {\n      result.append(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpsdb_cfwc.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpsdb_cfwc.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpsdb_cfwc.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsdb_cfwc.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpsdb_cfwc.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsdb_cfwc.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb_cfwc.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0\n  let max_value = numbers[0]\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i]\n      max_index = i\n    }\n  }\n  let result = Vec::new()\n  for i in numbers.iter() {\n    if i == max_index {\n      result.push(max_value)\n    } else {\n      result.push(numbers[i])\n    }\n  }\n  return result\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n --> /tmp/tmpt_hb06v9.rs:6:20\n  |\n6 |   let max_index = 0\n  |                    ^ help: add `;` here\n7 |   let max_value = numbers[0]\n  |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n --> /tmp/tmpt_hb06v9.rs:7:29\n  |\n7 |   let max_value = numbers[0]\n  |                             ^ help: add `;` here\n8 |   for i in numbers.iter() {\n  |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpt_hb06v9.rs:10:29\n   |\n10 |       max_value = numbers[i]\n   |                             ^ help: add `;` here\n11 |       max_index = i\n   |       --------- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpt_hb06v9.rs:14:26\n   |\n14 |   let result = Vec::new()\n   |                          ^ help: add `;` here\n15 |   for i in numbers.iter() {\n   |   --- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpt_hb06v9.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpt_hb06v9.rs:10:19\n   |\n10 |       max_value = numbers[i]\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_hb06v9.rs:11:19\n   |\n6  |   let max_index = 0\n   |                   - expected due to this value\n...\n11 |       max_index = i\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider derefer",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// From a given vector of integers, generate a vector of rolling maximum element found until given moment\n/// in the sequence.\n/// >>> rolling_max(vec![1, 2, 3, 2, 3, 4, 2])\n/// vec![1, 2, 3, 3, 3, 4, 4]\nfn rolling_max(numbers: Vec<isize>) -> Vec<isize> {\n  let max_index = 0;\n  let max_value = numbers[0];\n  for i in numbers.iter() {\n    if numbers[i] > max_value {\n      max_value = numbers[i];\n      max_index = i;\n    }\n  }\n  let result = Vec::new();\n  for i in numbers.iter() {\n    if i == max_index {\n      result.append(max_value);\n    } else {\n      result.append(numbers[i]);\n    }\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = rolling_max;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, 2, 3, 4]), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 1]), vec![4, 4, 4, 4]);\n    assert_eq!(candidate(vec![3, 2, 3, 100, 3]), vec![3, 3, 3, 100, 100]);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n --> /tmp/tmpepvf21uo.rs:9:8\n  |\n9 |     if numbers[i] > max_value {\n  |        ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  |\n  = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n  = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpepvf21uo.rs:10:19\n   |\n10 |       max_value = numbers[i];\n   |                   ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:11:19\n   |\n6  |   let max_index = 0;\n   |                   - expected due to this value\n...\n11 |       max_index = i;\n   |                   ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n11 |       max_index = *i;\n   |                   +\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpepvf21uo.rs:16:10\n   |\n16 |     if i == max_index {\n   |          ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpepvf21uo.rs:17:21\n   |\n17 |       result.append(max_value);\n   |                     ^^^^^^^^^ expected `&mut Vec<_>`, found `isize`\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n                           found type `isize`\n\nerror[E0277]: the ",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}