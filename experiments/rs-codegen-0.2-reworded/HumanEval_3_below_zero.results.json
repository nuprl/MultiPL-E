{
  "name": "HumanEval_3_below_zero",
  "language": "rs",
  "prompt": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n",
  "tests": "}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.slice(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpbafza9w6.rs:15:29\n   |\n15 |     operations = operations.slice(1);\n   |                             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |     operations = operations.as_slice(1);\n   |                             ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.drop(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmpp31t7qmy.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  -----------^^^^---\n   |                  |          |\n   |                  |          explicit destructor calls not allowed\n   |                  help: consider using `drop` function: `drop(operations)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpp31t7qmy.rs:15:29\n    |\n15  |     operations = operations.drop(1);\n    |                             ^^^^ - supplied 1 argument\n    |                             |\n    |                             expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp31t7qmy.rs:15:18\n   |\n8  | fn below_zero(operations: Vec<isize>) -> bool {\n   |                           ---------- expected due to this parameter type\n...\n15 |     operations = operations.drop(1);\n   |                  ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmpp31t7qmy.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  ---------- ^^^^ this call modifies `operations` in-place\n   |                  |\n   |                  you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance = balance + i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmph_kp_3ow.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance = balance + i;\n   |     ^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    balance += operation(balance);\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `operation` in this scope\n  --> /tmp/tmpwjxy_ifm.rs:11:16\n   |\n11 |     balance += operation(balance);\n   |                ^^^^^^^^^ help: a local variable with a similar name exists: `operations`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.drop(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmpp31t7qmy.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  -----------^^^^---\n   |                  |          |\n   |                  |          explicit destructor calls not allowed\n   |                  help: consider using `drop` function: `drop(operations)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpp31t7qmy.rs:15:29\n    |\n15  |     operations = operations.drop(1);\n    |                             ^^^^ - supplied 1 argument\n    |                             |\n    |                             expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp31t7qmy.rs:15:18\n   |\n8  | fn below_zero(operations: Vec<isize>) -> bool {\n   |                           ---------- expected due to this parameter type\n...\n15 |     operations = operations.drop(1);\n   |                  ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmpp31t7qmy.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  ---------- ^^^^ this call modifies `operations` in-place\n   |                  |\n   |                  you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance = balance + i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmph_kp_3ow.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance = balance + i;\n   |     ^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations[1..];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpl84diygr.rs:15:18\n   |\n8  | fn below_zero(operations: Vec<isize>) -> bool {\n   |                           ---------- expected due to this parameter type\n...\n15 |     operations = operations[1..];\n   |                  ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n   |                  |\n   |                  expected struct `Vec`, found slice `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n               found slice `[isize]`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in 0..operations.len() {\n    if operations[i] {\n      if operations[i] < 0 {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0271]: type mismatch resolving `<usize as SliceIndex<[isize]>>::Output == bool`\n  --> /tmp/tmp50iuy_qv.rs:10:8\n   |\n10 |     if operations[i] {\n   |        ^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0271`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.slice(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpbafza9w6.rs:15:29\n   |\n15 |     operations = operations.slice(1);\n   |                             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |     operations = operations.as_slice(1);\n   |                             ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    balance += operation(balance);\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `operation` in this scope\n  --> /tmp/tmpwjxy_ifm.rs:11:16\n   |\n11 |     balance += operation(balance);\n   |                ^^^^^^^^^ help: a local variable with a similar name exists: `operations`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance = balance + i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmph_kp_3ow.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance = balance + i;\n   |     ^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance = balance + i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmph_kp_3ow.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance = balance + i;\n   |     ^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.drop(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmpp31t7qmy.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  -----------^^^^---\n   |                  |          |\n   |                  |          explicit destructor calls not allowed\n   |                  help: consider using `drop` function: `drop(operations)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpp31t7qmy.rs:15:29\n    |\n15  |     operations = operations.drop(1);\n    |                             ^^^^ - supplied 1 argument\n    |                             |\n    |                             expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp31t7qmy.rs:15:18\n   |\n8  | fn below_zero(operations: Vec<isize>) -> bool {\n   |                           ---------- expected due to this parameter type\n...\n15 |     operations = operations.drop(1);\n   |                  ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmpp31t7qmy.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  ---------- ^^^^ this call modifies `operations` in-place\n   |                  |\n   |                  you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in 0..operations.len() {\n    if operations[i] {\n      if operations[i] < 0 {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0271]: type mismatch resolving `<usize as SliceIndex<[isize]>>::Output == bool`\n  --> /tmp/tmp50iuy_qv.rs:10:8\n   |\n10 |     if operations[i] {\n   |        ^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0271`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in 0..operations.len() {\n    if operations[i] {\n      if operations[i] < 0 {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0271]: type mismatch resolving `<usize as SliceIndex<[isize]>>::Output == bool`\n  --> /tmp/tmp50iuy_qv.rs:10:8\n   |\n10 |     if operations[i] {\n   |        ^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0271`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in 0..operations.len() {\n    if operations[i] {\n      if operations[i] < 0 {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0271]: type mismatch resolving `<usize as SliceIndex<[isize]>>::Output == bool`\n  --> /tmp/tmp50iuy_qv.rs:10:8\n   |\n10 |     if operations[i] {\n   |        ^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0271`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in 0..operations.len() {\n    if operations[i] {\n      if operations[i] < 0 {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0271]: type mismatch resolving `<usize as SliceIndex<[isize]>>::Output == bool`\n  --> /tmp/tmp50iuy_qv.rs:10:8\n   |\n10 |     if operations[i] {\n   |        ^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0271`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    balance += operations[0];\n    if balance < 0 {\n      return true;\n    }\n    operations = operations.drop(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmprn7nn5_y.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  -----------^^^^---\n   |                  |          |\n   |                  |          explicit destructor calls not allowed\n   |                  help: consider using `drop` function: `drop(operations)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmprn7nn5_y.rs:15:29\n    |\n15  |     operations = operations.drop(1);\n    |                             ^^^^ - supplied 1 argument\n    |                             |\n    |                             expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprn7nn5_y.rs:15:18\n   |\n8  | fn below_zero(operations: Vec<isize>) -> bool {\n   |                           ---------- expected due to this parameter type\n...\n15 |     operations = operations.drop(1);\n   |                  ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmprn7nn5_y.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  ---------- ^^^^ this call modifies `operations` in-place\n   |                  |\n   |                  you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    if i > 0 {\n      balance += i;\n    } else {\n      balance -= i;\n      if balance < 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpalak35s9.rs:12:7\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n12 |       balance += i;\n   |       ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpalak35s9.rs:14:7\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |       balance -= i;\n   |       ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in 0..operations.len() {\n    if operations[i] {\n      if operations[i] < 0 {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0271]: type mismatch resolving `<usize as SliceIndex<[isize]>>::Output == bool`\n  --> /tmp/tmp50iuy_qv.rs:10:8\n   |\n10 |     if operations[i] {\n   |        ^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0271`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.slice(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpbafza9w6.rs:15:29\n   |\n15 |     operations = operations.slice(1);\n   |                             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |     operations = operations.as_slice(1);\n   |                             ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    balance += operation(balance);\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `operation` in this scope\n  --> /tmp/tmpwjxy_ifm.rs:11:16\n   |\n11 |     balance += operation(balance);\n   |                ^^^^^^^^^ help: a local variable with a similar name exists: `operations`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in 0..operations.len() {\n    if operations[i] {\n      if operations[i] < 0 {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0271]: type mismatch resolving `<usize as SliceIndex<[isize]>>::Output == bool`\n  --> /tmp/tmp50iuy_qv.rs:10:8\n   |\n10 |     if operations[i] {\n   |        ^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0271`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance = balance + i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmph_kp_3ow.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance = balance + i;\n   |     ^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    if i > 0 {\n      balance += i;\n    } else if i < 0 {\n      balance -= i;\n      if balance < 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpnfbp835s.rs:12:7\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n12 |       balance += i;\n   |       ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpnfbp835s.rs:14:7\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |       balance -= i;\n   |       ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    balance += operation(balance);\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `operation` in this scope\n  --> /tmp/tmpwjxy_ifm.rs:11:16\n   |\n11 |     balance += operation(balance);\n   |                ^^^^^^^^^ help: a local variable with a similar name exists: `operations`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    balance += operations[0];\n    if balance < 0 {\n      return true;\n    }\n    operations = operations.drop(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmprn7nn5_y.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  -----------^^^^---\n   |                  |          |\n   |                  |          explicit destructor calls not allowed\n   |                  help: consider using `drop` function: `drop(operations)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmprn7nn5_y.rs:15:29\n    |\n15  |     operations = operations.drop(1);\n    |                             ^^^^ - supplied 1 argument\n    |                             |\n    |                             expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprn7nn5_y.rs:15:18\n   |\n8  | fn below_zero(operations: Vec<isize>) -> bool {\n   |                           ---------- expected due to this parameter type\n...\n15 |     operations = operations.drop(1);\n   |                  ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmprn7nn5_y.rs:15:29\n   |\n15 |     operations = operations.drop(1);\n   |                  ---------- ^^^^ this call modifies `operations` in-place\n   |                  |\n   |                  you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in 0..operations.len() {\n    if operations[i] {\n      if operations[i] < 0 {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0271]: type mismatch resolving `<usize as SliceIndex<[isize]>>::Output == bool`\n  --> /tmp/tmp50iuy_qv.rs:10:8\n   |\n10 |     if operations[i] {\n   |        ^^^^^^^^^^^^^ expected `isize`, found `bool`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0271`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance = balance + i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmph_kp_3ow.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance = balance + i;\n   |     ^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.drop(0);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmpgbf3h2jx.rs:15:29\n   |\n15 |     operations = operations.drop(0);\n   |                  -----------^^^^---\n   |                  |          |\n   |                  |          explicit destructor calls not allowed\n   |                  help: consider using `drop` function: `drop(operations)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpgbf3h2jx.rs:15:29\n    |\n15  |     operations = operations.drop(0);\n    |                             ^^^^ - supplied 1 argument\n    |                             |\n    |                             expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgbf3h2jx.rs:15:18\n   |\n8  | fn below_zero(operations: Vec<isize>) -> bool {\n   |                           ---------- expected due to this parameter type\n...\n15 |     operations = operations.drop(0);\n   |                  ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmpgbf3h2jx.rs:15:29\n   |\n15 |     operations = operations.drop(0);\n   |                  ---------- ^^^^ this call modifies `operations` in-place\n   |                  |\n   |                  you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.slice(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpbafza9w6.rs:15:29\n   |\n15 |     operations = operations.slice(1);\n   |                             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |     operations = operations.as_slice(1);\n   |                             ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    balance += operation(balance);\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `operation` in this scope\n  --> /tmp/tmpwjxy_ifm.rs:11:16\n   |\n11 |     balance += operation(balance);\n   |                ^^^^^^^^^ help: a local variable with a similar name exists: `operations`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.drop(0);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0040]: explicit use of destructor method\n  --> /tmp/tmpgbf3h2jx.rs:15:29\n   |\n15 |     operations = operations.drop(0);\n   |                  -----------^^^^---\n   |                  |          |\n   |                  |          explicit destructor calls not allowed\n   |                  help: consider using `drop` function: `drop(operations)`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpgbf3h2jx.rs:15:29\n    |\n15  |     operations = operations.drop(0);\n    |                             ^^^^ - supplied 1 argument\n    |                             |\n    |                             expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgbf3h2jx.rs:15:18\n   |\n8  | fn below_zero(operations: Vec<isize>) -> bool {\n   |                           ---------- expected due to this parameter type\n...\n15 |     operations = operations.drop(0);\n   |                  ^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `drop` modifies its receiver in-place\n  --> /tmp/tmpgbf3h2jx.rs:15:29\n   |\n15 |     operations = operations.drop(0);\n   |                  ---------- ^^^^ this call modifies `operations` in-place\n   |                  |\n   |                  you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `drop`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0040, E0061, E0308.\nFor more information about an error, try `rustc --explain E0040`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance = balance + i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmph_kp_3ow.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance = balance + i;\n   |     ^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.slice(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpbafza9w6.rs:15:29\n   |\n15 |     operations = operations.slice(1);\n   |                             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |     operations = operations.as_slice(1);\n   |                             ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n    operations = operations.slice(1);\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpbafza9w6.rs:15:29\n   |\n15 |     operations = operations.slice(1);\n   |                             ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n15 |     operations = operations.as_slice(1);\n   |                             ~~~~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    balance += operation(balance);\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `operation` in this scope\n  --> /tmp/tmpwjxy_ifm.rs:11:16\n   |\n11 |     balance += operation(balance);\n   |                ^^^^^^^^^ help: a local variable with a similar name exists: `operations`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  for i in operations {\n    if i == 0 {\n      continue\n    }\n    if i < 0 {\n      return true\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpz09hyhsr.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for i in operations {\n    balance += i;\n    if balance < 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpegiomq7h.rs:11:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n10 |   for i in operations {\n11 |     balance += i;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += 1;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmpl1e07xex.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += 1;\n   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// You're given a vector of deposit and withdrawal operations on a bank account that starts with\n/// zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n/// at that point function should return true. Otherwise it should return false.\n/// >>> below_zero(vec![1, 2, 3])\n/// false\n/// >>> below_zero(vec![1, 2, -4, 5])\n/// true\nfn below_zero(operations: Vec<isize>) -> bool {\n  let balance = 0;\n  for _ in operations {\n    if balance < 0 {\n      return true;\n    }\n    balance += operations[0];\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = below_zero;\n    assert_eq!(candidate(Vec::<isize>::new()), false);\n    assert_eq!(candidate(vec![1, 2, -3, 1, 2, -3]), false);\n    assert_eq!(candidate(vec![1, 2, -4, 5, 6]), true);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n    assert_eq!(candidate(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n    assert_eq!(candidate(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n}\n",
      "timestamp": 1664293159,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `balance`\n  --> /tmp/tmp_ph8czc7.rs:14:5\n   |\n9  |   let balance = 0;\n   |       -------\n   |       |\n   |       first assignment to `balance`\n   |       help: consider making this binding mutable: `mut balance`\n...\n14 |     balance += operations[0];\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: borrow of moved value: `operations`\n   --> /tmp/tmp_ph8czc7.rs:14:16\n    |\n8   | fn below_zero(operations: Vec<isize>) -> bool {\n    |               ---------- move occurs because `operations` has type `Vec<isize>`, which does not implement the `Copy` trait\n9   |   let balance = 0;\n10  |   for _ in operations {\n    |            ---------- `operations` moved due to this implicit call to `.into_iter()`\n...\n14  |     balance += operations[0];\n    |                ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `operations`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n10  |   for _ in &operations {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}