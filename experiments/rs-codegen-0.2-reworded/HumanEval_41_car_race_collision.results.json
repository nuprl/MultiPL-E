{
  "name": "HumanEval_41_car_race_collision",
  "language": "rs",
  "prompt": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n",
  "tests": "}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1\n          cars[i] = cars[j]\n          cars[j] = i\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpzule0u_x.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpzule0u_x.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: expected `;`, found `cars`\n  --> /tmp/tmpzule0u_x.rs:19:26\n   |\n19 |           collisions += 1\n   |                          ^ help: add `;` here\n20 |           cars[i] = cars[j]\n   |           ---- unexpected token\n\nerror: expected `;`, found `cars`\n  --> /tmp/tmpzule0u_x.rs:20:28\n   |\n20 |           cars[i] = cars[j]\n   |                            ^ help: add `;` here\n21 |           cars[j] = i\n   |           ---- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpzule0u_x.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpmqki75wq.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n\n  let cars_right = n\n  let cars_left_pos = 0\n  let cars_right_pos = 0\n  let cars_left_speed = 1\n  let cars_right_speed = -1\n  let cars_left_collisions = 0\n  let cars_right_collisions = 0\n  while cars_left > 0 || cars_right > 0 {\n    if cars_left > 0 {\n      cars_left_pos += cars_left_speed\n      cars_left -= 1\n    }\n    if cars_right > 0 {\n      cars_right_pos += cars_right_speed\n      cars_right -= 1\n    }\n    if cars_left_pos > cars_right_pos {\n      cars_left_collisions += 1\n      cars_left_speed = -cars_left_speed\n    } else if cars_left_pos < cars_right_pos {\n      cars_right_collisions += 1\n      cars_right_speed = -cars_right_speed\n    }\n  }\n  return cars_left_collisions + cars_right_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp38qegulj.rs:10:20\n   |\n10 |   let cars_left = n\n   |                    ^ help: add `;` here\n11 |   let cars_right = n\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp38qegulj.rs:11:21\n   |\n11 |   let cars_right = n\n   |                     ^ help: add `;` here\n12 |   let cars_left_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp38qegulj.rs:12:24\n   |\n12 |   let cars_left_pos = 0\n   |                        ^ help: add `;` here\n13 |   let cars_right_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp38qegulj.rs:13:25\n   |\n13 |   let cars_right_pos = 0\n   |                         ^ help: add `;` here\n14 |   let cars_left_speed = 1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp38qegulj.rs:14:26\n   |\n14 |   let cars_left_speed = 1\n   |                          ^ help: add `;` here\n15 |   let cars_right_speed = -1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp38qegulj.rs:15:28\n   |\n15 |   let cars_right_speed = -1\n   |                            ^ help: add `;` here\n16 |   let cars_left_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp38qegulj.rs:16:31\n   |\n16 |   let cars_left_collisions = 0\n   |                               ^ help: add `;` here\n17 |   let cars_right_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp38qegulj.rs:17:32\n   |\n17 |   let cars_right_collisions = 0\n   |                                ^ help: add `;` here\n18 |   while cars_left > 0 || cars_right > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `cars_left`\n  --> /tmp/tmp38qegulj.rs:20:39\n   |\n20 |       cars_left_pos += cars_left_speed\n   |                                       ^ help: add `;` here\n21 |       cars_left -= 1\n   |       --------- unexpected token\n\nerror: expected ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] < cars[j] {\n          collisions += 1;\n          cars[i] += 1;\n          cars[j] -= 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpu7bpee5q.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[j] + 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpspvelv20.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] + cars[j] == 0 {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpmp695hzr.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[j];\n          cars[j] = i;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpf2g1pfn0.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpyttrr75v.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = (n - 1) - j;\n      if cars[0] > cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpfqttdf8m.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpfqttdf8m.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpfqttdf8m.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:15:7\n   |\n15 |       cars[1] = (n - 1) - j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1\n          cars[i] = cars[j]\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppqgv1nbr.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppqgv1nbr.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: expected `;`, found `cars`\n  --> /tmp/tmppqgv1nbr.rs:19:26\n   |\n19 |           collisions += 1\n   |                          ^ help: add `;` here\n20 |           cars[i] = cars[j]\n   |           ---- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmppqgv1nbr.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  let i: isize = 0;\n  let j: isize = 0;\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        cars[i] += 1;\n        cars[j] += 1;\n        if cars[i] > cars[j] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpwzoz26zn.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpwzoz26zn.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpwzoz26zn.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpwzoz26zn.rs:17:9\n   |\n17 |         cars[i] += 1;\n   |         ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpwzoz26zn.rs:18:9\n   |\n18 |         cars[j] += 1;\n   |         ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpwzoz26zn.rs:19:12\n   |\n19 |         if cars[i] > cars[j] {\n   |            ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpwzoz26zn.rs:19:22\n   |\n19 |         if cars[i] > cars[j] {\n   |                      ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let cars_left: [isize, isize] = [0, 0];\n  let cars_right: [isize, isize] = [0, 0];\n  let cars_left_left: [isize, isize] = [0, 0];\n  let cars_right_right: [isize, isize] = [0, 0];\n  let cars_left_right: [isize, isize] = [0, 0];\n  let cars_right_left: [isize, isize] = [0, 0];\n  let cars_left_left_left: [isize, isize] = [0, 0];\n  let cars_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_left: [isize, isize] = [0, 0];\n  let cars_right_left_right: [isize, isize] = [0, 0];\n  let cars_left_left_right: [isize, isize] = [0, 0];\n  let cars_right_right_left: [isize, isize] = [0, 0];\n  let cars_left_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_right_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_left_right: [isize, isize] = [0, 0];\n  let cars_right_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_left_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_left_left: [isize,\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpze59yhny.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpze59yhny.rs:31:38\n   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                                          - closing delimiter possibly meant for this\n...\n31 |   let cars_left_left_left_left_left: [isize,\n   |                                      ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpze59yhny.rs:11:24\n   |\n11 |   let cars_left: [isize, isize] = [0, 0];\n   |       ----------       ^ expected one of 7 possible tokens\n   |       |        |\n   |       |        help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpze59yhny.rs:12:25\n   |\n12 |   let cars_right: [isize, isize] = [0, 0];\n   |       -----------       ^ expected one of 7 possible tokens\n   |       |         |\n   |       |         help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpze59yhny.rs:13:29\n   |\n13 |   let cars_left_left: [isize, isize] = [0, 0];\n   |       ---------------       ^ expected one of 7 possible tokens\n   |       |             |\n   |       |             help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpze59yhny.rs:14:31\n   |\n14 |   let cars_right_right: [isize, isize] = [0, 0];\n   |       -----------------       ^ expected one of 7 possible tokens\n   |       |               |\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpx90seclk.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpx90seclk.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpx90seclk.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpmqki75wq.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else if cars[0] > cars[1] {\n        cars[0] -= 1;\n      } else {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp7oshy8ca.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp7oshy8ca.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp7oshy8ca.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:18:17\n   |\n18 |       } else if cars[0] > cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:18:27\n   |\n18 |       } else if cars[0] > cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let cars_left: [isize, isize] = [0, 0];\n  let cars_right: [isize, isize] = [0, 0];\n  let cars_left_left: [isize, isize] = [0, 0];\n  let cars_left_right: [isize, isize] = [0, 0];\n  let cars_right_left: [isize, isize] = [0, 0];\n  let cars_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left: [isize, isize] = [0, 0];\n  let cars_right_left_right: [isize, isize] = [0, 0];\n  let cars_right_right_left: [isize, isize] = [0, 0];\n  let cars_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_left_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_left_left: [isize, isize] = [0, 0];\n  let cars_left_right_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_right_left: [isize, isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp1wmlgfrd.rs:31:35\n   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                                          - closing delimiter possibly meant for this\n...\n31 |   let cars_left_right_right_left: [isize, isize\n   |                                   ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:11:24\n   |\n11 |   let cars_left: [isize, isize] = [0, 0];\n   |       ----------       ^ expected one of 7 possible tokens\n   |       |        |\n   |       |        help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:12:25\n   |\n12 |   let cars_right: [isize, isize] = [0, 0];\n   |       -----------       ^ expected one of 7 possible tokens\n   |       |         |\n   |       |         help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:13:29\n   |\n13 |   let cars_left_left: [isize, isize] = [0, 0];\n   |       ---------------       ^ expected one of 7 possible tokens\n   |       |             |\n   |       |             help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:14:30\n   |\n14 |   let cars_left_right: [isize, isize] = [0, 0];\n   |       ----------------       ^ expected one of 7 possible tokens\n   |       |              |\n   |  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpx90seclk.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpx90seclk.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpx90seclk.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          collisions += car_race_collision(cars[0] + 1);\n        }\n      } else if cars[0] > cars[1] {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        } else {\n          collisions += car_race_collision(cars[1] + 1);\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp271w7j7s.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp271w7j7s.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp271w7j7s.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp271w7j7s.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp271w7j7s.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp271w7j7s.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp271w7j7s.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp271w7j7s.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp271w7j7s.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp271w7j7s.rs:20:44\n   |\n20 |           collisions += car_race_collision(cars[0] + 1);\n   |                                            ^",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1\n          cars[i] = cars[n]\n          cars[j] = cars[n]\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpp0qy2h6j.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpp0qy2h6j.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: expected `;`, found `cars`\n  --> /tmp/tmpp0qy2h6j.rs:19:26\n   |\n19 |           collisions += 1\n   |                          ^ help: add `;` here\n20 |           cars[i] = cars[n]\n   |           ---- unexpected token\n\nerror: expected `;`, found `cars`\n  --> /tmp/tmpp0qy2h6j.rs:20:28\n   |\n20 |           cars[i] = cars[n]\n   |                            ^ help: add `;` here\n21 |           cars[j] = cars[n]\n   |           ---- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpp0qy2h6j.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  let car_index: isize = 0;\n  let car_index_inc: isize = 1;\n  let car_index_dec: isize = -1;\n  let car_index_inc_dec: isize = 1;\n  let car_index_dec_inc: isize = -1;\n  let car_index_inc_dec_inc: isize = 1;\n  let car_index_dec_inc_dec: isize = -1;\n  let car_index_dec_dec_inc: isize = -1;\n  let car_index_dec_dec_dec: isize = -1;\n  let car_index_inc_dec_dec: isize = 1;\n  let car_index_dec_dec_dec_inc: isize = -1;\n  let car_index_inc_dec_dec_dec: isize = 1;\n  let car_index_inc_dec_dec_dec_inc: isize = -1;\n  let car_index_inc_dec_dec_dec_dec: isize = 1;\n  let car_index_inc_dec_dec_dec_dec_inc: isize = -1;\n  let car_index_inc_dec_dec_dec_dec_dec: isize = 1;\n  let car_index_inc_dec_dec_dec_dec_dec_inc: isize = -1;\n  let car_index_inc_dec_dec_dec_dec_dec_dec: isize = 1;\n  let car_index_inc_dec_dec_dec_dec_dec_dec_inc: isize = -1;\n  let car_index_inc_dec_dec_dec_dec_dec_dec_dec: isize = 1;\n  let car_index_inc_dec_dec_dec_dec_dec_dec_dec_inc: isize = -1;\n  let car_index_inc_dec_dec_dec_dec_dec_dec_dec_dec: isize = 1;\n  let car_index_inc_dec_dec\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpz8tjvyxe.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpz8tjvyxe.rs:34:28\n   |\n34 |   let car_index_inc_dec_dec\n   |                            ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpz8tjvyxe.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpz8tjvyxe.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0308]: mismatched types\n --> /tmp/tmpz8tjvyxe.rs:9:36\n  |\n9 | fn car_race_collision(n: isize) -> isize {\n  |    ------------------              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else if cars[0] > cars[1] {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxqu6o5sn.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:20:17\n   |\n20 |       } else if cars[0] > cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `car",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else {\n          cars[i] -= 1;\n        }\n      }\n    }\n  }\n  for i in 0..n {\n    if cars[i] < 0 {\n      collisions += 1;\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpyy778g93.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i == j {\n        continue;\n      }\n      if cars[i] < cars[j] {\n        cars[i] += 1;\n      } else if cars[i] > cars[j] {\n        cars[j] += 1;\n      } else {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpztng8lig.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpto4_05io.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpto4_05io.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpto4_05io.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = make(n, 0);\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `make` in this scope\n  --> /tmp/tmp7kihsblr.rs:10:14\n   |\n10 |   let cars = make(n, 0);\n   |              ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n\n  let cars_right = n\n  let cars_left_pos = 0\n  let cars_right_pos = 0\n  let cars_left_speed = 1\n  let cars_right_speed = -1\n  let cars_left_collisions = 0\n  let cars_right_collisions = 0\n  while cars_left > 0 || cars_right > 0 {\n    if cars_left > 0 {\n      cars_left_pos += cars_left_speed\n      cars_left -= 1\n    }\n    if cars_right > 0 {\n      cars_right_pos += cars_right_speed\n      cars_right -= 1\n    }\n    if cars_left_pos > cars_right_pos {\n      cars_left_collisions += 1\n    } else if cars_left_pos < cars_right_pos {\n      cars_right_collisions += 1\n    }\n  }\n  return cars_left_collisions + cars_right_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphccyi77_.rs:10:20\n   |\n10 |   let cars_left = n\n   |                    ^ help: add `;` here\n11 |   let cars_right = n\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphccyi77_.rs:11:21\n   |\n11 |   let cars_right = n\n   |                     ^ help: add `;` here\n12 |   let cars_left_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphccyi77_.rs:12:24\n   |\n12 |   let cars_left_pos = 0\n   |                        ^ help: add `;` here\n13 |   let cars_right_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphccyi77_.rs:13:25\n   |\n13 |   let cars_right_pos = 0\n   |                         ^ help: add `;` here\n14 |   let cars_left_speed = 1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphccyi77_.rs:14:26\n   |\n14 |   let cars_left_speed = 1\n   |                          ^ help: add `;` here\n15 |   let cars_right_speed = -1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphccyi77_.rs:15:28\n   |\n15 |   let cars_right_speed = -1\n   |                            ^ help: add `;` here\n16 |   let cars_left_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmphccyi77_.rs:16:31\n   |\n16 |   let cars_left_collisions = 0\n   |                               ^ help: add `;` here\n17 |   let cars_right_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmphccyi77_.rs:17:32\n   |\n17 |   let cars_right_collisions = 0\n   |                                ^ help: add `;` here\n18 |   while cars_left > 0 || cars_right > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `cars_left`\n  --> /tmp/tmphccyi77_.rs:20:39\n   |\n20 |       cars_left_pos += cars_left_speed\n   |                                       ^ help: add `;` here\n21 |       cars_left -= 1\n   |       --------- unexpected token\n\nerror: expected ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1\n        } else {\n          collisions += 1\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbn9anu21.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbn9anu21.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpbn9anu21.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = make(n, 0);\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `make` in this scope\n  --> /tmp/tmp7kihsblr.rs:10:14\n   |\n10 |   let cars = make(n, 0);\n   |              ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i == j {\n        continue;\n      }\n      if cars[i] < cars[j] {\n        cars[i] += 1;\n      } else {\n        cars[i] -= 1;\n      }\n      if cars[i] < cars[j] {\n        cars[j] += 1;\n      } else {\n        cars[j] -= 1;\n      }\n      if cars[i] == cars[j] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmp_jnl1omn.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else if cars[0] > cars[1] {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpajqsxu5e.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpajqsxu5e.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpajqsxu5e.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpajqsxu5e.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpajqsxu5e.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpajqsxu5e.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpajqsxu5e.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpajqsxu5e.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpajqsxu5e.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpajqsxu5e.rs:20:17\n   |\n20 |       } else if cars[0] > cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `car",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n          cars[j] -= 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmp1etwe7zs.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = make(n, 0);\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] + cars[j] == 0 {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `make` in this scope\n  --> /tmp/tmpi_fp9yya.rs:10:14\n   |\n10 |   let cars = make(n, 0);\n   |              ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[j] + 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpme0u3xgw.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpx90seclk.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpx90seclk.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpx90seclk.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx90seclk.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n;\n  let cars_right = n;\n  let collisions = 0;\n  while cars_left > 0 || cars_right > 0 {\n    if cars_left > 0 {\n      cars_left -= 1;\n      cars_right += 1;\n    } else {\n      cars_left += 1;\n      cars_right -= 1;\n    }\n    collisions += 1;\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `cars_left`\n  --> /tmp/tmpc_jt1i_y.rs:15:7\n   |\n10 |   let cars_left = n;\n   |       ---------\n   |       |\n   |       first assignment to `cars_left`\n   |       help: consider making this binding mutable: `mut cars_left`\n...\n15 |       cars_left -= 1;\n   |       ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `cars_right`\n  --> /tmp/tmpc_jt1i_y.rs:16:7\n   |\n11 |   let cars_right = n;\n   |       ----------\n   |       |\n   |       first assignment to `cars_right`\n   |       help: consider making this binding mutable: `mut cars_right`\n...\n16 |       cars_right += 1;\n   |       ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `cars_left`\n  --> /tmp/tmpc_jt1i_y.rs:18:7\n   |\n10 |   let cars_left = n;\n   |       ---------\n   |       |\n   |       first assignment to `cars_left`\n   |       help: consider making this binding mutable: `mut cars_left`\n...\n18 |       cars_left += 1;\n   |       ^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `cars_right`\n  --> /tmp/tmpc_jt1i_y.rs:19:7\n   |\n11 |   let cars_right = n;\n   |       ----------\n   |       |\n   |       first assignment to `cars_right`\n   |       help: consider making this binding mutable: `mut cars_right`\n...\n19 |       cars_right -= 1;\n   |       ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `collisions`\n  --> /tmp/tmpc_jt1i_y.rs:21:5\n   |\n12 |   let collisions = 0;\n   |       ----------\n   |       |\n   |       first assignment to `collisions`\n   |       help: consider making this binding mutable: `mut collisions`\n...\n21 |     collisions += 1;\n   |     ^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n\n  let cars_right = n\n  let cars_left_pos = 0\n  let cars_right_pos = 0\n  let cars_left_speed = 1\n  let cars_right_speed = -1\n  let cars_left_collision = 0\n  let cars_right_collision = 0\n  let cars_left_collision_count = 0\n  let cars_right_collision_count = 0\n  let cars_left_collision_count_max = 0\n  let cars_right_collision_count_max = 0\n  let cars_left_collision_count_min = 0\n  let cars_right_collision_count_min = 0\n  let cars_left_collision_count_sum = 0\n  let cars_right_collision_count_sum = 0\n  let cars_left_collision_count_sum_max = 0\n  let cars_right_collision_count_sum_max = 0\n  let cars_left_collision_count_sum_min = 0\n  let cars_right_collision_count_sum_min = 0\n  let cars_left_collision_count_sum_sum = 0\n  let cars_right_collision_count_sum_sum = 0\n  let cars_left_collision_count_sum_sum_max = 0\n  let cars_right_collision_count_sum_sum_max = 0\n  let cars_left_collision_count_sum_sum_min = 0\n  let cars_right_collision_count_sum_sum_min = 0\n  let cars_left_collision_count_sum_sum_sum = 0\n  let cars_right_collision_count_sum_sum_sum = 0\n  let cars_left_collision_count_sum_sum_sum_max = 0\n  let cars_right_collision_count_sum_sum_sum_max = 0\n  let cars_left_collision_count_sum_sum_sum_min = 0\n  let cars_right_collision_count_sum_sum_sum_min = 0\n  let cars_left_collision_count_sum_sum_sum_\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:10:20\n   |\n10 |   let cars_left = n\n   |                    ^ help: add `;` here\n11 |   let cars_right = n\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:11:21\n   |\n11 |   let cars_right = n\n   |                     ^ help: add `;` here\n12 |   let cars_left_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:12:24\n   |\n12 |   let cars_left_pos = 0\n   |                        ^ help: add `;` here\n13 |   let cars_right_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:13:25\n   |\n13 |   let cars_right_pos = 0\n   |                         ^ help: add `;` here\n14 |   let cars_left_speed = 1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:14:26\n   |\n14 |   let cars_left_speed = 1\n   |                          ^ help: add `;` here\n15 |   let cars_right_speed = -1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:15:28\n   |\n15 |   let cars_right_speed = -1\n   |                            ^ help: add `;` here\n16 |   let cars_left_collision = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:16:30\n   |\n16 |   let cars_left_collision = 0\n   |                              ^ help: add `;` here\n17 |   let cars_right_collision = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:17:31\n   |\n17 |   let cars_right_collision = 0\n   |                               ^ help: add `;` here\n18 |   let cars_left_collision_count = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp5k3y4t42.rs:18:36\n   |\n18 |   let cars_left_collision_count = 0\n   |                                    ^ help: add `;` here\n19 |   let cars_right_collision_count = 0\n   |   --- unexpected token\n\nerror: expected `;`, found key",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = (n - 1) - j;\n      if cars[0] > cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpfqttdf8m.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpfqttdf8m.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpfqttdf8m.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:15:7\n   |\n15 |       cars[1] = (n - 1) - j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] < cars[j] {\n          collisions += 1;\n          cars[i] += 1;\n          cars[j] -= 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpu7bpee5q.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = (n - 1) - j;\n      if cars[0] < cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp93czfjj1.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp93czfjj1.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp93czfjj1.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp93czfjj1.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp93czfjj1.rs:15:7\n   |\n15 |       cars[1] = (n - 1) - j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp93czfjj1.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp93czfjj1.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let cars_left: [isize, isize] = [0, 0];\n  let cars_right: [isize, isize] = [0, 0];\n  let cars_left_left: [isize, isize] = [0, 0];\n  let cars_left_right: [isize, isize] = [0, 0];\n  let cars_right_left: [isize, isize] = [0, 0];\n  let cars_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left: [isize, isize] = [0, 0];\n  let cars_right_left_right: [isize, isize] = [0, 0];\n  let cars_right_right_left: [isize, isize] = [0, 0];\n  let cars_right_right_right: [isize, isize] = [0, 0];\n\n  for i in 0..n {\n    cars[i] = i;\n    cars_left[i] = i;\n    cars_right[i] = i;\n    cars_left_left[i] = i;\n    cars_left_right[i] = i;\n    cars_right_left[i] = i;\n    cars_right_right[i] = i;\n    cars_left_left_left[i] = i;\n    cars_left_left_right[i] = i;\n    cars_left_right_left[i] = i;\n    cars_left_right_right[i] = i;\n    cars_right_left_left[i] = i;\n    cars_right_left_\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp3ywbecl7.rs:49:3\n   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                                          - unclosed delimiter\n...\n26 |   for i in 0..n {\n   |                 - this delimiter might not be properly closed...\n...\n40 | }\n   | - ...as it matches this but it has different indentation\n...\n49 | }\n   |   ^\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp3ywbecl7.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp3ywbecl7.rs:11:24\n   |\n11 |   let cars_left: [isize, isize] = [0, 0];\n   |       ----------       ^ expected one of 7 possible tokens\n   |       |        |\n   |       |        help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp3ywbecl7.rs:12:25\n   |\n12 |   let cars_right: [isize, isize] = [0, 0];\n   |       -----------       ^ expected one of 7 possible tokens\n   |       |         |\n   |       |         help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp3ywbecl7.rs:13:29\n   |\n13 |   let cars_left_left: [isize, isize] = [0, 0];\n   |       ---------------       ^ expected one of 7 possible tokens\n   |       |             |\n   |       |             help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp3ywbecl7.rs:14:30\n   |\n14 |   let cars_left_right: [isize, isize] = [0, 0];\n   |       ----------------       ^ expected one of 7 possible tokens\n   |       |         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = (n - 1) - j;\n      if cars[0] < cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp93czfjj1.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp93czfjj1.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp93czfjj1.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp93czfjj1.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp93czfjj1.rs:15:7\n   |\n15 |       cars[1] = (n - 1) - j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp93czfjj1.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp93czfjj1.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpmqki75wq.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = make_array(n);\n  let collisions = 0;\n  for (i in 0..n) {\n    cars[i] = i;\n  }\n  for (i in 0..n) {\n    for (j in 0..n) {\n      if (i < j) {\n        if (cars[i] + 1 == cars[j]) {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpw8w7mpic.rs:12:10\n   |\n12 |   for (i in 0..n) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpw8w7mpic.rs:12:7\n   |\n12 |   for (i in 0..n) {\n   |       ^         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n12 -   for (i in 0..n) {\n12 +   for i in 0..n {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpw8w7mpic.rs:15:10\n   |\n15 |   for (i in 0..n) {\n   |          ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpw8w7mpic.rs:15:7\n   |\n15 |   for (i in 0..n) {\n   |       ^         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n15 -   for (i in 0..n) {\n15 +   for i in 0..n {\n   | \n\nerror: expected one of `)`, `,`, `@`, or `|`, found keyword `in`\n  --> /tmp/tmpw8w7mpic.rs:16:12\n   |\n16 |     for (j in 0..n) {\n   |            ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpw8w7mpic.rs:16:9\n   |\n16 |     for (j in 0..n) {\n   |         ^         ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n16 -     for (j in 0..n) {\n16 +     for j in 0..n {\n   | \n\nerror[E0425]: cannot find function `make_array` in this scope\n  --> /tmp/tmpw8w7mpic.rs:10:14\n   |\n10 |   let cars = make_array(n);\n   |              ^^^^^^^^^^ not found in this scope\n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw8w7mpic.rs:17:10\n   |\n17 |       if (i < j) {\n   |          ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -       if (i < j) {\n17 +       if i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw8w7mpic.rs:18:12\n   |\n18 |         if (cars[i] + 1 == cars[j]) {\n   |            ^                      ^\n   |\nhelp: remove these parentheses\n   |\n18 -         if (cars[i] + 1 == cars[j]) {\n18 +         if cars[",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n\n  let cars_right = n\n  let cars_left_count = 0\n  let cars_right_count = 0\n  let cars_left_left = 0\n  let cars_left_right = 0\n  let cars_right_left = 0\n  let cars_right_right = 0\n  let cars_left_left_count = 0\n  let cars_left_right_count = 0\n  let cars_right_left_count = 0\n  let cars_right_right_count = 0\n  let cars_left_left_left = 0\n  let cars_left_left_right = 0\n  let cars_left_right_left = 0\n  let cars_left_right_right = 0\n  let cars_right_left_left = 0\n  let cars_right_left_right = 0\n  let cars_right_right_left = 0\n  let cars_right_right_right = 0\n  let cars_left_left_left_count = 0\n  let cars_left_left_right_count = 0\n  let cars_left_right_left_count = 0\n  let cars_left_right_right_count = 0\n  let cars_right_left_left_count = 0\n  let cars_right_left_right_count = 0\n  let cars_right_right_left_count = 0\n  let cars_right_right_right_count = 0\n  let cars_left_left_left_left = 0\n  let cars_left_left_left_right = 0\n  let cars_left_left_right_left = 0\n  let cars_left_left_right_right = 0\n  let cars_left_right_left_left = 0\n  let cars_left_right_left_right = 0\n  let cars_left_right_right_left = 0\n  let cars_left_right_right_right = 0\n  let cars_right_left_left_left = 0\n  let cars_right_left_left_right = 0\n  let cars_right_left_right_left = 0\n  let cars_right_left_right_right = 0\n  let cars_right_right_left_left =\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:10:20\n   |\n10 |   let cars_left = n\n   |                    ^ help: add `;` here\n11 |   let cars_right = n\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:11:21\n   |\n11 |   let cars_right = n\n   |                     ^ help: add `;` here\n12 |   let cars_left_count = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:12:26\n   |\n12 |   let cars_left_count = 0\n   |                          ^ help: add `;` here\n13 |   let cars_right_count = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:13:27\n   |\n13 |   let cars_right_count = 0\n   |                           ^ help: add `;` here\n14 |   let cars_left_left = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:14:25\n   |\n14 |   let cars_left_left = 0\n   |                         ^ help: add `;` here\n15 |   let cars_left_right = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:15:26\n   |\n15 |   let cars_left_right = 0\n   |                          ^ help: add `;` here\n16 |   let cars_right_left = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:16:26\n   |\n16 |   let cars_right_left = 0\n   |                          ^ help: add `;` here\n17 |   let cars_right_right = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:17:27\n   |\n17 |   let cars_right_right = 0\n   |                           ^ help: add `;` here\n18 |   let cars_left_left_count = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:18:31\n   |\n18 |   let cars_left_left_count = 0\n   |                               ^ help: add `;` here\n19 |   let cars_left_right_count = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpzei005ct.rs:19:3",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] < cars[j] {\n          collisions += 1;\n          cars[i] = cars[j];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpuzrre1yl.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n\n  let cars_right = n\n  let cars_left_pos = 0\n  let cars_right_pos = 0\n  let cars_left_speed = 1\n  let cars_right_speed = -1\n  let cars_left_collisions = 0\n  let cars_right_collisions = 0\n  while cars_left > 0 || cars_right > 0 {\n    if cars_left > 0 {\n      cars_left_pos += cars_left_speed\n      cars_left -= 1\n    }\n    if cars_right > 0 {\n      cars_right_pos += cars_right_speed\n      cars_right -= 1\n    }\n    if cars_left_pos > cars_right_pos {\n      cars_left_collisions += 1\n    } else if cars_right_pos > cars_left_pos {\n      cars_right_collisions += 1\n    }\n  }\n  return cars_left_collisions + cars_right_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpwhxon626.rs:10:20\n   |\n10 |   let cars_left = n\n   |                    ^ help: add `;` here\n11 |   let cars_right = n\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpwhxon626.rs:11:21\n   |\n11 |   let cars_right = n\n   |                     ^ help: add `;` here\n12 |   let cars_left_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpwhxon626.rs:12:24\n   |\n12 |   let cars_left_pos = 0\n   |                        ^ help: add `;` here\n13 |   let cars_right_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpwhxon626.rs:13:25\n   |\n13 |   let cars_right_pos = 0\n   |                         ^ help: add `;` here\n14 |   let cars_left_speed = 1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpwhxon626.rs:14:26\n   |\n14 |   let cars_left_speed = 1\n   |                          ^ help: add `;` here\n15 |   let cars_right_speed = -1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpwhxon626.rs:15:28\n   |\n15 |   let cars_right_speed = -1\n   |                            ^ help: add `;` here\n16 |   let cars_left_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpwhxon626.rs:16:31\n   |\n16 |   let cars_left_collisions = 0\n   |                               ^ help: add `;` here\n17 |   let cars_right_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpwhxon626.rs:17:32\n   |\n17 |   let cars_right_collisions = 0\n   |                                ^ help: add `;` here\n18 |   while cars_left > 0 || cars_right > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `cars_left`\n  --> /tmp/tmpwhxon626.rs:20:39\n   |\n20 |       cars_left_pos += cars_left_speed\n   |                                       ^ help: add `;` here\n21 |       cars_left -= 1\n   |       --------- unexpected token\n\nerror: expected ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n\n  let cars_right = n\n  let cars_left_pos = 0\n  let cars_right_pos = 0\n  let cars_left_speed = 1\n  let cars_right_speed = -1\n  let cars_left_collisions = 0\n  let cars_right_collisions = 0\n  while cars_left > 0 || cars_right > 0 {\n    if cars_left > 0 {\n      if cars_left_pos < cars_left_speed {\n        cars_left_pos += 1\n      } else {\n        cars_left_pos = 0\n        cars_left -= 1\n      }\n    }\n    if cars_right > 0 {\n      if cars_right_pos < cars_right_speed {\n        cars_right_pos += 1\n      } else {\n        cars_right_pos = 0\n        cars_right -= 1\n      }\n    }\n    if cars_left_pos == cars_right_pos {\n      cars_left_collisions += 1\n      cars_right_collisions += 1\n    }\n  }\n  return cars_left_collisions + cars_right_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpna0ytm2s.rs:10:20\n   |\n10 |   let cars_left = n\n   |                    ^ help: add `;` here\n11 |   let cars_right = n\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpna0ytm2s.rs:11:21\n   |\n11 |   let cars_right = n\n   |                     ^ help: add `;` here\n12 |   let cars_left_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpna0ytm2s.rs:12:24\n   |\n12 |   let cars_left_pos = 0\n   |                        ^ help: add `;` here\n13 |   let cars_right_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpna0ytm2s.rs:13:25\n   |\n13 |   let cars_right_pos = 0\n   |                         ^ help: add `;` here\n14 |   let cars_left_speed = 1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpna0ytm2s.rs:14:26\n   |\n14 |   let cars_left_speed = 1\n   |                          ^ help: add `;` here\n15 |   let cars_right_speed = -1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpna0ytm2s.rs:15:28\n   |\n15 |   let cars_right_speed = -1\n   |                            ^ help: add `;` here\n16 |   let cars_left_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpna0ytm2s.rs:16:31\n   |\n16 |   let cars_left_collisions = 0\n   |                               ^ help: add `;` here\n17 |   let cars_right_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpna0ytm2s.rs:17:32\n   |\n17 |   let cars_right_collisions = 0\n   |                                ^ help: add `;` here\n18 |   while cars_left > 0 || cars_right > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `cars_left`\n  --> /tmp/tmpna0ytm2s.rs:23:26\n   |\n23 |         cars_left_pos = 0\n   |                          ^ help: add `;` here\n24 |         cars_left -= 1\n   |         --------- unexpected token\n\nerror: expected `;`, found `cars_right",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1\n        } else {\n          collisions += 1\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbn9anu21.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbn9anu21.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpbn9anu21.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          cars[i] = cars[j] + 1;\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmp3ta9d_w1.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else {\n          cars[i] -= 1;\n        }\n      }\n    }\n  }\n  for i in 0..n {\n    if cars[i] != i {\n      collisions += 1;\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmp2tcircuo.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmppgtr4ww2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpmitzspxn.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = make(n, 0);\n  let collisions = 0;\n  let left_to_right = 0;\n  let right_to_left = 0;\n  let left_to_right_collisions = 0;\n  let right_to_left_collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    let car_i = cars[i];\n    let car_i_left = car_i - 1;\n    let car_i_right = car_i + 1;\n    if car_i_left < 0 {\n      car_i_left = n - 1;\n    }\n    if car_i_right >= n {\n      car_i_right = 0;\n    }\n    if cars[car_i_left] < cars[car_i_right] {\n      left_to_right += 1;\n      if cars[car_i_left] == cars[car_i_right] {\n        left_to_right_collisions += 1;\n      }\n    } else if cars[car_i_left] > cars[car_i_right] {\n      right_to_left += 1;\n      if cars[car_i_left] == cars[car_i_right] {\n        right_to_left_collisions += 1;\n      }\n    }\n  }\n  collisions = left_to_right_collisions + right_to_left_collisions;\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `make` in this scope\n  --> /tmp/tmpgnmcf2t4.rs:10:14\n   |\n10 |   let cars = make(n, 0);\n   |              ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[j] = i;\n          break;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmp1wzhr1ib.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          cars[i] = cars[j] + 1\n          collisions += 1\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpv__e1v85.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpv__e1v85.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: expected `;`, found `collisions`\n  --> /tmp/tmpv__e1v85.rs:19:32\n   |\n19 |           cars[i] = cars[j] + 1\n   |                                ^ help: add `;` here\n20 |           collisions += 1\n   |           ---------- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpv__e1v85.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1\n        } else {\n          collisions += 1\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbn9anu21.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbn9anu21.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpbn9anu21.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = make(n, 0);\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          collisions += 1;\n          cars[i] += 1;\n          cars[j] -= 1;\n        } else {\n          cars[i] -= 1;\n          cars[j] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `make` in this scope\n  --> /tmp/tmpc9y_hq9a.rs:10:14\n   |\n10 |   let cars = make(n, 0);\n   |              ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else if cars[0] > cars[1] {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxqu6o5sn.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:20:17\n   |\n20 |       } else if cars[0] > cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `car",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1\n        } else {\n          collisions += 1\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbn9anu21.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbn9anu21.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpbn9anu21.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp5i2n6mak.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp5i2n6mak.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp5i2n6mak.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp5i2n6mak.rs:13:5\n   |\n13 |     cars[i] = i;\n   |     ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp5i2n6mak.rs:18:12\n   |\n18 |         if cars[i] < cars[j] {\n   |            ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp5i2n6mak.rs:18:22\n   |\n18 |         if cars[i] < cars[j] {\n   |                      ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp5i2n6mak.rs:19:11\n   |\n19 |           cars[i] += 1;\n   |           ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp5i2n6mak.rs:20:19\n   |\n20 |         } else if cars[i] > cars[j] {\n   |                   ^^^^^^^\n   |\n   = help: to access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp5i2n6mak.rs:20:29\n   |\n20 |         } else if cars[i] > cars[j] {\n   |                             ^^^^^^^\n   |\n   = help: t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n\n  let cars_right = n\n  let cars_left_pos = 0\n  let cars_right_pos = 0\n  let cars_left_speed = 1\n  let cars_right_speed = -1\n  let cars_left_collisions = 0\n  let cars_right_collisions = 0\n  while cars_left > 0 || cars_right > 0 {\n    if cars_left > 0 {\n      if cars_left_pos + cars_left_speed < cars_right_pos {\n        cars_left_collisions += 1\n        cars_left_pos += cars_left_speed\n        cars_left -= 1\n      } else {\n        cars_left_pos += cars_left_speed\n        cars_left -= 1\n      }\n    }\n    if cars_right > 0 {\n      if cars_right_pos + cars_right_speed > cars_left_pos {\n        cars_right_collisions += 1\n        cars_right_pos += cars_right_speed\n        cars_right -= 1\n      } else {\n        cars_right_pos += cars_right_speed\n        cars_right -= 1\n      }\n    }\n  }\n  return cars_left_collisions + cars_right_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9k56k6nc.rs:10:20\n   |\n10 |   let cars_left = n\n   |                    ^ help: add `;` here\n11 |   let cars_right = n\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9k56k6nc.rs:11:21\n   |\n11 |   let cars_right = n\n   |                     ^ help: add `;` here\n12 |   let cars_left_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9k56k6nc.rs:12:24\n   |\n12 |   let cars_left_pos = 0\n   |                        ^ help: add `;` here\n13 |   let cars_right_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9k56k6nc.rs:13:25\n   |\n13 |   let cars_right_pos = 0\n   |                         ^ help: add `;` here\n14 |   let cars_left_speed = 1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9k56k6nc.rs:14:26\n   |\n14 |   let cars_left_speed = 1\n   |                          ^ help: add `;` here\n15 |   let cars_right_speed = -1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9k56k6nc.rs:15:28\n   |\n15 |   let cars_right_speed = -1\n   |                            ^ help: add `;` here\n16 |   let cars_left_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp9k56k6nc.rs:16:31\n   |\n16 |   let cars_left_collisions = 0\n   |                               ^ help: add `;` here\n17 |   let cars_right_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmp9k56k6nc.rs:17:32\n   |\n17 |   let cars_right_collisions = 0\n   |                                ^ help: add `;` here\n18 |   while cars_left > 0 || cars_right > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `cars_left_pos`\n  --> /tmp/tmp9k56k6nc.rs:21:34\n   |\n21 |         cars_left_collisions += 1\n   |                                  ^ help: add `;` here\n22 |         cars_left_pos += cars_left_speed\n   |         ------------- unexpected tok",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpmqki75wq.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = make(n, 0);\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        let x = cars[i];\n        let y = cars[j];\n        let x_next = cars[(i + 1) % n];\n        let y_next = cars[(j + 1) % n];\n        if x < y {\n          if x_next > y {\n            collisions += 1;\n          }\n        } else {\n          if y_next > x {\n            collisions += 1;\n          }\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `make` in this scope\n  --> /tmp/tmpu9ojnxrt.rs:10:14\n   |\n10 |   let cars = make(n, 0);\n   |              ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else if cars[0] > cars[1] {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxqu6o5sn.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:20:17\n   |\n20 |       } else if cars[0] > cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `car",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1\n          cars[i] = cars[n]\n          cars[j] = cars[n]\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpp0qy2h6j.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpp0qy2h6j.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: expected `;`, found `cars`\n  --> /tmp/tmpp0qy2h6j.rs:19:26\n   |\n19 |           collisions += 1\n   |                          ^ help: add `;` here\n20 |           cars[i] = cars[n]\n   |           ---- unexpected token\n\nerror: expected `;`, found `cars`\n  --> /tmp/tmpp0qy2h6j.rs:20:28\n   |\n20 |           cars[i] = cars[n]\n   |                            ^ help: add `;` here\n21 |           cars[j] = cars[n]\n   |           ---- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpp0qy2h6j.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1\n        } else if cars[i] > cars[j] {\n          cars[j] += 1\n        } else {\n          collisions += 1\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_h9z6717.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_h9z6717.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmp_h9z6717.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[j];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpjsuv4b5z.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = (n - 1) - j;\n      if cars[0] > cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpfqttdf8m.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpfqttdf8m.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpfqttdf8m.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:15:7\n   |\n15 |       cars[1] = (n - 1) - j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[j];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpo4m_u77i.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpmqki75wq.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else if cars[0] < cars[1] {\n        cars[0] += 1;\n        cars[1] -= 1;\n      } else {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpufvkyymq.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpufvkyymq.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpufvkyymq.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpufvkyymq.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpufvkyymq.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpufvkyymq.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpufvkyymq.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpufvkyymq.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpufvkyymq.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpufvkyymq.rs:19:17\n   |\n19 |       } else if cars[0] < cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of ty",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars_left = n\n  let cars_right = n\n  let cars_left_pos = 0\n  let cars_right_pos = 0\n  let cars_left_vel = 1\n  let cars_right_vel = -1\n  let cars_left_collisions = 0\n  let cars_right_collisions = 0\n  while cars_left > 0 || cars_right > 0 {\n    if cars_left > 0 {\n      cars_left_pos += cars_left_vel\n      cars_left -= 1\n    }\n    if cars_right > 0 {\n      cars_right_pos += cars_right_vel\n      cars_right -= 1\n    }\n    if cars_left_pos > cars_right_pos {\n      cars_left_collisions += 1\n    } else if cars_left_pos < cars_right_pos {\n      cars_right_collisions += 1\n    }\n  }\n  return cars_left_collisions + cars_right_collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpb_rmmyou.rs:10:20\n   |\n10 |   let cars_left = n\n   |                    ^ help: add `;` here\n11 |   let cars_right = n\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb_rmmyou.rs:11:21\n   |\n11 |   let cars_right = n\n   |                     ^ help: add `;` here\n12 |   let cars_left_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb_rmmyou.rs:12:24\n   |\n12 |   let cars_left_pos = 0\n   |                        ^ help: add `;` here\n13 |   let cars_right_pos = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb_rmmyou.rs:13:25\n   |\n13 |   let cars_right_pos = 0\n   |                         ^ help: add `;` here\n14 |   let cars_left_vel = 1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb_rmmyou.rs:14:24\n   |\n14 |   let cars_left_vel = 1\n   |                        ^ help: add `;` here\n15 |   let cars_right_vel = -1\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb_rmmyou.rs:15:26\n   |\n15 |   let cars_right_vel = -1\n   |                          ^ help: add `;` here\n16 |   let cars_left_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpb_rmmyou.rs:16:31\n   |\n16 |   let cars_left_collisions = 0\n   |                               ^ help: add `;` here\n17 |   let cars_right_collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `while`\n  --> /tmp/tmpb_rmmyou.rs:17:32\n   |\n17 |   let cars_right_collisions = 0\n   |                                ^ help: add `;` here\n18 |   while cars_left > 0 || cars_right > 0 {\n   |   ----- unexpected token\n\nerror: expected `;`, found `cars_left`\n  --> /tmp/tmpb_rmmyou.rs:20:37\n   |\n20 |       cars_left_pos += cars_left_vel\n   |                                     ^ help: add `;` here\n21 |       cars_left -= 1\n   |       --------- unexpected token\n\nerror: expected `;`, found `cars",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpto4_05io.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpto4_05io.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpto4_05io.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1\n          cars[i] = cars[j]\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppqgv1nbr.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppqgv1nbr.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror: expected `;`, found `cars`\n  --> /tmp/tmppqgv1nbr.rs:19:26\n   |\n19 |           collisions += 1\n   |                          ^ help: add `;` here\n20 |           cars[i] = cars[j]\n   |           ---- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmppqgv1nbr.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] + cars[j] == 0 {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpmp695hzr.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[n - 1];\n          cars[j] = cars[0];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpstro8kx2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          collisions += car_race_collision(cars[1] - cars[0]);\n        }\n      } else {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        } else {\n          collisions += car_race_collision(cars[0] - cars[1]);\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpdqkhs3zh.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpdqkhs3zh.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpdqkhs3zh.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpdqkhs3zh.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpdqkhs3zh.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpdqkhs3zh.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpdqkhs3zh.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpdqkhs3zh.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpdqkhs3zh.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpdqkhs3zh.rs:20:44\n   |\n20 |           collisions += car_race_collision(cars[1] - cars[0]);\n   |                                       ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[j];\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpo4m_u77i.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i < j {\n        if cars[i] + 1 == cars[j] {\n          collisions += 1;\n          cars[i] = cars[j] + 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpspvelv20.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = (n - 1) - j;\n      if cars[0] > cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpfqttdf8m.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpfqttdf8m.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpfqttdf8m.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:15:7\n   |\n15 |       cars[1] = (n - 1) - j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpfqttdf8m.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        } else {\n          cars[0] += 1;\n        }\n      } else {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        } else {\n          cars[1] += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpmqki75wq.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpmqki75wq.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpmqki75wq.rs:20:11\n   |\n20 |           cars[0] += 1;\n   |           ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else if cars[0] > cars[1] {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxqu6o5sn.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:20:17\n   |\n20 |       } else if cars[0] > cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `car",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let cars_left: [isize, isize] = [0, 0];\n  let cars_right: [isize, isize] = [0, 0];\n  let cars_left_left: [isize, isize] = [0, 0];\n  let cars_right_right: [isize, isize] = [0, 0];\n  let cars_left_right: [isize, isize] = [0, 0];\n  let cars_right_left: [isize, isize] = [0, 0];\n  let cars_left_left_left: [isize, isize] = [0, 0];\n  let cars_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_right_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_right_right_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_right_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_right_right_right_right_right_right: [isize, isize] =\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmppf_g37nz.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmppf_g37nz.rs:11:24\n   |\n11 |   let cars_left: [isize, isize] = [0, 0];\n   |       ----------       ^ expected one of 7 possible tokens\n   |       |        |\n   |       |        help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmppf_g37nz.rs:12:25\n   |\n12 |   let cars_right: [isize, isize] = [0, 0];\n   |       -----------       ^ expected one of 7 possible tokens\n   |       |         |\n   |       |         help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmppf_g37nz.rs:13:29\n   |\n13 |   let cars_left_left: [isize, isize] = [0, 0];\n   |       ---------------       ^ expected one of 7 possible tokens\n   |       |             |\n   |       |             help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmppf_g37nz.rs:14:31\n   |\n14 |   let cars_right_right: [isize, isize] = [0, 0];\n   |       -----------------       ^ expected one of 7 possible tokens\n   |       |               |\n   |       |               help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmppf_g37nz.rs:15:30\n   |\n15 |   let cars_left_right: [isize, isize] = [0, 0];\n   |       ----------------       ^ expected one of 7 possible tokens\n   |       |              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i == j {\n        continue;\n      }\n      if cars[i] < cars[j] {\n        cars[i] += 1;\n      } else if cars[i] > cars[j] {\n        cars[i] -= 1;\n      } else {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpw_b4dhwa.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else if cars[0] > cars[1] {\n        cars[0] -= 1;\n      } else {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp7oshy8ca.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp7oshy8ca.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmp7oshy8ca.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:18:17\n   |\n18 |       } else if cars[0] > cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp7oshy8ca.rs:18:27\n   |\n18 |       } else if cars[0] > cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let cars_left: [isize, isize] = [0, 0];\n  let cars_right: [isize, isize] = [0, 0];\n  let cars_left_left: [isize, isize] = [0, 0];\n  let cars_left_right: [isize, isize] = [0, 0];\n  let cars_right_left: [isize, isize] = [0, 0];\n  let cars_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left: [isize, isize] = [0, 0];\n  let cars_right_left_right: [isize, isize] = [0, 0];\n  let cars_right_right_left: [isize, isize] = [0, 0];\n  let cars_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_left_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_left_left: [isize, isize] = [0, 0];\n  let cars_left_right_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_right_left: [isize, isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp1wmlgfrd.rs:31:35\n   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                                          - closing delimiter possibly meant for this\n...\n31 |   let cars_left_right_right_left: [isize, isize\n   |                                   ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:11:24\n   |\n11 |   let cars_left: [isize, isize] = [0, 0];\n   |       ----------       ^ expected one of 7 possible tokens\n   |       |        |\n   |       |        help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:12:25\n   |\n12 |   let cars_right: [isize, isize] = [0, 0];\n   |       -----------       ^ expected one of 7 possible tokens\n   |       |         |\n   |       |         help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:13:29\n   |\n13 |   let cars_left_left: [isize, isize] = [0, 0];\n   |       ---------------       ^ expected one of 7 possible tokens\n   |       |             |\n   |       |             help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:14:30\n   |\n14 |   let cars_left_right: [isize, isize] = [0, 0];\n   |       ----------------       ^ expected one of 7 possible tokens\n   |       |              |\n   |  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let cars_left: [isize, isize] = [0, 0];\n  let cars_right: [isize, isize] = [0, 0];\n  let cars_left_left: [isize, isize] = [0, 0];\n  let cars_right_right: [isize, isize] = [0, 0];\n  let cars_left_right: [isize, isize] = [0, 0];\n  let cars_right_left: [isize, isize] = [0, 0];\n\n  for i in 0..n {\n    cars[0] = i;\n    cars_left[0] = i;\n    cars_right[0] = n - i - 1;\n    for j in 1..n {\n      cars[j] = n - j;\n      cars_left[j] = n - j - 1;\n      cars_right[j] = j - 1;\n    }\n    for j in 0..n {\n      for k in 0..n {\n        if (cars[j] == cars[k]) {\n          if (j < k) {\n            cars_left_left[j] = cars_left_left[j] + 1;\n          } else {\n            cars_right_right[j] = cars_right_right[j] + 1;\n          }\n        }\n        if (cars[j] == cars[k] + 1) {\n          if (j < k) {\n            cars_left_right[j] = cars_left_right[j] + 1;\n          } else {\n            cars_right_left[j] = cars_right_left[j] + 1;\n          }\n        }\n      }\n    }\n  }\n  let collisions: isize = 0;\n  for j in 0..n {\n    if (cars_left_left[j] > 0) {\n      collisions = collisions + 1;\n    }\n    if (cars_right_right[j] > 0) {\n      collisions = collisions + 1;\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpp6gskypa.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpp6gskypa.rs:11:24\n   |\n11 |   let cars_left: [isize, isize] = [0, 0];\n   |       ----------       ^ expected one of 7 possible tokens\n   |       |        |\n   |       |        help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpp6gskypa.rs:12:25\n   |\n12 |   let cars_right: [isize, isize] = [0, 0];\n   |       -----------       ^ expected one of 7 possible tokens\n   |       |         |\n   |       |         help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpp6gskypa.rs:13:29\n   |\n13 |   let cars_left_left: [isize, isize] = [0, 0];\n   |       ---------------       ^ expected one of 7 possible tokens\n   |       |             |\n   |       |             help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpp6gskypa.rs:14:31\n   |\n14 |   let cars_right_right: [isize, isize] = [0, 0];\n   |       -----------------       ^ expected one of 7 possible tokens\n   |       |               |\n   |       |               help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpp6gskypa.rs:15:30\n   |\n15 |   let cars_left_right: [isize, isize] = [0, 0];\n   |       ----------------       ^ expected one of 7 possible tokens\n   |       |              ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpto4_05io.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpto4_05io.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpto4_05io.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpto4_05io.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0423, E0608.\nFor more information about an error, try `rustc --explain E0423`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    cars[1] = n - i - 1;\n    if cars[0] > cars[1] {\n      cars[0], cars[1] = cars[1], cars[0];\n    }\n    if cars[0] == cars[1] {\n      collisions += 1;\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpp9fowg8p.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n  --> /tmp/tmpp9fowg8p.rs:16:14\n   |\n16 |       cars[0], cars[1] = cars[1], cars[0];\n   |              ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpp9fowg8p.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpp9fowg8p.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpp9fowg8p.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpp9fowg8p.rs:14:5\n   |\n14 |     cars[1] = n - i - 1;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpp9fowg8p.rs:15:8\n   |\n15 |     if cars[0] > cars[1] {\n   |        ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpp9fowg8p.rs:15:18\n   |\n15 |     if cars[0] > cars[1] {\n   |                  ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpp9fowg8p.rs:18:8\n   |\n18 |     if cars[0] == cars[1] {\n   |        ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpp9fowg8p.rs:18:19\n   |\n18 |     if cars[0] == cars[1] {\n   |                   ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror: ab",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i == j {\n        continue;\n      }\n      if cars[i] < cars[j] {\n        cars[i] += 1;\n      } else if cars[i] > cars[j] {\n        cars[i] -= 1;\n      } else {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpw_b4dhwa.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else if cars[0] > cars[1] {\n        if cars[1] + 1 == cars[0] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxqu6o5sn.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxqu6o5sn.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxqu6o5sn.rs:20:17\n   |\n20 |       } else if cars[0] > cars[1] {\n   |                 ^^^^^^^ help: to access tuple elements, use: `car",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let cars_left: [isize, isize] = [0, 0];\n  let cars_right: [isize, isize] = [0, 0];\n  let cars_left_left: [isize, isize] = [0, 0];\n  let cars_left_right: [isize, isize] = [0, 0];\n  let cars_right_left: [isize, isize] = [0, 0];\n  let cars_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left: [isize, isize] = [0, 0];\n  let cars_right_left_right: [isize, isize] = [0, 0];\n  let cars_right_right_left: [isize, isize] = [0, 0];\n  let cars_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_left_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_left_left: [isize, isize] = [0, 0];\n  let cars_left_right_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_right_left: [isize, isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp1wmlgfrd.rs:31:35\n   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                                          - closing delimiter possibly meant for this\n...\n31 |   let cars_left_right_right_left: [isize, isize\n   |                                   ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:11:24\n   |\n11 |   let cars_left: [isize, isize] = [0, 0];\n   |       ----------       ^ expected one of 7 possible tokens\n   |       |        |\n   |       |        help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:12:25\n   |\n12 |   let cars_right: [isize, isize] = [0, 0];\n   |       -----------       ^ expected one of 7 possible tokens\n   |       |         |\n   |       |         help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:13:29\n   |\n13 |   let cars_left_left: [isize, isize] = [0, 0];\n   |       ---------------       ^ expected one of 7 possible tokens\n   |       |             |\n   |       |             help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:14:30\n   |\n14 |   let cars_left_right: [isize, isize] = [0, 0];\n   |       ----------------       ^ expected one of 7 possible tokens\n   |       |              |\n   |  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        cars[0] += 1;\n      } else {\n        cars[0] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpnews_c8c.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpnews_c8c.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:17:9\n   |\n17 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:19:9\n   |\n19 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpnews_c8c.rs:21:10\n   |\n21 |       if cars[0] == cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  -->",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  let car_idx: isize = 0;\n  let car_idx_next: isize = 0;\n  let car_idx_prev: isize = 0;\n  let car_idx_prev_next: isize = 0;\n  let car_idx_next_prev: isize = 0;\n  let car_idx_prev_next_next: isize = 0;\n  let car_idx_next_prev_next: isize = 0;\n  let car_idx_prev_next_prev: isize = 0;\n  let car_idx_next_prev_prev: isize = 0;\n  let car_idx_prev_next_prev_prev: isize = 0;\n  let car_idx_next_prev_prev_prev: isize = 0;\n  let car_idx_prev_next_prev_prev_prev: isize = 0;\n  let car_idx_next_prev_prev_prev_prev_prev: isize = 0;\n  let car_idx_prev_next_prev_prev_prev_prev_prev: isize = 0;\n  let car_idx_next_prev_prev_prev_prev_prev_prev_prev: isize = 0;\n  let car_idx_prev_next_prev_prev_prev_prev_prev_prev_prev: isize = 0;\n  let car_idx_next_prev_prev_prev_prev_prev_prev_prev_prev_prev: isize = 0;\n  let car_idx_prev_next_prev_prev_prev_prev_prev_prev_prev_prev_prev: isize = 0;\n  let car_idx_next_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev: isize = 0;\n  let car_idx_prev_next_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev: isize = 0;\n  let car_idx_next_prev\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpilrfxlhq.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpilrfxlhq.rs:32:24\n   |\n32 |   let car_idx_next_prev\n   |                        ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpilrfxlhq.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpilrfxlhq.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0308]: mismatched types\n --> /tmp/tmpilrfxlhq.rs:9:36\n  |\n9 | fn car_race_collision(n: isize) -> isize {\n  |    ------------------              ^^^^^ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0423.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let cars_left: [isize, isize] = [0, 0];\n  let cars_right: [isize, isize] = [0, 0];\n  let cars_left_left: [isize, isize] = [0, 0];\n  let cars_left_right: [isize, isize] = [0, 0];\n  let cars_right_left: [isize, isize] = [0, 0];\n  let cars_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_right_right: [isize, isize] = [0, 0];\n  let cars_right_left_left: [isize, isize] = [0, 0];\n  let cars_right_left_right: [isize, isize] = [0, 0];\n  let cars_right_right_left: [isize, isize] = [0, 0];\n  let cars_right_right_right: [isize, isize] = [0, 0];\n  let cars_left_left_left_left: [isize, isize] = [0, 0];\n  let cars_left_left_left_right: [isize, isize] = [0, 0];\n  let cars_left_left_right_left: [isize, isize] = [0, 0];\n  let cars_left_left_right_right: [isize, isize] = [0, 0];\n  let cars_left_right_left_left: [isize, isize] = [0, 0];\n  let cars_left_right_left_right: [isize, isize] = [0, 0];\n  let cars_left_right_right_left: [isize, isize\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp1wmlgfrd.rs:31:35\n   |\n9  | fn car_race_collision(n: isize) -> isize {\n   |                                          - closing delimiter possibly meant for this\n...\n31 |   let cars_left_right_right_left: [isize, isize\n   |                                   ^ unclosed delimiter\n32 | }\n   | ^ mismatched closing delimiter\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:11:24\n   |\n11 |   let cars_left: [isize, isize] = [0, 0];\n   |       ----------       ^ expected one of 7 possible tokens\n   |       |        |\n   |       |        help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:12:25\n   |\n12 |   let cars_right: [isize, isize] = [0, 0];\n   |       -----------       ^ expected one of 7 possible tokens\n   |       |         |\n   |       |         help: use `=` if you meant to assign\n   |       while parsing the type for `cars_right`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:13:29\n   |\n13 |   let cars_left_left: [isize, isize] = [0, 0];\n   |       ---------------       ^ expected one of 7 possible tokens\n   |       |             |\n   |       |             help: use `=` if you meant to assign\n   |       while parsing the type for `cars_left_left`\n\nerror: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmp1wmlgfrd.rs:14:30\n   |\n14 |   let cars_left_right: [isize, isize] = [0, 0];\n   |       ----------------       ^ expected one of 7 possible tokens\n   |       |              |\n   |  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n\n  let collisions = 0\n  for i in 0..n {\n    cars[i] = i\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1\n        } else {\n          collisions += 1\n        }\n      }\n    }\n  }\n  return collisions\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbn9anu21.rs:10:21\n   |\n10 |   let cars = [0] * n\n   |                     ^ help: add `;` here\n11 |   let collisions = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbn9anu21.rs:11:21\n   |\n11 |   let collisions = 0\n   |                     ^ help: add `;` here\n12 |   for i in 0..n {\n   |   --- unexpected token\n\nerror[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpbn9anu21.rs:10:18\n   |\n10 |   let cars = [0] * n\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[i] -= 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpd8fl9hy2.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] > cars[1] {\n        cars[0] -= 1;\n        cars[1] += 1;\n      } else {\n        cars[0] += 1;\n        cars[1] -= 1;\n      }\n      if cars[0] == cars[1] {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpxzpfoanl.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpxzpfoanl.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:10\n   |\n16 |       if cars[0] > cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:16:20\n   |\n16 |       if cars[0] > cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:17:9\n   |\n17 |         cars[0] -= 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:18:9\n   |\n18 |         cars[1] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpxzpfoanl.rs:20:9\n   |\n20 |         cars[0] += 1;\n   |         ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpx",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars: [isize, isize] = [0, 0];\n  let collisions: isize = 0;\n  for i in 0..n {\n    cars[0] = i;\n    for j in 0..n {\n      cars[1] = j;\n      if cars[0] < cars[1] {\n        if cars[0] + 1 == cars[1] {\n          collisions += 1;\n        }\n      } else {\n        if cars[0] - 1 == cars[1] {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpltccy58_.rs:10:19\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |       -----       ^ expected one of 7 possible tokens\n   |       |   |\n   |       |   help: use `=` if you meant to assign\n   |       while parsing the type for `cars`\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:14\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |              ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpltccy58_.rs:10:21\n   |\n10 |   let cars: [isize, isize] = [0, 0];\n   |                     ^^^^^ not a value\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:13:5\n   |\n13 |     cars[0] = i;\n   |     ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:15:7\n   |\n15 |       cars[1] = j;\n   |       ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:10\n   |\n16 |       if cars[0] < cars[1] {\n   |          ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:16:20\n   |\n16 |       if cars[0] < cars[1] {\n   |                    ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:12\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:17:27\n   |\n17 |         if cars[0] + 1 == cars[1] {\n   |                           ^^^^^^^ help: to access tuple elements, use: `cars.1`\n\nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpltccy58_.rs:21:12\n   |\n21 |         if cars[0] - 1 == cars[1] {\n   |            ^^^^^^^ help: to access tuple elements, use: `cars.0`\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i != j {\n        if cars[i] < cars[j] {\n          cars[i] += 1;\n        } else if cars[i] > cars[j] {\n          cars[j] += 1;\n        } else {\n          collisions += 1;\n        }\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpy6eqcqyh.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Imagine a road that's a perfectly straight infinitely long line.\n/// n cars are driving left to right;  simultaneously, a different set of n cars\n/// are driving right to left.   The two sets of cars start out being very far from\n/// each other.  All cars move in the same speed.  Two cars are said to collide\n/// when a car that's moving left to right hits a car that's moving right to left.\n/// However, the cars are infinitely sturdy and strong; as a result, they continue moving\n/// in their trajectory as if they did not collide.\n/// This function outputs the number of such collisions.\nfn car_race_collision(n: isize) -> isize {\n  let cars = [0] * n;\n  let collisions = 0;\n  for i in 0..n {\n    cars[i] = i;\n  }\n  for i in 0..n {\n    for j in 0..n {\n      if i == j {\n        continue;\n      }\n      if cars[i] < cars[j] {\n        cars[i] += 1;\n      } else if cars[i] > cars[j] {\n        cars[i] -= 1;\n      } else {\n        collisions += 1;\n      }\n    }\n  }\n  return collisions;\n}\n\nfn main() {\n    let candidate = car_race_collision;\n    assert_eq!(candidate(2), 4);\n    assert_eq!(candidate(3), 9);\n    assert_eq!(candidate(4), 16);\n    assert_eq!(candidate(8), 64);\n    assert_eq!(candidate(10), 100);\n}\n",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "error[E0369]: cannot multiply `[{integer}; 1]` by `isize`\n  --> /tmp/tmpw_b4dhwa.rs:10:18\n   |\n10 |   let cars = [0] * n;\n   |              --- ^ - isize\n   |              |\n   |              [{integer}; 1]\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0369`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}