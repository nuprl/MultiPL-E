{
  "name": "HumanEval_25_factorize",
  "language": "rs",
  "prompt": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  for isize i = 2; i <= n; i *= 2 {\n    while n % i == 0 {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp9f3gtlqg.rs:12:12\n   |\n12 |   for isize i = 2; i <= n; i *= 2 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp9f3gtlqg.rs:12:18\n   |\n12 |   for isize i = 2; i <= n; i *= 2 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.concat(vec![i, 1]);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n, 1]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpykizehag.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpykizehag.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpykizehag.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpykizehag.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ ---------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpykizehag.rs:21:23\n    |\n21  |     factors = factors.concat(vec![n, 1]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpykizehag.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpykizehag.rs:21:23\n    |\n21  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = append(factors, i);\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors = append(factors, n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpkrpiqmq4.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpkrpiqmq4.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = append(factors, i);\n      n /= i;\n    }\n  }\n  if n > 1 {\n    factors = append(factors, n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpqu5jqs68.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpqu5jqs68.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwa_tvdmp.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 0; i < n; i++ {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n    }\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp7z3b8v4t.rs:12:12\n   |\n12 |   for isize i = 0; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp7z3b8v4t.rs:12:18\n   |\n12 |   for isize i = 0; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbzf5w1cq.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbzf5w1cq.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbzf5w1cq.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbzf5w1cq.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3r7cx5i5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:22:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp3r7cx5i5.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if n > 1 {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpu6zt6u7f.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpu6zt6u7f.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (n > 1) {\n    while (n % i == 0) {\n      factors = factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp29mfp9wx.rs:13:9\n   |\n13 |   while (n > 1) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (n > 1) {\n13 +   while n > 1 {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp29mfp9wx.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp29mfp9wx.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp29mfp9wx.rs:15:25\n   |\n15 |       factors = factors.push_back(i);\n   |                         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwa_tvdmp.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp1ns3r7cl.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp1ns3r7cl.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n    }\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp0rmvgwqq.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp0rmvgwqq.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if n > 1 {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpx80zjein.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpx80zjein.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpx80zjein.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpx80zjein.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbzf5w1cq.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbzf5w1cq.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbzf5w1cq.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbzf5w1cq.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa0kxijtw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa0kxijtw.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa0kxijtw.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa0kxijtw.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa0kxijtw.rs:21:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n21 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpa0kxijtw.rs:21:23\n   |\n21 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = vec![i, factors];\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors = vec![n, factors];\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpwxgtu3vd.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpwxgtu3vd.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.concat(vec![i, 1]);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n, 1]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpphyjx19e.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpphyjx19e.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpphyjx19e.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ ---------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:21:23\n    |\n21  |     factors = factors.concat(vec![n, 1]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpphyjx19e.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = vec![i, n / i];\n      break;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = vec![n];\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2xrosune.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2xrosune.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2xrosune.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `factors`\n  --> /tmp/tmp2xrosune.rs:15:7\n   |\n11 |   let factors = vec![];\n   |       -------\n   |       |\n   |       first assignment to `factors`\n   |       help: consider making this binding mutable: `mut factors`\n...\n15 |       factors = vec![i, n / i];\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp2xrosune.rs:18:5\n   |\n12 |   let i = 2;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n18 |     i += 1;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `factors`\n  --> /tmp/tmp2xrosune.rs:21:5\n   |\n11 |   let factors = vec![];\n   |       -------\n   |       |\n   |       first assignment to `factors`\n   |       help: consider making this binding mutable: `mut factors`\n...\n21 |     factors = vec![n];\n   |     ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3r7cx5i5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:22:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp3r7cx5i5.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i++;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmpymp3d685.rs:18:8\n   |\n18 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n18 -       i++;\n18 +       i += 1;\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpymp3d685.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpymp3d685.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpymp3d685.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpymp3d685.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpymp3d685.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.concat(vec![i, 1]);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n, 1]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpphyjx19e.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpphyjx19e.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpphyjx19e.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ ---------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:21:23\n    |\n21  |     factors = factors.concat(vec![n, 1]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpphyjx19e.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = vec![i, n / i];\n      break;\n    }\n    i += 1;\n  }\n  if n > 1 {\n    factors = vec![n];\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `factors`\n  --> /tmp/tmpa883_9mf.rs:15:7\n   |\n11 |   let factors = vec![];\n   |       -------\n   |       |\n   |       first assignment to `factors`\n   |       help: consider making this binding mutable: `mut factors`\n...\n15 |       factors = vec![i, n / i];\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpa883_9mf.rs:18:5\n   |\n12 |   let i = 2;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n18 |     i += 1;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `factors`\n  --> /tmp/tmpa883_9mf.rs:21:5\n   |\n11 |   let factors = vec![];\n   |       -------\n   |       |\n   |       first assignment to `factors`\n   |       help: consider making this binding mutable: `mut factors`\n...\n21 |     factors = vec![n];\n   |     ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    }\n    i = i + 1;\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjnkrtow6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjnkrtow6.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjnkrtow6.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpjnkrtow6.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpjnkrtow6.rs:21:23\n    |\n21  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpjnkrtow6.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpjnkrtow6.rs:21:23\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppml71p3w.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppml71p3w.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppml71p3w.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmppml71p3w.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppml71p3w.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppml71p3w.rs:21:23\n   |\n21 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = append(factors, i);\n      n /= i;\n    }\n  }\n  if n > 1 {\n    factors = append(factors, n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpqu5jqs68.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpqu5jqs68.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3r7cx5i5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:22:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp3r7cx5i5.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3r7cx5i5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:22:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp3r7cx5i5.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwa_tvdmp.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  factors.push_back(1);\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1p7t0q5w.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1p7t0q5w.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1p7t0q5w.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1p7t0q5w.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1p7t0q5w.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1p7t0q5w.rs:24:11\n   |\n24 |   factors.push_back(1);\n   |           ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (n % i == 0) {\n    factors = vec![i, n / i];\n    n = n / i;\n    i = i + 1;\n  }\n  if (n > 1) {\n    factors = vec![n, n];\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpmynzk7fp.rs:13:9\n   |\n13 |   while (n % i == 0) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (n % i == 0) {\n13 +   while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpmynzk7fp.rs:18:6\n   |\n18 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n18 -   if (n > 1) {\n18 +   if n > 1 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `factors`\n  --> /tmp/tmpmynzk7fp.rs:14:5\n   |\n11 |   let factors = vec![];\n   |       -------\n   |       |\n   |       first assignment to `factors`\n   |       help: consider making this binding mutable: `mut factors`\n...\n14 |     factors = vec![i, n / i];\n   |     ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpmynzk7fp.rs:15:5\n   |\n10 | fn factorize(n: isize) -> Vec<isize> {\n   |              - help: consider making this binding mutable: `mut n`\n...\n15 |     n = n / i;\n   |     ^^^^^^^^^ cannot assign to immutable argument\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpmynzk7fp.rs:16:5\n   |\n12 |   let i = 2;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n16 |     i = i + 1;\n   |     ^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `factors`\n  --> /tmp/tmpmynzk7fp.rs:19:5\n   |\n11 |   let factors = vec![];\n   |       -------\n   |       |\n   |       first assignment to `factors`\n   |       help: consider making this binding mutable: `mut factors`\n...\n19 |     factors = vec![n, n];\n   |     ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppml71p3w.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppml71p3w.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppml71p3w.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmppml71p3w.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppml71p3w.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppml71p3w.rs:21:23\n   |\n21 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp1ns3r7cl.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp1ns3r7cl.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.concat(vec![i, 1]);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n, 1]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpphyjx19e.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpphyjx19e.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpphyjx19e.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ ---------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:21:23\n    |\n21  |     factors = factors.concat(vec![n, 1]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpphyjx19e.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (n > 1) {\n    while (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpiss_o31j.rs:13:9\n   |\n13 |   while (n > 1) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (n > 1) {\n13 +   while n > 1 {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpiss_o31j.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpiss_o31j.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpiss_o31j.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i++;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmp55d9use5.rs:18:8\n   |\n18 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n18 -       i++;\n18 +       i += 1;\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp55d9use5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55d9use5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55d9use5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp55d9use5.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp55d9use5.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if n > 1 {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpreoiuz57.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpreoiuz57.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpreoiuz57.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpreoiuz57.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfu47onbg.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu47onbg.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu47onbg.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfu47onbg.rs:15:17\n   |\n11 |   let factors = vec![];\n   |                 ------ expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfu47onbg.rs:22:15\n   |\n11 |   let factors = vec![];\n   |                 ------ expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpfu47onbg.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa0kxijtw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa0kxijtw.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa0kxijtw.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa0kxijtw.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa0kxijtw.rs:21:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n21 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpa0kxijtw.rs:21:23\n   |\n21 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwa_tvdmp.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3r7cx5i5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:22:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp3r7cx5i5.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwa_tvdmp.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = vec![i, n / i];\n      break;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = vec![n];\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp2xrosune.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2xrosune.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp2xrosune.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0384]: cannot assign twice to immutable variable `factors`\n  --> /tmp/tmp2xrosune.rs:15:7\n   |\n11 |   let factors = vec![];\n   |       -------\n   |       |\n   |       first assignment to `factors`\n   |       help: consider making this binding mutable: `mut factors`\n...\n15 |       factors = vec![i, n / i];\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp2xrosune.rs:18:5\n   |\n12 |   let i = 2;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n18 |     i += 1;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `factors`\n  --> /tmp/tmp2xrosune.rs:21:5\n   |\n11 |   let factors = vec![];\n   |       -------\n   |       |\n   |       first assignment to `factors`\n   |       help: consider making this binding mutable: `mut factors`\n...\n21 |     factors = vec![n];\n   |     ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwa_tvdmp.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n    }\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp0rmvgwqq.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp0rmvgwqq.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (n > 1) {\n    while (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpiss_o31j.rs:13:9\n   |\n13 |   while (n > 1) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (n > 1) {\n13 +   while n > 1 {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpiss_o31j.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpiss_o31j.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpiss_o31j.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp88rqw_8x.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp88rqw_8x.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp88rqw_8x.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp88rqw_8x.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp88rqw_8x.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp88rqw_8x.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp8vw9lo5y.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8vw9lo5y.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp8vw9lo5y.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp8vw9lo5y.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp8vw9lo5y.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp8vw9lo5y.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp8vw9lo5y.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = append(factors, i);\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors = append(factors, n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp558u2506.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp558u2506.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = factors.concat(vec![i]);\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp0p_pvh4f.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp0p_pvh4f.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp0p_pvh4f.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = factors.concat(i);\n      n /= i;\n    }\n  }\n  if n > 1 {\n    factors = factors.concat(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmph0j1vdsi.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmph0j1vdsi.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmph0j1vdsi.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwa_tvdmp.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if n > 1 {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpreoiuz57.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpreoiuz57.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpreoiuz57.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpreoiuz57.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppml71p3w.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmppml71p3w.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmppml71p3w.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmppml71p3w.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppml71p3w.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmppml71p3w.rs:21:23\n   |\n21 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if n > 1 {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpreoiuz57.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpreoiuz57.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpreoiuz57.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpreoiuz57.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 0; i < n; i++ {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n    }\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp7z3b8v4t.rs:12:12\n   |\n12 |   for isize i = 0; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp7z3b8v4t.rs:12:18\n   |\n12 |   for isize i = 0; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = vec![i, factors];\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors = vec![n, factors];\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpwxgtu3vd.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpwxgtu3vd.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 0; i < n; i++ {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n    }\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp7z3b8v4t.rs:12:12\n   |\n12 |   for isize i = 0; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp7z3b8v4t.rs:12:18\n   |\n12 |   for isize i = 0; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.concat(vec![i, 1]);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n, 1]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpphyjx19e.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpphyjx19e.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpphyjx19e.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ ---------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpphyjx19e.rs:21:23\n    |\n21  |     factors = factors.concat(vec![n, 1]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpphyjx19e.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpc1x_1uda.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpc1x_1uda.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpc1x_1uda.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpc1x_1uda.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1x_1uda.rs:15:17\n   |\n11 |   let factors = Vec::new(n);\n   |                 ----------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc1x_1uda.rs:21:15\n   |\n11 |   let factors = Vec::new(n);\n   |                 ----------- expected due to this value\n...\n21 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpc1x_1uda.rs:21:23\n   |\n21 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if n > 1 {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpx80zjein.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpx80zjein.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpx80zjein.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpx80zjein.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbzf5w1cq.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbzf5w1cq.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbzf5w1cq.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbzf5w1cq.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i++;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmp55d9use5.rs:18:8\n   |\n18 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n18 -       i++;\n18 +       i += 1;\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp55d9use5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55d9use5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55d9use5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp55d9use5.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp55d9use5.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp88rqw_8x.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp88rqw_8x.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp88rqw_8x.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp88rqw_8x.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp88rqw_8x.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp88rqw_8x.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp88rqw_8x.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp88rqw_8x.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp88rqw_8x.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp88rqw_8x.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp88rqw_8x.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp88rqw_8x.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqhyl0w4z.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpqhyl0w4z.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpqhyl0w4z.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpqhyl0w4z.rs:15:25\n   |\n15 |       factors = factors.push_back(i);\n   |                         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpqhyl0w4z.rs:21:23\n   |\n21 |     factors = factors.push_back(n);\n   |                       ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = vec![i, factors];\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors = vec![n, factors];\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpwxgtu3vd.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpwxgtu3vd.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp85pk40ko.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp85pk40ko.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp85pk40ko.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp85pk40ko.rs:15:25\n   |\n15 |       factors = factors.push_back(i);\n   |                         ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp85pk40ko.rs:22:23\n   |\n22 |     factors = factors.push_back(n);\n   |                       ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n    }\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp0rmvgwqq.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp0rmvgwqq.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = vec![i, factors];\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = vec![n, factors];\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4kv4ohcr.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp4kv4ohcr.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4kv4ohcr.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4kv4ohcr.rs:15:25\n   |\n15 |       factors = vec![i, factors];\n   |                         ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4kv4ohcr.rs:21:23\n   |\n21 |     factors = vec![n, factors];\n   |                       ^^^^^^^ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n            found struct `Vec<isize>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors = vec![i, n / i];\n      n /= i;\n    }\n  }\n  if n > 1 {\n    factors = vec![n];\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmp93zmbf_g.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmp93zmbf_g.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if n > 1 {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpx80zjein.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpx80zjein.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpx80zjein.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpx80zjein.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i++;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  factors.reverse();\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmp718chqy4.rs:18:8\n   |\n18 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n18 -       i++;\n18 +       i += 1;\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp718chqy4.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp718chqy4.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp718chqy4.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp718chqy4.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp718chqy4.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(n);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp04kdenn6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp04kdenn6.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp04kdenn6.rs:11:17\n    |\n11  |   let factors = Vec::new(n);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp04kdenn6.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i <= n; i++ {\n    while n % i == 0 {\n      factors = vec![i, factors];\n      n /= i;\n    }\n  }\n  if n != 1 {\n    factors = vec![n, factors];\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmphcvyiexc.rs:12:12\n   |\n12 |   for isize i = 2; i <= n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmphcvyiexc.rs:12:18\n   |\n12 |   for isize i = 2; i <= n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpfu47onbg.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu47onbg.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpfu47onbg.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfu47onbg.rs:15:17\n   |\n11 |   let factors = vec![];\n   |                 ------ expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfu47onbg.rs:22:15\n   |\n11 |   let factors = vec![];\n   |                 ------ expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpfu47onbg.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  for isize i = 2; i < n; i++ {\n    while n % i == 0 {\n      factors.push_back(i);\n      n /= i;\n    }\n  }\n  if n > 1 {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpu6zt6u7f.rs:12:12\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpu6zt6u7f.rs:12:18\n   |\n12 |   for isize i = 2; i < n; i++ {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  factors.push_back(1);\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1p7t0q5w.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1p7t0q5w.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1p7t0q5w.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1p7t0q5w.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1p7t0q5w.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1p7t0q5w.rs:24:11\n   |\n24 |   factors.push_back(1);\n   |           ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1ab8n1za.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1ab8n1za.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp1ab8n1za.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1ab8n1za.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if n > 1 {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpezlnpm91.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpezlnpm91.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpezlnpm91.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3r7cx5i5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:22:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp3r7cx5i5.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  for isize i = 2; i <= n; i *= 2 {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n    }\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpm_sct32g.rs:12:12\n   |\n12 |   for isize i = 2; i <= n; i *= 2 {\n   |            ^ help: try adding `in` here\n\nerror: expected `{`, found `;`\n  --> /tmp/tmpm_sct32g.rs:12:18\n   |\n12 |   for isize i = 2; i <= n; i *= 2 {\n   |                  ^ expected `{`\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  factors\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp1rplwkqj.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp1rplwkqj.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1rplwkqj.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpte0c9pyy.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpte0c9pyy.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpte0c9pyy.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpte0c9pyy.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpte0c9pyy.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpte0c9pyy.rs:21:23\n   |\n21 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new(0);\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbzf5w1cq.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbzf5w1cq.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbzf5w1cq.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:11:17\n    |\n11  |   let factors = Vec::new(0);\n    |                 ^^^^^^^^ - supplied 1 argument\n    |                 |\n    |                 expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpbzf5w1cq.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpbzf5w1cq.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp98p8e18q.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp98p8e18q.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp98p8e18q.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp98p8e18q.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmp98p8e18q.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp98p8e18q.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmp98p8e18q.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.concat(vec![i, 1]);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n, 1]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpykizehag.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpykizehag.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpykizehag.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpykizehag.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ ---------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpykizehag.rs:21:23\n    |\n21  |     factors = factors.concat(vec![n, 1]);\n    |                       ^^^^^^ ---------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpykizehag.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, 1]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpykizehag.rs:21:23\n    |\n21  ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpigj57gjw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpigj57gjw.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpigj57gjw.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpwa_tvdmp.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpwa_tvdmp.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpwa_tvdmp.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp3r7cx5i5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3r7cx5i5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3r7cx5i5.rs:22:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n22 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmp3r7cx5i5.rs:22:23\n   |\n22 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i = i + 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcz_pj9ro.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcz_pj9ro.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpcz_pj9ro.rs:22:23\n    |\n22  |     fact",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    }\n    i = i + 1;\n  }\n  if (n > 1) {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjnkrtow6.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpjnkrtow6.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpjnkrtow6.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpjnkrtow6.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpjnkrtow6.rs:21:23\n    |\n21  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpjnkrtow6.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpjnkrtow6.rs:21:23\n    ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors = factors.push(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors = factors.push(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa0kxijtw.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpa0kxijtw.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpa0kxijtw.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa0kxijtw.rs:15:17\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n15 |       factors = factors.push(i);\n   |                 ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa0kxijtw.rs:21:15\n   |\n11 |   let factors = Vec::new();\n   |                 ---------- expected due to this value\n...\n21 |     factors = factors.push(n);\n   |               ^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote: method `push` modifies its receiver in-place\n  --> /tmp/tmpa0kxijtw.rs:21:23\n   |\n21 |     factors = factors.push(n);\n   |               ------- ^^^^ this call modifies `factors` in-place\n   |               |\n   |               you probably want to use this value after calling the method...\n   = note: ...instead of the `()` output of method `push`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpyryaovvd.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpyryaovvd.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpyryaovvd.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = vec![];\n  let i = 2;\n  while i * i <= n {\n    if n % i == 0 {\n      factors = factors.concat(vec![i, n / i]);\n      n = n / i;\n    } else {\n      i += 1;\n    }\n  }\n  if n > 1 {\n    factors = factors.concat(vec![n]);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpx80zjein.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ -------------- supplied 1 argument\n    |                         |\n    |                         expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpx80zjein.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ ------- supplied 1 argument\n    |                       |\n    |                       expected 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpx80zjein.rs:15:25\n    |\n15  |       factors = factors.concat(vec![i, n / i]);\n    |                         ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror[E0277]: the trait bound `[isize]: Concat<_>` is not satisfied\n   --> /tmp/tmpx80zjein.rs:22:23\n    |\n22  |     factors = factors.concat(vec![n]);\n    |                       ^^^^^^ the trait `Concat<_>` is not implemented for `[isize]`\n    |\n    = help: the following other types implement trait `Concat<Item>`:\n              <[S] as Concat<str>>\n              <[V] as Concat<T>>\nnote: required by a bound in `slice::<impl [T]>::concat`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    while (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    }\n    i += 1;\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpgfk3i20r.rs:14:11\n   |\n14 |     while (n % i == 0) {\n   |           ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     while (n % i == 0) {\n14 +     while n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpgfk3i20r.rs:20:6\n   |\n20 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (n > 1) {\n20 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpgfk3i20r.rs:21:13\n   |\n21 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors.push_back(i);\n      n /= i;\n    } else {\n      i++;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmp55d9use5.rs:18:8\n   |\n18 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n18 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n18 -       i++;\n18 +       i += 1;\n   | \n\nwarning: unnecessary parentheses around `while` condition\n  --> /tmp/tmp55d9use5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55d9use5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp55d9use5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp55d9use5.rs:15:15\n   |\n15 |       factors.push_back(i);\n   |               ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp55d9use5.rs:22:13\n   |\n22 |     factors.push_back(n);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Return vector of prime factors of given integer in the order from smallest to largest.\n/// Each of the factors should be vectored number of times corresponding to how many times it appeares in factorization.\n/// Input number should be equal to the product of all factors\n/// >>> factorize(8)\n/// vec![2, 2, 2]\n/// >>> factorize(25)\n/// vec![5, 5]\n/// >>> factorize(70)\n/// vec![2, 5, 7]\nfn factorize(n: isize) -> Vec<isize> {\n  let factors = Vec::new();\n  let i = 2;\n  while (i * i <= n) {\n    if (n % i == 0) {\n      factors = factors.plus(i);\n      n /= i;\n    } else {\n      i += 1;\n    }\n  }\n  if (n > 1) {\n    factors = factors.plus(n);\n  }\n  return factors;\n}\n\nfn main() {\n    let candidate = factorize;\n    assert_eq!(candidate(2), vec![2]);\n    assert_eq!(candidate(4), vec![2, 2]);\n    assert_eq!(candidate(8), vec![2, 2, 2]);\n    assert_eq!(candidate(57), vec![3, 19]);\n    assert_eq!(candidate(3249), vec![3, 3, 19, 19]);\n    assert_eq!(candidate(185193), vec![3, 3, 3, 19, 19, 19]);\n    assert_eq!(candidate(20577), vec![3, 19, 19, 19]);\n    assert_eq!(candidate(18), vec![2, 3, 3]);\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpcmkr_nc5.rs:13:9\n   |\n13 |   while (i * i <= n) {\n   |         ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i * i <= n) {\n13 +   while i * i <= n {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:14:8\n   |\n14 |     if (n % i == 0) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (n % i == 0) {\n14 +     if n % i == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpcmkr_nc5.rs:21:6\n   |\n21 |   if (n > 1) {\n   |      ^     ^\n   |\nhelp: remove these parentheses\n   |\n21 -   if (n > 1) {\n21 +   if n > 1 {\n   | \n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:15:25\n   |\n15 |       factors = factors.plus(i);\n   |                         ^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `plus` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcmkr_nc5.rs:22:23\n   |\n22 |     factors = factors.plus(n);\n   |                       ^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}